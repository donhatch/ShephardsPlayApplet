#include "macros.h"

/*
    failure: alg5killer1 outward: null pointer exception (now "null initial and final vertex" message ) in compute_priority2f
        (actually I think this is structural badness-- doesn't happen if re-delaunayize)
    assertion failure: if symmetrical and no vertex at origin
    assertion failure: FaceSweepKiller, turn on delaunayize and calc underside (nothing really works in that case, but should maybe give better message)
*/

import com.donhatchsw.compat.IntArrayList;
import com.donhatchsw.compat.ArrayList;
import com.donhatchsw.util.SortStuff;
import com.donhatchsw.util.Arrays;
import com.donhatchsw.util.IndexBinaryHeap;
import com.donhatchsw.util.IndexBinaryHeapKeyed;
import com.donhatchsw.util.TopSorter;
import com.donhatchsw.util.VecMath;

public class MyAlgorithmMaybe
{
    public final static int STRATEGY_BEST_GOODNESS = 1; // original implementation.  prone to infinite looping, in ways the code doesn't detect yet.
    public final static int STRATEGY_RANDOM_GOOD = 2; // second implementation.  seen it bite own tail (Just Noise 10000, prewarp, apply radial match. more tailbiting with upward than outward).  hard to make it infinite loop (radial heightfields don't do it) but I got it to, see DUMP.off.ConvexNoise1_144_makes_my_algorithm_infinite_loop
    public final static int STRATEGY_BEST_COMPOSITE = 3; // third implementation.
    public static int strategy = STRATEGY_RANDOM_GOOD; // TODO: make this a parameter to doIt, maybe? not sure

    public static class Graphic
    {
        public int iPass; // 0: before dual, 1: after dual
        public java.awt.Color color;
        public double verts[][/*2*/];
        public Graphic(int iPass, java.awt.Color color, double verts[][])
        {
            this.iPass = iPass;
            this.color = color;
            this.verts = verts; // note there may be some sharing
        }
    }  // class Graphic

    private MyAlgorithmMaybe(){ throw new AssertionError(); } // non-instantiatable util class


    // TODO: move to VecMath?
    // Return -1,0,1 according to whether a <,==,> b, lexicographically.
    private static int cmp(int n, double a[], double b[])
    {
        FORI (i, n)
        {
            if (a[i] < b[i]) return -1;
            if (a[i] > b[i]) return 1;
        }
        return 0;
    }
    // Return -1,0,1 according to whether a <,==,> b, lexicographically. a,b must have same length.
    private static int cmp(double a[], double b[])
    {
        int n = a.length;
        assert_eq(n, b.length);
        return cmp(n, a, b);
    }

    // Helper function.
    // Square root of height of face plane at sweep origin
    // minus square root of height of face plane 0 at sweep origin.
    // This varies roughly linearly with distance from sweep origin (exactly, if h is 0).
    // h matters less and less the smaller cw is, i.e. the closer to infinite c is.
    private static double relativeHeightOfFacePlaneAtSweepOrigin(
      double x, double y, double h,    // face plane normal
      double cx, double cy, double cw) // sweep origin
    {
        double answer;
        if (false)
        {
            // Naive way for starters.
            // This actually works perfectly well,
            // don't really need to put all that thought into it.
            if (cw == .0)
            {
                cw = 1e-9;
            }
            double height = (SQR(x-cx/cw)+SQR(y-cy/cw))*.5 - h;
            double height0 = (SQR(0-cx/cw)+SQR(0-cy/cw))*.5;
            answer = Math.sqrt(height) - Math.sqrt(height0);
        }
        else
        {
            // Follow the method of http://math.stackexchange.com/questions/2077174/how-do-you-compute-c-a-b-a-without-catastrophic-cancellation.
            // That is, first apply scalar binary identity, then vector binary identity.
            // Actually work with twice height and height0 from above, for simpler expressions,
            // to get sqrt(2) times the answer.
            //   sqrt(2*height) - sqrt(2*height0)
            // = sqrt((x-cx/cw)^2+(y-cy/cw)^2-2h) - sqrt((cx/cw)^2+(cy/cw)^2)
            // = ((x-cx/cw)^2+(y-cy/cw)^2-2h - ((cx/cw)^2+(cy/cw)^2)) / (sqrt((x-cx/cw)^2+(y-cy/cw)^2-2h)+sqrt((cx/cw)^2+(cy/cw)^2))
            // = ((p-c/cw).self - (c/cw).self - 2h) / (...)
            // = ((p-c/cw+c/cw).(p-c/cw-c/cw) - 2h) / (...)
            // = (p.(p-2*c/cw) - 2h) / (...)
            // = (p.p - 2h - 2*p.c/cw) / (...)
            // Multiplying numerator and denominator by abs(cw)=cw (since cw is guaranteed nonnegative) gives:
            // = (cw*(p.p-2*h) - 2*p.c) / ( sqrt((cw*x-cx)^2 + (cw*y-cy)^2 - 2*cw*h) + sqrt(cx^2+cy^2) )
            // So answer is sqrt(.5) times that.
            assert_ge(1./cw, 0.); // it's non-negative and not -0 either
            double numerator = cw*(x*x+y*y-2*h) - 2*(x*cx+y*cy);
            double denominator = Math.sqrt(SQR(cw*x-cx) + SQR(cw*y-cy) - 2*cw*h) + Math.hypot(cx, cy);
            answer = numerator / denominator * Math.sqrt(.5);
        }
        return answer;
    }

    // Common code used by compute_priority2v and compute_priority2f.
    private static int[] compute_priority2v_or_f(
        double sweepOriginHomo[/*3*/],
        double facesXYH[/*nVerts or nFaces*/][/*2 or 3*/]) // actually vertsXY if computing vertex priorities.
    {
        int verboseLevel = 0;
        if (verboseLevel >= 1) OUT("            in compute_priority2f");
        boolean useHeights = (facesXYH.length > 0 && facesXYH[0].length == 3);
        assert(!VecMath.isZeroExactly(sweepOriginHomo));
        // Simplify life
        if (1./sweepOriginHomo[2] < 0.)
        {
            sweepOriginHomo = VecMath.sxv(-1., sweepOriginHomo);
        }
        int nFaces = facesXYH.length;
        // Order key is (relative) height of the face plane at the sweep origin.
        double f2orderKey[][] = new double[nFaces][3];

        double c0x = sweepOriginHomo[0];
        double c0y = sweepOriginHomo[1];
        double c0w = sweepOriginHomo[2];
        assert_ge(1./c0w, 0.);
        // Pick a secondary sweep origin as tiebreaker.
        // Anything not too close to primary sweep center will suffice.
        double c1x = c0x<0. ? .25 : -.25;
        double c1y = 0.;
        double c1w = 1.;

        // Easiest method would be:
        // Priority of a face is the height of the face plane at the sweep origin.
        // For sweep origin at 0, that's:
        //      (x^2+y^2)*.5 - h
        // For finite sweep origin cx,cy, that's:
        //      ((x-cx)^2+(y-cy)^2)*.5 - h
        // For homogeneous sweep origin cx/cw,cy/cw, that's:
        //      ((x-cx/cw)^2+(y-cy/cw)^2)*.5 - h
        // Unfortunately that doesn't behave well when cw approaches 0.
        // So we take the square root of that, instead,
        // minus the same expression for the zero face plane.
        // That's what relativeHeightOfFacePlaneAtSweepOrigin does.
        FORI (iFace, nFaces)
        {
            double x = facesXYH[iFace][0];
            double y = facesXYH[iFace][1];
            double h = useHeights ? facesXYH[iFace][2] : 0.;
            // for starters, just make the sweep center 0
            f2orderKey[iFace][0] = relativeHeightOfFacePlaneAtSweepOrigin(x, y, h, c0x, c0y, c0w);
            f2orderKey[iFace][1] = relativeHeightOfFacePlaneAtSweepOrigin(x, y, h, c1x, c1y, c1w);
            f2orderKey[iFace][2] = iFace; // make face index be the tiebreaker
            if (verboseLevel >= 2) OUT("                  iFace="+iFace+": x="+x+" y="+y+" h="+h);
            if (verboseLevel >= 2) OUT("                      f2orderKey[iFace="+iFace+"] = "+Arrays.toStringCompact(f2orderKey[iFace]));
        }
        SortStuff.sort(f2orderKey, new SortStuff.Comparator() {
            @Override public int compare(Object a, Object b)
            {
                // use generic lexicographic compare that asserts equal length
                return cmp((double[])a, (double[])b);
            }
        });
        int priority2f[] = new int[nFaces];
        FORI (iFace, nFaces)
        {
            priority2f[iFace] = (int)f2orderKey[iFace][2];
        }
        if (verboseLevel >= 1) PRINTVEC(priority2f);
        if (verboseLevel >= 1) OUT("            out compute_priority2f");
        return priority2f;

    } // compute_priority2v_or_f

    // Note on the sweep order on faces:
    // Have to do something tricky to make sure we don't start out disconnected,
    // e.g. SweepKiller1epsMult >=2.
    // What's the problem with starting out disconnected?
    // Something to do with the assertion that no-light-sides only happens on the very first face?
    // Well, isn't the same thing going to happen if sweep origin is sufficiently far from zero even if not infinite?
    // Answer: no, it would require several edges to *pass through* the sweep origin.
    // I think a similar problem might occur if there's a vertex at the sweep origin, though?
    // No, actually it isn't a problem. In that case there's one first, the others have predecessors which form folds,
    // and the last one makes one fold and one cut from the sweep origin, which is appropriate.
    // It *is* a problem in the infinite center case though:
    // - (minor) no-light-sides happens on multiple faces (not a big deal, could just remove the assertion)
    // - face tree isn't a tree, it's a forest (not a big deal-- could just let it be a forest,
    //     or add an extra synthetic face similar to how we add the extra synthetic vertex)
    // - but if there's a forest, it will cause some infinite face to have to choose
    //     which of two infinite predecessors to attach to, and the other one will be a cut:
    //     i.e. a cut flowing upward from infinity, which generally isn't done and has undefined weight&moment semantics.
    // Possible resolutions:
    //  - allow the infinite cuts upward from infinity, but give them zero weight and remove them at some point
    //  - treat this as a special case: if we see we're about to make a cut flowing upward from infinity,
    //        just make it a fold instead
    //  - just treat them all as firsts all at once, with folds between them
    //  - fudge the order so this doesn't happen: that is, pick one special one of the infinite-downward faces,
    //    make it first, and the rest ordered after it, appropriately, so every one has a predecessor which becomes a fold
    //    (this is effectively what I ended up doing: secondarily sort according to some other sweep origin)

    // Compute sweep order on faces.
    // Priority of a face is (in same order as) the height of the face plane at the sweep origin.
    // Ties are broken by priorities relative to some arbitrary other sweep origin.
    // Remaining ties are broken by face index.
    private static int[] compute_priority2f(double sweepOriginHomo[/*3*/], Mesh meshIgnored, Mesh dualMesh)
    {
        return compute_priority2v_or_f(sweepOriginHomo, MeshUtils.getMeshVertsXYH(dualMesh));
    }

    // Compute sweep order on vertices.
    // This is just a sort by distance from sweep origin, breaking ties by index.
    // The math happens to be exactly the same for that of compute_priority2f, but ignoring heights.
    private static int[] compute_priority2v(double sweepOriginHomo[/*3*/], Mesh mesh, Mesh dualMeshIgnored)
    {
        return compute_priority2v_or_f(sweepOriginHomo, MeshUtils.getMeshVertsXY(mesh));
    }



    // So I can see more clearly,
    // isolate exactly the data we will use during the algorithm(s).
    private static class HelperDataStructure
    {
        //
        // Representation of the original mesh with vertex weights.
        // Immutable after initial construction.
        //
        public double vertsXY[/*nVerts*/][/*2*/];
        public double v2momentAndArea[][/*4*/]; // from original verts... although I suspect [2] isn't meaningful for us
        public double e2direction[/*nEdges*/][/*3*/];
        public int e2v[/*nEdges*/][/*2*/]; // values are in [0..nVerts] (not 0..nVerts-1 !) since nVerts represents "the infinite vertex"
        public int v2e[/*nVerts*/][];

        public HelperDataStructure(Mesh mesh, boolean mergeInsideOutVertsIntoInfiniteVert)
        {
            int nVerts = mesh.verts.size();
            int nEdges = mesh.edges.size();
            this.vertsXY = MeshUtils.getMeshVertsXY(mesh);
            assert_eq(vertsXY.length, nVerts);
            this.v2momentAndArea = new double[nVerts][];
            FORI (iVert, nVerts)
                this.v2momentAndArea[iVert] = mesh.getVert(iVert).momentAndArea;
            this.e2direction = new double[nEdges][];
            FORI (iEdge, nEdges)
                this.e2direction[iEdge] = mesh.getEdge(iEdge).direction;

            {
                MeshUtils.SimplerMeshDataStructure simplerMeshDataStructure = new MeshUtils.SimplerMeshDataStructure(mesh, mergeInsideOutVertsIntoInfiniteVert);
                this.e2v = simplerMeshDataStructure.e2v;
                this.v2e = simplerMeshDataStructure.v2e;
            }
            assert_eq(this.e2v.length, nEdges);

            if (e2direction[0] != null) // is this the right condition?  original primal doesn't have directions, original dual does
            {
                // Make sure neighbors of each vert are listed in ccw order.
                FORI (iVert, nVerts)
                {
                    // Note that there can be an isolated vertex,
                    // in the case that "calc underside when delaunayizing" was checked;
                    // the original inside-out vert gets isolated since everything
                    // got reconnected to the synthetic infinite vert.
                    if (v2e[iVert].length == 0) continue;
                    assert_eq(v2e[iVert].length, 3);
                    if (VecMath.vxv2(e2direction[v2e[iVert][0]],
                                     e2direction[v2e[iVert][1]]) < 0.)
                    {
                        assert(false); // yay! doesn't happen any more since SimplerMeshDataStructure gets it right
                        int temp;
                        SWAP(v2e[iVert][0], v2e[iVert][1], temp);
                    }
                    assert(VecMath.vxv2(e2direction[v2e[iVert][0]],
                                        e2direction[v2e[iVert][1]]) > 0.);
                    assert(VecMath.vxv2(e2direction[v2e[iVert][1]],
                                        e2direction[v2e[iVert][2]]) > 0.);
                    assert(VecMath.vxv2(e2direction[v2e[iVert][2]],
                                        e2direction[v2e[iVert][0]]) > 0.);
                }
            }
        }

    }; // HelperDataStructure

    // "v0->e3->v1->e2[->v100->e3->v200]"
    private static String edgeListToDebugString(int edgeListSize, int edgeList[],
                                                int e2v[][], int v2e[][],
                                                int v2parentVert[],
                                                boolean assertParentRelationshipsFlag) // can only assert *after* have changed parents
    {
        StringBuffer sb = new StringBuffer();
        int nVerts = v2parentVert.length;
        //sb.append("[nVerts="+nVerts+"]");

        FORI (i, edgeListSize)
        {
            int e = edgeList[i];
            int v0 = e2v[e][0];
            int v1 = e2v[e][1];
            if (assertParentRelationshipsFlag)
            {
                if (!(v2parentVert[v0]==v1 || (i>=edgeListSize-1 && v2parentVert[v0]==-1)))
                {
                    sb.append("[XXX WTF? v2parentVert[v"+v0+"]==v"+v2parentVert[v0]+"]");
                    assert(false);
                }
            }

            if (i==0 && v2parentVert[v0]!=-1 && v2parentVert[v0]!=v1)
            {
                sb.append("(v"+v2parentVert[v0]+"<-)");
            }
            sb.append("v"+v0);
            assert_ne(v0, nVerts); // so don't need to emit "(infinite)"

            if (i!=0 && v2parentVert[v0]!=-1 && v2parentVert[v0]!=v1)
            {
                sb.append("(->v"+v2parentVert[v0]+")");
            }

            if (false) // not of major interest, can hard-code to true when interested
            {
                sb.append("[-e"+e+"->]");
            }

            if (v2parentVert[v0] == v1)
            {
                sb.append("->");
            }
            else if (v1!=nVerts && v2parentVert[v1] == v0)
            {
                sb.append("<-");
            }
            else
            {
                sb.append(" ");
            }

            if (i+1<edgeListSize)
            {
                assert_eq(v1, e2v[edgeList[i+1]][0]);
                // will emit it as v0 on next iteration
            }
            else
            {
                sb.append("v"+v1);
                if (v1==nVerts)
                    sb.append("(infinite)");
                else if (v2parentVert[v1] != -1 && v2parentVert[v1]!=v0)
                    sb.append("(->v"+v2parentVert[v1]+")");
            }
        }
        return sb.toString();
    } // edgeListToDebugString

    // helper function.
    // computes v2momentAndWeightStrictlyUpstream[iVert]
    // from those of its children and moments and areas of its children.
    private static void computeMomentAndAreaStrictlyUpstreamFromUpstream(int iVert,
                                                                         int e2v[][], // in
                                                                         int v2e[][], // in
                                                                         double v2momentAndArea[][], // in
                                                                         int v2parentVert[], // in
                                                                         double v2momentAndWeightStrictlyUpstream[][], // in/out
                                                                         int verboseLevel)
    {
        int nVerts = v2momentAndWeightStrictlyUpstream.length;
        VecMath.zerovec(v2momentAndWeightStrictlyUpstream[iVert]);
        FORI (iEdgeThisVert, v2e[iVert].length)
        {
            int iNeighborVert = e2v[v2e[iVert][iEdgeThisVert]][1];
            if (iNeighborVert < nVerts
             && v2parentVert[iNeighborVert] == iVert)
            {
                if (verboseLevel >= 2) OUT("                              accumulating centroid from upstream v"+iNeighborVert+" into v"+iVert);
                GeomUtils.accumulateMomentAndArea(v2momentAndWeightStrictlyUpstream[iVert],
                                                  v2momentAndWeightStrictlyUpstream[iNeighborVert]);
                GeomUtils.accumulateMomentAndArea(v2momentAndWeightStrictlyUpstream[iVert],
                                                  v2momentAndArea[iNeighborVert]);
            }
        }
    } // computeMomentAndAreaStrictlyUpstreamFromUpstream

    // helper function.
    static double computeExitGoodness(double v[/*2*/],
                                      double momentAndWeightStrictlyUpstream[/*2*/],
                                      double normalizedEdgeDirection[/*2*/],
                                      double scratchCentroid[/*2*/],
                                      double scratchVertMinusCentroid[/*2*/],
                                      int verboseLevel)
    {
        double exitGoodness;
        if (momentAndWeightStrictlyUpstream[2] > 0.)
        {
            VecMath.vxs(2, scratchCentroid, momentAndWeightStrictlyUpstream, 1./momentAndWeightStrictlyUpstream[2]);
            VecMath.vmv(2, scratchVertMinusCentroid, v, scratchCentroid);
            exitGoodness = VecMath.dot(2, normalizedEdgeDirection, scratchVertMinusCentroid);
            if (verboseLevel >= 2) OUT("                                          exitGoodness = "+exitGoodness);
        }
        else
        {
            // There's no weight hanging from this vertex,
            // So goodness is 0; it's good, but it's not really in danger of being bad.
            //exitGoodness = 0.;
            exitGoodness = Double.POSITIVE_INFINITY;
            if (verboseLevel >= 2) OUT("                                          exitGoodness = 0 (setting to "+exitGoodness+" because no danger)");
        }
        return exitGoodness;
    } // computeExitGoodness

    public static Net doItFaceSweep(
        Mesh originalMesh, Mesh originalDualMesh, // generally reversed from the calling app's notion.   XXX why am I calling these "original"?
        double sweepOriginHomo[/*3*/], // if [2] is 0, the vertex is infinitely far from origin
        int maxIters, // interpreted in funny way: on even iterations, sweep to next face but don't do anything with it.
        int putProblematicVertsHereForDebugging[/*1*/][],
        double putLastPointSweptHere[/*1*/][/*2*/],
        ArrayList putGraphicsOfLastDecisionHere)
    {
        int verboseLevel = 1; // 1: constant, 2: linear
        if (verboseLevel >= 1) OUT("        in MyAlgorithmMaybe.doItFaceSweep");
        if (verboseLevel >= 1) OUT("          sweepOriginHomo = "+VecMath.toString(sweepOriginHomo));
        assert_eq(sweepOriginHomo.length, 3);

        int nVerts = originalMesh.verts.size();
        int nEdges = originalMesh.edges.size();
        int nFaces = originalDualMesh.verts.size();
        if (verboseLevel >= 1) OUT("          nVerts = "+nVerts);
        if (verboseLevel >= 1) OUT("          nEdges = "+nEdges);
        if (verboseLevel >= 1) OUT("          nFaces = "+nFaces);

        if (nEdges == 0)
        {
            if (verboseLevel >= 1) OUT("        out MyAlgorithmMaybe.doIt (no edges, nothing to do)");
            return new Net(originalMesh, originalDualMesh);
        }

        HelperDataStructure helperDataStructure = new HelperDataStructure(originalMesh, true);
        double vertsXY[][] = helperDataStructure.vertsXY;
        double v2momentAndArea[][] = helperDataStructure.v2momentAndArea;
        double e2direction[][] = helperDataStructure.e2direction;
        int e2v[][] = helperDataStructure.e2v;
        int v2e[][] = helperDataStructure.v2e;

        HelperDataStructure dualHelperDataStructure = new HelperDataStructure(originalDualMesh, false); // all verts are finite, for this one
        double dualVertsXY[][] = dualHelperDataStructure.vertsXY;
        int e2f[][] = dualHelperDataStructure.e2v;
        int f2e[][] = dualHelperDataStructure.v2e;
        int priority2f[] = compute_priority2f(sweepOriginHomo, originalMesh, originalDualMesh);
        if (verboseLevel >= 2) OUT("          priority2f = "+VecMath.toString(priority2f));
        int f2priority[] = VecMath.invertperm(priority2f);

        {
            // a bit of fudge... e2f and f2e have edges backwards from how I'd like them
            int temp[];
            FORI (iEdgePair, nEdges/2)
                SWAP(e2f[2*iEdgePair], e2f[2*iEdgePair+1], temp);
            FORI (iFace, f2e.length)
                FORI (iSide, f2e[iFace].length)
                    f2e[iFace][iSide] ^= 1;
        }

        double v2momentAndWeightStrictlyUpstream[][] = new double[nVerts][3];
        int v2parentEdge[] = VecMath.fillvec(nVerts, -1);
        int v2parentVert[] = VecMath.fillvec(nVerts, -1); // redundant but convenient
        // Note, f2parent isn't really needed for the algorithm,
        // but it helps to visualize which folds have been decided so far
        // when displaying a partial solution.
        int f2parentEdge[] = VecMath.fillvec(nFaces, -1);
        int f2parentFace[] = VecMath.fillvec(nFaces, -1); // redundant but convenient

        // [1] = min(exitGoodness,0) // so first priority is to make exitGoodness >= 0
        // [2] = sweepGoodness       // tiebreaker, usually when both have exitGoodness >= 0
        // [3] = exitGoodness        // tiebreaker, seldom needed
        double globalWorstGoodness[] = VecMath.fillvec(3, Double.POSITIVE_INFINITY);

        double bestNeighborGoodness[] = new double[3]; // scratch for loop
        double worstLagoonExitGoodness[] = new double[3]; // scratch for inner loop
        double thisLagoonExitGoodness[] = new double[3]; // scratch for inner loop

        boolean sideIsLight[] = new boolean[nEdges/2]; // scratch for loop
        int lightSides[] = new int[nEdges/2]; // scratch for loop
        int lightSideParts[][] = new int[2][nEdges/2]; // scratch for loop
        int lightSidePartSizes[] = new int[2]; // scratch for loop
        double scratchMomentAndArea[] = new double[3]; // scratch for loop
        double scratchCentroid[] = new double[2]; // scratch for loop
        double vertMinusCentroid[] = new double[2]; // scratch for loop
        double normalizedEdgeDirection[] = new double[2]; // scratch for loop
        double sweepDirection[] = new double[2]; // scratch for loop

        boolean isVeryFirstNontrivialFace = true;
        int lastFaceConsidered = -1;

        int iIter;
        boolean fatalProblemDetected = false;
        for (iIter = 0;
             iIter/2 < nFaces && (maxIters<0 || iIter < maxIters) && !fatalProblemDetected;
             ++iIter)
        {
            // for each face, in order, in the sweep direction
            int iFacePriority = iIter / 2;
            int iFace = priority2f[iFacePriority];
            lastFaceConsidered = iFace;

            // On even iterations, we just sweep to the next face but don't do anything with it.
            // This helps for a nicer visualization.
            boolean justShowOptionsAndBreak = false;
            if (iIter % 2 == 0)
            {
                if (maxIters >= 0 && iIter == maxIters-1)
                    justShowOptionsAndBreak = true; // have to proceed a bit farther to know the options
                else
                    continue;
            }

            if (verboseLevel >= 2) OUT("              iIter="+iIter+": top of loop");
            if (verboseLevel >= 2) OUT("                  priority="+iFacePriority+" iFace="+iFace);

            // Call the "light" ["dark"] sides of this face
            // the sides that do [don't] border on previous faces.
            int face[] = f2e[iFace];
            int nSides = face.length;

            if (nSides == 0)
            {
                // Isolated vert in original (our dual) leads to empty face in primal.
                // Nothing to do.
                if (verboseLevel >= 2) OUT("                      (isolated)");
                continue;
            }

            FORI (iSide, nSides)
            {
                int iEdge = face[iSide];
                assert_eq(e2f[iEdge][0], iFace);
                int iNeighborFace = e2f[iEdge][1];
                sideIsLight[iSide] = f2priority[iNeighborFace] < iFacePriority;
            }
            if (verboseLevel >= 2) OUT("                      sideIsLight = "+VecMath.toString((boolean[])Arrays.subarray(sideIsLight,0,nSides)));
            int iFirstLightSide = -1;
            int iFirstDarkSide = -1;
            {
                boolean prevSideIsLight = sideIsLight[nSides-1];
                FORI (iSide, nSides)
                {
                    boolean thisSideIsLight = sideIsLight[iSide];
                    if (thisSideIsLight != prevSideIsLight)
                    {
                        if (thisSideIsLight)
                        {
                            assert_eq(iFirstLightSide, -1);
                            iFirstLightSide = iSide;
                        }
                        else
                        {
                            assert_eq(iFirstDarkSide, -1);
                            iFirstDarkSide = iSide;
                        }
                    }
                    prevSideIsLight = thisSideIsLight;
                }
            }
            if (verboseLevel >= 2) OUT("                      iFirstLightSide = "+iFirstLightSide);
            if (verboseLevel >= 2) OUT("                      iFirstDarkSide = "+iFirstDarkSide);

            if (isVeryFirstNontrivialFace)
            {
                // should be all dark
                assert_eq(iFirstLightSide, -1);
                assert_eq(iFirstDarkSide, -1);
                assert(!sideIsLight[0]);
                f2parentEdge[iFace] = -1;
                f2parentFace[iFace] = -1;
                isVeryFirstNontrivialFace = false;
                if (justShowOptionsAndBreak)
                    break;
            }
            else
            {
                if (iFirstLightSide == -1)
                {
                    // TODO: this fails if symmetrical and no vertex at origin.  should try to fix that.
                    assert(sideIsLight[0]);
                    // All sides are light.
                    // This is the last nontrivial face. (I think.)
                    // This face must be incident on the infinite vertex.
                    // Arrange so first light side is the one emanating from the infinite vertex.
                    FORI (iSide, nSides)
                    {
                        if (e2v[face[iSide]][0] == nVerts)
                        {
                            assert_eq(iFirstLightSide, -1);
                            iFirstLightSide = iSide;
                            iFirstDarkSide = iSide;
                            if (verboseLevel >= 2) OUT("                      iFirstLightSide = "+iFirstLightSide);
                            if (verboseLevel >= 2) OUT("                      iFirstDarkSide = "+iFirstDarkSide);
                        }
                    }
                    assert_ne(iFirstLightSide, -1);
                }
                assert_ne(iFirstLightSide, -1);
                assert_ne(iFirstDarkSide, -1);
                int nLightSides = (iFirstDarkSide-iFirstLightSide+nSides-1) % nSides + 1;
                if (verboseLevel >= 2) OUT("                      nLightSides = "+nLightSides);
                assert_le_le(0, nLightSides, nSides);

                // Make linear list of light sides, for clarity
                FORI (iLightSide, nLightSides)
                {
                    int iSide = (iFirstLightSide+iLightSide) % nSides;
                    lightSides[iLightSide] = face[iSide];
                    if (iLightSide > 0)
                    {
                        assert_eq(e2v[lightSides[iLightSide-1]][1],
                                  e2v[lightSides[iLightSide]][0]);
                    }
                }
                if (verboseLevel >= 2) OUT("                      lightSides = "+VecMath.toString((int[])Arrays.subarray(lightSides,0,nLightSides)));

                if (justShowOptionsAndBreak)
                {
                    FORI (iLightSide, nLightSides)
                    {
                        int iEdge = lightSides[iLightSide];
                        int i0 = e2v[iEdge][0];
                        int i1 = e2v[iEdge][1];
                        double v0[] = i0!=nVerts ? vertsXY[i0] : VecMath.vmv(vertsXY[i1], e2direction[iEdge]);
                        double v1[] = i1!=nVerts ? vertsXY[i1] : VecMath.vpv(vertsXY[i0], e2direction[iEdge]);
                        putGraphicsOfLastDecisionHere.add(new Graphic(
                            1, // iPass (after dual)
                            java.awt.Color.YELLOW.darker().darker(),
                            new double[][]{
                                v0,
                                v1,
                            }
                        ));
                    }
                    break;
                }

                // Choose a parent face on the light side, to glue this face to.
                int iBestLightSide = -1;
                VecMath.fillvec(bestNeighborGoodness, Double.NEGATIVE_INFINITY);
                FORI (iLightSide, nLightSides)
                {
                    int iEdge = lightSides[iLightSide];
                    if (verboseLevel >= 2) OUT("                          trying iLightSide="+iLightSide+": "+iEdge);
                    int iNeighborFace = e2f[iEdge][1];
                    // If we glue to this parent,
                    // the glued side will become a fold
                    // and all the other light sides will become cuts,
                    // each one forming a lagoon exit.
                    // Goodness of this potential parent
                    // will be the least goodness of all these lagoon exits.
                    // I.e. this parent isn't good (i.e. goodness >=0)
                    // unless all these lagoon exits are good.
                    VecMath.fillvec(worstLagoonExitGoodness, Double.POSITIVE_INFINITY);

                    lightSidePartSizes[0] = 0;
                    FORIDOWN(jLightSide, iLightSide)
                        lightSideParts[0][lightSidePartSizes[0]++] = lightSides[jLightSide] ^ 1; // backwards from the way we've been considering it
                    lightSidePartSizes[1] = 0;
                    for (int jLightSide = iLightSide+1; jLightSide < nLightSides; ++jLightSide)
                        lightSideParts[1][lightSidePartSizes[1]++] = lightSides[jLightSide];

                    FORI (jPart, 2)
                    {
                        if (verboseLevel >= 2) OUT("                              "+(jPart==0 ? "first part, backwards" : "second part"));
                        int lightSidePart[] = lightSideParts[jPart];
                        int lightSidePartSize = lightSidePartSizes[jPart];
                        VecMath.zerovec(scratchMomentAndArea);
                        FORI (jLightSideInPart, lightSidePartSize)
                        {
                            int jEdge = lightSidePart[jLightSideInPart];
                            if (verboseLevel >= 2) OUT("                                  looking at jLightSideInPart="+jLightSideInPart+": "+jEdge);
                            int v0 = e2v[jEdge][0];
                            int v1 = e2v[jEdge][1];

                            // speculatively parent.
                            if (verboseLevel >= 2) OUT("                                      speculatively "+v0+"->"+v1);
                            assert_lt(v0, nVerts); // CBB: fails if "calc underside when delaunayizing"; should sanity check first or something?
                            assert_eq(v2parentEdge[v0], -1);
                            assert_eq(v2parentVert[v0], -1);
                            v2parentEdge[v0] = jEdge;
                            v2parentVert[v0] = v1;
                            computeMomentAndAreaStrictlyUpstreamFromUpstream(v0, e2v, v2e, v2momentAndArea, v2parentVert,
                                                                             v2momentAndWeightStrictlyUpstream,
                                                                             verboseLevel);
                            // check it
                            {
                                // CBB: extra work normalizing same thing over and over... I think I should normalize everything once at beginning
                                VecMath.normalize(2, normalizedEdgeDirection, e2direction[jEdge]);

                                double exitGoodness = computeExitGoodness(vertsXY[v0],
                                                                          v2momentAndWeightStrictlyUpstream[v0],
                                                                          normalizedEdgeDirection,
                                                                          scratchCentroid,
                                                                          vertMinusCentroid,
                                                                          verboseLevel);

                                // Get sweepDirection: unit, or zero (if sweep origin is exactly at vert).
                                // sweepDirection = vertsXY[iVert] - sweepOrigin, homogeneous
                                VecMath.sxvpsxv(2, sweepDirection,
                                                sweepOriginHomo[2], vertsXY[v0],
                                                -1., sweepOriginHomo);
                                if (VecMath.normsqrd(2, sweepDirection) != 0.) // if vertex is not exactly on sweep origin
                                    VecMath.normalize(2, sweepDirection,
                                                         sweepDirection);

                                double sweepGoodness;
                                {
                                    // CBB: actually I think I should be measuring sweepGoodness at the end points?  since that's the interface with other stuff.
                                    sweepGoodness = VecMath.dot(2, normalizedEdgeDirection, sweepDirection);
                                }

                                thisLagoonExitGoodness[0] = MIN(exitGoodness, 0.);
                                thisLagoonExitGoodness[1] = sweepGoodness;
                                thisLagoonExitGoodness[2] = exitGoodness;
                                if (verboseLevel >= 2) OUT("                                          thisLagoonExitGoodness = "+VecMath.toString(thisLagoonExitGoodness));
                                if (cmp(thisLagoonExitGoodness, worstLagoonExitGoodness) < 0)
                                {
                                    VecMath.copyvec(worstLagoonExitGoodness, thisLagoonExitGoodness);
                                }
                            }
                        }
                    }

                    if (verboseLevel >= 2) OUT("                              thisNeighborGoodness = worstLagoonExitGoodness = "+VecMath.toString(worstLagoonExitGoodness));
                    double thisNeighborGoodness[] = worstLagoonExitGoodness; // clearer name

                    //assert_eq((thisNeighborGoodness[0] < Double.POSITIVE_INFINITY), (nLightSides > 1)); // can't assert this because I play subtle games with infinity
                    if (cmp(thisNeighborGoodness, bestNeighborGoodness) > 0)
                    {
                        VecMath.copyvec(bestNeighborGoodness, thisNeighborGoodness);
                        iBestLightSide = iLightSide;
                    }

                    // Clear speculative parenting of inter-light-side verts.
                    // Don't need to clear the speculative moments&weights,
                    // since those will get clobbered by future values as appropriate.
                    FORI (jLightSide, nLightSides-1)
                    {
                        int jEdge = lightSides[jLightSide];
                        int v1 = e2v[jEdge][1];
                        assert_ne(v2parentEdge[v1], -1);
                        assert_ne(v2parentVert[v1], -1);
                        v2parentEdge[v1] = -1;
                        v2parentVert[v1] = -1;
                    }
                }
                if (bestNeighborGoodness[0] < 0.)
                {
                    if (verboseLevel >= 2) OUT("                      OH NO!!! bestNeighborGoodness = "+VecMath.toString(bestNeighborGoodness));
                }
                else
                {
                    if (verboseLevel >= 2) OUT("                      bestNeighborGoodness = "+VecMath.toString(bestNeighborGoodness));
                }
                assert_gt(bestNeighborGoodness[0], Double.NEGATIVE_INFINITY);
                assert_ne(iBestLightSide, -1);
                if (cmp(bestNeighborGoodness, globalWorstGoodness) < 0)
                    VecMath.copyvec(globalWorstGoodness, bestNeighborGoodness);

                int iBestNeighborEdge = lightSides[iBestLightSide];
                int iBestNeighborFace = e2f[iBestNeighborEdge][1];
                if (verboseLevel >= 2) OUT("                      bestLightSide = "+iBestLightSide+": "+iBestNeighborEdge+" to neighbor face "+iBestNeighborFace);
                f2parentEdge[iFace] = iBestNeighborEdge;
                f2parentFace[iFace] = iBestNeighborFace;

                // That nails down some more of the vertex tree as well...
                FORI (iPart, 2)
                {
                    // First part: iBestLightSide-1 down to 0
                    // Second part: iBestLightSide+1 up to nLightSides-1
                    int iFirstLightSideInPart = (iPart==0 ? iBestLightSide-1 : iBestLightSide+1);
                    int iPastLastLightSideInPart = (iPart==0 ? -1 : nLightSides);
                    int incr = (iPart==0 ? -1 : 1);
                    for (int iLightSide = iFirstLightSideInPart;
                         iLightSide != iPastLastLightSideInPart;
                         iLightSide += incr) {
                        int iEdge = lightSides[iLightSide];
                        if (iPart == 0) iEdge ^= 1; // backwards;
                        int v0 = e2v[iEdge][0];
                        int v1 = e2v[iEdge][1];
                        if (verboseLevel >= 2) OUT("                          parenting "+v0+"->"+v1);
                        v2parentEdge[v0] = iEdge;
                        v2parentVert[v0] = v1;
                        // since we're giving v0 a parent, we know its children are locked in
                        // so we can compute its moment.
                        computeMomentAndAreaStrictlyUpstreamFromUpstream(v0, e2v, v2e, v2momentAndArea, v2parentVert,
                                                                         v2momentAndWeightStrictlyUpstream,
                                                                         verboseLevel);

                        // CBB: extra work normalizing same thing over and over... I think I should normalize everything once at beginning.
                        // In fact I don't even use this unless goodness is bad
                        VecMath.normalize(2, normalizedEdgeDirection, e2direction[iEdge]);
                        double exitGoodness = computeExitGoodness(vertsXY[v0],
                                                                  v2momentAndWeightStrictlyUpstream[v0],
                                                                  normalizedEdgeDirection,
                                                                  scratchCentroid,
                                                                  vertMinusCentroid,
                                                                  verboseLevel);
                        if (exitGoodness < 0.)
                        {
                            double v0coords[] = v0!=nVerts ? vertsXY[v0] : VecMath.vmv(vertsXY[v1], e2direction[iEdge]);
                            double v1coords[] = v1!=nVerts ? vertsXY[v1] : VecMath.vpv(vertsXY[v0], e2direction[iEdge]);
                            putGraphicsOfLastDecisionHere.add(new Graphic(
                                1, // iPass (after dual)
                                java.awt.Color.RED,
                                new double[][]{
                                    v0coords,
                                    v1coords,
                                }
                            ));
                        }
                    }
                }
            } // iFacePriority > 0
        } // for iFacePriority
        if ((iIter/2 == nFaces || maxIters<0) && !fatalProblemDetected)
        {
            if (verboseLevel >= 1) OUT("          finished in "+iIter+" iterations!");
            lastFaceConsidered = -1;
        }
        else
        {
            if (verboseLevel >= 1) OUT("          didn't finish in "+iIter+" iterations!");
        }
        // The result is now in v2parent.
        if (verboseLevel >= 2) PRINTVEC(v2parentVert);
        if (verboseLevel >= 2) PRINTVEC(v2parentEdge);
        if (verboseLevel >= 2) PRINTVEC(f2parentEdge);
        Net net = new Net(originalMesh, originalDualMesh);
        FORI (iVert, nVerts)
        {
            if (v2parentEdge[iVert] != -1)
                net.cut(v2parentEdge[iVert], true);
        }
        FORI (iFace, nFaces)
        {
            if (f2parentEdge[iFace] != -1)
                net.fold(f2parentEdge[iFace], true);
        }

        if (lastFaceConsidered != -1 && putLastPointSweptHere != null)
        {
            putLastPointSweptHere[0] = dualVertsXY[lastFaceConsidered];
        }

        if (globalWorstGoodness[0] < 0.)
        {
            if (verboseLevel >= 1) OUT("          OH NO!!! globalWorstGoodness = "+VecMath.toString(globalWorstGoodness));

            // I actually haven't seen this one fail yet,
            // despite throwing stuff at it that has made every other algorithm
            // fail (except the exit-swapping "polishing" non-algorithm heuristic
            // which doesn't impress me).
            // Oh wait!  it does fail, on grid 8,10,11,...
            // Argh, but it's by -5.5511e-17 :-(
            //assert(false);
            // And it really does fail, see "Face Sweep Killer" and "Simpler Face Sweep Killer"
        }
        else
        {
            if (verboseLevel >= 1) OUT("          globalWorstGoodness = "+VecMath.toString(globalWorstGoodness));
        }
        if (verboseLevel >= 1) OUT("        out MyAlgorithmMaybe.doItFaceSweep");
        return net;
    } // doItFaceSweep



    // Another attempt.
    // This one is a bit more focused/restrictive:
    // it only tries to alter flow along a single face that intersects the sweep line/circle.
    // Assert-fails if it hits any vertices flowing from that face into the interior
    // (which does happen sometimes, it turns out).
    // I didn't realize it, but this is actually following largely the same logic
    // as doItFaceSweep.
    public static Net doIt2(
        Mesh originalMesh, Mesh originalDualMesh, // generally reversed from the calling app's notion.   XXX why am I calling these "original"?
        double sweepOriginHomo[/*3*/], // if [2] is 0, the vertex is infinitely far from origin
        int maxIters, // interpreted in funny way: on even iterations, sweep to next vertex but don't do anything with it.
        int putProblematicVertsHereForDebugging[/*1*/][],
        double putLastPointSweptHere[/*1*/][/*2*/])
    {
        int verboseLevel = 1; // 1: constant, 2: linear
        if (verboseLevel >= 1) OUT("        in MyAlgorithmMaybe.doIt");
        assert_eq(sweepOriginHomo.length, 3);

        int nVerts = originalMesh.verts.size();
        int nEdges = originalMesh.edges.size();
        if (verboseLevel >= 1) OUT("          nVerts = "+nVerts);
        if (verboseLevel >= 1) OUT("          nEdges = "+nEdges);

        if (nEdges == 0)
        {
            if (verboseLevel >= 1) OUT("        out MyAlgorithmMaybe.doIt (no edges, nothing to do)");
            return new Net(originalMesh, originalDualMesh);
        }

        HelperDataStructure helperDataStructure = new HelperDataStructure(originalMesh, true);
        double vertsXY[][] = helperDataStructure.vertsXY;
        double v2momentAndArea[][] = helperDataStructure.v2momentAndArea;
        double e2direction[][] = helperDataStructure.e2direction;
        int e2v[][] = helperDataStructure.e2v;
        int v2e[][] = helperDataStructure.v2e;
        int priority2v[] = compute_priority2v(sweepOriginHomo, originalMesh, originalDualMesh);
        int v2priority[] = VecMath.invertperm(priority2v);

        double v2momentAndWeightStrictlyUpstream[][] = new double[nVerts][3];
        // could just have v2parentEdge, I suppose, since v2parentVert[v] is always e2v[v2parentEdge[v]][1], but I think this is easier
        int v2parentEdge[] = VecMath.fillvec(nVerts, -1);
        int v2parentVert[] = VecMath.fillvec(nVerts, -1);

        IndexBinaryHeapKeyed todo = new IndexBinaryHeapKeyed(nVerts);
        FORI (iVert, nVerts)
        {
            if (v2e[iVert].length != 0) // if not isolated, i.e. not one of the original inside out verts
                todo.add(iVert, (double)v2priority[iVert]);
        }

        double vertMinusCentroidDirection[] = new double[2]; // scratch for loop
        double sweepDirection[] = new double[2]; // scratch for loop
        int maxValence = 0; FORI (iVert, nVerts) maxValence = MAX(maxValence, v2e[iVert].length);
        if (maxValence != 3)
        {
            // could mean only one edge and no incident verts, or something
            if (verboseLevel >= 1) OUT("        out MyAlgorithmMaybe.doIt (maxValence="+maxValence+", can't handle it)");
            return new Net(originalMesh, originalDualMesh);
        }
        double goodnesses[] = new double[maxValence]; // scratch for loop
        double sweepGoodnesses[] = new double[maxValence]; // scratch for loop
        boolean isBackwashes[] = new boolean[maxValence]; // scratch for loop

        double centroid[] = new double[2]; // very scratch for loop
        double normalizedEdgeDirection[] = new double[2]; // very scratch for loop


        int edgeListSize; // scratch for loop
        int edgeList[] = new int[nEdges]; // scratch for loop
        int v2parentEdgeScratch[] = new int[nVerts]; // scratch for loop
        int v2parentVertScratch[] = new int[nVerts]; // scratch for loop
        double v2momentAndWeightStrictlyUpstreamScratch[][] = new double[nVerts][3]; // scratch for loop

        int lastVertexConsidered = -1;

        int iIter;
        boolean fatalProblemDetected = false;
        for (iIter = 0;
             !todo.isEmpty() && (maxIters<0 || iIter < maxIters) && !fatalProblemDetected;
             ++iIter)
        {
            // On even iterations, we just sweep to the next vertex but don't do anything with it.
            // This helps for a nicer visualization.
            if (iIter % 2 == 0)
            {
                lastVertexConsidered = todo.min();
                continue;
            }

            int iVert = todo.extractMin();
            lastVertexConsidered = iVert;
            if (verboseLevel >= 2) OUT("              iIter="+iIter+": top of loop");
            if (verboseLevel >= 2) OUT("                  priority="+v2priority[iVert]+" iVert="+iVert);
            assert_lt(iVert, nVerts);
            assert_eq(v2parentEdge[iVert], -1);
            assert_eq(v2parentVert[iVert], -1);

            computeMomentAndAreaStrictlyUpstreamFromUpstream(iVert, e2v, v2e, v2momentAndArea, v2parentVert,
                                                             v2momentAndWeightStrictlyUpstream,
                                                             verboseLevel);

            // get vertMinusCentroidDirection: unit, or zero (if weight is zero or centroid is exactly at vert)
            if (v2momentAndWeightStrictlyUpstream[iVert][2] > 0.)
            {
                VecMath.vxs(2, centroid, v2momentAndWeightStrictlyUpstream[iVert], 1./v2momentAndWeightStrictlyUpstream[iVert][2]);
                VecMath.vmv(2, vertMinusCentroidDirection, vertsXY[iVert], centroid);
                if (VecMath.normsqrd(2, vertMinusCentroidDirection) != 0.) // if it didn't happen to land exactly on vertex
                    VecMath.normalize(2, vertMinusCentroidDirection,
                                         vertMinusCentroidDirection);
            }
            else
                VecMath.zerovec(2, vertMinusCentroidDirection);

            // Get sweepDirection: unit, or zero (if sweep origin is exactly at vert).
            // sweepDirection = vertsXY[iVert] - sweepOrigin, homogeneous
            VecMath.sxvpsxv(2, sweepDirection,
                            sweepOriginHomo[2], vertsXY[iVert],
                            -1., sweepOriginHomo);
            if (VecMath.normsqrd(2, sweepDirection) != 0.) // if vertex is not exactly on sweep origin
                VecMath.normalize(2, sweepDirection,
                                     sweepDirection);

            if (verboseLevel >= 2) OUT("                      vertMinusCentroidDirection = "+VecMath.toString(vertMinusCentroidDirection));
            if (verboseLevel >= 2) OUT("                      sweepDirection = "+VecMath.toString(sweepDirection));

            // Gather information about each neighbor,
            // into goodnesses, sweepGoodnesses, isBackwashes.
            FORI (iEdgeThisVert, v2e[iVert].length)
            {
                int iNeighborEdge = v2e[iVert][iEdgeThisVert];
                assert_eq(e2v[iNeighborEdge][0], iVert);
                int iNeighborVert = e2v[iNeighborEdge][1];
                if (verboseLevel >= 2) OUT("                          neighbor "+iEdgeThisVert+": e"+iNeighborEdge+" -> v"+iNeighborVert);
                VecMath.normalize(2, normalizedEdgeDirection, e2direction[iNeighborEdge]);
                if (verboseLevel >= 2) OUT("                              normalizedEdgeDirection = "+VecMath.toString(normalizedEdgeDirection));
                double goodness = VecMath.dot(2, normalizedEdgeDirection, vertMinusCentroidDirection);
                double sweepGoodness = VecMath.dot(2, normalizedEdgeDirection, sweepDirection);
                boolean isBackwash = (iNeighborVert < nVerts && v2parentVert[iNeighborVert] == iVert);
                if (verboseLevel >= 2) OUT("                                  goodness = "+goodness);
                if (verboseLevel >= 2) OUT("                                  sweepGoodness = "+sweepGoodness);
                if (verboseLevel >= 2) OUT("                                  isBackwash = "+isBackwash);
                if (verboseLevel >= 2) OUT("                                  "+(iNeighborVert==nVerts?"(infinite)":"(parent = v"+v2parentVert[iNeighborVert]+")"));
                goodnesses[iEdgeThisVert] = goodness;
                sweepGoodnesses[iEdgeThisVert] = sweepGoodness;
                isBackwashes[iEdgeThisVert] = isBackwash;
            }


            {
                // Easy case: if there's a good edge to a not-yet-swept vert, take it. If more than one, prefer most sweepward
                // (even if apparently against sweep dir).
                // NOTE: this isn't entirely principled, since a good edge to not-yet-swept vert might actually
                // start out against the sweep dir (if the edge goes tangent to the sweep circle)
                // (or the edge is to the infinite vert and directed against sweep dir if UPWARD-- same thing).
                // However, it seems to end up doing something reasonable (at least in OutStressor),
                // so we let it slide for now.
                // Might need to adjust this at some point by adding synthetic events/verts at tangent points,
                // so that "to unswept vert" always means same thing as "in sweep direction".
                int bestNeighborIndex = -1;
                FORI (iEdgeThisVert, v2e[iVert].length)
                {
                    int jVert = e2v[v2e[iVert][iEdgeThisVert]][1];
                    if ((jVert==nVerts || v2parentVert[jVert]==-1)
                     && goodnesses[iEdgeThisVert] >= 0.
                     && (bestNeighborIndex==-1
                      || sweepGoodnesses[iEdgeThisVert] > sweepGoodnesses[bestNeighborIndex]))
                        bestNeighborIndex = iEdgeThisVert;
                }
                if (bestNeighborIndex != -1)
                {
                    if (verboseLevel >= 2) OUT("                      easy case: there's a good edge to a not-yet-swept vert");
                    int bestNeighborEdge = v2e[iVert][bestNeighborIndex];
                    int bestNeighborVert = e2v[bestNeighborEdge][1];
                    if (verboseLevel >= 2) OUT("                          bestNeighborVert = "+bestNeighborVert);
                    assert_ne(bestNeighborEdge, -1);
                    assert_ne(bestNeighborVert, -1);
                    assert_eq(v2parentEdge[iVert], -1);
                    assert_eq(v2parentVert[iVert], -1);
                    v2parentEdge[iVert] = bestNeighborEdge;
                    v2parentVert[iVert] = bestNeighborVert;
                    if (verboseLevel >= 2) OUT("                          adding edge e"+v2parentEdge[iVert]+" (v"+iVert+"->v"+v2parentVert[iVert]+")");
                    continue;
                }
            }

            {
                // All edges to not-yet-swept verts are bad.
                // There's usually 1 of them, but could be 2 (see DUMP.2badup.off).
                // Oh wait!  I think there can actually be only 1 of them, assuming we didn't fudge the previous edge!!
                assert_eq(v2e[iVert].length, 3);

                int firstNotYetSweptNeighborIndex = -1;
                int lastNotYetSweptNeighborIndex = -1;
                FORI (iEdgeThisVert, v2e[iVert].length)
                {
                    int jVert = e2v[v2e[iVert][iEdgeThisVert]][1];
                    if (jVert==nVerts || v2parentVert[jVert]==-1)
                    {
                        if (firstNotYetSweptNeighborIndex == -1)
                            firstNotYetSweptNeighborIndex = iEdgeThisVert;
                        lastNotYetSweptNeighborIndex = iEdgeThisVert;
                    }
                }
                assert_ne(firstNotYetSweptNeighborIndex, -1);
                assert_ne(lastNotYetSweptNeighborIndex, -1);
                if (firstNotYetSweptNeighborIndex == 0 && lastNotYetSweptNeighborIndex == 2)
                {
                    // hack-- make it so first and last are when traversing around the vert (assume CCW)
                    firstNotYetSweptNeighborIndex = 2;
                    lastNotYetSweptNeighborIndex = 0;
                }
                if (verboseLevel >= 2) OUT("                      first not-yet-swept neighbor = v"+e2v[v2e[iVert][firstNotYetSweptNeighborIndex]][1]);
                if (verboseLevel >= 2) OUT("                      last not-yet-swept neighbor = v"+e2v[v2e[iVert][lastNotYetSweptNeighborIndex]][1]);

                // Is the downstream turn too far left or too far right? Must be one or the other.
                // I.e. does the bad quill(s) point CCW or CW?
                boolean isLeftTurn;
                {
                    // I.e. does the quill point CCW or CW?
                    assert_ne(VecMath.normsqrd(2, sweepDirection), 0.); // we can't get here if vert is exactly at sweep origin
                    assert_ne(VecMath.normsqrd(2, vertMinusCentroidDirection), 0.); // would have to be extremely degenerate for this to fail
                    double leftTurnness = VecMath.vxv2(vertMinusCentroidDirection, sweepDirection);
                    assert_ne(leftTurnness, 0.);
                    isLeftTurn = leftTurnness > 0.;
                }
                if (verboseLevel >= 2) OUT("                      isLeftTurn = "+isLeftTurn);



                int walkTheBoundaryIndex =
                    isLeftTurn ? MOD(firstNotYetSweptNeighborIndex-1,3) // walk around boundary CW
                               : MOD(lastNotYetSweptNeighborIndex+1,3); // walk around boundary CCW

                // Gather up list of edges, starting at iVert
                // and walking around the face opposite the quill until
                // the final edge leaves the sweep circle.
                if (true)
                {
                    edgeListSize = 0;
                    {
                        int iEdge = v2e[iVert][walkTheBoundaryIndex];
                        edgeList[edgeListSize++] = iEdge;
                        while (e2v[iEdge][1] != nVerts
                            && v2parentVert[e2v[iEdge][1]] != -1)
                        {
                            int toVert = e2v[iEdge][1];
                            int backIndex = Arrays.indexOf(v2e[toVert], iEdge^1);
                            assert_ne(backIndex, -1);
                            int forwardIndex = MOD(backIndex + (isLeftTurn ? -1 : 1), 3); // isLeftTurn: CCW around face so CW around vert
                            iEdge = v2e[toVert][forwardIndex];
                            edgeList[edgeListSize++] = iEdge;
                        }
                    }
                    if (verboseLevel >= 2) OUT("                      edgeList: "+edgeListToDebugString(edgeListSize, edgeList, e2v, v2e, v2parentVert, false));
                    assert_ge(edgeListSize, 2); // we wouldn't be in this case if the first edge out of iVert left the sweep circle

                    // All intermediate verts have parents.
                    // Do any of them have parents that are swept but not prev-or-next along this edge list?
                    // If so, flunk.
                    boolean flunked = false;
                    FORI (i, edgeListSize-1)
                    {
                        int jVert = e2v[edgeList[i]][1];
                        int jVertParent = v2parentVert[jVert];
                        assert_ne(jVertParent, -1);
                        if (jVertParent != nVerts
                         && jVertParent != e2v[edgeList[i]][0]
                         && jVertParent != e2v[edgeList[i+1]][1])
                        {
                            if (verboseLevel >= 1) OUT("                      oh no! flunked due to downstream edge (v"+jVert+"->v"+jVertParent+") into interior! edgeList: "+edgeListToDebugString(edgeListSize, edgeList, e2v, v2e, v2parentVert, false));
                            flunked = true;
                            break;
                        }
                    }

                    if (!flunked)
                    {
                        // See whether we can blaze the trail around this face to the sweep boundary.
                        // We need to make sure each edge along the way would be good.
                        // To figure that out, we need to compute speculative centroids-upstream
                        // at each of the vertices, as well as at iVert.

                        // We do this by saving and restoring parent verts of each vert on the list.
                        {
                            // Save...
                            double temp[];
                            FORI (j, edgeListSize)
                            {
                                int jVert = e2v[edgeList[j]][0];
                                v2parentEdgeScratch[jVert] = v2parentEdge[jVert];
                                v2parentVertScratch[jVert] = v2parentVert[jVert];
                                SWAP(v2momentAndWeightStrictlyUpstreamScratch[jVert], v2momentAndWeightStrictlyUpstream[jVert], temp);
                            }
                        }

                        // Speculate...
                        FORI (i, edgeListSize)
                        {
                            int e = edgeList[i];
                            int v0 = e2v[e][0];
                            int v1 = e2v[e][1];
                            v2parentEdge[v0] = e;
                            v2parentVert[v0] = v1;
                        }

                        FORI (i, edgeListSize)
                        {
                            if (verboseLevel >= 2) OUT("                          checking the edge v"+e2v[edgeList[i]][0]+" -e"+edgeList[i]+"-> v"+e2v[edgeList[i]][1]);
                            int jVert = e2v[edgeList[i]][0];
                            computeMomentAndAreaStrictlyUpstreamFromUpstream(jVert, e2v, v2e, v2momentAndArea, v2parentVert,
                                                                             v2momentAndWeightStrictlyUpstream,
                                                                             verboseLevel);
                            // get vertMinusCentroidDirection: unit, or zero (if weight is zero or centroid is exactly at vert)
                            if (v2momentAndWeightStrictlyUpstream[jVert][2] > 0.)
                            {
                                VecMath.vxs(2, centroid, v2momentAndWeightStrictlyUpstream[jVert], 1./v2momentAndWeightStrictlyUpstream[jVert][2]);
                                VecMath.vmv(2, vertMinusCentroidDirection, vertsXY[jVert], centroid);
                                if (VecMath.normsqrd(2, vertMinusCentroidDirection) != 0.) // if it didn't happen to land exactly on vertex
                                    VecMath.normalize(2, vertMinusCentroidDirection,
                                                         vertMinusCentroidDirection);
                            }
                            else
                                VecMath.zerovec(2, vertMinusCentroidDirection);

                            VecMath.normalize(2, normalizedEdgeDirection, e2direction[edgeList[i]]);
                            double goodness = VecMath.dot(2, normalizedEdgeDirection, vertMinusCentroidDirection);
                            if (goodness < 0.)
                            {
                                assert_ne(i, 0); // we wouldn't be in this case if the first edge was bad

                                if (i == edgeListSize-1)
                                {
                                    // In this case, we allow it!
                                    // Erase the last edge and unsweep the last swept vertex.
                                    if (verboseLevel >= 2) OUT("            erasing e"+v2parentEdge[jVert]+" (v"+jVert+"->v"+e2v[edgeList[i]][0]+") and putting v"+jVert+" back on todo list");
                                    v2parentEdge[jVert] = -1;
                                    v2parentVert[jVert] = -1;
                                    todo.add(jVert, (double)v2priority[jVert]);
                                }
                                else
                                {
                                    if (verboseLevel >= 1) OUT("                      oh no! flunked due to one of the edges curving back so far that it's bad! e"+edgeList[i]+" (v"+jVert+"->v"+e2v[edgeList[i]][1]+") edgeList: "+edgeListToDebugString(edgeListSize, edgeList, e2v, v2e, v2parentVert, false));
                                    flunked = true;
                                    break;
                                }
                            }
                        }

                        if (!flunked)
                        {
                            // It worked!
                            // And we already set parents and moments appropriately;
                            // leave the moments entries swapped.
                            if (verboseLevel >= 1) OUT("                      second-most-easy case worked! "+edgeListToDebugString(edgeListSize, edgeList, e2v, v2e, v2parentVert, true));
                            continue;
                        }

                        if (flunked)
                        {
                            // Restore...
                            double temp[];
                            FORI (j, edgeListSize)
                            {
                                int jVert = e2v[edgeList[j]][0];
                                v2parentEdge[jVert] = v2parentEdgeScratch[jVert];
                                v2parentVert[jVert] = v2parentVertScratch[jVert];
                                SWAP(v2momentAndWeightStrictlyUpstreamScratch[jVert], v2momentAndWeightStrictlyUpstream[jVert], temp);
                            }
                        }
                    }
                }


                // TODO: fix it!
                int chosenEdge = v2e[iVert][firstNotYetSweptNeighborIndex];
                int chosenVert = e2v[chosenEdge][1];
                OUT("          XXX outputting bad edge from v"+iVert+" to v"+chosenVert+" on iteration "+iIter);
                v2parentEdge[iVert] = chosenEdge;
                v2parentVert[iVert] = chosenVert;
                continue;
            }
        }
        if (todo.isEmpty() && !fatalProblemDetected)
        {
            if (verboseLevel >= 1) OUT("          finished in "+iIter+" iterations!");
            lastVertexConsidered = -1;
        }
        else
        {
            if (verboseLevel >= 1) OUT("          didn't finish in "+iIter+" iterations!");
        }

        // The result is now in v2parent.
        if (verboseLevel >= 2) PRINTVEC(v2parentEdge);
        if (verboseLevel >= 2) PRINTVEC(v2parentVert);
        Net net = new Net(originalMesh, originalDualMesh);
        FORI (iVert, nVerts)
        {
            if (v2parentEdge[iVert] != -1)
                net.cut(v2parentEdge[iVert], true);
        }

        if (lastVertexConsidered != -1 && putLastPointSweptHere != null)
        {
            putLastPointSweptHere[0] = vertsXY[lastVertexConsidered];
        }

        if (verboseLevel >= 1) OUT("        out MyAlgorithmMaybe.doIt");
        return net;
    } // doIt2

    public static Net doIt(
        Mesh originalMesh, Mesh originalDualMesh, // generally reversed from the calling app's notion.   XXX why am I calling these "original"?
        double sweepOriginHomo[/*3*/], // if [2] is 0, the vertex is infinitely far from origin
        java.util.Random rng,
        int maxIters,
        int putProblematicVertsHereForDebugging[/*1*/][])
    {
        int verboseLevel = 1;
        if (verboseLevel >= 1) OUT("        in MyAlgorithmMaybe.doIt");
        assert_eq(sweepOriginHomo.length, 3);

        int nVerts = originalMesh.verts.size();
        int nEdges = originalMesh.edges.size();
        if (verboseLevel >= 1) OUT("          nVerts = "+nVerts);
        if (verboseLevel >= 1) OUT("          nEdges = "+nEdges);

        HelperDataStructure helperDataStructure = new HelperDataStructure(originalMesh, true);
        double vertsXY[][] = helperDataStructure.vertsXY;
        double v2momentAndArea[][] = helperDataStructure.v2momentAndArea;
        double e2direction[][] = helperDataStructure.e2direction;
        int e2v[][] = helperDataStructure.e2v;
        int v2e[][] = helperDataStructure.v2e;
        int priority2v[] = compute_priority2v(sweepOriginHomo, originalMesh, originalDualMesh);
        int v2priority[] = VecMath.invertperm(priority2v);

        double v2momentAndWeightStrictlyUpstream[][] = new double[nVerts][3];
        // could just have v2parentEdge, I suppose, but I think this is easier
        int v2parentEdge[] = VecMath.fillvec(nVerts, -1);
        int v2parentVert[] = VecMath.fillvec(nVerts, -1);

        IndexBinaryHeapKeyed todo = new IndexBinaryHeapKeyed(nVerts);
        FORI (iVert, nVerts)
        {
            if (v2e[iVert].length != 0) // if not isolated, i.e. not one of the original inside out verts
                todo.add(iVert, (double)v2priority[iVert]);
        }

        double vertMinusCentroidDirection[] = new double[2]; // scratch for loop
        double sweepDirection[] = new double[2]; // scratch for loop
        int maxValence = 0; FORI (iVert, nVerts) maxValence = MAX(maxValence, v2e[iVert].length);
        assert_eq(maxValence, 3); // XXX unless no edges... need to get something more solid here
        double goodnesses[] = new double[maxValence]; // scratch for loop
        double sweepGoodnesses[] = new double[maxValence]; // scratch for loop
        boolean isBackwashes[] = new boolean[maxValence]; // scratch for loop
        int goods[] = new int[3]; // scratch for loop

        double centroid[] = new double[2]; // very scratch for loop
        double normalizedEdgeDirection[] = new double[2]; // very scratch for loop

        java.util.HashMap fingerprints = new java.util.HashMap();
        IntArrayList invalidationPathForDebugging = new IntArrayList(); // scratch for loop

        int nFineIters = 0;
        int iIter;
        boolean infiniteLoopDetected = false;
        for (iIter = 0;
             !todo.isEmpty() && (maxIters<0 || iIter < maxIters) && !infiniteLoopDetected;
             ++iIter)
        {
            int iVert = todo.min();
            if (verboseLevel >= 2) OUT("              iIter="+iIter+": top of loop");
            if (verboseLevel >= 2) OUT("                  priority="+v2priority[iVert]+" iVert="+iVert);
            assert_lt(iVert, nVerts);
            assert_eq(v2parentEdge[iVert], -1);
            assert_eq(v2parentVert[iVert], -1);

            while (v2parentVert[iVert] == -1 // this is sort of a hack: keep going as long as I got put back on the todo list, even if I'm not otherwise the first on the todo list.  I have no reason to think this will result in a good algorithm, it's just a heuristic to get out of the endless-loop of the moment.
                && !infiniteLoopDetected)
            {
                nFineIters++;
                todo.remove(iVert);

                computeMomentAndAreaStrictlyUpstreamFromUpstream(iVert, e2v, v2e, v2momentAndArea, v2parentVert,
                                                                 v2momentAndWeightStrictlyUpstream,
                                                                 verboseLevel);

                // get vertMinusCentroidDirection: unit, or zero (if weight is zero or centroid is exactly at vert)
                if (v2momentAndWeightStrictlyUpstream[iVert][2] > 0.)
                {
                    VecMath.vxs(2, centroid, v2momentAndWeightStrictlyUpstream[iVert], 1./v2momentAndWeightStrictlyUpstream[iVert][2]);
                    VecMath.vmv(2, vertMinusCentroidDirection, vertsXY[iVert], centroid);
                    if (VecMath.normsqrd(2, vertMinusCentroidDirection) != 0.) // if it didn't happen to land exactly on vertex
                        VecMath.normalize(2, vertMinusCentroidDirection,
                                             vertMinusCentroidDirection);
                }
                else
                    VecMath.zerovec(2, vertMinusCentroidDirection);

                // Get sweepDirection: unit, or zero (if sweep origin is exactly at vert).
                // sweepDirection = vertsXY[iVert] - sweepOrigin, homogeneous
                VecMath.sxvpsxv(2, sweepDirection,
                                sweepOriginHomo[2], vertsXY[iVert],
                                -1., sweepOriginHomo);
                if (VecMath.normsqrd(2, sweepDirection) != 0.) // if vertex is not exactly on sweep origin
                    VecMath.normalize(2, sweepDirection,
                                         sweepDirection);

                // Gather information about each neighbor,
                // into goodnesses, sweepGoodnesses, isBackwashes.
                FORI (iEdgeThisVert, v2e[iVert].length)
                {
                    int iNeighborEdge = v2e[iVert][iEdgeThisVert];
                    assert_eq(e2v[iNeighborEdge][0], iVert);
                    int iNeighborVert = e2v[iNeighborEdge][1];
                    VecMath.normalize(2, normalizedEdgeDirection, e2direction[iNeighborEdge]);
                    double goodness = VecMath.dot(2, normalizedEdgeDirection, vertMinusCentroidDirection);
                    double sweepGoodness = VecMath.dot(2, normalizedEdgeDirection, sweepDirection);
                    boolean isBackwash = (iNeighborVert < nVerts && v2parentVert[iNeighborVert] == iVert);
                    goodnesses[iEdgeThisVert] = goodness;
                    sweepGoodnesses[iEdgeThisVert] = sweepGoodness;
                    isBackwashes[iEdgeThisVert] = isBackwash;
                }

                // Figure out which we think is the best.
                // There are actually a lot of possible choices here.

                int bestNeighborEdge;
                int bestNeighborVert;
                {
                    int bestNeighborIndex = -1;
                    if (strategy == STRATEGY_RANDOM_GOOD)
                    {
                        int nGoods = 0;
                        if (goodnesses[0] == 0.
                         && goodnesses[1] == 0.
                         && goodnesses[2] == 0.)
                        {
                            bestNeighborIndex = VecMath.maxi(sweepGoodnesses);
                        }
                        else
                        {
                            FORI (iEdgeThisVert, v2e[iVert].length)
                            {
                                if (goodnesses[iEdgeThisVert] >= 0.)
                                {
                                    goods[nGoods++] = iEdgeThisVert;
                                }
                            }
                            assert_le_le(1, nGoods, 3);
                            bestNeighborIndex = goods[rng.nextInt(nGoods)];
                        }
                    }
                    else
                    {
                        FORI (iEdgeThisVert, v2e[iVert].length)
                        {
                            if (bestNeighborIndex == -1)
                            {
                                //assert(false); // coverage
                                bestNeighborIndex = iEdgeThisVert;
                            }
                            else
                            {
                                if (strategy == STRATEGY_BEST_GOODNESS) // original implementation
                                {
                                    if (goodnesses[iEdgeThisVert] > goodnesses[bestNeighborIndex])
                                    {
                                        //assert(false); // coverage
                                        bestNeighborIndex = iEdgeThisVert;
                                    }
                                    else if (goodnesses[iEdgeThisVert] < goodnesses[bestNeighborIndex])
                                    {
                                        //assert(false); // coverage
                                        ; // nothing
                                    }
                                    else if (sweepGoodnesses[iEdgeThisVert] > sweepGoodnesses[bestNeighborIndex])
                                    {
                                        //assert(false); // coverage
                                        bestNeighborIndex = iEdgeThisVert;
                                    }
                                    else if (sweepGoodnesses[iEdgeThisVert] < sweepGoodnesses[bestNeighborIndex])
                                    {
                                        //assert(false); // coverage
                                        ; // nothing
                                    }
                                    else
                                    {
                                        //assert(false); // coverage
                                        ; // nothing
                                    }
                                } 
                                else if (strategy == STRATEGY_BEST_COMPOSITE)
                                {
                                    // invariant: have to pick one with goodness >= 0.  so if one is >=0 and other is negative, must pick it.
                                    if (goodnesses[iEdgeThisVert] >= 0. && goodnesses[bestNeighborIndex] < 0.)
                                    {
                                        //assert(false); // coverage
                                        bestNeighborIndex = iEdgeThisVert;
                                    }
                                    else if (goodnesses[bestNeighborIndex] >= 0. && goodnesses[iEdgeThisVert] < 0.)
                                    {
                                        //assert(false); // coverage
                                        ; // nothing
                                    }
                                    else
                                    {
                                        //assert(false); // coverage
                                        // Favor non-backwash.
                                        if (!isBackwashes[iEdgeThisVert] && isBackwashes[bestNeighborIndex])
                                        {
                                            //assert(false); // coverage
                                            bestNeighborIndex = iEdgeThisVert;
                                        }
                                        else if (isBackwashes[iEdgeThisVert] && !isBackwashes[bestNeighborIndex])
                                        {
                                            //assert(false); // coverage
                                            ; // nothing
                                        }
                                        else
                                        {
                                            //assert(false); // coverage
                                            // Favor best sweep direction.
                                            // Doesn't need to be strictly positive.
                                            if (sweepGoodnesses[iEdgeThisVert] > sweepGoodnesses[bestNeighborIndex])
                                            {
                                                //assert(false); // coverage
                                                bestNeighborIndex = iEdgeThisVert;
                                            }
                                            else if (sweepGoodnesses[iEdgeThisVert] < sweepGoodnesses[bestNeighborIndex])
                                            {
                                                //assert(false); // coverage
                                                ; // nothing
                                            }
                                            else
                                            {
                                                //assert(false); // coverage
                                                // No other differentiators...
                                                // Favor best goodness.
                                                if (goodnesses[iEdgeThisVert] > goodnesses[bestNeighborIndex])
                                                {
                                                    //assert(false); // coverage
                                                    bestNeighborIndex = iEdgeThisVert;
                                                }
                                                else if (goodnesses[iEdgeThisVert] < goodnesses[bestNeighborIndex])
                                                {
                                                    //assert(false); // coverage
                                                    ; // nothing
                                                }
                                                else
                                                {
                                                    // No differentiators at all!  Wow!
                                                    //assert(false); // coverage
                                                    ; // nothing
                                                }
                                            }
                                        }
                                    }
                                }
                                else
                                {
                                    assert(false);
                                }
                            }
                        }
                    }


                    assert_ne(bestNeighborIndex, -1);
                    bestNeighborEdge = v2e[iVert][bestNeighborIndex];
                    bestNeighborVert = e2v[bestNeighborEdge][1];
                }

                if (verboseLevel >= 2) OUT("                      bestNeighborVert = "+bestNeighborVert);

                assert_ne(bestNeighborEdge, -1);
                assert_ne(bestNeighborVert, -1);
                assert_eq(v2parentEdge[iVert], -1);
                assert_eq(v2parentVert[iVert], -1);
                v2parentEdge[iVert] = bestNeighborEdge; // note it might get unset again in a moment if we backwash though
                v2parentVert[iVert] = bestNeighborVert; // note it might get unset again in a moment if we backwash though
                {
                    invalidationPathForDebugging.clear();
                    invalidationPathForDebugging.add(iVert);


                    // invalidate bestNeighbor and downstream, and put in todo list:
                    // bestNeighbor, its parent, grandparent, ...
                    // stopping when we either hit something that's already invalid-and-in-todo,
                    // or at the infinite vertex (which is always invalid but not in todo).
                    int v = bestNeighborVert;
                    while (v < nVerts && v2parentVert[v] != -1)
                    {
                        invalidationPathForDebugging.add(v);
                        if (verboseLevel >= 2) OUT("                          invalidating: "+v);
                        if (v == iVert)
                        {
                            // This is the interesting event!  Biting own tail.
                            int thisInvalidationPathCycle[] = invalidationPathForDebugging.toArray();
                            if (verboseLevel >= 1) OUT("                              iFineIter="+nFineIters+" ooh interesting! started at v"+iVert+" but invalidated it! "+VecMath.toString(vertsXY[iVert])+" invalidation path = "+Arrays.toStringCompact(VecMath.composeluts(v2priority, thisInvalidationPathCycle))+": "+Arrays.toStringCompact(thisInvalidationPathCycle));

                            if (strategy != STRATEGY_RANDOM_GOOD)
                            {
                                // Take fingerprint of the whole thing.

                                java.security.MessageDigest messageDigest;
                                try { messageDigest = java.security.MessageDigest.getInstance("SHA-1"); }
                                catch (java.security.NoSuchAlgorithmException e) { assert(false); }

                                String message = Arrays.toStringCompact(v2parentEdge); // CBB: could do something faster
                                messageDigest.update(message.getBytes());
                                java.math.BigInteger fingerprint = new java.math.BigInteger(1,messageDigest.digest());
                                Integer previous = (Integer)fingerprints.get(fingerprint);
                                if (previous != null)
                                {
                                    if (verboseLevel >= 0) OUT("                                  oh no! infinite loop detected!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! previous iFineIter="+previous);
                                    if (verboseLevel < 2)
                                    {
                                        // Allow another iteration with verbosity on.
                                        // Clear fingerprints, so that we will come back to this point.
                                        fingerprints.clear();
                                        fingerprints.put(fingerprint, nFineIters);

                                        // CBB: oh this isn't good, it will only tell about the very next one... want it to tell about everything til we get back to this same point!
                                        OUT("                                  setting verboseLevel to 2");
                                        verboseLevel = 2;
                                    }
                                    else
                                    {
                                        infiniteLoopDetected = true;
                                        putProblematicVertsHereForDebugging[0] = thisInvalidationPathCycle;
                                    }
                                }
                                else
                                {
                                    if (verboseLevel >= 2) OUT("                                      (I think I'm not in an infinite loop)");
                                    if (verboseLevel >= 2) OUT("                                      (inserting "+fingerprint+" -> "+nFineIters+")");
                                    fingerprints.put(fingerprint, nFineIters);
                                }
                            }
                        }
                        todo.add(v, (double)v2priority[v]);
                        int parentVert = v2parentVert[v];
                        v2parentEdge[v] = -1;
                        v2parentVert[v] = -1;
                        v = parentVert;
                    }
                }
            }
        } // while !todo.isEmpty()
        if (todo.isEmpty())
        {
            if (verboseLevel >= 1) OUT("          finished in "+iIter+"(coarse) "+nFineIters+"(fine) iterations!");
        }
        else
        {
            if (verboseLevel >= 1) OUT("          didn't finish in "+iIter+" iterations!");
        }

        // The result is now in v2parent.
        if (verboseLevel >= 2) PRINTVEC(v2parentEdge);
        if (verboseLevel >= 2) PRINTVEC(v2parentVert);
        Net net = new Net(originalMesh, originalDualMesh);
        FORI (iVert, nVerts)
        {
            if (v2parentEdge[iVert] != -1)
                net.cut(v2parentEdge[iVert], true);
        }
        if (verboseLevel >= 1) OUT("        out MyAlgorithmMaybe.doIt");
        return net;
    } // doIt
} // class MyAlgorithmMaybe

