#include "macros.h"

import com.donhatchsw.compat.IntArrayList;
import com.donhatchsw.util.SortStuff;
import com.donhatchsw.util.Arrays;
import com.donhatchsw.util.IndexBinaryHeap;
import com.donhatchsw.util.VecMath;

public class MyAlgorithmMaybe
{
    public final static int STRATEGY_BEST_GOODNESS = 1; // original implementation.  prone to infinite looping, in ways the code doesn't detect yet.
    public final static int STRATEGY_BEST_COMPOSITE = 2; // second implementation.  seen it bite own tail (Just Noise 10000, prewarp, apply radial match. more tailbiting with upward than outward).  hard to make it infinite loop (radial heightfields don't do it) but I got it to, see DUMP.off.ConvexNoise1_144_makes_my_algorithm_infinite_loop
    public static int strategy = STRATEGY_BEST_COMPOSITE; // TODO: make this a parameter to doIt, maybe

    private MyAlgorithmMaybe(){ throw new AssertionError(); } // non-instantiatable util class

    // So I can see more clearly,
    // isolate exactly the data we will use during the algorithm(s).
    private static class HelperDataStructure
    {
        //
        // Representation of the original mesh with vertex weights.
        // Immutable after initial construction.
        //
        public double vertsXY[/*nVerts*/][/*2*/];
        public double v2momentAndArea[][/*4*/]; // from original verts... although I suspect [2] isn't meaningful for us
        public double e2direction[/*nEdges*/][/*3*/];
        public int e2v[/*nEdges*/][/*2*/]; // values are in [0..nVerts] (not 0..nVerts-1 !) since nVerts represents "the infinite vertex"
        public int v2e[/*nVerts*/][];

        public int v2priority[/*nVerts*/];
        public int priority2v[/*nVerts*/];


        public HelperDataStructure(Mesh mesh, double sweepOriginHomo[/*3*/])
        {
            int nVerts = mesh.verts.size();
            int nEdges = mesh.edges.size();
            this.vertsXY = MeshUtils.getMeshVertsXY(mesh);
            assert(vertsXY.length == nVerts);
            this.v2momentAndArea = new double[nVerts][];
            FORI (iVert, nVerts)
                this.v2momentAndArea[iVert] = mesh.getVert(iVert).momentAndArea;
            this.e2direction = new double[nEdges][];
            FORI (iEdge, nEdges)
                this.e2direction[iEdge] = mesh.getEdge(iEdge).direction;

            {
                MeshUtils.SimplerMeshDataStructure simplerMeshDataStructure = new MeshUtils.SimplerMeshDataStructure(mesh, true);
                this.e2v = simplerMeshDataStructure.e2v;
                this.v2e = simplerMeshDataStructure.v2e;
            }
            assert(this.e2v.length == nEdges);
            assert(this.v2e.length == nVerts+1); // the "infinite vertex" got added at the end


            // CBB: SimplerMeshDataStructure should emit in ccw order.
            if (true)
            {
                // Fix so neighbors of each vert are listed in ccw order
                FORI (iVert, nVerts)
                {
                    if (VecMath.vxv2(e2direction[v2e[iVert][0]],
                                     e2direction[v2e[iVert][1]]) < 0.)
                    {
                        int temp;
                        SWAP(v2e[iVert][0], v2e[iVert][1], temp);
                    }
                    assert(v2e[iVert].length == 3);
                    assert(VecMath.vxv2(e2direction[v2e[iVert][0]],
                                    e2direction[v2e[iVert][1]]) > 0.);
                    assert(VecMath.vxv2(e2direction[v2e[iVert][1]],
                                        e2direction[v2e[iVert][2]]) > 0.);
                    assert(VecMath.vxv2(e2direction[v2e[iVert][2]],
                                        e2direction[v2e[iVert][0]]) > 0.);

                }
            }



            double v2orderKey[] = new double[nVerts]; // vertex to radius squared, i.e. distance squared from center
            {
                double center[] = new double[2]; // scratch for loop
                // TODO: do this homo math right... if there is a "right"
                assert(sweepOriginHomo.length == 3);
                if (sweepOriginHomo[2] == 0.)
                {
                    FORI (iVert, nVerts)
                        v2orderKey[iVert] = -VecMath.dot(2, vertsXY[iVert], sweepOriginHomo);
                }
                else
                {
                    VecMath.vxs(2, center, sweepOriginHomo, 1./sweepOriginHomo[2]);
                    FORI (iVert, nVerts)
                        v2orderKey[iVert] = VecMath.distsqrd(2, vertsXY[iVert], center);
                }
            }

            // Could just make an IndexBinaryHeap based on v2orderKey,
            // but it's nicer to use indices that reflect how much progress has been made.
            this.priority2v = VecMath.identityperm(nVerts);
            SortStuff.sort(this.priority2v, new SortStuff.IntComparator() {
                @Override public int compare(int a, int b)
                {
                    if (v2orderKey[a] < v2orderKey[b]) return -1;
                    if (v2orderKey[a] > v2orderKey[b]) return 1;
                    // Arbitrarily use original index as tiebreaker
                    // CBB: use some geometric consideration instead?
                    // Could also use a random permutation, but I would like to be deterministic, so no.
                    if (a < b) return -1;
                    if (a > b) return 1;
                    return 0;
                }
            });
            this.v2priority = VecMath.invertperm(this.priority2v);
        }
    }; // HelperDataStructure



    public static Net doIt2(
        Mesh originalMesh, Mesh originalDualMesh, // generally reversed from the calling app's notion
        double sweepOriginHomo[/*3*/], // if [2] is 0, the vertex is infinitely far from origin
        int maxIters, // interpreted in funny way
        int putProblematicVertsHereForDebugging[/*1*/][],
        double putLastPointSweptHere[/*1*/][/*2*/])
    {
        int verboseLevel = 1; // 1: constant, 2: linear
        if (verboseLevel >= 1) OUT("        in MyAlgorithmMaybe.doIt");
        assert(sweepOriginHomo.length == 3);

        int nVerts = originalMesh.verts.size();
        int nEdges = originalMesh.edges.size();
        if (verboseLevel >= 1) OUT("          nVerts = "+nVerts);
        if (verboseLevel >= 1) OUT("          nEdges = "+nEdges);

        HelperDataStructure helperDataStructure = new HelperDataStructure(originalMesh, sweepOriginHomo);
        double vertsXY[][] = helperDataStructure.vertsXY;
        double v2momentAndArea[][] = helperDataStructure.v2momentAndArea;
        double e2direction[][] = helperDataStructure.e2direction;
        int e2v[][] = helperDataStructure.e2v;
        int v2e[][] = helperDataStructure.v2e;
        int v2priority[] = helperDataStructure.v2priority;
        int priority2v[] = helperDataStructure.priority2v;

        double v2momentAndWeightStrictlyUpstream[][] = new double[nVerts][3];
        // CBB: could just have v2parentEdge, I suppose
        int v2parentEdge[] = VecMath.fillvec(nVerts, -1);
        int v2parentVert[] = VecMath.fillvec(nVerts, -1);

        IndexBinaryHeap todo = new IndexBinaryHeap(nVerts);
        FORI (iVert, nVerts)
        {
            if (v2e[iVert].length != 0) // if not isolated, i.e. not one of the original inside out verts
                todo.add(iVert, (double)v2priority[iVert]);
        }

        double vertMinusCentroidDirection[] = new double[2]; // scratch for loop
        double sweepDirection[] = new double[2]; // scratch for loop
        int maxValence = 0; FORI (iVert, nVerts) maxValence = MAX(maxValence, v2e[iVert].length);
        assert(maxValence == 3); // XXX unless no edges... need to get something more solid here
        double goodnesses[] = new double[maxValence]; // scratch for loop
        double sweepGoodnesses[] = new double[maxValence]; // scratch for loop
        boolean isBackwashes[] = new boolean[maxValence]; // scratch for loop

        double centroid[] = new double[2]; // very scratch for loop
        double normalizedEdgeDirection[] = new double[2]; // very scratch for loop

        int lastVertexConsidered = -1;

        int iIter;
        boolean fatalProblemDetected = false;
        for (iIter = 0;
             !todo.isEmpty() && (maxIters<0 || iIter < maxIters) && !fatalProblemDetected;
             ++iIter)
        {
            // On even iterations, we just sweep to the next vertex but don't do anything with it.
            // This helps for a nicer visualization.
            if (iIter % 2 == 0)
            {
                lastVertexConsidered = todo.min();
                continue;
            }

            int iVert = todo.extractMin();
            lastVertexConsidered = iVert;
            if (verboseLevel >= 2) OUT("              iIter="+iIter+": top of loop");
            if (verboseLevel >= 2) OUT("                  priority="+v2priority[iVert]+" iVert="+iVert);
            assert(iVert < nVerts);
            assert(v2parentEdge[iVert] == -1);
            assert(v2parentVert[iVert] == -1);

            VecMath.zerovec(v2momentAndWeightStrictlyUpstream[iVert]);
            FORI (iEdgeThisVert, v2e[iVert].length)
            {
                int iNeighborVert = e2v[v2e[iVert][iEdgeThisVert]][1];
                if (iNeighborVert < nVerts
                 && v2parentVert[iNeighborVert] == iVert)
                {
                    if (verboseLevel >= 2) OUT("                          accumulating centroid from upstream vert "+iNeighborVert);
                    GeomUtils.accumulateMomentAndArea(v2momentAndWeightStrictlyUpstream[iVert],
                                                      v2momentAndWeightStrictlyUpstream[iNeighborVert]);
                    GeomUtils.accumulateMomentAndArea(v2momentAndWeightStrictlyUpstream[iVert],
                                                      v2momentAndArea[iNeighborVert]);
                }
            }

            // get vertMinusCentroidDirection: unit, or zero (if weight is zero or centroid is exactly at vert)
            if (v2momentAndWeightStrictlyUpstream[iVert][2] > 0.)
            {
                VecMath.vxs(2, centroid, v2momentAndWeightStrictlyUpstream[iVert], 1./v2momentAndWeightStrictlyUpstream[iVert][2]);
                //if (verboseLevel >= 2) PRINTVEC(vertsXY[iVert]);
                //if (verboseLevel >= 2) PRINTVEC(centroid);
                VecMath.vmv(2, vertMinusCentroidDirection, vertsXY[iVert], centroid);
                //if (verboseLevel >= 2) PRINTVEC(vertMinusCentroidDirection);
                if (VecMath.normsqrd(2, vertMinusCentroidDirection) != 0.) // if it didn't happen to land exactly on vertex
                    VecMath.normalize(2, vertMinusCentroidDirection,
                                         vertMinusCentroidDirection);
            }
            else
                VecMath.zerovec(2, vertMinusCentroidDirection);

            // Get sweepDirection: unit, or zero (if sweep origin is exactly at vert).
            // sweepDirection = vertsXY[iVert] - sweepOrigin, homogeneous
            VecMath.sxvpsxv(2, sweepDirection,
                            sweepOriginHomo[2], vertsXY[iVert],
                            -1., sweepOriginHomo);
            if (VecMath.normsqrd(2, sweepDirection) != 0.) // if vertex is not exactly on sweep origin
                VecMath.normalize(2, sweepDirection,
                                     sweepDirection);

            if (verboseLevel >= 2) OUT("                      vertMinusCentroidDirection = "+VecMath.toString(vertMinusCentroidDirection));
            if (verboseLevel >= 2) OUT("                      sweepDirection = "+VecMath.toString(sweepDirection));

            // Gather information about each neighbor,
            // into goodnesses, sweepGoodnesses, isBackwashes.
            FORI (iEdgeThisVert, v2e[iVert].length)
            {
                int iNeighborEdge = v2e[iVert][iEdgeThisVert];
                assert(e2v[iNeighborEdge][0] == iVert);
                int iNeighborVert = e2v[iNeighborEdge][1];
                if (verboseLevel >= 2) OUT("                          neighbor "+iEdgeThisVert+": e"+iNeighborEdge+" -> v"+iNeighborVert);
                VecMath.normalize(2, normalizedEdgeDirection, e2direction[iNeighborEdge]);
                if (verboseLevel >= 2) OUT("                              normalizedEdgeDirection = "+VecMath.toString(normalizedEdgeDirection));
                double goodness = VecMath.dot(2, normalizedEdgeDirection, vertMinusCentroidDirection);
                double sweepGoodness = VecMath.dot(2, normalizedEdgeDirection, sweepDirection);
                boolean isBackwash = (iNeighborVert < nVerts && v2parentVert[iNeighborVert] == iVert);
                if (verboseLevel >= 2) OUT("                                  goodness = "+goodness);
                if (verboseLevel >= 2) OUT("                                  sweepGoodness = "+sweepGoodness);
                if (verboseLevel >= 2) OUT("                                  isBackwash = "+isBackwash);
                goodnesses[iEdgeThisVert] = goodness;
                sweepGoodnesses[iEdgeThisVert] = sweepGoodness;
                isBackwashes[iEdgeThisVert] = isBackwash;
            }


            {
                // Easy case: if there's a good edge to a not-yet-swept vert, take it. If more than one, prefer most sweepward.
                // NOTE: this isn't entirely principled, since a good edge to not-yet-swept vert might actually
                // start out against the sweep dir (if the edge goes tangent to the sweep circle).
                // However, it seems to end up doing something reasonable (at least in OutStressor),
                // so we let it slide for now.
                // Might need to adjust this at some point by adding synthetic events/verts at tangent points,
                // so that "to unswept vert" always means same thing as "in sweep direction".
                int bestNeighborIndex = -1;
                FORI (iEdgeThisVert, v2e[iVert].length)
                {
                    int jVert = e2v[v2e[iVert][iEdgeThisVert]][1];
                    if ((jVert==nVerts || v2parentVert[jVert]==-1)
                     && goodnesses[iEdgeThisVert] >= 0.
                     && (bestNeighborIndex==-1
                      || sweepGoodnesses[iEdgeThisVert] > sweepGoodnesses[bestNeighborIndex]))
                        bestNeighborIndex = iEdgeThisVert;
                }
                if (bestNeighborIndex != -1)
                {
                    if (verboseLevel >= 2) OUT("                      easy case: there's a good edge to a not-yet-swept vert");
                    int bestNeighborEdge = v2e[iVert][bestNeighborIndex];
                    int bestNeighborVert = e2v[bestNeighborEdge][1];
                    if (verboseLevel >= 2) OUT("                          bestNeighborVert = "+bestNeighborVert);
                    assert(bestNeighborEdge != -1);
                    assert(bestNeighborVert != -1);
                    assert(v2parentEdge[iVert] == -1);
                    assert(v2parentVert[iVert] == -1);
                    v2parentEdge[iVert] = bestNeighborEdge;
                    v2parentVert[iVert] = bestNeighborVert;
                    if (verboseLevel >= 2) OUT("                          adding edge e"+v2parentEdge[iVert]+" (v"+iVert+"->v"+v2parentVert[iVert]+")");
                    continue;
                }
            }

            {
                // All edges to not-yet-swept verts are bad.
                // There's usually 1 of them, but could be 2 (see DUMP.2badup.off).
                // Oh wait!  I think there can actually be only 1 of them, assuming we didn't fudge the previous edge!!
                assert(v2e[iVert].length == 3);

                int firstNotYetSweptNeighborIndex = -1;
                int lastNotYetSweptNeighborIndex = -1;
                FORI (iEdgeThisVert, v2e[iVert].length)
                {
                    int jVert = e2v[v2e[iVert][iEdgeThisVert]][1];
                    if (jVert==nVerts || v2parentVert[jVert]==-1)
                    {
                        if (firstNotYetSweptNeighborIndex == -1)
                            firstNotYetSweptNeighborIndex = iEdgeThisVert;
                        lastNotYetSweptNeighborIndex = iEdgeThisVert;
                    }
                }
                assert(firstNotYetSweptNeighborIndex != -1);
                assert(lastNotYetSweptNeighborIndex != -1);
                if (firstNotYetSweptNeighborIndex == 0 && lastNotYetSweptNeighborIndex == 2)
                {
                    // hack-- make it so first and last are when traversing around the vert (assume CCW)
                    firstNotYetSweptNeighborIndex = 2;
                    lastNotYetSweptNeighborIndex = 0;
                }
                if (verboseLevel >= 2) OUT("                      first not-yet-swept neighbor = v"+e2v[v2e[iVert][firstNotYetSweptNeighborIndex]][1]);
                if (verboseLevel >= 2) OUT("                      last not-yet-swept neighbor = v"+e2v[v2e[iVert][lastNotYetSweptNeighborIndex]][1]);

                // Is the downstream turn too far left or too far right? Must be one or the other.
                // I.e. does the bad quill(s) point CCW or CW?
                boolean isLeftTurn;
                {
                    // I.e. does the quill point CCW or CW?
                    assert(VecMath.normsqrd(2, sweepDirection) != 0.); // we can't get here if vert is exactly at sweep origin
                    assert(VecMath.normsqrd(2, vertMinusCentroidDirection) != 0.); // would have to be extremely degenerate for this to fail
                    double leftTurnness = VecMath.vxv2(vertMinusCentroidDirection, sweepDirection);
                    assert(leftTurnness != 0.);
                    isLeftTurn = leftTurnness > 0.;
                }
                if (verboseLevel >= 2) OUT("                      isLeftTurn = "+isLeftTurn);



                int walkTheBoundaryIndex =
                    isLeftTurn ? MOD(firstNotYetSweptNeighborIndex-1,3) // walk around boundary CW
                               : MOD(lastNotYetSweptNeighborIndex+1,3); // walk around boundary CCW
                {
                    // Next most easy case:
                    // the walk-the-boundary edge is to an already-swept vert
                    // whose parent is unswept (not iVert itself)
                    // so that we can erase that edge and put it back on the todo list.
                    int jEdge = v2e[iVert][walkTheBoundaryIndex];
                    int jVert = e2v[jEdge][1];
                    int kVert = v2parentVert[jVert];
                    if (verboseLevel >= 2) OUT("                      walk-the-boundary: e"+jEdge+"(v"+iVert+"->v"+jVert+") parent v"+kVert);
                    assert(kVert != -1);
                    if (kVert == iVert)
                    {
                        if (verboseLevel >= 2) OUT("                          (damn! it's my child)");
                    }
                    if (kVert != iVert && v2parentVert[kVert] == -1)
                    {
                        if (verboseLevel >= 2) OUT("                      second-most-easy case: erasing e"+v2parentEdge[jVert]+" (v"+jVert+"->v"+kVert+") and putting v"+jVert+" back on todo list");
                        v2parentEdge[jVert] = -1;
                        v2parentVert[jVert] = -1;
                        todo.add(jVert, (double)v2priority[jVert]);

                        v2parentEdge[iVert] = jEdge;
                        v2parentVert[iVert] = jVert;
                        if (verboseLevel >= 2) if (verboseLevel >= 2) OUT("                          adding edge e"+v2parentEdge[iVert]+" (v"+iVert+"->v"+v2parentVert[iVert]+")");
                        continue;
                    }
                }

                // TODO: fix it!
                int chosenEdge = v2e[iVert][firstNotYetSweptNeighborIndex];
                int chosenVert = e2v[chosenEdge][1];
                OUT("              XXX outputting bad edge from v"+iVert+" to v"+chosenVert+" on iteration "+iIter);
                v2parentEdge[iVert] = chosenEdge;
                v2parentVert[iVert] = chosenVert;
                continue;
            }
        }
        if (todo.isEmpty() && !fatalProblemDetected)
        {
            if (verboseLevel >= 1) OUT("          finished in "+iIter+" iterations!");
        }
        else
        {
            if (verboseLevel >= 1) OUT("          didn't finish in "+iIter+" iterations!");
        }

        // The result is now in v2parent.
        if (verboseLevel >= 2) PRINTVEC(v2parentEdge);
        if (verboseLevel >= 2) PRINTVEC(v2parentVert);
        Net net = new Net(originalMesh, originalDualMesh);
        FORI (iVert, nVerts)
        {
            if (v2parentEdge[iVert] != -1)
                net.cut(v2parentEdge[iVert], true);
        }

        if (lastVertexConsidered != -1 && putLastPointSweptHere != null)
        {
            putLastPointSweptHere[0] = vertsXY[lastVertexConsidered];
        }

        if (verboseLevel >= 1) OUT("        out MyAlgorithmMaybe.doIt");
        return net;
    } // doIt2

    public static Net doIt(
        Mesh originalMesh, Mesh originalDualMesh, // generally reversed from the calling app's notion
        double sweepOriginHomo[/*3*/], // if [2] is 0, the vertex is infinitely far from origin
        int maxIters,
        int putProblematicVertsHereForDebugging[/*1*/][])
    {
        int verboseLevel = 1;
        if (verboseLevel >= 1) OUT("        in MyAlgorithmMaybe.doIt");
        assert(sweepOriginHomo.length == 3);

        int nVerts = originalMesh.verts.size();
        int nEdges = originalMesh.edges.size();
        if (verboseLevel >= 1) OUT("          nVerts = "+nVerts);
        if (verboseLevel >= 1) OUT("          nEdges = "+nEdges);

        HelperDataStructure helperDataStructure = new HelperDataStructure(originalMesh, sweepOriginHomo);
        double vertsXY[][] = helperDataStructure.vertsXY;
        double v2momentAndArea[][] = helperDataStructure.v2momentAndArea;
        double e2direction[][] = helperDataStructure.e2direction;
        int e2v[][] = helperDataStructure.e2v;
        int v2e[][] = helperDataStructure.v2e;
        int v2priority[] = helperDataStructure.v2priority;
        int priority2v[] = helperDataStructure.priority2v;

        double v2momentAndWeightStrictlyUpstream[][] = new double[nVerts][3];
        // CBB: could just have v2parentEdge, I suppose
        int v2parentEdge[] = VecMath.fillvec(nVerts, -1);
        int v2parentVert[] = VecMath.fillvec(nVerts, -1);

        IndexBinaryHeap todo = new IndexBinaryHeap(nVerts);
        FORI (iVert, nVerts)
        {
            if (v2e[iVert].length != 0) // if not isolated, i.e. not one of the original inside out verts
                todo.add(iVert, (double)v2priority[iVert]);
        }

        double vertMinusCentroidDirection[] = new double[2]; // scratch for loop
        double sweepDirection[] = new double[2]; // scratch for loop
        int maxValence = 0; FORI (iVert, nVerts) maxValence = MAX(maxValence, v2e[iVert].length);
        assert(maxValence == 3); // XXX unless no edges... need to get something more solid here
        double goodnesses[] = new double[maxValence]; // scratch for loop
        double sweepGoodnesses[] = new double[maxValence]; // scratch for loop
        boolean isBackwashes[] = new boolean[maxValence]; // scratch for loop

        double centroid[] = new double[2]; // very scratch for loop
        double normalizedEdgeDirection[] = new double[2]; // very scratch for loop

        java.util.HashMap fingerprints = new java.util.HashMap();
        IntArrayList invalidationPathForDebugging = new IntArrayList(); // scratch for loop

        int nFineIters = 0;
        int iIter;
        boolean infiniteLoopDetected = false;
        for (iIter = 0;
             !todo.isEmpty() && (maxIters<0 || iIter < maxIters) && !infiniteLoopDetected;
             ++iIter)
        {
            int iVert = todo.min();
            if (verboseLevel >= 2) OUT("              iIter="+iIter+": top of loop");
            if (verboseLevel >= 2) OUT("                  priority="+v2priority[iVert]+" iVert="+iVert);
            assert(iVert < nVerts);
            assert(v2parentEdge[iVert] == -1);
            assert(v2parentVert[iVert] == -1);

            while (v2parentVert[iVert] == -1 // this is sort of a hack: keep going as long as I got put back on the todo list, even if I'm not otherwise the first on the todo list.  I have no reason to think this will result in a good algorithm, it's just a heuristic to get out of the endless-loop of the moment.
                && !infiniteLoopDetected)
            {
                nFineIters++;
                todo.remove(iVert);

                VecMath.zerovec(v2momentAndWeightStrictlyUpstream[iVert]);
                FORI (iEdgeThisVert, v2e[iVert].length)
                {
                    int iNeighborVert = e2v[v2e[iVert][iEdgeThisVert]][1];
                    if (iNeighborVert < nVerts
                     && v2parentVert[iNeighborVert] == iVert)
                    {
                        if (verboseLevel >= 2) OUT("                          accumulating from upstream vert "+iNeighborVert);
                        GeomUtils.accumulateMomentAndArea(v2momentAndWeightStrictlyUpstream[iVert],
                                                          v2momentAndWeightStrictlyUpstream[iNeighborVert]);
                        GeomUtils.accumulateMomentAndArea(v2momentAndWeightStrictlyUpstream[iVert],
                                                          v2momentAndArea[iNeighborVert]);
                    }
                }

                // get vertMinusCentroidDirection: unit, or zero (if weight is zero or centroid is exactly at vert)
                if (v2momentAndWeightStrictlyUpstream[iVert][2] > 0.)
                {
                    VecMath.vxs(2, centroid, v2momentAndWeightStrictlyUpstream[iVert], 1./v2momentAndWeightStrictlyUpstream[iVert][2]);
                    VecMath.vmv(2, vertMinusCentroidDirection, vertsXY[iVert], centroid);
                    if (VecMath.normsqrd(2, vertMinusCentroidDirection) != 0.) // if it didn't happen to land exactly on vertex
                        VecMath.normalize(2, vertMinusCentroidDirection,
                                             vertMinusCentroidDirection);
                }
                else
                    VecMath.zerovec(2, vertMinusCentroidDirection);

                // Get sweepDirection: unit, or zero (if sweep origin is exactly at vert).
                // sweepDirection = vertsXY[iVert] - sweepOrigin, homogeneous
                VecMath.sxvpsxv(2, sweepDirection,
                                sweepOriginHomo[2], vertsXY[iVert],
                                -1., sweepOriginHomo);
                if (VecMath.normsqrd(2, sweepDirection) != 0.) // if vertex is not exactly on sweep origin
                    VecMath.normalize(2, sweepDirection,
                                         sweepDirection);

                // Gather information about each neighbor,
                // into goodnesses, sweepGoodnesses, isBackwashes.
                FORI (iEdgeThisVert, v2e[iVert].length)
                {
                    int iNeighborEdge = v2e[iVert][iEdgeThisVert];
                    assert(e2v[iNeighborEdge][0] == iVert);
                    int iNeighborVert = e2v[iNeighborEdge][1];
                    VecMath.normalize(2, normalizedEdgeDirection, e2direction[iNeighborEdge]);
                    double goodness = VecMath.dot(2, normalizedEdgeDirection, vertMinusCentroidDirection);
                    double sweepGoodness = VecMath.dot(2, normalizedEdgeDirection, sweepDirection);
                    boolean isBackwash = (iNeighborVert < nVerts && v2parentVert[iNeighborVert] == iVert);
                    goodnesses[iEdgeThisVert] = goodness;
                    sweepGoodnesses[iEdgeThisVert] = sweepGoodness;
                    isBackwashes[iEdgeThisVert] = isBackwash;
                }

                // Figure out which we think is the best.
                // There are actually a lot of possible choices here.

                int bestNeighborEdge;
                int bestNeighborVert;
                {
                    int bestNeighborIndex = -1;
                    FORI (iEdgeThisVert, v2e[iVert].length)
                    {
                        if (bestNeighborIndex == -1)
                        {
                            //assert(false); // coverage
                            bestNeighborIndex = iEdgeThisVert;
                        }
                        else
                        {
                            if (strategy == STRATEGY_BEST_GOODNESS) // original implementation
                            {
                                if (goodnesses[iEdgeThisVert] > goodnesses[bestNeighborIndex])
                                {
                                    //assert(false); // coverage
                                    bestNeighborIndex = iEdgeThisVert;
                                }
                                else if (goodnesses[iEdgeThisVert] < goodnesses[bestNeighborIndex])
                                {
                                    //assert(false); // coverage
                                    ; // nothing
                                }
                                else if (sweepGoodnesses[iEdgeThisVert] > sweepGoodnesses[bestNeighborIndex])
                                {
                                    //assert(false); // coverage
                                    bestNeighborIndex = iEdgeThisVert;
                                }
                                else if (sweepGoodnesses[iEdgeThisVert] < sweepGoodnesses[bestNeighborIndex])
                                {
                                    //assert(false); // coverage
                                    ; // nothing
                                }
                                else
                                {
                                    //assert(false); // coverage
                                    ; // nothing
                                }
                            } 
                            else if (strategy == STRATEGY_BEST_COMPOSITE)
                            {
                                // invariant: have to pick one with goodness >= 0.  so if one is >=0 and other is negative, must pick it.
                                if (goodnesses[iEdgeThisVert] >= 0. && goodnesses[bestNeighborIndex] < 0.)
                                {
                                    //assert(false); // coverage
                                    bestNeighborIndex = iEdgeThisVert;
                                }
                                else if (goodnesses[bestNeighborIndex] >= 0. && goodnesses[iEdgeThisVert] < 0.)
                                {
                                    //assert(false); // coverage
                                    ; // nothing
                                }
                                else
                                {
                                    //assert(false); // coverage
                                    // Favor non-backwash.
                                    if (!isBackwashes[iEdgeThisVert] && isBackwashes[bestNeighborIndex])
                                    {
                                        //assert(false); // coverage
                                        bestNeighborIndex = iEdgeThisVert;
                                    }
                                    else if (isBackwashes[iEdgeThisVert] && !isBackwashes[bestNeighborIndex])
                                    {
                                        //assert(false); // coverage
                                        ; // nothing
                                    }
                                    else
                                    {
                                        //assert(false); // coverage
                                        // Favor best sweep direction.
                                        // Doesn't need to be strictly positive.
                                        if (sweepGoodnesses[iEdgeThisVert] > sweepGoodnesses[bestNeighborIndex])
                                        {
                                            //assert(false); // coverage
                                            bestNeighborIndex = iEdgeThisVert;
                                        }
                                        else if (sweepGoodnesses[iEdgeThisVert] < sweepGoodnesses[bestNeighborIndex])
                                        {
                                            //assert(false); // coverage
                                            ; // nothing
                                        }
                                        else
                                        {
                                            //assert(false); // coverage
                                            // No other differentiators...
                                            // Favor best goodness.
                                            if (goodnesses[iEdgeThisVert] > goodnesses[bestNeighborIndex])
                                            {
                                                //assert(false); // coverage
                                                bestNeighborIndex = iEdgeThisVert;
                                            }
                                            else if (goodnesses[iEdgeThisVert] < goodnesses[bestNeighborIndex])
                                            {
                                                //assert(false); // coverage
                                                ; // nothing
                                            }
                                            else
                                            {
                                                // No differentiators at all!  Wow!
                                                //assert(false); // coverage
                                                ; // nothing
                                            }
                                        }
                                    }
                                }
                            }
                            else
                            {
                                assert(false);
                            }
                        }
                    }
                    assert(bestNeighborIndex != -1);
                    bestNeighborEdge = v2e[iVert][bestNeighborIndex];
                    bestNeighborVert = e2v[bestNeighborEdge][1];
                }

                if (verboseLevel >= 2) OUT("                      bestNeighborVert = "+bestNeighborVert);

                assert(bestNeighborEdge != -1);
                assert(bestNeighborVert != -1);
                assert(v2parentEdge[iVert] == -1);
                assert(v2parentVert[iVert] == -1);
                v2parentEdge[iVert] = bestNeighborEdge; // note it might get unset again in a moment if we backwash though
                v2parentVert[iVert] = bestNeighborVert; // note it might get unset again in a moment if we backwash though
                {
                    invalidationPathForDebugging.clear();
                    invalidationPathForDebugging.add(iVert);


                    // invalidate bestNeighbor and downstream, and put in todo list:
                    // bestNeighbor, its parent, grandparent, ...
                    // stopping when we either hit something that's already invalid-and-in-todo,
                    // or at the infinite vertex (which is always invalid but not in todo).
                    int v = bestNeighborVert;
                    while (v < nVerts && v2parentVert[v] != -1)
                    {
                        invalidationPathForDebugging.add(v);
                        if (verboseLevel >= 2) OUT("                          invalidating: "+v);
                        if (v == iVert)
                        {
                            // This is the interesting event!  Biting own tail.
                            int thisInvalidationPathCycle[] = invalidationPathForDebugging.toArray();
                            if (verboseLevel >= 1) OUT("                              iFineIter="+nFineIters+" ooh interesting! started at v"+iVert+" but invalidated it! "+VecMath.toString(vertsXY[iVert])+" invalidation path = "+Arrays.toStringCompact(VecMath.composeluts(v2priority, thisInvalidationPathCycle))+": "+Arrays.toStringCompact(thisInvalidationPathCycle));

                            {
                                // Take fingerprint of the whole thing.

                                java.security.MessageDigest messageDigest;
                                try { messageDigest = java.security.MessageDigest.getInstance("SHA-1"); }
                                catch (java.security.NoSuchAlgorithmException e) { assert(false); }

                                String message = Arrays.toStringCompact(v2parentEdge); // CBB: could do something faster
                                messageDigest.update(message.getBytes());
                                java.math.BigInteger fingerprint = new java.math.BigInteger(1,messageDigest.digest());
                                Integer previous = (Integer)fingerprints.get(fingerprint);
                                if (previous != null)
                                {
                                    if (verboseLevel >= 0) OUT("                                  oh no! infinite loop detected!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! previous iFineIter="+previous);
                                    if (verboseLevel < 2)
                                    {
                                        // Allow another iteration with verbosity on.
                                        // Clear fingerprints, so that we will come back to this point.
                                        fingerprints.clear();
                                        fingerprints.put(fingerprint, nFineIters);

                                        // CBB: oh this isn't good, it will only tell about the very next one... want it to tell about everything til we get back to this same point!
                                        OUT("                                  setting verboseLevel to 2");
                                        verboseLevel = 2;
                                    }
                                    else
                                    {
                                        infiniteLoopDetected = true;
                                        putProblematicVertsHereForDebugging[0] = thisInvalidationPathCycle;
                                    }
                                }
                                else
                                {
                                    if (verboseLevel >= 2) OUT("                                      (I think I'm not in an infinite loop)");
                                    if (verboseLevel >= 2) OUT("                                      (inserting "+fingerprint+" -> "+nFineIters+")");
                                    fingerprints.put(fingerprint, nFineIters);
                                }
                            }
                        }
                        todo.add(v, (double)v2priority[v]);
                        int parentVert = v2parentVert[v];
                        v2parentEdge[v] = -1;
                        v2parentVert[v] = -1;
                        v = parentVert;
                    }
                }
            }
        } // while !todo.isEmpty()
        if (todo.isEmpty())
        {
            if (verboseLevel >= 1) OUT("          finished in "+iIter+"(coarse) "+nFineIters+"(fine) iterations!");
        }
        else
        {
            if (verboseLevel >= 1) OUT("          didn't finish in "+iIter+" iterations!");
        }

        // The result is now in v2parent.
        if (verboseLevel >= 2) PRINTVEC(v2parentEdge);
        if (verboseLevel >= 2) PRINTVEC(v2parentVert);
        Net net = new Net(originalMesh, originalDualMesh);
        FORI (iVert, nVerts)
        {
            if (v2parentEdge[iVert] != -1)
                net.cut(v2parentEdge[iVert], true);
        }
        if (verboseLevel >= 1) OUT("        out MyAlgorithmMaybe.doIt");
        return net;
    }
} // class MyAlgorithmMaybe

