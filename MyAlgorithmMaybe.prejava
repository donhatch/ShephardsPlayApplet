#include "macros.h"

import com.donhatchsw.compat.IntArrayList;
import com.donhatchsw.util.Arrays;
import com.donhatchsw.util.IndexBinaryHeap;
import com.donhatchsw.util.VecMath;

public class MyAlgorithmMaybe
{
    private MyAlgorithmMaybe(){ throw new AssertionError(); } // non-instantiatable util class

    public static Net doIt(
        Mesh mesh, Mesh dualMesh, // generally reversed from the app's notion
        double sweepOriginHomo[/*3*/],
        int maxIters)
    {
        int verboseLevel = 1;
        if (verboseLevel >= 1) OUT("        in MyAlgorithmMaybe.doIt");
        assert(sweepOriginHomo.length == 3);
        int nVerts = mesh.verts.size();
        int nEdges = mesh.edges.size();
        double verts[][] = MeshUtils.getMeshVertsXYH(mesh);
        assert(verts.length == nVerts);
        double v2orderKey[] = new double[nVerts]; // vertex to radius squared, i.e. distance squared from center

        // TODO: do this homo math right
        if (sweepOriginHomo[2] == 0.)
        {
          FORI (iVert, nVerts)
              v2orderKey[iVert] = -VecMath.dot(2, verts[iVert], sweepOriginHomo);
        }
        else
        {
          double center[] = VecMath.vxs(2, sweepOriginHomo, 1./sweepOriginHomo[2]);
          FORI (iVert, nVerts)
              v2orderKey[iVert] = VecMath.distsqrd(2, verts[iVert], center);
        }

        MeshUtils.SimplerMeshDataStructure simplerMeshDataStructure = new MeshUtils.SimplerMeshDataStructure(mesh, true);
        int e2v[][] = simplerMeshDataStructure.e2v;
        int v2e[][] = simplerMeshDataStructure.v2e;
        assert(e2v.length == nEdges);
        assert(v2e.length == nVerts+1); // the "infinite vertex" got added at the end

        double v2momentAndWeightStrictlyUpstream[][] = new double[nVerts][3];
        // CBB: could just have v2parentEdge
        int v2parentEdge[] = VecMath.fillvec(nVerts, -1);
        int v2parentVert[] = VecMath.fillvec(nVerts, -1);

        IndexBinaryHeap todo = new IndexBinaryHeap(nVerts);
        FORI (iVert, nVerts)
            if (v2e[iVert].length != 0) // if not isolated, i.e. not one of the original inside out verts
                todo.add(iVert, v2orderKey[iVert]);

        double centroid[] = new double[2]; // scratch for loop
        double centroidMinusVertDirection[] = new double[2]; // scratch for loop
        double normalizedEdgeDirection[] = new double[2]; // scratch for loop

        IntArrayList invalidationPathForDebugging = new IntArrayList(); // scratch for loop
        int invalidationPathCycleHistory[][] = new int[10][];

        int iIter;
        boolean infiniteLoopDetected = false;
        for (iIter = 0;
             !todo.isEmpty() && (maxIters==-1 || iIter < maxIters) && !infiniteLoopDetected;
             ++iIter)
        {
            int iVert = todo.min();
            if (verboseLevel >= 2) OUT("              iIter="+iIter+": top of loop");
            if (verboseLevel >= 2) OUT("                  iVert = "+iVert);
            assert(iVert < nVerts);
            assert(v2parentEdge[iVert] == -1);
            assert(v2parentVert[iVert] == -1);

            while (v2parentVert[iVert] == -1 // this is sort of a hack: keep going as long as I got put back on the todo list, even if I'm not otherwise the first on the todo list.  I have no reason to think this will result in a good algorithm, it's just a heuristic to get out of the endless-loop of the moment.
                && !infiniteLoopDetected)
            {
                todo.remove(iVert);

                VecMath.zerovec(v2momentAndWeightStrictlyUpstream[iVert]);
                FORI (iEdgeThisVert, v2e[iVert].length)
                {
                    int iNeighborVert = e2v[v2e[iVert][iEdgeThisVert]][1];
                    if (iNeighborVert < nVerts
                     && v2parentVert[iNeighborVert] == iVert)
                    {
                        if (verboseLevel >= 2) OUT("                          accumulating from upstream vert "+iNeighborVert);
                        GeomUtils.accumulateMomentAndArea(v2momentAndWeightStrictlyUpstream[iVert],
                                                          v2momentAndWeightStrictlyUpstream[iNeighborVert]);
                        GeomUtils.accumulateMomentAndArea(v2momentAndWeightStrictlyUpstream[iVert],
                                                          mesh.getVert(iNeighborVert).momentAndArea);
                    }
                }

                // Find best neighbor, i.e. neighbor that's most opposite the upstream centroid.
                int bestNeighborEdge;
                int bestNeighborVert;
                double bestGoodness;
                {
                    // TODO: I suspect this logic could be cleaner
                    if (v2momentAndWeightStrictlyUpstream[iVert][2] == 0.)
                    {
                        // no weight, so go outward from sweep origin
                        if (sweepOriginHomo[2] == 0.)
                        {
                            VecMath.copyvec(2, centroidMinusVertDirection, sweepOriginHomo); // infinite center
                        }
                        else
                        {
                            VecMath.vxs(2, centroid, sweepOriginHomo, 1./sweepOriginHomo[2]);
                            VecMath.vmv(2, centroidMinusVertDirection, centroid, verts[iVert]);
                        }
                    }
                    else
                    {
                        // There's a weight at the centroid.  Use it, ignoring sweep center.
                        VecMath.vxs(2, centroid, v2momentAndWeightStrictlyUpstream[iVert], 1./v2momentAndWeightStrictlyUpstream[iVert][2]);
                        VecMath.vmv(2, centroidMinusVertDirection, centroid, verts[iVert]);
                    }


                    VecMath.normalize(2, centroidMinusVertDirection,
                                      centroidMinusVertDirection); // might be indeterminate, in which case it doesn't matter which neighbor we pick

                    bestNeighborEdge = -1;
                    bestNeighborVert = -1;
                    bestGoodness = Double.NEGATIVE_INFINITY;
                    FORI (iEdgeThisVert, v2e[iVert].length)
                    {
                        int iNeighborEdge = v2e[iVert][iEdgeThisVert];
                        assert(e2v[iNeighborEdge][0] == iVert);
                        int iNeighborVert = e2v[iNeighborEdge][1];
                        VecMath.normalize(normalizedEdgeDirection, mesh.getEdge(iNeighborEdge).direction);
                        double goodness = -VecMath.dot(2, normalizedEdgeDirection, centroidMinusVertDirection);
                        //PRINTVEC(normalizedEdgeDirection);
                        //PRINTVEC(centroidMinusVertDirection);
                        if (verboseLevel >= 2) OUT("                          neighbor vert "+iNeighborVert+" goodness = "+goodness);
                        if (goodness > bestGoodness)
                        {
                            bestGoodness = goodness;
                            bestNeighborEdge = iNeighborEdge;
                            bestNeighborVert = iNeighborVert;
                        }
                    }
                }
                if (verboseLevel >= 2) OUT("                      bestNeighborVert = "+bestNeighborVert+" bestGoodness = "+bestGoodness);
                assert(bestGoodness >= 0.);
                assert(bestNeighborEdge != -1);
                assert(bestNeighborVert != -1);
                assert(v2parentEdge[iVert] == -1);
                assert(v2parentVert[iVert] == -1);
                v2parentEdge[iVert] = bestNeighborEdge; // note it might get unset again in a moment if we backwash though
                v2parentVert[iVert] = bestNeighborVert; // note it might get unset again in a moment if we backwash though
                {
                    invalidationPathForDebugging.clear();
                    invalidationPathForDebugging.add(iVert);

                    // invalidate bestNeighbor and downstream, and put in todo list:
                    // bestNeighbor, its parent, grandparent, ...
                    // stopping when we either hit something that's already invalid-and-in-todo,
                    // or at the infinite vertex (which is always invalid but not in todo).
                    int v = bestNeighborVert;
                    while (v < nVerts && v2parentVert[v] != -1)
                    {
                        invalidationPathForDebugging.add(v);
                        if (verboseLevel >= 2) OUT("                      invalidating: "+v);
                        if (v == iVert)
                        {
                            // This is the interesting event!
                            int thisInvalidationPathCycle[] = invalidationPathForDebugging.toArray();
                            if (verboseLevel >= 1) OUT("                          ooh interesting! started at v"+iVert+" but invalidated it! "+VecMath.toString(verts[iVert])+" invalidation path = "+Arrays.toStringCompact(thisInvalidationPathCycle));

                            //PRINTARRAY(invalidationPathCycleHistory);
                            FORI (i, invalidationPathCycleHistory.length)
                            {
                                if (VecMath.equals(thisInvalidationPathCycle, invalidationPathCycleHistory[i])
                                 && i+1 < invalidationPathCycleHistory.length
                                 && VecMath.equals(invalidationPathCycleHistory[0], invalidationPathCycleHistory[i+1]))
                                {
                                    if (verboseLevel >= 0) OUT("                              oh no! infinite loop detected maybe!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
                                    infiniteLoopDetected = true;
                                }
                            }

                            FORIDOWN(i, invalidationPathCycleHistory.length-1)
                                invalidationPathCycleHistory[i+1] = invalidationPathCycleHistory[i];
                            invalidationPathCycleHistory[0] = thisInvalidationPathCycle;
                        }
                        todo.add(v, v2orderKey[v]);
                        int parentVert = v2parentVert[v];
                        v2parentEdge[v] = -1;
                        v2parentVert[v] = -1;
                        v = parentVert;
                    }
                }
            }
        } // while !todo.isEmpty()
        if (todo.isEmpty())
            if (verboseLevel >= 1) OUT("          finished in "+iIter+" iterations!");
        else
            if (verboseLevel >= 1) OUT("          didn't finish in "+iIter+" iterations!");

        if (verboseLevel >= 2) PRINTVEC(v2parentEdge);
        if (verboseLevel >= 2) PRINTVEC(v2parentVert);
        Net net = new Net(mesh, dualMesh);
        FORI (iVert, nVerts)
        {
            if (v2parentEdge[iVert] != -1)
                net.cut(v2parentEdge[iVert], true);
        }
        if (verboseLevel >= 1) OUT("        out MyAlgorithmMaybe.doIt");
        return net;
    }
} // class MyAlgorithmMaybe

