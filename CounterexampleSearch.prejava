#include "macros.h"

import com.donhatchsw.compat.Format;

public class CounterexampleSearch
{
    private static String repeat(String s, int n) { return new String(new char[n]).replace("\0", s); }

    public static void main(String args[])
    {
        if (args.length != 2)
        {
            System.err.println("Usage: CounterexampleSearch <lookahead> <nSamples>");
            System.exit(1);
        }
        int lookahead = Integer.parseInt(args[0]); // e.g. 5
        int nSamples = Integer.parseInt(args[1]); // e.g. 1000

        int verboseLevel = 1;
        long seed = 0;
        java.util.Random rng = new java.util.Random(seed);
        int nInitialVerts = 3; // must be 3 or 4, not sure if 4 even works
        int maxVerts = 100; // we'll never get that high

        ConvexNoiseMaker convexNoiseMaker = new ConvexNoiseMaker(nInitialVerts, maxVerts);
        convexNoiseMaker.pushRandomVertex(rng, verboseLevel); // always the one in the middle

        while (true)
        {
            OUT("      top of loop");
            // add lookahead more verts, in each of nSamples ways
            double worstGoodFrac = Double.POSITIVE_INFINITY;
            double worstLookahead[][] = new double[lookahead][3];
            FORI (iSample, nSamples)
            {
                OUT("          iSample="+iSample+"/"+nSamples+":");
                int nVerts = convexNoiseMaker.getInternalMesh().verts.size();
                OUT("              pushing "+lookahead+" random verts: "+nVerts+" -> "+(nVerts+lookahead));
                FORI (iLookahead, lookahead)
                {
                    // note, verboseLevel=2 makes it print "." each time, currently
                    convexNoiseMaker.pushRandomVertex(rng, verboseLevel);
                }

                // Extract the mesh
                // and delaunayize it "the right way".
                // XXX wait, what? do I need this, since inside out is just a triangle?  think about this
                Mesh triangulatedMesh = MeshUtils.delaunayized(convexNoiseMaker.getInternalMesh(),
                                                               false,  // wrapAroundSphereFlagValue,
                                                               1.,     // wrapSphereCurvatureValue,
                                                               true,  // centerSphereFlagValue,
                                                               false,  // calcInsideOutDualVertsFlagValue (this is the important one)
                                                               false); // slightlyVerbose
                Mesh trivalentMesh = Mesh.makeDualMesh(triangulatedMesh,
                                                       false, // includeNonArity3
                                                       false, // includeInsideOut
                                                       false, // wrapAroundSphereFlag
                                                       false, // centerSphereFlag
                                                       0.);   // wrapSphereCurvature)
                //PRINT(triangulatedMesh);
                //PRINT(trivalentMesh);
                BigInt nGood = new BigInt(-1);
                BigInt nBad = new BigInt(-1);
                BigInt nTotal = new BigInt(-1);
                int max = 1000*1000*1000;
                MeshUtils.countGoodBad(trivalentMesh, triangulatedMesh, 
                                       max,
                                       nGood, nBad, nTotal,
                                       0); // verboseLevel
                double goodFrac = nGood.doubleValue()/nTotal.doubleValue();
                double badFrac = nBad.doubleValue()/nTotal.doubleValue();
                {
                    double goodPercent = goodFrac * 100.;
                    double badPercent = badFrac * 100.;
                    String goodPercentString = Format.sprintf("%.5g", goodPercent);
                    String badPercentString = Format.sprintf("%.5g", badPercent);
                    OUT("                  (good:bad)/total = ("+nGood+":"+nBad+")/"+nTotal+" = "+goodPercentString+"%:"+badPercentString+"%");
                    if (nGood.eq(0))
                    {
                        OUT(repeat("!", 1000));
                        assert(false); // XXX what should I do here? notify the press?
                    }
                }
                if (goodFrac < worstGoodFrac)
                {
                    worstGoodFrac = goodFrac;
                    FORI (iLookahead, lookahead)
                    {
                        int iVert = triangulatedMesh.verts.size() - lookahead + iLookahead;
                        Mesh.Vertex v = triangulatedMesh.getVert(iVert);
                        worstLookahead[iLookahead][0] = v.x();
                        worstLookahead[iLookahead][1] = v.y();
                        worstLookahead[iLookahead][2] = v.z();
                    }
                }

                OUT("              popping "+lookahead+" verts.");
                FORI (iLookahead, lookahead)
                {
                    convexNoiseMaker.popVertex();
                }
                OUT("              worstGoodPercent = "+worstGoodFrac*100.);
            } // for iSample
            assert_le(worstGoodFrac, 1.);
            convexNoiseMaker.pushSpecificVertex(
                worstLookahead[0][0],
                worstLookahead[0][1],
                worstLookahead[0][2],
                null);
        } // while true
    }
} // class CounterexampleSearch
