#include "macros.h"

import com.donhatchsw.compat.Format;

public class CounterexampleSearch
{
    private static String repeat(String s, int n) { return new String(new char[n]).replace("\0", s); }

    public static void main(String args[])
    {
        if (args.length != 2)
        {
            System.err.println("Usage: CounterexampleSearch <lookahead> <nSamples>");
            System.exit(1);
        }
        int lookahead = Integer.parseInt(args[0]); // e.g. 5
        int nSamples = Integer.parseInt(args[1]); // e.g. 1000

        int verboseLevel = 1;
        long seed = 0;
        java.util.Random rng = new java.util.Random(seed);
        int nInitialVerts = 3; // must be 3 or 4, not sure if 4 even works
        int maxVerts = 100; // we'll never get that high

        ConvexNoiseMaker convexNoiseMaker = new ConvexNoiseMaker(nInitialVerts, maxVerts);
        convexNoiseMaker.pushRandomVert(rng, verboseLevel); // always the one in the middle

        while (true)
        {
            OUT("      top of loop");
            // add lookahead more verts, in each of nSamples ways
            double worstGoodFrac = Double.POSITIVE_INFINITY;
            FORI (iSample, nSamples)
            {
                OUT("          pushing "+lookahead+" random verts");
                FORI (iLookahead, lookahead)
                {
                    convexNoiseMaker.pushRandomVert(rng, verboseLevel);
                }

                // Extract the mesh
                // and delaunayize it "the right way".
                // XXX wait, what? do I need this, since inside out is just a triangle?  think about this
                Mesh triangulatedMesh = MeshUtils.delaunayized(convexNoiseMaker.getInternalMesh(),
                                                               false,  // wrapAroundSphereFlagValue,
                                                               1.,     // wrapSphereCurvatureValue,
                                                               true,  // centerSphereFlagValue,
                                                               false,  // calcInsideOutDualVertsFlagValue (this is the important one)
                                                               false); // slightlyVerbose
                Mesh trivalentMesh = Mesh.makeDualMesh(triangulatedMesh,
                                                       false, // includeNonArity3
                                                       false, // includeInsideOut
                                                       false, // wrapAroundSphereFlag
                                                       false, // centerSphereFlag
                                                       0.);   // wrapSphereCurvature)
                //PRINT(triangulatedMesh);
                //PRINT(trivalentMesh);
                BigInt nGood = new BigInt(-1);
                BigInt nBad = new BigInt(-1);
                BigInt nTotal = new BigInt(-1);
                int max = 1000*1000*1000;
                MeshUtils.countGoodBad(trivalentMesh, triangulatedMesh, 
                                       max,
                                       nGood, nBad, nTotal,
                                       0); // verboseLevel
                {
                    double goodPercent = nGood.doubleValue()/nTotal.doubleValue()*100.;
                    double badPercent = nBad.doubleValue()/nTotal.doubleValue()*100.;
                    String goodPercentString = Format.sprintf("%.5g", goodPercent);
                    String badPercentString = Format.sprintf("%.5g", badPercent);
                    OUT("    (good:bad)/total = ("+nGood+":"+nBad+")/"+nTotal+" = "+goodPercentString+"%:"+badPercentString+"%");
                    if (nGood.eq(0))
                    {
                        OUT(repeat("!", 1000));
                        assert(false); // XXX what should I do here? notify the press?
                    }
                }

                OUT("          popping "+lookahead+" verts.");
                FORI (iLookahead, lookahead)
                {
                    convexNoiseMaker.popVert();
                }
            } // for iSample
        } // while true
    }
} // class CounterexampleSearch
