#include "macros.h"

import com.donhatchsw.util.Arrays;
import com.donhatchsw.util.IndexBinaryHeapKeyed;
import com.donhatchsw.util.VecMath;

// Helper class for incrementally making convex noise.
public class ConvexNoiseMaker
{
    private int nInitialVerts;
    private double initialVerts3d[][];
    private double verts3d[][];
    private double maxHeight;
    Mesh scratchMesh;
    IndexBinaryHeapKeyed horizon; // scratch for loop
    public ConvexNoiseMaker(
        int nInitialVerts, // 3 or 4
        int maxVerts)
    {
        assert_le_le(3, nInitialVerts, 4);
        assert_le(nInitialVerts, maxVerts);
        int initialFaces[][];
        if (nInitialVerts == 4)
        {
          // square
          double r = .25;
          this.initialVerts3d = new double[][]{
            {-r,-r,0},
            {r,-r,0},
            {r,r,0},
            {-r,r,0},
          };
          initialFaces = new int[][]{{0,1,2},{0,2,3},{0,3,1},{3,2,1}};
          this.maxHeight = r / 2.; // if it's too big, dual will be too big. if it's too small, primal will look too flat to be interesting
        }
        else if (nInitialVerts == 3)
        {
          // triangle, tuned so 3 outer faces are cube faces (but then fudged so they're not, oh well)
          this.initialVerts3d = new double[][]{
            { Math.sqrt(1.5), Math.sqrt(.5)},
            {-Math.sqrt(1.5), Math.sqrt(.5)},
            {0,-Math.sqrt(2.)},
          };
          double scale = 1./2.;
          VecMath.mxs(initialVerts3d, initialVerts3d, scale);
          initialFaces = new int[][]{{0,1,2},{2,1,0}};
          this.maxHeight = 1./8; // fudged til dual tends to be in window mostly
        }
        else
        {
            assert(false); // can't happen, we checked at the beginning
        }
        verts3d = new double[maxVerts][3];
        VecMath.copymat(verts3d, initialVerts3d); // if initialVerts3d verts had length 2, [2] will be 0
        this.nInitialVerts = nInitialVerts;
        if (true)
        {
            // When mesh ctor sees vert coords of length 2 or 3, it interprets them as XYH.
            // That's not what we want, we want XYZ instead.  So go through this contortion...
            double initialVertsXYZW[][] = new double[nInitialVerts][4];
            FORI (i, nInitialVerts)
            {
                initialVertsXYZW[i][2] = 0.;
                initialVertsXYZW[i][3] = 1.;
                VecMath.copyvec(initialVerts3d[i].length, initialVertsXYZW[i], initialVerts3d[i]);
            }
            this.scratchMesh = new Mesh(initialVertsXYZW, initialFaces);
        }
        int maxPossibleDirectedEdges = 3*verts3d.length * 2; // I think that's an upper bound... *2 for directed edges
        this.horizon = new IndexBinaryHeapKeyed(maxPossibleDirectedEdges); // scratch for loop. size is max size we'll encounter.
    } // ConvexNoiseMaker ctor
    public void pushRandomVertex(java.util.Random rng, int verboseLevel)
    {
        int iVert = scratchMesh.verts.size();
        if (verboseLevel >= 3) OUT("          choosing vert "+iVert+"/"+verts3d.length);
        assert_lt(iVert, verts3d.length);

        while (true)
        {
            if (iVert == initialVerts3d.length)
            {
                VecMath.zerovec(2, verts3d[iVert]);
            }
            else
                GeomUtils.random2insideConvexPolygon(verts3d[iVert], // put it here
                                                     initialVerts3d,
                                                     rng);

            // Figure out what height to put it at.

            double zMinNonBruteForce = Double.NaN;
            double zMaxNonBruteForce = Double.NaN;
            double zMinBruteForce = Double.NaN;
            double zMaxBruteForce = Double.NaN;


            // First, locate the triangle the point is in.
            // zMin will be its face plane z,
            // and zMax will be the min of all the other face plane z's.
            Mesh.Edge someEdgeOnFaceVertIsIn = MeshUtils.findSomeEdgeOnFaceVertIsIn(scratchMesh, verts3d[iVert][0], verts3d[iVert][1]);
            if (verboseLevel >= 3) OUT("              someEdgeOnFaceVertIsIn = "+someEdgeOnFaceVertIsIn);

            // At least one of these must be set. If both set, we compare.
            boolean nonBruteForceFlag = true;
            boolean bruteForceFlag = false;

            if (nonBruteForceFlag)
            {
                // Non-brute-force way.

                zMaxNonBruteForce = maxHeight; // in case we don't run into any other ceiling

                {
                    int i = someEdgeOnFaceVertIsIn.initialVertex().myIndex();
                    //int j = someEdgeOnFaceVertIsIn.next().initialVertex().myIndex();
                    int j = someEdgeOnFaceVertIsIn.finalVertex().myIndex();
                    int k = someEdgeOnFaceVertIsIn.prev().initialVertex().myIndex();
                    double zIntercept = GeomUtils.computeZIntercept(verts3d[i],
                                                                    verts3d[j],
                                                                    verts3d[k],
                                                                    verts3d[iVert]);
                    zMinNonBruteForce = zIntercept;
                    if (verboseLevel >= 3) OUT("              zMinNonBruteForce = "+zMinNonBruteForce+" from verts "+i+" "+j+" "+k+" at x="+verts3d[iVert][0]+" y="+verts3d[iVert][1]+"");

                    // CBB: original brute-force code discarded this vertex if something was within 1e-9 of an existing edge.  should do that.
                }

                // Now rise z, which walks the horizon outwards,
                // as far as we can without losing another vertex.
                // The horizon is represented by a heap (priority queue),
                // which is initially the triangle.
                // Process the queue, taking away an edge and adding the other two of the increment triangle instead.
                // Stop when we some edge we add to the horizon is the opposite of some other edge on the horizon.
                assert(horizon.isEmpty());
                {
                    Mesh.Edge initialHorizonEdge = someEdgeOnFaceVertIsIn;
                    FORI (iEdgeThisTri, 3)
                    {
                        Mesh.Edge opp = initialHorizonEdge.opposite();
                        int i = opp.initialVertex().myIndex();
                        int j = opp.finalVertex().myIndex();
                        int k = opp.prev().initialVertex().myIndex();
                        if (!(i<nInitialVerts && j<nInitialVerts && k<nInitialVerts)) // if not the original triangle inside out
                        {
                            double zIntercept = GeomUtils.computeZIntercept(verts3d[i],
                                                                            verts3d[j],
                                                                            verts3d[k],
                                                                            verts3d[iVert]);
                            if (verboseLevel >= 3) OUT("              adding initial horizon edge "+initialHorizonEdge+" at zIntercept="+zIntercept+" from verts "+i+" "+j+" "+k+"");
                            // Every (non-inside-out) triangle plane should have a z intercept
                            // strictly greater than that of the face it's hovering over.
                            assert_gt(zIntercept, zMinNonBruteForce);
                            horizon.add(initialHorizonEdge.myIndex(), zIntercept);
                        }
                        initialHorizonEdge = initialHorizonEdge.next();
                    }
                    assert_eq(initialHorizonEdge, someEdgeOnFaceVertIsIn);
                }

                while (!horizon.isEmpty())
                {
                    if (verboseLevel >= 3) OUT("                  top of horizon loop");
                    // extractMin, but get the value first
                    int iOldHorizonEdge = horizon.min();
                    double zInterceptOld = horizon.getValue(iOldHorizonEdge);
                    assert(!Double.isNaN(zInterceptOld));
                    horizon.remove(iOldHorizonEdge);

                    // This is just a re-assert of when we added it.
                    assert_gt(zInterceptOld, zMinNonBruteForce);

                    if (zInterceptOld >= maxHeight)
                    {
                        zMaxNonBruteForce = maxHeight;
                        break;
                    }

                    Mesh.Edge oldHorizonEdge = scratchMesh.getEdge(iOldHorizonEdge);
                    Mesh.Edge newHorizonEdge = oldHorizonEdge.opposite().next();
                    if (verboseLevel >= 3) OUT("                      removed old horizon edge "+oldHorizonEdge+" at zIntercept="+zInterceptOld+", maybe adding new horizon edges "+newHorizonEdge+", "+newHorizonEdge.next());


                    boolean broke = false;
                    FORI (iNewHorizonEdge, 2) // two new horizon edges
                    {
                        // CBB: should there be an "isInHeap" method?
                        boolean oppositeIsPartOfHorizon = !Double.isNaN(horizon.getValue(newHorizonEdge.opposite().myIndex()));
                        if (oppositeIsPartOfHorizon)
                        {
                            // Adding this triangle obscures the vertex (barely); this is where we stop.
                            // It's fine if horizon is a bit insane at this point; we're just going to clear it.
                            if (verboseLevel >= 3) OUT("                          aha! was about to add "+newHorizonEdge+" but its opposite "+newHorizonEdge.opposite()+" is already on horizon! done! (and I think maybe I should set zMaxNonBruteForce to "+zInterceptOld+")");
                            zMaxNonBruteForce = zInterceptOld;

                            broke = true;
                            break;
                        }
                        Mesh.Edge opp = newHorizonEdge.opposite();
                        int i = opp.initialVertex().myIndex();
                        int j = opp.finalVertex().myIndex();
                        int k = opp.prev().initialVertex().myIndex();
                        if (!(i<nInitialVerts && j<nInitialVerts && k<nInitialVerts)) // if not the original triangle inside out
                        {
                            double zIntercept = GeomUtils.computeZIntercept(verts3d[i],
                                                                            verts3d[j],
                                                                            verts3d[k],
                                                                            verts3d[iVert]);
                            if (verboseLevel >= 3) OUT("                          adding new horizon edge "+newHorizonEdge+" at zIntercept="+zIntercept);
                            // Every (non-inside-out) triangle plane should have a z intercept
                            // strictly greater than that of the face it's hovering over.
                            assert_gt(zInterceptOld, zMinNonBruteForce);
                            horizon.add(newHorizonEdge.myIndex(), zIntercept);
                        }
                        else
                        {
                            if (verboseLevel >= 3) OUT("                          (not adding new horizon edge "+newHorizonEdge+" because original boundary)");
                        }
                        newHorizonEdge = newHorizonEdge.next();
                    }
                    if (broke) break; // double break
                    assert_eq(newHorizonEdge, oldHorizonEdge.opposite());
                }

                // clear horizon for next iteration
                while (!horizon.isEmpty())
                {
                    horizon.extractMin();
                }

                assert(!Double.isNaN(zMinNonBruteForce));
                assert(!Double.isNaN(zMaxNonBruteForce));
            } // nonBruteForceFlag
            if (bruteForceFlag)
            {
                // brute force way: examine all triangles.
                // TODO: salvage the 1e-9 part and then remove this

                zMinBruteForce = -1.;
                zMaxBruteForce = maxHeight;

                int nEdges = scratchMesh.edges.size();
                FORI (iEdge, nEdges)
                {
                    Mesh.Edge edgeI = scratchMesh.getEdge(iEdge);
                    assert_eq(edgeI.next().next().next(), edgeI);
                    int i = edgeI.initialVertex().myIndex();
                    int j = edgeI.next().initialVertex().myIndex();
                    int k = edgeI.prev().initialVertex().myIndex();

                    double a[] = verts3d[i];
                    double b[] = verts3d[j];
                    double c[] = verts3d[k];
                    double abcArea = GeomUtils.twiceTriangleArea(a,b,c);
                    if (abcArea < 0.)
                    {
                        if (verboseLevel >= 3) OUT("              skipping tri v"+i+",v"+j+",v"+k+" because inside out");
                        continue;
                    }
                    if (verboseLevel >= 3) OUT("              not skipping tri v"+i+",v"+j+",v"+k+" because not inside out");

                    double d[] = verts3d[iVert]; // with z not set yet
                    double abdArea = GeomUtils.twiceTriangleArea(a,b,d);
                    double bcdArea = GeomUtils.twiceTriangleArea(b,c,d);
                    double cadArea = GeomUtils.twiceTriangleArea(c,a,d);

                    if (!(initialVerts3d.length == 4 && iVert == 4)) // allow that special case
                    {
                        if (EQ(abdArea, 0., 1e-9)
                         || EQ(bcdArea, 0., 1e-9)
                         || EQ(cadArea, 0., 1e-9))
                        {
                            // set to impossible so we kill this x,y
                            zMinBruteForce = 1.;
                            zMaxBruteForce = -1.;
                            System.out.print("?");
                            System.out.flush();
                            //assert(false); // yeah it finally happened once
                            break;
                        }
                    }

                    boolean dIsInMiddle = (abdArea >= 0. && bcdArea >= 0 && cadArea >= 0); // CBB: we end up doing this 3 times, oh well
                    boolean cIsInMiddle = (abdArea >= 0. && bcdArea <= 0. && cadArea <= 0.); // or maybe on the verge
                    if (verboseLevel >= 3) OUT("                  dIsInMiddle = "+dIsInMiddle+(dIsInMiddle?"!!!!!!!!!!!!!!!!!":""));
                    if (verboseLevel >= 3) OUT("                  cIsInMiddle = "+cIsInMiddle);
                    if (dIsInMiddle || cIsInMiddle)
                    {
                        #define BARY(a, b, s, c, t) ((1.-(s)-(t))*(a) + (b)*(s) + (t)*(c))
                        // Extrapolation in plane of a triangle can be done
                        // by barycentric averaging (same as interpolation)
                        double zIntercept = BARY(a[2],
                                                 b[2], cadArea/abcArea,
                                                 c[2], abdArea/abcArea);
                        if (dIsInMiddle)
                        {
                            // d is in middle. Make sure z isn't so low that it disappears below this triangle.
                            zMinBruteForce = MAX(zMinBruteForce, zIntercept);
                            if (verboseLevel >= 3) OUT("                      so contributing zIntercept="+zIntercept+" to zMinBruteForce from "+i+" "+j+" "+k+" at x="+verts3d[iVert][0]+" y="+verts3d[iVert][1]+"");
                        }
                        else
                        {
                            // c is in middle. Make sure z isn't so high that it makes c disappear from convex hull.
                            zMaxBruteForce = MIN(zMaxBruteForce, zIntercept);
                            if (verboseLevel >= 3) OUT("                      so contributing zIntercept="+zIntercept+" to zMaxBruteForce");
                        }
                    }
                }
                assert(!Double.isNaN(zMinBruteForce));
                assert(!Double.isNaN(zMaxBruteForce));
            } // brute force

            double zMin = Double.isNaN(zMinNonBruteForce) ? zMinBruteForce : zMinNonBruteForce;
            double zMax = Double.isNaN(zMaxNonBruteForce) ? zMaxBruteForce : zMaxNonBruteForce;
            assert(!Double.isNaN(zMin));
            assert(!Double.isNaN(zMax));
            if (!Double.isNaN(zMinNonBruteForce) && !Double.isNaN(zMinBruteForce))
            {
                assert_almost_eq(zMinNonBruteForce, zMinBruteForce, 1e-9);
            }
            if (!Double.isNaN(zMaxNonBruteForce) && !Double.isNaN(zMaxBruteForce))
            {
                assert_almost_eq(zMaxNonBruteForce, zMaxBruteForce, 1e-9);
            }

            if (verboseLevel >= 3) PRINT(zMin);
            if (verboseLevel >= 3) PRINT(zMax);
            if (zMin > zMax)
            {
                // Someone hit the 1e-9 thing.  Or something.
                System.out.print("!");
                System.out.flush();
                assert(false); // coverage.  yeah, it happens once in a blue moon.
                continue; // bad; try again
            }
            if (iVert == initialVerts3d.length)
            {
                assert_eq(zMin, 0.);
                assert_eq(zMax, maxHeight);
            }
            else
            {
                assert_gt(zMin, 0.);
                assert_lt(zMin, maxHeight);
            }
            double t;
            if (iVert == initialVerts3d.length)
                t = 1.;
            else
                t = rng.nextDouble();
            double z = LERP(zMin, zMax, t);

            // Add the new vertex to scratchMesh.

            // a little weird since we've been using verts3d as scratch
            pushSpecificVertex(verts3d[iVert][0],
                               verts3d[iVert][1],
                               z,
                               someEdgeOnFaceVertIsIn);
            break; // succeeded in adding the vertex, so break out of the while (true) loop

        } // while (true)

        if (verboseLevel == 2) System.out.print(".");
        if (verboseLevel == 2) System.out.flush();
    } // pushRandomVertex

    void pushSpecificVertex(
        double x, double y, double z,
        Mesh.Edge someEdgeOnFaceVertIsIn) // may be null if caller doesn't know it
    {
          if (someEdgeOnFaceVertIsIn == null)
              someEdgeOnFaceVertIsIn = MeshUtils.findSomeEdgeOnFaceVertIsIn(scratchMesh, x, y);

          int iVert = scratchMesh.verts.size();
          verts3d[iVert][0] = x;
          verts3d[iVert][1] = y;
          verts3d[iVert][2] = z;

          assert_eq(scratchMesh.verts.size(), iVert);
          scratchMesh.addIsolatedVertex(verts3d[iVert][0],
                                        verts3d[iVert][1],
                                        verts3d[iVert][2],
                                        1.);
          scratchMesh.kisIsolatedVertex(scratchMesh.getVert(scratchMesh.verts.size()-1),
                                        someEdgeOnFaceVertIsIn);
          assert_eq(scratchMesh.verts.size(), iVert+1);
          if (false)
          {
              // Assert no isolated verts.  can do that by counting edges and tris, and using euler's formula:
              //     v+f = e+2
              //       -> f = e+2-v
              //     2e = 3f (for triangulated)
              //        = 3(e+2-v)
              //     2e = 3e+6-3v
              //     -e = 6-3v
              //      e = 3v-6
              //     except this e is our edges.size()/2.
              // Note: appearance of isolated verts, currently, may be due to "and flat edges"
              if (nInitialVerts==3) // XXX what do I do in case nInitialVerts==4?
              {
                  assert_eq(scratchMesh.edges.size(), 2*(3*scratchMesh.verts.size()-6)); // XXX hmm, sometimes fails even if nInitialVerts==3? maybe same bug that's causing the "!"s
              }
          }

          // Yes, need to re-delaunayize! Because it's not necessarily just the kis.
          // CBB: but could do an incremental delaunayization polishing instead
          if (true)
          {
              scratchMesh = MeshUtils.delaunayized(scratchMesh,
                                                   false,
                                                   1.,
                                                   true,
                                                   //true, // calcInsideOutDualVertsFlag=true for now. must be set to false at the end.
                                                   false, // or maybe not. false means remove edges between pairs of non-positive-area (or very small) faces, true means leave it as is.  shouldn't make a difference if nInitialVerts==3 since there's only one such face, right? unless something tiny.  in any case, false seems right, at least for nInitialVerts=3.
                                                   false);
          }

          // TODO: assert that there are exactly two inside out tris,
          // same as when we started (if started with a square)
      } // pushSpecificVertex
    public void popVertex()
    {
        assert_gt(scratchMesh.verts.size(), nInitialVerts);
        scratchMesh.deleteVertex(scratchMesh.getVert(scratchMesh.verts.size()-1), null, null);
    } // popVertex

    // Caller should not modify the returned value.
    // Invalidated by next call to pushRandomVertex() or popVertex().
    // Note that the internal mesh is fully triangulated, as if "calc underside when delaunayizing" was true,
    // so caller should re-delaunayize if desired.
    public Mesh getInternalMesh()
    {
        return this.scratchMesh;
    } // getInternalMesh
} // class ConvexNoiseMaker
