//
// ARGH evidently this has totally diverged from the one in donhatchsw.com
// 
// Wrapper class for Graphics
// that does a subset of the Graphics2D API
// (But with saner API.)
//
#include "macros.h"

import com.donhatchsw.util.MyMath;
import com.donhatchsw.util.VecMath;

public class MyGraphics
{
    public MyGraphics(java.awt.Graphics g,
                      java.awt.Dimension gsize,
                      double x0, double x1, double y0, double y1)
    {
        this.g = g;
        this.gsize = gsize;
        fitToWindow(x0, x1, y0, y1);
    }
    public MyGraphics(java.awt.Graphics g,
                      java.awt.Dimension gsize)
    {
        this.g = g;
        this.gsize = gsize;
        fitToWindow(-1., 1., -1., 1.);
    }

    //
    // Set translate and scale
    // so that x0,x1,y0,y0
    // map to left,right,bottom,top.
    //
    public void fit(double x0,   double x1,    double y0,     double y1,
                    double left, double right, double bottom, double top)
    {
        scaleX = (right-left) / (x1-x0);
        scaleY = (top-bottom) / (y1-y0);
        translateX = left - scaleX*x0;
        translateY = bottom - scaleY*y0;
    }
    public void fitToWindow(double x0, double x1, double y0, double y1)
    {
        fit(x0, x1,             y0,              y1,
            .5, gsize.width-.5, gsize.height-.5, .5);
    }
    public void fitToPixel(double centerX, double centerY,
                           double pixelSizeX, double pixelSizeY)
    {
        fit(centerX, centerX+pixelSizeX, centerY, centerY+pixelSizeY,
            gsize.width*.5, gsize.width*.5 + 1., gsize.height*.5, gsize.height*.5 + 1);
    }

    public void translate(double x, double y)
    {
        translateX += x*scaleX;
        translateY += y*scaleY;
    }

    // window coords to input coords
    // If getting from an event, usually you want x=e.getX()+.5, y=e.getY()+.5.
    public void pick(double x, double y, double result[/*2*/])
    {
        result[0] = (x-translateX)/scaleX;
        result[1] = (y-translateY)/scaleY;
    }

    // input coords to window coords.
    // XXX name is dorky
    public void unpick(double x, double y, double result[/*2*/])
    {
        result[0] = x*scaleX + translateX;
        result[1] = y*scaleY + translateY;
    }


    public void fillWindow()
    {
        g.fillRect(0,0, gsize.width,gsize.height);
    }

    public void drawLineNonClipped(double x0, double y0, double x1, double y1,
                                   boolean antiAlias)
    {
        if (antiAlias)
        {
            if (x0 == x1 && y0 == y1)
            {
                drawPoint(x0, y0, 1);
                return;
            }

            // Transform to window coords...
            // "the pen hangs down and to the right of the coordinate",
            // so adjust the coordinate by half a pixel up and to the left...
            x0 = (x0 * scaleX + translateX - .5);
            y0 = (y0 * scaleY + translateY - .5);
            x1 = (x1 * scaleX + translateX - .5);
            y1 = (y1 * scaleY + translateY - .5);

            java.awt.Color savedColor = getColor();
            java.awt.Color[/*256*/] transparentColorCache = getTransparentColorCache(savedColor);

            if (Math.abs(y1-y0) >= Math.abs(x1-x0))
            {
                int Y0 = (int)Math.round(y0);
                int Y1 = (int)Math.round(y1);
                int dirY = (Y0 <= Y1 ? 1 : -1);
                double slope = (x1-x0)/(y1-y0);
                for (int Y = Y0; Y != Y1; Y += dirY)
                {
                    // XXX should use Wu's algorithm,
                    // XXX although I doubt this is the bottleneck
                    double x = x0 + (Y-y0) * slope;
                    int X = (int)Math.floor(x);
                    double frac = x-X;
                    int alpha = (int)(frac * 256.);
                    setColor(transparentColorCache[255-alpha]);
                    g.fillRect(X, Y, 1, 1);
                    setColor(transparentColorCache[alpha]);
                    g.fillRect(X+1, Y, 1, 1);
                }
            }
            else
            {
                int X0 = (int)Math.round(x0);
                int X1 = (int)Math.round(x1);
                int dirX = (X0 <= X1 ? 1 : -1);
                double slope = (y1-y0)/(x1-x0);
                for (int X = X0; X != X1; X += dirX)
                {
                    // XXX should use Wu's algorithm,
                    // XXX although I doubt this is the bottleneck
                    double y = y0 + (X-x0) * slope;
                    int Y = (int)Math.floor(y);
                    double frac = y-Y;
                    int alpha = (int)(frac * 256.);
                    setColor(transparentColorCache[255-alpha]);
                    g.fillRect(X, Y, 1, 1);
                    setColor(transparentColorCache[alpha]);
                    g.fillRect(X, Y+1, 1, 1);
                }
            }

            setColor(savedColor);
        }
        else
        {
            // window coordinates are all >= 0, so it should be okay
            // to truncate rather than round.
            // "the pen hangs down and to the right of the coordinate",
            // so adjust the coordinate by half a pixel up and to the left...

            // XXX except currently the curved arcs don't do this properly,
            // XXX so we end up not matching. need to fix both!
            if (false)
            g.drawLine((int)(x0 * scaleX + translateX - .5),
                       (int)(y0 * scaleY + translateY - .5),
                       (int)(x1 * scaleX + translateX - .5),
                       (int)(y1 * scaleY + translateY - .5));
            else
            g.drawLine((int)(x0 * scaleX + translateX),
                       (int)(y0 * scaleY + translateY),
                       (int)(x1 * scaleX + translateX),
                       (int)(y1 * scaleY + translateY));
        }
    } // drawLineNonClipped

    public void drawLineClipped(double x0, double y0, double x1, double y1,
                                boolean antiAlias,
                                double clipX0, double clipX1, double clipY0, double clipY1,
                                double slack)
    {
        {
            double temp;
            // make the line left to right
            if (x0 > x1)
            {
                SWAP(x0, x1, temp);
                SWAP(y0, y1, temp);
            }
            else if (x0 == x1 && y0 == y1)
                return;
            if (clipX0 > clipX1)
                SWAP(clipX0, clipX1, temp);
            if (clipY0 > clipY1)
                SWAP(clipY0, clipY1, temp);
        }

        if (false) // this works, but can be optimized better
        {
            double t0, t1;
            if (y0 <= y1)
            {
                // Positive slope
                //if (true) {drawLineNonClipped(x0, y0, x1, y1, antiAlias); return;}
                //if (true) return;

                //t0 = MAX((clipX0-x0)/(x1-x0), (clipY0-y0)/(y1-y0));
                // t0 = (clipX0-x0)/(x1-x0) >= (clipY0-y0)/(y1-y0) ? (clipX0-x0)/(x1-x0) : (clipY0-y0)/(y1-y0);
                t0 = (clipX0-x0)*(y1-y0) >= (clipY0-y0)*(x1-x0) ? (clipX0-x0)/(x1-x0) : (clipY0-y0)/(y1-y0);

                //t1 = MIN((clipX1-x0)/(x1-x0), (clipY1-y0)/(y1-y0));
                t1 = (clipX1-x0)*(y1-y0) <= (clipY1-y0)*(x1-x0) ? (clipX1-x0)/(x1-x0) : (clipY1-y0)/(y1-y0);
            }
            else
            {
                // Negative slope
                //if (true) {drawLineNonClipped(x0, y0, x1, y1, antiAlias); return;}
                //if (true) return;

                //t0 = MAX((clipX0-x0)/(x1-x0), (clipY1-y0)/(y1-y0));
                //t0 = MAX((clipX0-x0)/(x1-x0), (y0-clipY1)/(y0-y1));
                t0 = (clipX0-x0)*(y0-y1) >= (y0-clipY1)*(x1-x0) ? (clipX0-x0)/(x1-x0) : (y0-clipY1)/(y0-y1);

                //t1 = MIN((clipX1-x0)/(x1-x0), (clipY0-y0)/(y1-y0));
                //t1 = MIN((clipX1-x0)/(x1-x0), (y0-clipY0)/(y0-y1));
                t1 = (clipX1-x0)*(y0-y1) <= (y0-clipY0)*(x1-x0) ? (clipX1-x0)/(x1-x0) : (y0-clipY0)/(y0-y1);
            }
            t0 = MAX(t0, 0);
            t1 = MIN(t1, 1);
            if (t1 > t0)
                drawLineNonClipped(LERP(x0, x1, t0),
                                   LERP(y0, y1, t0),
                                   LERP(x0, x1, t1),
                                   LERP(y0, y1, t1),
                                   antiAlias);
        }
        else
        {
            // super optimized
            // XXX in progress
            double clippedx0, clippedy0, clippedx1, clippedy1;
            if (y1 >= y0)
            {
                // Non-negative slope
                if (x1 <= clipX0
                 || x0 >= clipX1
                 || y1 <= clipY0
                 || y0 >= clipY1)
                    return;
                if (x0 < clipX0 - slack)
                {
                    if (y0 < clipY0 - slack)
                    {
                        if ((clipX0-x0)*(y1-y0) >= (clipY0-y0)*(x1-x0))
                        {
                            // Clip to clipX0
                            clippedy0 = LERP(y0, y1, (clipX0-x0)/(x1-x0));
                            clippedx0 = clipX0;
                        }
                        else
                        {
                            // Clip to clipY0
                            clippedx0 = LERP(x0, x1, (clipY0-y0)/(y1-y0));
                            clippedy0 = clipY0;
                        }
                    }
                    else
                    {
                        // Clip to clipX0
                        clippedy0 = LERP(y0, y1, (clipX0-x0)/(x1-x0));
                        clippedx0 = clipX0;
                    }
                }
                else if (y0 < clipY0 - slack)
                {
                    // Clip to clipY0
                    clippedx0 = LERP(x0, x1, (clipY0-y0)/(y1-y0));
                    clippedy0 = clipY0;
                }
                else
                {
                    clippedx0 = x0;
                    clippedy0 = y0;
                }
                if (x1 > clipX1 + slack)
                {
                    if (y1 > clipY1 + slack)
                    {
                        if ((clipX1-x0)*(y1-y0) <= (clipY1-y0)/(x1-x0))
                        {
                            // Clip to clipX1
                            clippedy1 = LERP(y0, y1, (clipX1-x0)/(x1-x0));
                            clippedx1 = clipX1;
                        }
                        else
                        {
                            // Clip to clipY1
                            clippedx1 = LERP(x0, x1, (clipY1-y0)/(y1-y0));
                            clippedy1 = clipY1;
                        }
                    }
                    else
                    {
                        // Clip to clipX1
                        clippedy1 = LERP(y0, y1, (clipX1-x0)/(x1-x0));
                        clippedx1 = clipX1;
                    }
                }
                else if (y1 > clipY1 + slack)
                {
                    // Clip to clipY1
                    clippedx1 = LERP(x0, x1, (clipY1-y0)/(y1-y0));
                    clippedy1 = clipY1;
                }
                else
                {
                    clippedx1 = x1;
                    clippedy1 = y1;
                }
                if (clippedx0 > clippedx1
                 && clippedy0 > clippedy1)
                    return;
            }
            else // y1 < y0
            {
                //if (true) return;

                // Negative slope
                if (x1 <= clipX0
                 || x0 >= clipX1
                 || y0 <= clipY0  // since y0 == max(y0,y1)
                 || y1 >= clipY1) // since y1 == min(y0,y1)
                    return;
                if (x0 < clipX0 - slack)
                {
                    if (y0 > clipY1 + slack)
                    {
                        if ((clipX0-x0)*(y0-y1) >= (y0-clipY1)*(x1-x0))
                        {
                            // Clip to clipX0
                            clippedy0 = LERP(y0, y1, (clipX0-x0)/(x1-x0));
                            clippedx0 = clipX0;
                        }
                        else
                        {
                            // Clip to clipY1
                            clippedx0 = LERP(x0, x1, (clipY1-y0)/(y1-y0));
                            clippedy0 = clipY1;
                        }
                    }
                    else
                    {
                        // Clip to clipX0
                        clippedy0 = LERP(y0, y1, (clipX0-x0)/(x1-x0));
                        clippedx0 = clipX0;
                    }
                }
                else if (y0 > clipY1 + slack)
                {
                    // Clip to clipY1
                    clippedx0 = LERP(x0, x1, (clipY1-y0)/(y1-y0));
                    clippedy0 = clipY1;
                }
                else
                {
                    clippedx0 = x0;
                    clippedy0 = y0;
                }
                if (x1 > clipX1 + slack)
                {
                    if (y1 < clipY0 - slack)
                    {
                        // if (clipX1-x0)/(x1-x0) <= (clipY0-y0)/(y1-y0) but y1-y0 < 0
                        if ((clipX1-x0)*(y0-y1) <= (y0-clipY0)*(x1-x0))
                        {
                            // Clip to clipX1
                            clippedy1 = LERP(y0, y1, (clipX1-x0)/(x1-x0));
                            clippedx1 = clipX1;
                        }
                        else
                        {
                            // hits this case when should hit other casse!

                            // Clip to clipY0
                            clippedx1 = LERP(x0, x1, (clipY0-y0)/(y1-y0));
                            clippedy1 = clipY0;
                        }
                    }
                    else
                    {
                        // Clip to clipX1
                        clippedy1 = LERP(y0, y1, (clipX1-x0)/(x1-x0));
                        clippedx1 = clipX1;
                    }
                }
                else if (y1 < clipY0 - slack)
                {
                    // Clip to clipY0
                    clippedx1 = LERP(x0, x1, (clipY0-y0)/(y1-y0));
                    clippedy1 = clipY0;
                }
                else
                {
                    clippedx1 = x1;
                    clippedy1 = y1;
                }
                if (false)
                {
                    clippedx0 = x0;
                    clippedx1 = x1;
                    clippedy0 = y0;
                    clippedy1 = y1;
                }
                if (clippedx0 > clippedx1
                 && clippedy0 < clippedy1)
                    return;
            }
            drawLineNonClipped(clippedx0, clippedy0, clippedx1, clippedy1,
                               antiAlias);
        }
    } // drawLineClipped

    public void drawLine(double x0, double y0, double x1, double y1,
                         boolean antiAlias)
    {
        // clip; it sucks without clipping
        double clipX0 = (0-translateX)/scaleX;
        double clipX1 = (gsize.width-translateX)/scaleX;
        double clipY0 = (0-translateY)/scaleY;
        double clipY1 = (gsize.height-translateY)/scaleY;

        if (debugClip)
        {
            // debug by setting clip to half what it was
            clipX0 *= .95;
            clipX1 *= .95;
            clipY0 *= .95;
            clipY1 *= .95;
        }

        drawLineClipped(x0, y0, x1, y1,
                        antiAlias,
                        clipX0, clipX1, clipY0, clipY1,
                        2./((Math.abs(scaleX)+Math.abs(scaleY))*.5));   // 2 pixels
    } // drawLine

    public void drawPoint(double x, double y, int nPixels)
    {
        int x0 = (int)Math.round(x * scaleX + translateX - .5*nPixels);
        int y0 = (int)Math.round(y * scaleY + translateY - .5*nPixels);
        if (verbose >= 3) System.out.println("in drawPoint("+x+","+y+","+nPixels+") -> "+x0+","+y0);
        // have to check, otherwise java fillRect does weird wraparound stuff
        // XXX should check in floating-point
        if (x0 < -nPixels
         || x0 > gsize.width+nPixels
         || y0 < -nPixels
         || y0 > gsize.height+nPixels)
            return;
        g.fillRect(x0, y0, nPixels, nPixels);
    }
    public void drawString(String s, double x, double y)
    {
        g.drawString(s, (int)(x * scaleX + translateX),
                        (int)(y * scaleY + translateY));
    }
    public void drawString(String s, double x, double y, 
                                     double xJustify, // -1,0,1 -> L,C,R
                                     double yJustify, // -1,0,1 -> T,C,B
                                     java.awt.Color backgroundColor)
    {
        java.awt.FontMetrics fm = g.getFontMetrics();

        /*
        x:
            -1 -> 0
            0 -> -.5
            1 -> -1

        y:
            -1 -> 1
            0 -> .5
            1 -> 0
        */

        int xFinal = (int)(x * scaleX + translateX - fm.stringWidth(s)*(xJustify+1.)*.5);
        int yFinal = (int)(y * scaleY + translateY + fm.getAscent()*(1.-yJustify)*.5); // XXX centered height seems to come out a bit low-- maybe fiddle with leading?
        if (backgroundColor != null)
        {
            java.awt.Color savedColor = g.getColor();
            g.setColor(backgroundColor);
            g.fillRect(xFinal-1,yFinal-fm.getAscent(),          // the -1 is fudge
                       fm.stringWidth(s)+2, fm.getAscent()+fm.getDescent());    // the +2 is fudge
            g.setColor(savedColor);
        }
        g.drawString(s, xFinal, yFinal);
    }
    public void drawString(String s, double x, double y, 
                                     double xJustify, // -1,0,1 -> L,C,R
                                     double yJustify) // -1,0,1 -> T,C,B
    {
        drawString(s, x, y, xJustify, yJustify, null);
    }
    public void drawStringCentered(String s, double x, double y)
    {
        drawString(s, x, y, 0, 0);
    }
    public void drawStringRightJustified(String s, double x, double y)
    {
        drawString(s, x, y, 1, 0);
    }
    // XXX should be more of these...
    public double getFontHeight()
    {
        java.awt.FontMetrics fm = g.getFontMetrics();
        return Math.abs(fm.getHeight() / scaleY);
    }

    //private static int recursionLevel = 0;


    // Draw the arc pixel by pixel (or antialiased segment by antialiased segment, if antiAlias),
    // without regard to whether the pixels are in any visible area.
    public void smartDrawArcNonClipped(
        double focusX, double focusY, // a point on the arc
        double focusAngleRadians,     // from center to focus
        double c,                     // curvature, i.e. 1/radius
        double start, double end,     // arc goes from focusAngle+start to focusAngle+end in arc length
        boolean antiAlias)
    {
        //System.out.println(spaces(4*recursionLevel++)+"            in smartDrawArcNonClipped(focusX="+focusX+",focusY="+focusY+",focusAngleDegrees="+focusAngleRadians*180/Math.PI+",c="+c+"=1/"+1./c+",start="+start+",end="+end+"");

        final boolean useSegments = antiAlias; // implement antialiasing by drawing the circle as a sequence of antialiased segments with floating point coords
        if (useSegments)
        {
            int nSegs = MAX(10, (int)(ABS((end-start)*c) / (1*(Math.PI/180)))); // 1 degree-- delicate tradeoff, if we make it too fine, it looks all warbly because the endpoints are snapped to unit pixel coords XXX but this comment is no longer true since we are using our own antialiased line procedure
    //PRINT(nSegs);

            double cosFocusAngle = Math.cos(focusAngleRadians);
            double sinFocusAngle = Math.sin(focusAngleRadians);
            double normalAndTangent[][] = {
                { cosFocusAngle, sinFocusAngle}, // unit normal vector
                {-sinFocusAngle, cosFocusAngle}, // unit tangent vector
            };

            double prevPoint[] = new double[2];
            double point[] = new double[2];
            double scratch[] = new double[2];
            for (int i = 0; i < nSegs+1; ++i)
            {
                double t = LERP(start, end, (double)i/nSegs);
                findPointOnArc(t, focusX, focusY, c, normalAndTangent, scratch, point);

                if (i > 0)
                    this.drawLineNonClipped(prevPoint[0], prevPoint[1],
                                            point[0],     point[1],
                                            antiAlias);
                //VecMath.setvec(prevPoint, point);
                System.arraycopy(point, 0, prevPoint, 0, 2);
            }
            return;
        }


        // our end condition can only handle angles < 180 degrees,
        // so split in half if that is not the case
        // (a full circle will be recursively split again).
        if (c*Math.abs(start-end) > .75*Math.PI)
        {
            smartDrawArcNonClipped(focusX, focusY, focusAngleRadians, c,
                                   start, (start+end)*.5,
                                   antiAlias);
            smartDrawArcNonClipped(focusX, focusY, focusAngleRadians, c,
                                   (start+end)*.5, end,
                                   antiAlias);
            //System.out.println(spaces(4*--recursionLevel)+"            out smartDrawArcNonClipped");
            return;
        }


        //
        // Need to work in pixel space
        // so that we can be aware of the integer grid...
        //
        {
            focusX = focusX * scaleX + translateX;
            focusY = focusY * scaleY + translateY;
            if (scaleY < 0.)
            {
                focusAngleRadians *= -1.;
                start *= -1.;
                end *= -1.;
            }
            double scale = .5 * (Math.abs(scaleX) + Math.abs(scaleY)); // XXX not really right unless scaleX == scaleY, but that's usually the case
            c /= scale;
            start *= scale;
            end *= scale;
        }

        //
        // Reverse/swap parameters if necessary so that we are
        // going CCW around an arc of positive radius...
        // XXX figure out how much of this is necessary
        //
        {
            if (c < 0.)
            {
                c *= -1.;
                focusAngleRadians += Math.PI;
                start *= -1.;
                end *= -1.;
            }
            if (start > end)
            {
                double temp = start;
                start = end;
                end = temp;
            }
        }

        //System.out.println("in smartDrawArcNonClipped(focusX="+focusX+",focusY="+focusY+",focusAngleDegrees="+focusAngleRadians*180/Math.PI+",c="+c+"=1/"+1./c+",start="+start+",end="+end+"");

        double normalX = Math.cos(focusAngleRadians);
        double normalY = Math.sin(focusAngleRadians);
        double normalAndTangent[][] = {
            { normalX, normalY}, // unit normal vector
            {-normalY, normalX}, // unit tangent vector
        };


        //
        // Find start point...
        //
        double startX, startY;
        double endX, endY;
        {
            double point[] = new double[2];
            double scratch[] = new double[2];

            findPointOnArc(start, focusX, focusY, c, normalAndTangent, scratch, point);
            startX = point[0];
            startY = point[1];

            findPointOnArc(end, focusX, focusY, c, normalAndTangent, scratch, point);
            endX = point[0];
            endY = point[1];
        }

        // At most one point drawn for every pixel width of arc length
        int maxPointsToDraw = (int)Math.ceil(Math.abs(end-start)) + 1;

        int nPointsDrawn = 0;
        int x = (int)Math.round(startX), y = (int)Math.round(startY);
        double X = x - focusX; // XXX clean this up
        double Y = y - focusY; // XXX clean this up
        //System.out.println("point at "+x+","+y);
        this.g.fillRect(x, y, 1, 1);
        nPointsDrawn++;

        if (c < 1) // i.e. radius > 1
        {
            while (true)
            {
                final int quantizedDirVectors[][] = {
                    {1,0}, {1,1}, {0,1}, {-1,1}, {-1,0}, {-1,-1}, {0,-1}, {1,-1}
                };
                // What direction are we most likely to be going in?
                int dir; // index into quantizedDirVectors
                {
                    // Figure out current normal and tangent (dir),
                    // not necessarily normalized to unit length
                    double thisNormalX = c*X + normalX;
                    double thisNormalY = c*Y + normalY;
                    double thisTangentX = -thisNormalY;
                    double thisTangentY = thisNormalX;
                    int quantizedDirX = (thisTangentX < 0. ? -1 : thisTangentX > 0. ? 1 : 0);
                    int quantizedDirY = (thisTangentY < 0. ? -1 : thisTangentY > 0. ? 1 : 0);
                    double absThisTangentX = Math.abs(thisTangentX);
                    double absThisTangentY = Math.abs(thisTangentY);
                    if (absThisTangentX > 2*absThisTangentY)
                        quantizedDirY = 0;
                    else if (absThisTangentY > 2*absThisTangentX)
                        quantizedDirX = 0;
                    // XXX figure out more efficient way!
                    for (dir = 0; dir < 8; ++dir)
                    {
                        if (quantizedDirVectors[dir][0] == quantizedDirX
                         && quantizedDirVectors[dir][1] == quantizedDirY)
                            break; // found it
                    }
                    if (dir == 8)
                    {
                        System.out.println("huh?????"); // XXX
                        break; // only happens when radius is very small
                    }
                }

                x += quantizedDirVectors[dir][0];
                y += quantizedDirVectors[dir][1];
                X = x - focusX;
                Y = y - focusY;

                // the following was worked out on paper...
                // XXX should show derivation for posterity
                double signedDistanceOutsideCircle =
                    (c * (X*X + Y*Y) + 2 * (X*normalX + Y*normalY))
                  / (MyMath.hypot(c*X + normalX, c*Y + normalY) + 1.);

                //
                // Make it "manhattan distance" from circle,
                // by inflating distance when normal is in diagonal direction.
                //
                double inflation;
                {
                    double thisNormalX = c*X + normalX;
                    double thisNormalY = c*Y + normalY;
                    inflation = MyMath.hypot(thisNormalX, thisNormalY)
                              / Math.max(Math.abs(thisNormalX), Math.abs(thisNormalY));
                }
                //System.out.println("        signedDistanceOutsideCircle = "+signedDistanceOutsideCircle);
                signedDistanceOutsideCircle *= inflation;
                //System.out.println("        inflated signedDistanceOutsideCircle = "+signedDistanceOutsideCircle);

                if (signedDistanceOutsideCircle > .5001) // too far outside circle XXX use GT?
                {
                    x -= quantizedDirVectors[dir][0];
                    y -= quantizedDirVectors[dir][1];
                    // pull inward, i.e. turn direction of travel CCW
                    dir = (dir + 1) % 8;
                    x += quantizedDirVectors[dir][0];
                    y += quantizedDirVectors[dir][1];
                    X = x - focusX;
                    Y = y - focusY;
                }
                else if (signedDistanceOutsideCircle < -.5001) // too far inside circle XXX use LT?
                {
                    x -= quantizedDirVectors[dir][0];
                    y -= quantizedDirVectors[dir][1];
                    // pull outward, i.e. turn direction of travel CW
                    dir = (dir - 1 + 8) % 8;
                    x += quantizedDirVectors[dir][0];
                    y += quantizedDirVectors[dir][1];
                    X = x - focusX;
                    Y = y - focusY;
                }

                //System.out.println("maybe point at "+x+","+y);

                // XXX if radius <= 2 or so, 
                // XXX may need to do the above multiple times!
                // XXX Ignoring this issue for now, so tiny arcs
                // XXX might draw some garbage (tiny garbage though)

                //
                // Determine whether we've past the end...
                // XXX this test is wrong for arcs > 180 degrees,
                // XXX and also when end < start!
                // XXX That is why we subdivided any arc > .75 * 180 degrees
                // XXX above, and we reversed start and end
                // XXX so that end <= start.
                //
                {
                    double thisNormalX = c*X + normalX;
                    double thisNormalY = c*Y + normalY;
                    signedDistanceOutsideCircle =
                        (c * (X*X + Y*Y) + 2 * (X*normalX + Y*normalY))
                      / (MyMath.hypot(c*X + normalX, c*Y + normalY) + 1.);
                    double arcPointX = focusX + X - signedDistanceOutsideCircle * thisNormalX;
                    double arcPointY = focusY + Y - signedDistanceOutsideCircle * thisNormalY;
                    double startToArcPoint = MyMath.hypot(arcPointX-startX,
                                                          arcPointY-startY);
                    double arcDistance = startToArcPoint * MyMath.asin_over_x(c*startToArcPoint*.5);
                    if (false)
                    {
                        System.out.println("    nPointsDrawn = "+nPointsDrawn);
                        System.out.println("        signedDistanceOutsideCircle = "+signedDistanceOutsideCircle);
                        System.out.println("        startX = "+startX);
                        System.out.println("        startY = "+startY);
                        System.out.println("        arcPointX = "+arcPointX);
                        System.out.println("        arcPointY = "+arcPointY);
                        System.out.println("        startToArcPoint = "+startToArcPoint);
                        System.out.println("        arcDistance = "+arcDistance);
                        System.out.println("        start = "+start);
                        System.out.println("        end = "+end);
                        System.out.println("        c = "+c);
                    }
                    if (arcDistance >= end-start) // XXX use GEQ I think
                        break;
                }

                this.g.fillRect(x, y, 1, 1);
                nPointsDrawn++;

                // XXX For some small circles, the above will never be satisfied
                // XXX so put a limit on number of points to draw.
                // XXX Shouldn't need this if we get the above condition right
                if (nPointsDrawn >= maxPointsToDraw-1)
                    break;
            }
            this.g.fillRect((int)Math.round(endX), (int)Math.round(endY), 1, 1);
            nPointsDrawn++;
        }
        //System.out.println(spaces(4*--recursionLevel)+"            out smartDrawArcNonClipped");
    } // smartDrawArcNonClipped

    public void smartDrawArcClipped(
        double focusX, double focusY, // a point on the arc
        double focusAngleRadians,     // from center to focus
        double c,                     // curvature, i.e. 1/radius
        double start, double end,     // arc goes from focusAngle+start to focusAngle+end in arc length
        boolean antiAlias,
        double clipX0, double clipX1, double clipY0, double clipY1,
        double slack)
    {
        if (verbose >= 2) System.out.println("            in smartDrawArcClipped");
        if (verbose >= 2) System.out.println("              focusX="+focusX);
        if (verbose >= 2) System.out.println("              focusY="+focusY);
        if (verbose >= 2) System.out.println("              focusAngleRadians="+focusAngleRadians+" focusAngleDegrees="+RTOD(focusAngleRadians));
        if (verbose >= 2) System.out.println("              c="+c);
        if (verbose >= 2) System.out.println("              start="+start);
        if (verbose >= 2) System.out.println("              end="+end);
        if (verbose >= 2) System.out.println("              antiAlias="+antiAlias);
        if (verbose >= 2) System.out.println("              clipX0="+clipX0);
        if (verbose >= 2) System.out.println("              clipX1="+clipX1);
        if (verbose >= 2) System.out.println("              clipY0="+clipY0);
        if (verbose >= 2) System.out.println("              clipY1="+clipY1);
        if (verbose >= 2) System.out.println("              slack="+slack);
        CHECK(Double.isFinite(focusX));
        CHECK(Double.isFinite(focusY));
        CHECK(Double.isFinite(focusAngleRadians));
        CHECK(Double.isFinite(focusAngleRadians));
        CHECK(Double.isFinite(c)); // CBB: handle infinity? that means the circle is a point
        CHECK(Double.isFinite(start));
        CHECK(Double.isFinite(end));
        CHECK(Double.isFinite(clipX0));
        CHECK(Double.isFinite(clipX1));
        CHECK(Double.isFinite(clipY0));
        CHECK(Double.isFinite(clipY1));
        CHECK(Double.isFinite(slack));

        // I don't know how to clip analytically yet,
        // so do the following instead:
        // while an endpoint is outside the clip area,
        // cut off that length of the arc.
        // This will exponentially approach the clip rectangle
        // (or exponentially recede from it).
        // Stop when our distance from the clip rectangle
        // is <= slack (typically 2 pixels).
        // XXX except it doesn't work, when arc direction is perpendicular to direction towards clip area

        double clipMinX = Math.min(clipX0, clipX1);
        double clipMaxX = Math.max(clipX0, clipX1);
        double clipMinY = Math.min(clipY0, clipY1);
        double clipMaxY = Math.max(clipY0, clipY1);

        if (verbose >= 2) System.out.println("              span degrees = "+RTOD(c * Math.abs(end-start)));
        if (c * Math.abs(end-start) > 2*Math.PI)
        {
            start = 0.;
            end = 2*Math.PI / c;  // safe because that test couldn't have passed if c were zero
            if (verbose >= 2) System.out.println("              MORE THAN FULL CIRCLE!  adjusting to start="+start+" end="+end);
        }

        // TODO: explain what this is for.  If it accomplishes the same thing as simply swapping start and end, then should probably do that instead.
        int dir = (start <= end ? 1 : -1);

        double normalX = Math.cos(focusAngleRadians);
        double normalY = Math.sin(focusAngleRadians);
        double normalAndTangent[][] = {
            { normalX, normalY}, // unit normal vector
            {-normalY, normalX}, // unit tangent vector
        };
        double point[] = new double[2];
        double scratch[] = new double[2];

        if (verbose >= 2) System.out.println("              clipMinX = "+clipMinX);
        if (verbose >= 2) System.out.println("              clipMaxX = "+clipMaxX);
        if (verbose >= 2) System.out.println("              clipMinY = "+clipMinY);
        if (verbose >= 2) System.out.println("              clipMaxY = "+clipMaxY);
        if (verbose >= 2) System.out.println("              slack = "+slack);

        if (boldNewWayFlag) {
          // Try new bold way.
          // Swap if necessary so start <= end; that's easier than keeping track.
          // CBB: I think this works, but it's horribly verbose; need to make it more concise.
          if (start > end) {
            double temp;
            SWAP(start, end, temp);
          }
          double startAngleRadians = focusAngleRadians + start*c;
          double endAngleRadians = focusAngleRadians + end*c;
          // CBB: should coerce the following to int, somehow
          long firstRelevantQuadrant = (long)(Math.floor(startAngleRadians / (Math.PI/2)));
          long lastRelevantQuadrant = (long)(Math.ceil(endAngleRadians / (Math.PI/2)) - 1.0);
          if (c == 0.) {
            CHECK_GE(firstRelevantQuadrant, lastRelevantQuadrant);  // this prevents the zero divide below
          }
          if (lastRelevantQuadrant == firstRelevantQuadrant-1) {
            // so horizontal and vertical lines don't disappear...
            lastRelevantQuadrant = firstRelevantQuadrant;
          }

          if (verbose >= 2) System.out.println("              firstRelevantQuadrant = "+firstRelevantQuadrant);
          if (verbose >= 2) System.out.println("              lastRelevantQuadrant = "+lastRelevantQuadrant);
          CHECK_LE_LE(firstRelevantQuadrant-1, lastRelevantQuadrant, firstRelevantQuadrant+4);
          double startPoint[] = new double[2];  // scratch for loop
          double endPoint[] = new double[2];  // scratch for loop
          double midPoint[] = new double[2];  // scratch for loop
          for (long quadrant = firstRelevantQuadrant; quadrant <= lastRelevantQuadrant; quadrant++) {
            if (verbose >= 2) System.out.println("                  quadrant = "+quadrant);
            double partStart = quadrant==firstRelevantQuadrant ? start : ((Math.PI/2)*quadrant - focusAngleRadians) / c;  // we never divide by c=0, because in that case there's at most 1 relevant quadrant
            double partEnd = quadrant==lastRelevantQuadrant ? end : ((Math.PI/2)*(quadrant+1.) - focusAngleRadians) / c;  // we never divide by c=0, because in that case there's at most 1 relevant quadrant
            if (verbose >= 2) System.out.println("                      partStartAngleDegrees = "+RTOD(focusAngleRadians + partStart*c));
            if (verbose >= 2) System.out.println("                      partEndAngleDegrees = "+RTOD(focusAngleRadians + partEnd*c));
            CHECK(Double.isFinite(partStart));
            CHECK(Double.isFinite(partEnd));

            // CBB: if we would refrain from altering endPoint from previous iteration, we could reuse it
            boolean oopsWeProbablyClobberedEndPoint = true;
            if (oopsWeProbablyClobberedEndPoint || quadrant == firstRelevantQuadrant) {
              findPointOnArc(partStart, focusX, focusY, c, normalAndTangent, scratch, startPoint);
            } else {
              VecMath.copyvec(startPoint, endPoint);  // reuse result from previous iteration
            }
            findPointOnArc(partEnd, focusX, focusY, c, normalAndTangent, scratch, endPoint);
            if (verbose >= 2) System.out.println("                      startPoint = "+VecMath.toString(startPoint));
            if (verbose >= 2) System.out.println("                      endPoint = "+VecMath.toString(endPoint));

            // Clip part against the four clip lines.
            CHECK_LE_LE(0, (quadrant&3), 3);
            if (true) {
              if ((quadrant&3) == 0) {
                // Moving NW.
                if (startPoint[0] <= clipMinX+slack
                 || endPoint[0] >= clipMaxX-slack
                 || startPoint[1] >= clipMaxY-slack
                 || endPoint[1] <= clipMinY+slack) {
                  if (verbose >= 2) System.out.println("                      clipped away");
                  continue;
                }
                // Clamp partStart to SE of clip region...
                if (startPoint[0] > clipMaxX+slack
                 || startPoint[1] < clipMinY-slack) {
                  double lo = partStart;
                  double hi = partEnd;
                  int nItersDone = 0;
                  while (true) {
                    double mid = (lo+hi)*.5;
                    findPointOnArc(mid, focusX, focusY, c, normalAndTangent, scratch, midPoint);
                    if (midPoint[0] < clipMaxX-slack && midPoint[1] > clipMinY+slack) {
                      // mid is too far inside
                      hi = mid;
                    } else if (midPoint[0] > clipMaxX+slack || midPoint[1] < clipMinY-slack) {
                      // mid is too far outside
                      lo = mid;
                    } else {
                      partStart = mid;
                      VecMath.copyvec(startPoint, midPoint);
                      break;
                    }
                    nItersDone++;
                    if (nItersDone == 10000) {
                      OUT("=========");
                      System.out.println("ARGH! quadrant=0 (NW) clamping partStart");  // CBB: dump everything here
                      CHECK(false);
                      break;
                    }
                  }
                  // Clipping to right may have left only stuff that's above top,
                  // or clipping to bottom may have left only stuff that's left of left.
                  if (startPoint[0] <= clipMinX+slack
                   || startPoint[1] >= clipMaxY-slack) {
                    continue;
                  }
                }
                // Clamp partEnd to NW of clip region...
                if (endPoint[0] < clipMinX-slack
                 || endPoint[1] > clipMaxY+slack) {
                  double lo = partStart;
                  double hi = partEnd;
                  int nItersDone = 0;
                  while (true) {
                    double mid = (lo+hi)*.5;
                    findPointOnArc(mid, focusX, focusY, c, normalAndTangent, scratch, midPoint);
                    if (midPoint[0] > clipMinX+slack && midPoint[1] < clipMaxY-slack) {
                      // mid is too far inside
                      lo = mid;
                    } else if (midPoint[0] < clipMinX-slack || midPoint[1] > clipMaxY+slack) {
                      // mid is too far outside
                      hi = mid;
                    } else {
                      partEnd = mid;
                      VecMath.copyvec(endPoint, midPoint);
                      break;
                    }
                    nItersDone++;
                    if (nItersDone == 10000) {
                      OUT("=========");
                      OUT("ARGH! quadrant=0 (NW) clamping partEnd");
                      PRINT(focusX);
                      PRINT(focusY);
                      PRINT(focusAngleRadians);
                      PRINT(RTOD(focusAngleRadians));
                      PRINT(c);
                      PRINT(start);
                      PRINT(end);
                      PRINT(partStart);
                      PRINT(partEnd);
                      PRINTVEC(startPoint);
                      PRINTVEC(endPoint);
                      PRINT(clipX0);
                      PRINT(clipX1);
                      PRINT(clipY0);
                      PRINT(clipY1);
                      PRINT(slack);
                      PRINT(hi);
                      PRINT(lo);
                      PRINT(mid);
                      PRINTVEC(midPoint);
                      CHECK(false);
                      this.setColor(java.awt.Color.RED);
                      break;
                    }
                  }
                  // Clipping to left may have left only stuff that's below bottom,
                  // or clipping to top may have left only stuff that's right of right.
                  if (endPoint[0] >= clipMaxX-slack
                   || endPoint[1] <= clipMinY+slack) {
                    continue;
                  }
                }

              } else if ((quadrant&3) == 1) {
                // Moving SW.
                if (startPoint[0] <= clipMinX+slack
                 || endPoint[0] >= clipMaxX-slack
                 || startPoint[1] <= clipMinY+slack
                 || endPoint[1] >= clipMaxY-slack) {
                  if (verbose >= 2) System.out.println("                      clipped away");
                  continue;
                }
                // Clamp partStart to NE of clip region...
                if (startPoint[0] > clipMaxX+slack
                 || startPoint[1] > clipMaxY+slack) {
                  double lo = partStart;
                  double hi = partEnd;
                  int nItersDone = 0;
                  while (true) {
                    double mid = (lo+hi)*.5;
                    findPointOnArc(mid, focusX, focusY, c, normalAndTangent, scratch, midPoint);
                    if (midPoint[0] < clipMaxX-slack && midPoint[1] < clipMaxY-slack) {
                      // mid is too far inside
                      hi = mid;
                    } else if (midPoint[0] > clipMaxX+slack || midPoint[1] > clipMaxY+slack) {
                      // mid is too far outside
                      lo = mid;
                    } else {
                      partStart = mid;
                      VecMath.copyvec(startPoint, midPoint);
                      break;
                    }
                    nItersDone++;
                    if (nItersDone == 10000) {
                      OUT("=========");
                      OUT("ARGH! quadrant=1 (SW) clamping partStart");
                      CHECK(false);
                      break;
                    }
                  }
                  // Clipping to right may have left only stuff that's below bottom,
                  // or clipping to top may have left only stuff that's left of left.
                  if (startPoint[0] <= clipMinX+slack
                   || startPoint[1] <= clipMinY+slack) {
                    continue;
                  }
                }
                // Clamp partEnd to SW of clip region...
                if (endPoint[0] < clipMinX-slack
                 || endPoint[1] < clipMinY-slack) {
                  double lo = partStart;
                  double hi = partEnd;
                  int nItersDone = 0;
                  while (true) {
                    double mid = (lo+hi)*.5;
                    findPointOnArc(mid, focusX, focusY, c, normalAndTangent, scratch, midPoint);
                    if (midPoint[0] > clipMinX+slack && midPoint[1] > clipMinY+slack) {
                      // mid is too far inside
                      lo = mid;
                    } else if (midPoint[0] < clipMinX-slack || midPoint[1] < clipMinY-slack) {
                      // mid is too far outside
                      hi = mid;
                    } else {
                      partEnd = mid;
                      VecMath.copyvec(endPoint, midPoint);
                      break;
                    }
                    nItersDone++;
                    if (nItersDone == 10000) {
                      OUT("=========");
                      OUT("ARGH! quadrant=1 (SW) clamping partEnd");
                      CHECK(false);
                      this.setColor(java.awt.Color.RED);
                      break;
                    }
                  }
                  // Clipping to left may have left only stuff that's above top,
                  // or clipping to bottom may have left only stuff that's right of right.
                  if (endPoint[0] >= clipMaxX-slack
                   || endPoint[1] >= clipMaxY-slack) {
                    continue;
                  }
                }
              } else if ((quadrant&3) == 2) {
                // Moving SE.
                if (startPoint[0] >= clipMaxX-slack
                 || endPoint[0] <= clipMinX+slack
                 || startPoint[1] <= clipMinY+slack
                 || endPoint[1] >= clipMaxY-slack) {
                  if (verbose >= 2) System.out.println("                      clipped away");
                  continue;
                }
                // Clamp partStart to NW of clip region...
                if (startPoint[0] < clipMinX-slack
                 || startPoint[1] > clipMaxY+slack) {
                  double lo = partStart;
                  double hi = partEnd;
                  int nItersDone = 0;
                  while (true) {
                    double mid = (lo+hi)*.5;
                    findPointOnArc(mid, focusX, focusY, c, normalAndTangent, scratch, midPoint);
                    if (midPoint[0] > clipMinX+slack && midPoint[1] < clipMaxY-slack) {
                      // mid is too far inside
                      hi = mid;
                    } else if (midPoint[0] < clipMinX-slack || midPoint[1] > clipMaxY+slack) {
                      // mid is too far outside
                      lo = mid;
                    } else {
                      partStart = mid;
                      VecMath.copyvec(startPoint, midPoint);
                      break;
                    }
                    nItersDone++;
                    if (nItersDone == 10000) {
                      OUT("=========");
                      OUT("ARGH! quadrant=2 (SE) clamping partStart");
                      CHECK(false);
                      break;
                    }
                  }
                  // Clipping to left may have left only stuff that's below bottom,
                  // or clipping to top may have left only stuff that's right of right.
                  if (startPoint[0] >= clipMaxX-slack
                   || startPoint[1] <= clipMinY+slack) {
                    continue;
                  }
                }
                // Clamp partEnd to SE of clip region...
                if (endPoint[0] > clipMaxX+slack
                 || endPoint[1] < clipMinY-slack) {
                  double lo = partStart;
                  double hi = partEnd;
                  int nItersDone = 0;
                  while (true) {
                    double mid = (lo+hi)*.5;
                    findPointOnArc(mid, focusX, focusY, c, normalAndTangent, scratch, midPoint);
                    if (midPoint[0] < clipMaxX-slack && midPoint[1] > clipMinY+slack) {
                      // mid is too far inside
                      lo = mid;
                    } else if (midPoint[0] > clipMaxX+slack || midPoint[1] < clipMinY-slack) {
                      // mid is too far outside
                      hi = mid;
                    } else {
                      partEnd = mid;
                      VecMath.copyvec(endPoint, midPoint);
                      break;
                    }
                    nItersDone++;
                    if (nItersDone == 10000) {
                      OUT("=========");
                      OUT("ARGH! quadrant=2 (SE) clamping partEnd");
                      CHECK(false);
                      this.setColor(java.awt.Color.RED);
                      break;
                    }
                  }
                  // Clipping to right may have left only stuff that's above top,
                  // or clipping to bottom may have left only stuff that's left of left.
                  if (endPoint[0] <= clipMinX+slack
                   || endPoint[1] >= clipMaxY-slack) {
                    continue;
                  }
                }
              } else if ((quadrant&3) == 3) {
                // Moving NE.
                if (startPoint[0] >= clipMaxX-slack
                 || endPoint[0] <= clipMinX+slack
                 || startPoint[1] >= clipMaxY-slack
                 || endPoint[1] <= clipMinY+slack) {
                  if (verbose >= 2) System.out.println("                      clipped away");
                  continue;
                }
                // Clamp partStart to SW of clip region...
                if (startPoint[0] < clipMinX-slack
                 || startPoint[1] < clipMinY-slack) {
                  double lo = partStart;
                  double hi = partEnd;
                  int nItersDone = 0;
                  while (true) {
                    double mid = (lo+hi)*.5;
                    findPointOnArc(mid, focusX, focusY, c, normalAndTangent, scratch, midPoint);
                    if (midPoint[0] > clipMinX+slack && midPoint[1] > clipMinY+slack) {
                      // mid is too far inside
                      hi = mid;
                    } else if (midPoint[0] < clipMinX-slack || midPoint[1] < clipMinY-slack) {
                      // mid is too far outside
                      lo = mid;
                    } else {
                      partStart = mid;
                      VecMath.copyvec(startPoint, midPoint);
                      break;
                    }
                    nItersDone++;
                    if (nItersDone == 10000) {
                      OUT("=========");
                      OUT("ARGH! quadrant=3 (NE) clamping partStart");
                      CHECK(false);
                      break;
                    }
                  }
                  // Clipping to left may have left only stuff that's above top,
                  // or clipping to bottom may have left only stuff that's right of right.
                  if (startPoint[0] >= clipMaxX-slack
                   || startPoint[1] >= clipMaxY-slack) {
                    continue;
                  }
                }
                // Clamp partEnd to NE of clip region...
                if (endPoint[0] > clipMaxX+slack
                 || endPoint[1] > clipMaxY+slack) {
                  double lo = partStart;
                  double hi = partEnd;
                  int nItersDone = 0;
                  while (true) {
                    double mid = (lo+hi)*.5;
                    findPointOnArc(mid, focusX, focusY, c, normalAndTangent, scratch, midPoint);
                    if (midPoint[0] < clipMaxX-slack && midPoint[1] < clipMaxY-slack) {
                      // mid is too far inside
                      lo = mid;
                    } else if (midPoint[0] > clipMaxX+slack || midPoint[1] > clipMaxY+slack) {
                      // mid is too far outside
                      hi = mid;
                    } else {
                      partEnd = mid;
                      VecMath.copyvec(endPoint, midPoint);
                      break;
                    }
                    nItersDone++;
                    if (nItersDone == 10000) {
                      OUT("=========");
                      OUT("ARGH! quadrant=3 (NE) clamping partEnd");
                      CHECK(false);
                      break;
                    }
                  }
                  // Clipping to right may have left only stuff that's below bottom,
                  // or clipping to top may have left only stuff that's left of left.
                  if (endPoint[0] <= clipMinX+slack
                   || endPoint[1] <= clipMinY+slack) {
                    continue;
                  }
                }
              } else {
                CHECK(false);  // can't happen because already checked
              }
            }
            CHECK_LE(partStart, partEnd);
            if (verbose >= 2) System.out.println("              calling smartDrawArcNonClipped...");
            smartDrawArcNonClipped(focusX,focusY, focusAngleRadians, c, partStart,partEnd,
                                   antiAlias);
            if (verbose >= 2) System.out.println("              returned from smartDrawArcNonClipped.");
          }
          if (verbose >= 2) System.out.println("            out smartDrawArcClipped (after better clipping)");
          return;
        }  // bold new way



        // Start by jumping start towards the clip area, so we don't start
        // by doing a bunch of nothing.
        if (verbose >= 2) System.out.println("              doing first loop...");
        int max = 100;  // off-the-rails detection
        for (int i = 0; ; i++)
        {
            CHECK_LT(i, max);
            if (verbose >= 2) System.out.println("                  top of loop (i="+i+")");
            if (verbose >= 2) System.out.println("                      start="+start);
            if (verbose >= 2) System.out.println("                      end="+end);
            CHECK(!Double.isNaN(start));
            CHECK(!Double.isNaN(end));
            findPointOnArc(start, focusX, focusY, c, normalAndTangent, scratch, point);
            double startX = point[0];
            double startY = point[1];
            if (verbose >= 2) System.out.println("                      startX="+startX);
            if (verbose >= 2) System.out.println("                      startY="+startY);
            double dist = MAX4(startX-clipMaxX,
                               clipMinX-startX,
                               startY-clipMaxY,
                               clipMinY-startY);
            if (verbose >= 2) System.out.println("                      dist="+dist);
            if (dist <= slack)
                break;
            start += dir * dist;
            if (verbose >= 2) System.out.println("                      new start="+start);
            if (dir * (end-start) < 0)
            {
                if (verbose >= 2) System.out.println("            out smartDrawArcClipped (without drawing)");
                return;
            }
        }
        if (verbose >= 2) System.out.println("              done with first loop.");
        if (verbose >= 2) System.out.println("              doing second loop...");
        while (true)
        {
            //System.out.println("start="+start);
            //System.out.println("end="+end);
            findPointOnArc(end, focusX, focusY, c, normalAndTangent, scratch, point);
            double endX = point[0];
            double endY = point[1];
            //System.out.println("endX = "+endX);
            //System.out.println("endY = "+endY);
            double dist = MAX4(endX-clipMaxX,
                               clipMinX-endX,
                               endY-clipMaxY,
                               clipMinY-endY);
            if (dist <= slack)
                break;
            end -= dir * dist;
            //System.out.println("new end="+end);
            if (dir * (end-start) < 0)
            {
                //System.out.println("        out smartDrawArcClipped (without drawing.");
                return;
            }
        }
        if (verbose >= 2) System.out.println("              done with second loop.");

        // Prevent huge circles that start and end in the clip rectangle.
        // Note this doesn't clip away all arc segments
        // that leave the clip rectangle, but it does
        // guarantee that any it misses won't be much larger
        // than the clip rectangle (and usually much smaller).
        {
            double mid = (start+end)*.5;
            findPointOnArc(mid, focusX, focusY, c, normalAndTangent, scratch, point);
            double midX = point[0];
            double midY = point[1];
            double dist = MAX4(midX-clipMaxX,
                               clipMinX-midX,
                               midY-clipMaxY,
                               clipMinY-midY);
            if (dist > slack)
            {
                smartDrawArcClipped(focusX, focusY, focusAngleRadians, c,
                                    start, mid,
                                    antiAlias,
                                    clipX0, clipX1, clipY0, clipY1, slack);
                smartDrawArcClipped(focusX, focusY, focusAngleRadians, c,
                                    mid, end,
                                    antiAlias,
                                    clipX0, clipX1, clipY0, clipY1, slack);
                if (verbose >= 2) System.out.println("        out smartDrawArcClipped (split in two)");
                return;
            }
        }

        if (verbose >= 2) System.out.println("              calling smartDrawArcNonClipped...");
        smartDrawArcNonClipped(focusX,focusY, focusAngleRadians, c, start,end,
                               antiAlias);
        if (verbose >= 2) System.out.println("              returned from smartDrawArcNonClipped.");
        if (verbose >= 2) System.out.println("            out smartDrawArcClipped (bottom)");
    } // smartDrawArcClipped

    public void smartDrawArc_(
        double focusX, double focusY, // a point on the arc
        double focusAngleRadians,     // from center to focus
        double c,                     // curvature, i.e. 1/radius
        double start, double end,     // arc goes from focusAngle+start to focusAngle+end in arc length
        boolean antiAlias)
    {
        if (verbose >= 2) System.out.println("        in smartDrawArc_");
        if (verbose >= 2) System.out.println("          focusX="+focusX);
        if (verbose >= 2) System.out.println("          focusY="+focusY);
        if (verbose >= 2) System.out.println("          focusAngleRadians="+focusAngleRadians);
        if (verbose >= 2) System.out.println("          c="+c);
        if (verbose >= 2) System.out.println("          start="+start);
        if (verbose >= 2) System.out.println("          end="+end);

        double clipX0 = (0-translateX)/scaleX;
        double clipX1 = (gsize.width-translateX)/scaleX;
        double clipY0 = (0-translateY)/scaleY;
        double clipY1 = (gsize.height-translateY)/scaleY;

        if (debugClip)
        {
            // debug by setting clip to half what it was
            clipX0 *= .95;
            clipX1 *= .95;
            clipY0 *= .95;
            clipY1 *= .95;
        }

        if (verbose >= 2) System.out.println("          calling smartDrawArcClipped...");
        smartDrawArcClipped(focusX, focusY, focusAngleRadians, c, start, end,
                            antiAlias,
                            clipX0, clipX1, clipY0, clipY1,
                            2./((Math.abs(scaleX)+Math.abs(scaleY))*.5));   // 2 pixels
        if (verbose >= 2) System.out.println("          returned from smartDrawArcClipped...");
        if (verbose >= 2) System.out.println("        out smartDrawArc_");
    } // smartDrawArc_

    //
    // Thickness is in pixels.  This will probably do something not-right
    // if scaleX != scaleY.
    //
    public void smartDrawThickArc(
        double thicknessInPixels,
        double focusX, double focusY, // a point on the arc
        double focusAngleRadians,     // from center to focus
        double c,                     // curvature, i.e. 1/radius
        double start, double end,     // arc goes from focusAngle+start to focusAngle+end in arc length
        boolean antiAlias) // should be false-- don't know what weird behavior will happen if it's true
    {
        if (verbose >= 2) System.out.println("    in smartDrawThickArc");
        double n = (int)Math.ceil(2.*thicknessInPixels-1.);
        if (n <= 1)
        {
            smartDrawArc_(focusX, focusY, focusAngleRadians, c, start, end, antiAlias);
            if (verbose >= 2) System.out.println("    out smartDrawThickArc (thickness<=1)");
            return;
        }

        double scale = .5 * (Math.abs(scaleX) + Math.abs(scaleY)); // XXX not really right unless scaleX == scaleY, but that's usually the case
        double onePixel = 1./scale;
        double dx = Math.cos(focusAngleRadians);
        double dy = Math.sin(focusAngleRadians);

        FORI (i, n)
        {
            double s = LERP(-(thicknessInPixels-1)/2, (thicknessInPixels-1)/2,
                            i/(n-1.)) * onePixel;
            double foo = 1. + c*s;
            if (foo <= 0.) // XXX should use some threshold?
                continue;
            smartDrawArc_(
                    focusX + s * dx,
                    focusY + s * dy,
                    focusAngleRadians,
                    c / foo,
                    start * foo,
                    end * foo,
                    antiAlias);
        }
        if (verbose >= 2) System.out.println("    out smartDrawThickArc");
    } // smartDrawThickArc




    // Arc drawing on Linux/Netscape is so broken it's unbelievable...
    // so, even though the simple finitistic API is inherently bad for
    // circles of unlimited radius,
    // this is still much much better than Netscape's.
    public void drawThickArc(double x, double y, double width, double height,
                        double startRadians, double arcRadians,
                        double thicknessInPixels,
                        boolean antiAlias) // hmm, according to smartDrawThickArc doc, this should always be false?
    {
        if (verbose >= 2) System.out.println("in drawThickArc");
        double centerX = x + width*.5;
        double centerY = y + height*.5;
        double radius = .25*(width+height); // XXX ignoring aspect for now
        double curvature = 1./radius;
        double focusAngleRadians = startRadians;
        double start = 0.;
        double end = arcRadians * radius;
        double focusX = centerX + radius * Math.cos(focusAngleRadians);
        double focusY = centerY + radius * Math.sin(focusAngleRadians);
        smartDrawThickArc(
                     thicknessInPixels,
                     focusX, focusY,
                     focusAngleRadians,
                     curvature,
                     start, end,
                     antiAlias);
        if (verbose >= 2) System.out.println("out drawThickArc");
        return;
    } // drawThickArc

    public java.awt.Color getColor() 
    {
        return g.getColor();
    }
    public void setColor(java.awt.Color color) 
    {
        g.setColor(color);
    }

    private java.awt.Graphics g;
    private java.awt.Dimension gsize;
    private double scaleX = 1;
    private double scaleY = 1;
    private double translateX = 0;
    private double translateY = 0;
    public boolean debugClip = false;
    public int verbose = 2; // caller can set this before making calls, to debug
    public boolean boldNewWayFlag = true;

    public double getScaleX() { return scaleX; }
    public double getScaleY() { return scaleY; }
    public double getTranslateX() { return translateX; }
    public double getTranslateY() { return translateY; }


        //
        // Return an array of the given Color
        // with each of 256 transparencies.
        // The array is cached from one call to the next,
        // so consecutive calls using the same color
        // will not suffer alllocation overhead.
        //
            private java.awt.Color[/*256*/] cache = null;
            private java.awt.Color cacheColor = null;
            private int cacheRGB;
        private java.awt.Color[/*256*/] getTransparentColorCache(java.awt.Color color)
        {
            if (color != cacheColor)
            {
                cacheColor = color;

                int colorRGB = color.getRGB();

                if (cache == null || colorRGB != cacheRGB)
                {
                    cacheRGB = colorRGB;
                    if (cache == null)
                        cache = new java.awt.Color[256];
                    int r = (colorRGB >> 16) & 0xff;
                    int g = (colorRGB >> 8) & 0xff;
                    int b = (colorRGB >> 0) & 0xff;
                    for (int i = 0; i < 256; ++i)
                    {
                        // XXX Note this will barf in 1.1; colors didn't have alpha
                        cache[i] = new java.awt.Color(r, g, b, i);
                        //System.out.println(""+i+": "+cache[i]+"");
                    }
                    //System.out.println("MISS");
                }
                else
                {
                    //System.out.println("    HIT (colors equal)");
                }
            }
            else
            {
                //System.out.println("    HIT (address equal)");
            }

            return cache;
        } // getTransparencyColorCache

    // Utility...
        private static void findPointOnArc(double t,
                                           double focusX, double focusY,
                                           double c,
                                           double normalAndTangent[][],
                                           double scratch[/*2*/],
                                           double result[/*2*/])
        {
            // coeff of normal vector: -(1-cos(t*c))/c
            //scratch[0] = -MyMath.cosf1_over_x(t*c) * t;
            scratch[0] = -MyMath.cosf1_over_xx(t*c) * (t*c) * t;
            // coeff of tangent vector: sin(t*c)/c
            scratch[1] = MyMath.sin_over_x(t*c) * t;
            VecMath.vxm(result, scratch, normalAndTangent);
            result[0] += focusX;
            result[1] += focusY;
        } // findPointOnArc

        /*
        private static String spaces(int n)
        {
            String s = "";
            for (int i = 0; i < n; ++i)
                s += " ";
            return s;
        } // spaces
        */

    //
    // Utilities to replace macros...
    //
        /*
        private static double LERP(double a, double b, double t)
        {
            return a + t * (b-a);
        }
        private static double MAX(double a, double b) // same as Math.max
        {
            return a >= b ? a : b;
        }
        private static int MAX(int a, int b) // same as Math.max
        {
            return a >= b ? a : b;
        }
        private static double MIN(double a, double b) // same as Math.min
        {
            return a <= b ? a : b;
        }
        private static int MIN(int a, int b) // same as Math.min
        {
            return a <= b ? a : b;
        }
        private static double ABS(double x) // same as Math.abs
        {
            return x >= 0. ? x : -x;
        }
        private static double MAX4(double a, double b, double c, double d)
        {
            return MAX(MAX(a,b),MAX(c,d));
        }
        */
    // Subclasses might want to do something here...
    public void flush()
    {
    }

    // little test program
    public static void main(String[] args)
    {
        if (false)
        {
          // Attempt to prevent the java window from stealing focus.
          // Doesn't work; gives a HeadlessException :-(
          System.setProperty("java.awt.headless", "true"); // Equivalent to -Djava.awt.headless=true
        }

        boolean initialBoldNewWayFlag;
        if (args.length == 1 && args[0].equals("true"))
          initialBoldNewWayFlag = true;
        else if (args.length == 1 && args[0].equals("false"))
          initialBoldNewWayFlag = false;
        else {
          System.err.println("Usage: MyGraphics <boldNewWay>[true|false]");
          System.exit(1);
          return;
        }

        new javax.swing.JFrame() {{
          this.add(new javax.swing.JPanel() {

            // Visible state
            private boolean boldNewWayFlag = initialBoldNewWayFlag;

            //private double clipX0 = -1.;
            //private double clipX1 = 1.;
            //private double clipY0 = -1.;
            //private double clipY1 = 1.;

            // These were causing an assert fail, now fixed
            //private double clipX0 = -0.7466340931508219;
            //private double clipX1 = 1.253365906849178;
            //private double clipY0 = -1.1993769470404987;
            //private double clipY1 = 0.8006230529595016;

            // Then these were, now fixed too
            private double clipX0 = -1.2699800646753538;
            private double clipX1 = -0.968777702401811;
            private double clipY0 = -1.1744548286604364;
            private double clipY1 = 0.9169262720664589;

            private MyGraphics mostRecentMyGraphics = null;

            @Override protected void paintComponent(java.awt.Graphics g) {
              System.out.println("    in paintComponent");
              long t0millis = System.currentTimeMillis();

              if (true) {

                java.awt.Dimension size = getSize();
                double x0 = -2.;
                double x1 = 2.;
                double y0 = -2.;
                double y1 = 2.;

                MyGraphics mg;
                {
                  // CBB: think of a way to make this a clean function
                  double x0Fudged = x0;
                  double x1Fudged = x1;
                  double y0Fudged = y0;
                  double y1Fudged = y1;
                  if (size.width > size.height) {
                    // wide; adjust x0Fudged and x1Fudged
                    x0Fudged *= (double)size.width / (double)size.height;
                    x1Fudged *= (double)size.width / (double)size.height;
                  } else {
                    // tall; adjust y0Fudged and y1Fudged
                    y0Fudged *= (double)size.height / (double)size.width;
                    y1Fudged *= (double)size.height / (double)size.width;
                  }
                  mg = new MyGraphics(g,
                                      size,
                                      x0Fudged, x1Fudged, y0Fudged, y1Fudged);
                  mostRecentMyGraphics = mg;
                }

                mg.boldNewWayFlag = boldNewWayFlag;

                mg.verbose = 0;
                //mg.verbose = 2;

                mg.setColor(java.awt.Color.WHITE);
                mg.fillWindow();

                mg.setColor(java.awt.Color.RED);
                mg.drawLineNonClipped(clipX0,clipY0, clipX1,clipY0, /*antiAlias=*/false);
                mg.drawLineNonClipped(clipX1,clipY0, clipX1,clipY1, /*antiAlias=*/false);
                mg.drawLineNonClipped(clipX1,clipY1, clipX0,clipY1, /*antiAlias=*/false);
                mg.drawLineNonClipped(clipX0,clipY1, clipX0,clipY0, /*antiAlias=*/false);

                mg.setColor(java.awt.Color.BLACK);

                int nRowsCols = 10;
                //int nRowsCols = 2;
                CHECK_GT(nRowsCols, 1);  // since we devide by nRowsCols-1
                double maxRadius = (x1-x0)/nRowsCols / 2;
                int verboseLevel = 0;
                for (int iRow = 0; iRow < nRowsCols; ++iRow) {
                  for (int iCol = 0; iCol < nRowsCols; ++iCol) {
                    //if (!(iRow == 0 && iCol == 1)) continue;
                    //if (!(iRow == 0 && iCol == nRowsCols-1)) continue;
                    if (verboseLevel >= 1) System.out.println("          iRow="+iRow+" iCol="+iCol);
                    double centerX = LERP(x0, x1, (iCol+.5)/nRowsCols);
                    double centerY = LERP(y0, y1, (iRow+.5)/nRowsCols);
                    if (verboseLevel >= 2) System.out.println("              centerX="+centerX+" centerY="+centerY);
                    double startDeltaRadians = 1.*LERP(-Math.PI, Math.PI, iRow/(nRowsCols-1.));  // not really; will scale by circle radius
                    double endDeltaRadians = 1.*LERP(-Math.PI, Math.PI, iCol/(nRowsCols-1.));  // not really; will scale by circle radius
                    int nConcentric = 17;
                    //int nConcentric = 4;
                    for (int i = 0; i < nConcentric; ++i) {
                      double radius = (i+1.)/nConcentric * maxRadius;
                      double c = 1. / radius;  // TODO: exercise c=0
                      double slack = .01;  // somewhat arbitrary
                      double focusAngleRadians = LERP(-Math.PI, Math.PI, i / (nConcentric-1.));
                      if (verboseLevel >= 3) System.out.println("                  i="+i+": radius="+radius+" c="+c+" focusAngleDegrees="+RTOD(focusAngleRadians));
                      double focusX = centerX + radius * Math.cos(focusAngleRadians);
                      double focusY = centerY + radius * Math.sin(focusAngleRadians);
                      double[] curvatureScales = {1., .5, 0.};
                      for (int iCurvatureScale = 0; iCurvatureScale < curvatureScales.length; ++iCurvatureScale) {
                        double curvatureScale = curvatureScales[iCurvatureScale];
                        mg.smartDrawArcClipped(focusX,
                                               focusY,
                                               focusAngleRadians,
                                               c * curvatureScale,
                                               startDeltaRadians*radius,
                                               endDeltaRadians*radius,
                                               /*antiAlias=*/false,
                                               /*clipX0=*/clipX0,
                                               /*clipX1=*/clipX1,
                                               /*clipY0=*/clipY0,
                                               /*clipY1=*/clipY1,
                                               /*slack=*/slack);
                      }
                    }
                  }
                }
              }

              if (false)
              {
                // Something that CHECK-failed before:
                //   - canned thing hexes spiral
                //   - my algorithm 2
                //   - my algorithm max iters = 295
                java.awt.Dimension size = getSize();
                MyGraphics mg = new MyGraphics(g,
                                               size,
                                               /*left=*/-20,
                                               /*right=*/20,
                                               /*bottom=*/-20,
                                               /*top=*/20
                                               );
                mg.verbose = 3;
                mg.smartDrawArcClipped(
                  ///*focusX=*/2.4065304826489604,  // EXCEPTION
                  /*focusX=*/2,  // EXCEPTION
                  ///*focusY=*/-1.016121680672899,  // EXCEPTION
                  /*focusY=*/-1.02,  // EXCEPTION
                  ///*focusY=*/-1,  // OK
                  ///*focusAngleRadians=*/1.5707963267948966,  // EXCEPTION
                  ///*focusAngleRadians=*/1.57,  // EXCEPTION
                  /*focusAngleRadians=*/1.5672,  // EXCEPTION
                  ///*focusAngleRadians=*/1.5671,  // OK
                  ///*focusAngleRadians=*/0,  // OK
                  /*c=*/0.0,
                  ///*start=*/-10.0, // EXCEPTION
                  /*start=*/1.5,  // EXCEPTION
                  ///*end=*/10.0,  // EXCEPTION
                  /*end=*/3.5,  // EXCEPTION
                  /*antiAlias=*/false,

                  // THESE CAUSE AN EXCEPTION
                  /*clipX0=*/-1.096158027664877,
                  /*clipX1=*/1.096158027664877,
                  /*clipY0=*/1.0021413276231264,
                  /*clipY1=*/-1.0021413276231264,

                  // THESE ARE OK
                  ///*clipX0=*/-10.96158027664877,
                  ///*clipX1=*/10.96158027664877,
                  ///*clipY0=*/10.021413276231264,
                  ///*clipY1=*/-10.021413276231264,

                  /*slack=*/0.008564522469325795
                );
              }
              long t1millis = System.currentTimeMillis();
              System.out.println("      boldNewWayFlag = "+boldNewWayFlag);
              System.out.println("    out paintComponent in "+(t1millis-t0millis)/1000.+" secs.");
            }  // paintComponent



            private boolean draggingClipX0 = false;
            private boolean draggingClipX1 = false;
            private boolean draggingClipY0 = false;
            private boolean draggingClipY1 = false;
            private double prevX = 0.;
            private double prevY = 0.;

            {
              this.setFocusable(true);
              this.addKeyListener(new java.awt.event.KeyListener() {
                @Override public void keyPressed(java.awt.event.KeyEvent e) {
                  //System.out.println("in keyPressed(e="+e+")");
                  if (e.getKeyChar() == 'q') {
                    System.out.println("Bye!");
                    System.exit(0);
                  } else if (e.getKeyChar() == 'b') {
                    boldNewWayFlag = !boldNewWayFlag;
                    System.out.println("boldNewWayFlag -> "+boldNewWayFlag);
                    repaint();
                  }
                  //System.out.println("out keyPressed(e="+e+")");
                }
                @Override public void keyReleased(java.awt.event.KeyEvent e) {
                }
                @Override public void keyTyped(java.awt.event.KeyEvent e) {
                }
              });
              this.addMouseListener(new java.awt.event.MouseListener() {
                @Override public void mouseEntered(java.awt.event.MouseEvent e) {
                   if (mostRecentMyGraphics != null) {
                     double[] xy = new double[2];
                     mostRecentMyGraphics.pick(e.getX()+.5, e.getY()+.5, xy);
                     System.out.println("  mouse entered at "+VecMath.toString(xy));
                     prevX = xy[0];
                     prevY = xy[1];
                   }
                }
                @Override public void mousePressed(java.awt.event.MouseEvent e) {
                   if (mostRecentMyGraphics != null) {
                     double[] xy = new double[2];
                     mostRecentMyGraphics.pick(e.getX()+.5, e.getY()+.5, xy);
                     System.out.println("          mouse pressed at "+VecMath.toString(xy));
                     double threshold = .05;  // CBB: measure in pixels?  not sure
                     // CBB: pick closest of X0,X1, and of Y0,Y1
                     draggingClipX0 = Math.abs(xy[0] - clipX0) <= threshold;
                     draggingClipX1 = !draggingClipX0 && Math.abs(xy[0] - clipX1) <= threshold;
                     draggingClipY0 = Math.abs(xy[1] - clipY0) <= threshold;
                     draggingClipY1 = !draggingClipY0 && Math.abs(xy[1] - clipY1) <= threshold;

                     if (!draggingClipX0 && !draggingClipX1 && !draggingClipY0 && !draggingClipY1
                      && (INRANGE(clipX0 <=, xy[0], <= clipX1) || INRANGE(clipX1 <=, xy[0], <= clipX0))
                      && (INRANGE(clipY0 <=, xy[1], <= clipY1) || INRANGE(clipY1 <=, xy[1], <= clipY0))) {
                        // In interior-- pan whole clip region
                       draggingClipX0 = true;
                       draggingClipX1 = true;
                       draggingClipY0 = true;
                       draggingClipY1 = true;
                     }

                     PRINT(draggingClipX0);
                     PRINT(draggingClipX1);
                     PRINT(draggingClipY0);
                     PRINT(draggingClipY1);
                     prevX = xy[0];
                     prevY = xy[1];
                   }
                }
                @Override public void mouseReleased(java.awt.event.MouseEvent e) {
                   if (mostRecentMyGraphics != null) {
                     double[] xy = new double[2];
                     mostRecentMyGraphics.pick(e.getX()+.5, e.getY()+.5, xy);
                     System.out.println("          mouse released at "+VecMath.toString(xy));
                     draggingClipX0 = false;
                     draggingClipX1 = false;
                     draggingClipY0 = false;
                     draggingClipY1 = false;
                     prevX = xy[0];
                     prevY = xy[1];
                   }
                }
                @Override public void mouseClicked(java.awt.event.MouseEvent e) {
                   if (mostRecentMyGraphics != null) {
                     double[] xy = new double[2];
                     mostRecentMyGraphics.pick(e.getX()+.5, e.getY()+.5, xy);
                     System.out.println("      mouse clicked at "+VecMath.toString(xy));
                     prevX = xy[0];
                     prevY = xy[1];
                   }
                }
                @Override public void mouseExited(java.awt.event.MouseEvent e) {
                   if (mostRecentMyGraphics != null) {
                     double[] xy = new double[2];
                     mostRecentMyGraphics.pick(e.getX()+.5, e.getY()+.5, xy);
                     System.out.println("  mouse exited at "+VecMath.toString(xy));
                     prevX = xy[0];
                     prevY = xy[1];
                   }
                }
              });
              this.addMouseMotionListener(new java.awt.event.MouseMotionListener() {
                @Override public void mouseMoved(java.awt.event.MouseEvent e) {
                   if (mostRecentMyGraphics != null) {
                     double[] xy = new double[2];
                     mostRecentMyGraphics.pick(e.getX()+.5, e.getY()+.5, xy);
                     System.out.println("      mouse moved to "+VecMath.toString(xy));
                     prevX = xy[0];
                     prevY = xy[1];
                   }
                }
                @Override public void mouseDragged(java.awt.event.MouseEvent e) {
                   if (mostRecentMyGraphics != null) {
                     double[] xy = new double[2];
                     mostRecentMyGraphics.pick(e.getX()+.5, e.getY()+.5, xy);
                     System.out.println("              mouse dragged to "+VecMath.toString(xy));
                     if (draggingClipX0) clipX0 += xy[0] - prevX;
                     if (draggingClipX1) clipX1 += xy[0] - prevX;
                     if (draggingClipY0) clipY0 += xy[1] - prevY;
                     if (draggingClipY1) clipY1 += xy[1] - prevY;
                     if (draggingClipX0 || draggingClipX1 || draggingClipY0 || draggingClipY1) {
                       repaint();
                     }
                     prevX = xy[0];
                     prevY = xy[1];
                  }
                }
              });
            }
          });
          //this.setSize(/*width=*/100, /*height=*/100);
          this.setSize(/*width=*/1000, /*height=*/1000);
          this.setVisible(true);
          this.setDefaultCloseOperation(EXIT_ON_CLOSE);
        }};  // new JFrame
    }  // main
} // class MyGraphics
