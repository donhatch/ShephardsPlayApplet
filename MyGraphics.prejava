//
// ARGH evidently this has totally diverged from the one in donhatchsw.com
//
// Wrapper class for Graphics
// that does a subset of the Graphics2D API
// (But with saner API.)
//
#include "macros.h"

import com.donhatchsw.util.MyMath;
import com.donhatchsw.util.VecMath;

public class MyGraphics
{
    private static int maxItersEver = 0;

    public MyGraphics(java.awt.Graphics g,
                      java.awt.Dimension gsize,
                      double x0, double x1, double y0, double y1)
    {
        this.g = g;
        this.gsize = gsize;
        fitToWindow(x0, x1, y0, y1);
    }
    public MyGraphics(java.awt.Graphics g,
                      java.awt.Dimension gsize)
    {
        this.g = g;
        this.gsize = gsize;
        fitToWindow(-1., 1., -1., 1.);
    }

    //
    // Set translate and scale
    // so that x0,x1,y0,y0
    // map to left,right,bottom,top.
    //
    public void fit(double x0,   double x1,    double y0,     double y1,
                    double left, double right, double bottom, double top)
    {
        scaleX = (right-left) / (x1-x0);
        scaleY = (top-bottom) / (y1-y0);
        translateX = left - scaleX*x0;
        translateY = bottom - scaleY*y0;
    }
    public void fitToWindow(double x0, double x1, double y0, double y1)
    {
        fit(x0, x1,             y0,              y1,
            .5, gsize.width-.5, gsize.height-.5, .5);
    }
    public void fitToPixel(double centerX, double centerY,
                           double pixelSizeX, double pixelSizeY)
    {
        fit(centerX, centerX+pixelSizeX, centerY, centerY+pixelSizeY,
            gsize.width*.5, gsize.width*.5 + 1., gsize.height*.5, gsize.height*.5 + 1);
    }

    public void translate(double x, double y)
    {
        translateX += x*scaleX;
        translateY += y*scaleY;
    }

    // window coords to input coords
    // If getting from an event, usually you want x=e.getX()+.5, y=e.getY()+.5.
    public void pick(double x, double y, double result[/*2*/])
    {
        result[0] = (x-translateX)/scaleX;
        result[1] = (y-translateY)/scaleY;
    }

    // input coords to window coords.
    // XXX name is dorky
    public void unpick(double x, double y, double result[/*2*/])
    {
        result[0] = x*scaleX + translateX;
        result[1] = y*scaleY + translateY;
    }


    public void fillWindow()
    {
        g.fillRect(0,0, gsize.width,gsize.height);
    }

    public void drawLineNonClipped(double x0, double y0, double x1, double y1,
                                   boolean antiAlias)
    {
        if (antiAlias)
        {
            if (x0 == x1 && y0 == y1)
            {
                drawPoint(x0, y0, 1);
                return;
            }

            // Transform to window coords...
            // "the pen hangs down and to the right of the coordinate",
            // so adjust the coordinate by half a pixel up and to the left...
            x0 = (x0 * scaleX + translateX - .5);
            y0 = (y0 * scaleY + translateY - .5);
            x1 = (x1 * scaleX + translateX - .5);
            y1 = (y1 * scaleY + translateY - .5);

            java.awt.Color savedColor = getColor();
            java.awt.Color[/*256*/] transparentColorCache = getTransparentColorCache(savedColor);

            if (Math.abs(y1-y0) >= Math.abs(x1-x0))
            {
                int Y0 = (int)Math.round(y0);
                int Y1 = (int)Math.round(y1);
                int dirY = (Y0 <= Y1 ? 1 : -1);
                double slope = (x1-x0)/(y1-y0);
                for (int Y = Y0; Y != Y1; Y += dirY)
                {
                    // XXX should use Wu's algorithm,
                    // XXX although I doubt this is the bottleneck
                    double x = x0 + (Y-y0) * slope;
                    int X = (int)Math.floor(x);
                    double frac = x-X;
                    int alpha = (int)(frac * 256.);
                    setColor(transparentColorCache[255-alpha]);
                    g.fillRect(X, Y, 1, 1);
                    setColor(transparentColorCache[alpha]);
                    g.fillRect(X+1, Y, 1, 1);
                }
            }
            else
            {
                int X0 = (int)Math.round(x0);
                int X1 = (int)Math.round(x1);
                int dirX = (X0 <= X1 ? 1 : -1);
                double slope = (y1-y0)/(x1-x0);
                for (int X = X0; X != X1; X += dirX)
                {
                    // XXX should use Wu's algorithm,
                    // XXX although I doubt this is the bottleneck
                    double y = y0 + (X-x0) * slope;
                    int Y = (int)Math.floor(y);
                    double frac = y-Y;
                    int alpha = (int)(frac * 256.);
                    setColor(transparentColorCache[255-alpha]);
                    g.fillRect(X, Y, 1, 1);
                    setColor(transparentColorCache[alpha]);
                    g.fillRect(X, Y+1, 1, 1);
                }
            }

            setColor(savedColor);
        }
        else
        {
            // window coordinates are all >= 0, so it should be okay
            // to truncate rather than round.
            // "the pen hangs down and to the right of the coordinate",
            // so adjust the coordinate by half a pixel up and to the left...

            // XXX except currently the curved arcs don't do this properly,
            // XXX so we end up not matching. need to fix both!
            if (false)
            g.drawLine((int)(x0 * scaleX + translateX - .5),
                       (int)(y0 * scaleY + translateY - .5),
                       (int)(x1 * scaleX + translateX - .5),
                       (int)(y1 * scaleY + translateY - .5));
            else
            g.drawLine((int)(x0 * scaleX + translateX),
                       (int)(y0 * scaleY + translateY),
                       (int)(x1 * scaleX + translateX),
                       (int)(y1 * scaleY + translateY));
        }
    } // drawLineNonClipped

    public void drawLineClipped(double x0, double y0, double x1, double y1,
                                boolean antiAlias,
                                double clipX0, double clipX1, double clipY0, double clipY1,
                                double slack)
    {
        {
            double temp;
            // make the line left to right
            if (x0 > x1)
            {
                SWAP(x0, x1, temp);
                SWAP(y0, y1, temp);
            }
            else if (x0 == x1 && y0 == y1)
                return;
            if (clipX0 > clipX1)
                SWAP(clipX0, clipX1, temp);
            if (clipY0 > clipY1)
                SWAP(clipY0, clipY1, temp);
        }

        if (false) // this works, but can be optimized better
        {
            double t0, t1;
            if (y0 <= y1)
            {
                // Positive slope
                //if (true) {drawLineNonClipped(x0, y0, x1, y1, antiAlias); return;}
                //if (true) return;

                //t0 = MAX((clipX0-x0)/(x1-x0), (clipY0-y0)/(y1-y0));
                // t0 = (clipX0-x0)/(x1-x0) >= (clipY0-y0)/(y1-y0) ? (clipX0-x0)/(x1-x0) : (clipY0-y0)/(y1-y0);
                t0 = (clipX0-x0)*(y1-y0) >= (clipY0-y0)*(x1-x0) ? (clipX0-x0)/(x1-x0) : (clipY0-y0)/(y1-y0);

                //t1 = MIN((clipX1-x0)/(x1-x0), (clipY1-y0)/(y1-y0));
                t1 = (clipX1-x0)*(y1-y0) <= (clipY1-y0)*(x1-x0) ? (clipX1-x0)/(x1-x0) : (clipY1-y0)/(y1-y0);
            }
            else
            {
                // Negative slope
                //if (true) {drawLineNonClipped(x0, y0, x1, y1, antiAlias); return;}
                //if (true) return;

                //t0 = MAX((clipX0-x0)/(x1-x0), (clipY1-y0)/(y1-y0));
                //t0 = MAX((clipX0-x0)/(x1-x0), (y0-clipY1)/(y0-y1));
                t0 = (clipX0-x0)*(y0-y1) >= (y0-clipY1)*(x1-x0) ? (clipX0-x0)/(x1-x0) : (y0-clipY1)/(y0-y1);

                //t1 = MIN((clipX1-x0)/(x1-x0), (clipY0-y0)/(y1-y0));
                //t1 = MIN((clipX1-x0)/(x1-x0), (y0-clipY0)/(y0-y1));
                t1 = (clipX1-x0)*(y0-y1) <= (y0-clipY0)*(x1-x0) ? (clipX1-x0)/(x1-x0) : (y0-clipY0)/(y0-y1);
            }
            t0 = MAX(t0, 0);
            t1 = MIN(t1, 1);
            if (t1 > t0)
                drawLineNonClipped(LERP(x0, x1, t0),
                                   LERP(y0, y1, t0),
                                   LERP(x0, x1, t1),
                                   LERP(y0, y1, t1),
                                   antiAlias);
        }
        else
        {
            // super optimized
            // XXX in progress
            double clippedx0, clippedy0, clippedx1, clippedy1;
            if (y1 >= y0)
            {
                // Non-negative slope
                if (x1 <= clipX0
                 || x0 >= clipX1
                 || y1 <= clipY0
                 || y0 >= clipY1)
                    return;
                if (x0 < clipX0 - slack)
                {
                    if (y0 < clipY0 - slack)
                    {
                        if ((clipX0-x0)*(y1-y0) >= (clipY0-y0)*(x1-x0))
                        {
                            // Clip to clipX0
                            clippedy0 = LERP(y0, y1, (clipX0-x0)/(x1-x0));
                            clippedx0 = clipX0;
                        }
                        else
                        {
                            // Clip to clipY0
                            clippedx0 = LERP(x0, x1, (clipY0-y0)/(y1-y0));
                            clippedy0 = clipY0;
                        }
                    }
                    else
                    {
                        // Clip to clipX0
                        clippedy0 = LERP(y0, y1, (clipX0-x0)/(x1-x0));
                        clippedx0 = clipX0;
                    }
                }
                else if (y0 < clipY0 - slack)
                {
                    // Clip to clipY0
                    clippedx0 = LERP(x0, x1, (clipY0-y0)/(y1-y0));
                    clippedy0 = clipY0;
                }
                else
                {
                    clippedx0 = x0;
                    clippedy0 = y0;
                }
                if (x1 > clipX1 + slack)
                {
                    if (y1 > clipY1 + slack)
                    {
                        if ((clipX1-x0)*(y1-y0) <= (clipY1-y0)/(x1-x0))
                        {
                            // Clip to clipX1
                            clippedy1 = LERP(y0, y1, (clipX1-x0)/(x1-x0));
                            clippedx1 = clipX1;
                        }
                        else
                        {
                            // Clip to clipY1
                            clippedx1 = LERP(x0, x1, (clipY1-y0)/(y1-y0));
                            clippedy1 = clipY1;
                        }
                    }
                    else
                    {
                        // Clip to clipX1
                        clippedy1 = LERP(y0, y1, (clipX1-x0)/(x1-x0));
                        clippedx1 = clipX1;
                    }
                }
                else if (y1 > clipY1 + slack)
                {
                    // Clip to clipY1
                    clippedx1 = LERP(x0, x1, (clipY1-y0)/(y1-y0));
                    clippedy1 = clipY1;
                }
                else
                {
                    clippedx1 = x1;
                    clippedy1 = y1;
                }
                if (clippedx0 > clippedx1
                 && clippedy0 > clippedy1)
                    return;
            }
            else // y1 < y0
            {
                //if (true) return;

                // Negative slope
                if (x1 <= clipX0
                 || x0 >= clipX1
                 || y0 <= clipY0  // since y0 == max(y0,y1)
                 || y1 >= clipY1) // since y1 == min(y0,y1)
                    return;
                if (x0 < clipX0 - slack)
                {
                    if (y0 > clipY1 + slack)
                    {
                        if ((clipX0-x0)*(y0-y1) >= (y0-clipY1)*(x1-x0))
                        {
                            // Clip to clipX0
                            clippedy0 = LERP(y0, y1, (clipX0-x0)/(x1-x0));
                            clippedx0 = clipX0;
                        }
                        else
                        {
                            // Clip to clipY1
                            clippedx0 = LERP(x0, x1, (clipY1-y0)/(y1-y0));
                            clippedy0 = clipY1;
                        }
                    }
                    else
                    {
                        // Clip to clipX0
                        clippedy0 = LERP(y0, y1, (clipX0-x0)/(x1-x0));
                        clippedx0 = clipX0;
                    }
                }
                else if (y0 > clipY1 + slack)
                {
                    // Clip to clipY1
                    clippedx0 = LERP(x0, x1, (clipY1-y0)/(y1-y0));
                    clippedy0 = clipY1;
                }
                else
                {
                    clippedx0 = x0;
                    clippedy0 = y0;
                }
                if (x1 > clipX1 + slack)
                {
                    if (y1 < clipY0 - slack)
                    {
                        // if (clipX1-x0)/(x1-x0) <= (clipY0-y0)/(y1-y0) but y1-y0 < 0
                        if ((clipX1-x0)*(y0-y1) <= (y0-clipY0)*(x1-x0))
                        {
                            // Clip to clipX1
                            clippedy1 = LERP(y0, y1, (clipX1-x0)/(x1-x0));
                            clippedx1 = clipX1;
                        }
                        else
                        {
                            // hits this case when should hit other casse!

                            // Clip to clipY0
                            clippedx1 = LERP(x0, x1, (clipY0-y0)/(y1-y0));
                            clippedy1 = clipY0;
                        }
                    }
                    else
                    {
                        // Clip to clipX1
                        clippedy1 = LERP(y0, y1, (clipX1-x0)/(x1-x0));
                        clippedx1 = clipX1;
                    }
                }
                else if (y1 < clipY0 - slack)
                {
                    // Clip to clipY0
                    clippedx1 = LERP(x0, x1, (clipY0-y0)/(y1-y0));
                    clippedy1 = clipY0;
                }
                else
                {
                    clippedx1 = x1;
                    clippedy1 = y1;
                }
                if (false)
                {
                    clippedx0 = x0;
                    clippedx1 = x1;
                    clippedy0 = y0;
                    clippedy1 = y1;
                }
                if (clippedx0 > clippedx1
                 && clippedy0 < clippedy1)
                    return;
            }
            drawLineNonClipped(clippedx0, clippedy0, clippedx1, clippedy1,
                               antiAlias);
        }
    } // drawLineClipped

    public void drawLine(double x0, double y0, double x1, double y1,
                         boolean antiAlias)
    {
        // clip; it sucks without clipping
        double clipX0 = (0-translateX)/scaleX;
        double clipX1 = (gsize.width-translateX)/scaleX;
        double clipY0 = (0-translateY)/scaleY;
        double clipY1 = (gsize.height-translateY)/scaleY;

        if (debugClip)
        {
            // debug by setting clip to half what it was
            clipX0 *= .95;
            clipX1 *= .95;
            clipY0 *= .95;
            clipY1 *= .95;
        }

        drawLineClipped(x0, y0, x1, y1,
                        antiAlias,
                        clipX0, clipX1, clipY0, clipY1,
                        2./((Math.abs(scaleX)+Math.abs(scaleY))*.5));   // 2 pixels
    } // drawLine

    public void drawPoint(double x, double y, int nPixels)
    {
        int x0 = (int)Math.round(x * scaleX + translateX - .5*nPixels);
        int y0 = (int)Math.round(y * scaleY + translateY - .5*nPixels);
        if (verbose >= 3) System.out.println("in drawPoint("+x+","+y+","+nPixels+") -> "+x0+","+y0);
        // have to check, otherwise java fillRect does weird wraparound stuff
        // XXX should check in floating-point
        if (x0 < -nPixels
         || x0 > gsize.width+nPixels
         || y0 < -nPixels
         || y0 > gsize.height+nPixels)
            return;
        g.fillRect(x0, y0, nPixels, nPixels);
    }
    public void drawString(String s, double x, double y)
    {
        g.drawString(s, (int)(x * scaleX + translateX),
                        (int)(y * scaleY + translateY));
    }
    public void drawString(String s, double x, double y,
                                     double xJustify, // -1,0,1 -> L,C,R
                                     double yJustify, // -1,0,1 -> T,C,B
                                     java.awt.Color backgroundColor)
    {
        java.awt.FontMetrics fm = g.getFontMetrics();

        /*
        x:
            -1 -> 0
            0 -> -.5
            1 -> -1

        y:
            -1 -> 1
            0 -> .5
            1 -> 0
        */

        int xFinal = (int)(x * scaleX + translateX - fm.stringWidth(s)*(xJustify+1.)*.5);
        int yFinal = (int)(y * scaleY + translateY + fm.getAscent()*(1.-yJustify)*.5); // XXX centered height seems to come out a bit low-- maybe fiddle with leading?
        if (backgroundColor != null)
        {
            java.awt.Color savedColor = g.getColor();
            g.setColor(backgroundColor);
            g.fillRect(xFinal-1,yFinal-fm.getAscent(),          // the -1 is fudge
                       fm.stringWidth(s)+2, fm.getAscent()+fm.getDescent());    // the +2 is fudge
            g.setColor(savedColor);
        }
        g.drawString(s, xFinal, yFinal);
    }
    public void drawString(String s, double x, double y,
                                     double xJustify, // -1,0,1 -> L,C,R
                                     double yJustify) // -1,0,1 -> T,C,B
    {
        drawString(s, x, y, xJustify, yJustify, null);
    }
    public void drawStringCentered(String s, double x, double y)
    {
        drawString(s, x, y, 0, 0);
    }
    public void drawStringRightJustified(String s, double x, double y)
    {
        drawString(s, x, y, 1, 0);
    }
    // XXX should be more of these...
    public double getFontHeight()
    {
        java.awt.FontMetrics fm = g.getFontMetrics();
        return Math.abs(fm.getHeight() / scaleY);
    }

    //private static int recursionLevel = 0;


    // Draw the arc pixel by pixel (or antialiased segment by antialiased segment, if antiAlias),
    // without regard to whether the pixels are in any visible area.
    public void smartDrawArcNonClipped(
        double focusX, double focusY, // a point on the arc
        double focusAngleRadians,     // from center to focus
        double c,                     // curvature, i.e. 1/radius
        double start, double end,     // arc goes from focusAngle+start to focusAngle+end in arc length
        boolean antiAlias)
    {
        //System.out.println(spaces(4*recursionLevel++)+"            in smartDrawArcNonClipped(focusX="+focusX+",focusY="+focusY+",focusAngleDegrees="+focusAngleRadians*180/Math.PI+",c="+c+"=1/"+1./c+",start="+start+",end="+end+"");

        final boolean useSegments = antiAlias; // implement antialiasing by drawing the circle as a sequence of antialiased segments with floating point coords
        if (useSegments)
        {
            int nSegs = MAX(10, (int)(ABS((end-start)*c) / (1*(Math.PI/180)))); // 1 degree-- delicate tradeoff, if we make it too fine, it looks all warbly because the endpoints are snapped to unit pixel coords XXX but this comment is no longer true since we are using our own antialiased line procedure
    //PRINT(nSegs);

            double cosFocusAngle = Math.cos(focusAngleRadians);
            double sinFocusAngle = Math.sin(focusAngleRadians);
            double normalAndTangent[][] = {
                { cosFocusAngle, sinFocusAngle}, // unit normal vector
                {-sinFocusAngle, cosFocusAngle}, // unit tangent vector
            };

            double prevPoint[] = new double[2];
            double point[] = new double[2];
            double scratch[] = new double[2];
            for (int i = 0; i < nSegs+1; ++i)
            {
                double t = LERP(start, end, (double)i/nSegs);
                findPointOnArc(t, focusX, focusY, c, normalAndTangent, scratch, point);

                if (i > 0)
                    this.drawLineNonClipped(prevPoint[0], prevPoint[1],
                                            point[0],     point[1],
                                            antiAlias);
                //VecMath.setvec(prevPoint, point);
                System.arraycopy(point, 0, prevPoint, 0, 2);
            }
            return;
        }


        // our end condition can handle only angles < 180 degrees,
        // so split in half if that is not the case
        // (a full circle will be recursively split again).
        if (c*Math.abs(start-end) > .75*Math.PI)
        {
            smartDrawArcNonClipped(focusX, focusY, focusAngleRadians, c,
                                   start, (start+end)*.5,
                                   antiAlias);
            smartDrawArcNonClipped(focusX, focusY, focusAngleRadians, c,
                                   (start+end)*.5, end,
                                   antiAlias);
            //System.out.println(spaces(4*--recursionLevel)+"            out smartDrawArcNonClipped");
            return;
        }


        //
        // Need to work in pixel space
        // so that we can be aware of the integer grid...
        //
        {
            focusX = focusX * scaleX + translateX;
            focusY = focusY * scaleY + translateY;
            if (scaleY < 0.)
            {
                focusAngleRadians *= -1.;
                start *= -1.;
                end *= -1.;
            }
            double scale = .5 * (Math.abs(scaleX) + Math.abs(scaleY)); // XXX not really right unless scaleX == scaleY, but that's usually the case
            c /= scale;
            start *= scale;
            end *= scale;
        }

        //
        // Reverse/swap parameters if necessary so that we are
        // going CCW around an arc of positive radius...
        // XXX figure out how much of this is necessary
        //
        {
            if (c < 0.)
            {
                c *= -1.;
                focusAngleRadians += Math.PI;
                start *= -1.;
                end *= -1.;
            }
            if (start > end)
            {
                double temp = start;
                start = end;
                end = temp;
            }
        }

        //System.out.println("in smartDrawArcNonClipped(focusX="+focusX+",focusY="+focusY+",focusAngleDegrees="+focusAngleRadians*180/Math.PI+",c="+c+"=1/"+1./c+",start="+start+",end="+end+"");

        double normalX = Math.cos(focusAngleRadians);
        double normalY = Math.sin(focusAngleRadians);
        double normalAndTangent[][] = {
            { normalX, normalY}, // unit normal vector
            {-normalY, normalX}, // unit tangent vector
        };


        //
        // Find start point...
        //
        double startX, startY;
        double endX, endY;
        {
            double point[] = new double[2];
            double scratch[] = new double[2];

            findPointOnArc(start, focusX, focusY, c, normalAndTangent, scratch, point);
            startX = point[0];
            startY = point[1];

            findPointOnArc(end, focusX, focusY, c, normalAndTangent, scratch, point);
            endX = point[0];
            endY = point[1];
        }

        // At most one point drawn for every pixel width of arc length
        int maxPointsToDraw = (int)Math.ceil(Math.abs(end-start)) + 1;

        int nPointsDrawn = 0;
        int x = (int)Math.round(startX), y = (int)Math.round(startY);
        double X = x - focusX; // XXX clean this up
        double Y = y - focusY; // XXX clean this up
        //System.out.println("point at "+x+","+y);
        this.g.fillRect(x, y, 1, 1);
        nPointsDrawn++;

        if (c < 1) // i.e. radius > 1
        {
            while (true)
            {
                final int quantizedDirVectors[][] = {
                    {1,0}, {1,1}, {0,1}, {-1,1}, {-1,0}, {-1,-1}, {0,-1}, {1,-1}
                };
                // What direction are we most likely to be going in?
                int dir; // index into quantizedDirVectors
                {
                    // Figure out current normal and tangent (dir),
                    // not necessarily normalized to unit length
                    double thisNormalX = c*X + normalX;
                    double thisNormalY = c*Y + normalY;
                    double thisTangentX = -thisNormalY;
                    double thisTangentY = thisNormalX;
                    int quantizedDirX = (thisTangentX < 0. ? -1 : thisTangentX > 0. ? 1 : 0);
                    int quantizedDirY = (thisTangentY < 0. ? -1 : thisTangentY > 0. ? 1 : 0);
                    double absThisTangentX = Math.abs(thisTangentX);
                    double absThisTangentY = Math.abs(thisTangentY);
                    if (absThisTangentX > 2*absThisTangentY)
                        quantizedDirY = 0;
                    else if (absThisTangentY > 2*absThisTangentX)
                        quantizedDirX = 0;
                    // XXX figure out more efficient way!
                    for (dir = 0; dir < 8; ++dir)
                    {
                        if (quantizedDirVectors[dir][0] == quantizedDirX
                         && quantizedDirVectors[dir][1] == quantizedDirY)
                            break; // found it
                    }
                    if (dir == 8)
                    {
                        System.out.println("huh?????"); // XXX
                        break; // happens only when radius is very small
                    }
                }

                x += quantizedDirVectors[dir][0];
                y += quantizedDirVectors[dir][1];
                X = x - focusX;
                Y = y - focusY;

                // the following was worked out on paper...
                // XXX should show derivation for posterity
                double signedDistanceOutsideCircle =
                    (c * (X*X + Y*Y) + 2 * (X*normalX + Y*normalY))
                  / (MyMath.hypot(c*X + normalX, c*Y + normalY) + 1.);

                //
                // Make it "manhattan distance" from circle,
                // by inflating distance when normal is in diagonal direction.
                //
                double inflation;
                {
                    double thisNormalX = c*X + normalX;
                    double thisNormalY = c*Y + normalY;
                    inflation = MyMath.hypot(thisNormalX, thisNormalY)
                              / Math.max(Math.abs(thisNormalX), Math.abs(thisNormalY));
                }
                //System.out.println("        signedDistanceOutsideCircle = "+signedDistanceOutsideCircle);
                signedDistanceOutsideCircle *= inflation;
                //System.out.println("        inflated signedDistanceOutsideCircle = "+signedDistanceOutsideCircle);

                if (signedDistanceOutsideCircle > .5001) // too far outside circle XXX use GT?
                {
                    x -= quantizedDirVectors[dir][0];
                    y -= quantizedDirVectors[dir][1];
                    // pull inward, i.e. turn direction of travel CCW
                    dir = (dir + 1) % 8;
                    x += quantizedDirVectors[dir][0];
                    y += quantizedDirVectors[dir][1];
                    X = x - focusX;
                    Y = y - focusY;
                }
                else if (signedDistanceOutsideCircle < -.5001) // too far inside circle XXX use LT?
                {
                    x -= quantizedDirVectors[dir][0];
                    y -= quantizedDirVectors[dir][1];
                    // pull outward, i.e. turn direction of travel CW
                    dir = (dir - 1 + 8) % 8;
                    x += quantizedDirVectors[dir][0];
                    y += quantizedDirVectors[dir][1];
                    X = x - focusX;
                    Y = y - focusY;
                }

                //System.out.println("maybe point at "+x+","+y);

                // XXX if radius <= 2 or so,
                // XXX may need to do the above multiple times!
                // XXX Ignoring this issue for now, so tiny arcs
                // XXX might draw some garbage (tiny garbage though)

                //
                // Determine whether we've past the end...
                // XXX this test is wrong for arcs > 180 degrees,
                // XXX and also when end < start!
                // XXX That is why we subdivided any arc > .75 * 180 degrees
                // XXX above, and we reversed start and end
                // XXX so that end <= start.
                //
                {
                    double thisNormalX = c*X + normalX;
                    double thisNormalY = c*Y + normalY;
                    signedDistanceOutsideCircle =
                        (c * (X*X + Y*Y) + 2 * (X*normalX + Y*normalY))
                      / (MyMath.hypot(c*X + normalX, c*Y + normalY) + 1.);
                    double arcPointX = focusX + X - signedDistanceOutsideCircle * thisNormalX;
                    double arcPointY = focusY + Y - signedDistanceOutsideCircle * thisNormalY;
                    double startToArcPoint = MyMath.hypot(arcPointX-startX,
                                                          arcPointY-startY);
                    double arcDistance = startToArcPoint * MyMath.asin_over_x(c*startToArcPoint*.5);
                    if (false)
                    {
                        System.out.println("    nPointsDrawn = "+nPointsDrawn);
                        System.out.println("        signedDistanceOutsideCircle = "+signedDistanceOutsideCircle);
                        System.out.println("        startX = "+startX);
                        System.out.println("        startY = "+startY);
                        System.out.println("        arcPointX = "+arcPointX);
                        System.out.println("        arcPointY = "+arcPointY);
                        System.out.println("        startToArcPoint = "+startToArcPoint);
                        System.out.println("        arcDistance = "+arcDistance);
                        System.out.println("        start = "+start);
                        System.out.println("        end = "+end);
                        System.out.println("        c = "+c);
                    }
                    if (arcDistance >= end-start) // XXX use GEQ I think
                        break;
                }

                this.g.fillRect(x, y, 1, 1);
                nPointsDrawn++;

                // XXX For some small circles, the above will never be satisfied
                // XXX so put a limit on number of points to draw.
                // XXX Shouldn't need this if we get the above condition right
                if (nPointsDrawn >= maxPointsToDraw-1)
                    break;
            }
            this.g.fillRect((int)Math.round(endX), (int)Math.round(endY), 1, 1);
            nPointsDrawn++;
        }
        //System.out.println(spaces(4*--recursionLevel)+"            out smartDrawArcNonClipped");
    } // smartDrawArcNonClipped

    public void smartDrawArcClipped(
        double focusX, double focusY, // a point on the arc
        double focusAngleRadians,     // from center to focus
        double c,                     // curvature, i.e. 1/radius
        double start, double end,     // arc goes from focusAngle+start to focusAngle+end in arc length
        boolean antiAlias,
        double clipX0, double clipX1, double clipY0, double clipY1,
        double slack)
    {
        if (verbose >= 2) System.out.println("            in smartDrawArcClipped");
        if (verbose >= 2) System.out.println("              focusX="+focusX);
        if (verbose >= 2) System.out.println("              focusY="+focusY);
        if (verbose >= 2) System.out.println("              focusAngleRadians="+focusAngleRadians+" focusAngleDegrees="+RTOD(focusAngleRadians));
        if (verbose >= 2) System.out.println("              c="+c);
        if (verbose >= 2) System.out.println("              start="+start);
        if (verbose >= 2) System.out.println("              end="+end);
        if (verbose >= 2) System.out.println("              antiAlias="+antiAlias);
        if (verbose >= 2) System.out.println("              clipX0="+clipX0);
        if (verbose >= 2) System.out.println("              clipX1="+clipX1);
        if (verbose >= 2) System.out.println("              clipY0="+clipY0);
        if (verbose >= 2) System.out.println("              clipY1="+clipY1);
        if (verbose >= 2) System.out.println("              slack="+slack);
        CHECK(Double.isFinite(focusX));
        CHECK(Double.isFinite(focusY));
        CHECK(Double.isFinite(focusAngleRadians));
        CHECK(Double.isFinite(focusAngleRadians));
        CHECK(Double.isFinite(c)); // CBB: handle infinity? that means the circle is a point
        CHECK(Double.isFinite(start));
        CHECK(Double.isFinite(end));
        CHECK(Double.isFinite(clipX0));
        CHECK(Double.isFinite(clipX1));
        CHECK(Double.isFinite(clipY0));
        CHECK(Double.isFinite(clipY1));
        CHECK(Double.isFinite(slack));

        // If curvature is negative, transform into a differerent scenario where it's positive.
        // Note that this may switch the relative order of start and end, so put this *before* the start/end correction swap.
        if (c < 0) {
            c *= -1.;
            focusAngleRadians += (focusAngleRadians > 0. ? -Math.PI : Math.PI);
            start *= -1.;
            end *= -1.;
        }

        // Swap if necessary so start <= end; that's easier than keeping track.
        if (start > end) {
            double temp;
            SWAP(start, end, temp);
            if (verbose >= 2) System.out.println("              SWAPPING start and end");
            if (verbose >= 2) System.out.println("                  start="+start);
            if (verbose >= 2) System.out.println("                  end="+end);
        }

        double clipMinX = Math.min(clipX0, clipX1);
        double clipMaxX = Math.max(clipX0, clipX1);
        double clipMinY = Math.min(clipY0, clipY1);
        double clipMaxY = Math.max(clipY0, clipY1);

        if (verbose >= 2) System.out.println("              span degrees = "+RTOD(c * Math.abs(end-start)));
        if (c * (end-start) > 2*Math.PI)
        {
            start = 0.;
            end = 2*Math.PI / c;  // relatively safe because that test above couldn't have passed if c were zero
            if (verbose >= 2) System.out.println("              MORE THAN FULL CIRCLE!  adjusting to start="+start+" end="+end);
        }

        double normalX = Math.cos(focusAngleRadians);
        double normalY = Math.sin(focusAngleRadians);
        double normalAndTangent[][] = {
            { normalX, normalY}, // unit normal vector
            {-normalY, normalX}, // unit tangent vector
        };
        double point[] = new double[2];
        double scratch[] = new double[2];

        if (verbose >= 2) System.out.println("              clipMinX = "+clipMinX);
        if (verbose >= 2) System.out.println("              clipMaxX = "+clipMaxX);
        if (verbose >= 2) System.out.println("              clipMinY = "+clipMinY);
        if (verbose >= 2) System.out.println("              clipMaxY = "+clipMaxY);
        if (verbose >= 2) System.out.println("              slack = "+slack);

        // CBB: I think this works, but it's horribly verbose; need to make it more concise.

        // Don't know how to clip analytically, so clip using binary search,
        // to clip bounds give or take slack (typically 2 pixels).
        // First, divide into quadrants, so that we're working in only a single quadrant at a time,
        // for simplicity.

        double startAngleRadians = focusAngleRadians + start*c;
        double endAngleRadians = focusAngleRadians + end*c;
        // CBB: should coerce the following to int, somehow, I think
        long firstRelevantQuadrant = (long)(Math.floor(startAngleRadians / (Math.PI/2)));
        long lastRelevantQuadrant = (long)(Math.ceil(endAngleRadians / (Math.PI/2)) - 1.0);
        if (c == 0.) {
          CHECK_GE(firstRelevantQuadrant, lastRelevantQuadrant);  // this prevents the zero divide below
        }
        if (lastRelevantQuadrant == firstRelevantQuadrant-1) {
          // so horizontal and vertical lines don't disappear...
          lastRelevantQuadrant = firstRelevantQuadrant;
        }

        if (verbose >= 2) System.out.println("              firstRelevantQuadrant = "+firstRelevantQuadrant);
        if (verbose >= 2) System.out.println("              lastRelevantQuadrant = "+lastRelevantQuadrant);
        CHECK_LE_LE(firstRelevantQuadrant-1, lastRelevantQuadrant, firstRelevantQuadrant+4);
        double startPoint[] = new double[2];  // scratch for loop
        double endPoint[] = new double[2];  // scratch for loop
        double midPoint[] = new double[2];  // scratch for loop
        for (long quadrant = firstRelevantQuadrant; quadrant <= lastRelevantQuadrant; quadrant++) {
          if (verbose >= 2) System.out.println("                  quadrant = "+quadrant);
          double partStart = quadrant==firstRelevantQuadrant ? start : ((Math.PI/2)*quadrant - focusAngleRadians) / c;  // we never divide by c=0, because in that case there's at most 1 relevant quadrant
          double partEnd = quadrant==lastRelevantQuadrant ? end : ((Math.PI/2)*(quadrant+1.) - focusAngleRadians) / c;  // we never divide by c=0, because in that case there's at most 1 relevant quadrant
          if (verbose >= 2) System.out.println("                      partStartAngleDegrees = "+RTOD(focusAngleRadians + partStart*c));
          if (verbose >= 2) System.out.println("                      partEndAngleDegrees = "+RTOD(focusAngleRadians + partEnd*c));
          CHECK(Double.isFinite(partStart));
          CHECK(Double.isFinite(partEnd));

          // CBB: if we would refrain from altering endPoint from previous iteration, we could reuse it
          boolean oopsWeProbablyClobberedEndPoint = true;
          if (oopsWeProbablyClobberedEndPoint || quadrant == firstRelevantQuadrant) {
            findPointOnArc(partStart, focusX, focusY, c, normalAndTangent, scratch, startPoint);
          } else {
            VecMath.copyvec(startPoint, endPoint);  // reuse result from previous iteration
          }
          findPointOnArc(partEnd, focusX, focusY, c, normalAndTangent, scratch, endPoint);
          if (verbose >= 2) System.out.println("                      startPoint = "+VecMath.toString(startPoint));
          if (verbose >= 2) System.out.println("                      endPoint = "+VecMath.toString(endPoint));


          if (true) {
              // Clip part against the four clip lines.
              if (MAX(startPoint[0], endPoint[0]) <= clipMinX+slack
               || MIN(startPoint[0], endPoint[0]) >= clipMaxX-slack
               || MAX(startPoint[1], endPoint[1]) <= clipMinY+slack
               || MIN(startPoint[1], endPoint[1]) >= clipMaxY-slack) {
                  if (verbose >= 2) System.out.println("                      clipped away easily");
                  continue;
              }

              int dxSign = endPoint[0] < startPoint[0] ? -1 : 1;
              int dySign = endPoint[1] < startPoint[1] ? -1 : 1;
              if (verbose >= 2) System.out.println("                      dxSign = "+dxSign);
              if (verbose >= 2) System.out.println("                      dySign = "+dySign);

              int tooManyIters = 100;  // the sample program gets max iters 5

              // Clamp start...
              if ((dxSign < 0 ? startPoint[0] > clipMaxX+slack : startPoint[0] < clipMinX-slack)
               || (dySign < 0 ? startPoint[1] > clipMaxY+slack : startPoint[1] < clipMinY-slack)) {
                  double lo = partStart;
                  double hi = partEnd;
                  int nItersDone = 0;
                  while (true) {
                      double mid = (lo+hi)*.5;
                      findPointOnArc(mid, focusX, focusY, c, normalAndTangent, scratch, midPoint);
                      if ((dxSign < 0 ? midPoint[0] < clipMaxX-slack : midPoint[0] > clipMinX+slack)
                       && (dySign < 0 ? midPoint[1] < clipMaxY-slack : midPoint[1] > clipMinY+slack)) {
                          // mid is too far inside
                          hi = mid;
                      } else if ((dxSign < 0 ? midPoint[0] > clipMaxX+slack : midPoint[0] < clipMinX-slack)
                              || (dySign < 0 ? midPoint[1] > clipMaxY+slack : midPoint[1] < clipMinY-slack)) {
                          // mid is too far outside
                          lo = mid;
                      } else {
                        partStart = mid;
                        VecMath.copyvec(startPoint, midPoint);
                        break;
                      }
                      nItersDone++;
                      if (nItersDone == tooManyIters) {
                        OUT("=========");
                        System.out.println("ARGH! clamping partStart reached tooManyIters="+tooManyIters);
                        CHECK(false);
                        break;
                      }
                  }
                  maxItersEver = MAX(maxItersEver, nItersDone);
                  // Clipping to the right may have left only stuff that's above top,
                  // or clipping to bottom may have left only stuff that's left of left, etc.
                  if ((dxSign<0 ? startPoint[0] <= clipMinX+slack : startPoint[0] >= clipMaxX-slack)
                   || (dySign<0 ? startPoint[1] <= clipMinY+slack : startPoint[1] >= clipMaxY-slack)) {
                    continue;
                  }
              }
              // Clamp end...
              if ((dxSign < 0 ? endPoint[0] < clipMinX-slack : endPoint[0] > clipMaxX+slack)
               || (dySign < 0 ? endPoint[1] < clipMinY-slack : endPoint[1] > clipMaxY+slack)) {
                  double lo = partStart;
                  double hi = partEnd;
                  int nItersDone = 0;
                  while (true) {
                      double mid = (lo+hi)*.5;
                      findPointOnArc(mid, focusX, focusY, c, normalAndTangent, scratch, midPoint);
                      if ((dxSign < 0 ? midPoint[0] > clipMinX+slack : midPoint[0] < clipMaxX-slack)
                       && (dySign < 0 ? midPoint[1] > clipMinY+slack : midPoint[1] < clipMaxY-slack)) {
                          // mid is too far inside
                          lo = mid;
                          if (verbose >= 2) System.out.println("                          lo = "+lo);
                      } else if ((dxSign < 0 ? midPoint[0] < clipMinX-slack : midPoint[0] > clipMaxX+slack)
                              || (dySign < 0 ? midPoint[1] < clipMinY-slack : midPoint[1] > clipMaxY+slack)) {
                          // mid is too far outside
                          hi = mid;
                          if (verbose >= 2) System.out.println("                          hi = "+hi);
                      } else {
                        partEnd = mid;
                        VecMath.copyvec(endPoint, midPoint);
                        break;
                      }
                      nItersDone++;
                      if (nItersDone == tooManyIters) {
                        OUT("=========");
                        System.out.println("ARGH! clamping partEnd reached tooManyIters="+tooManyIters);
                        CHECK(false);
                        break;
                      }
                  }
                  maxItersEver = MAX(maxItersEver, nItersDone);
                  // Clipping to left may have left only stuff that's below bottom,
                  // or clipping to top may have left only stuff that's right of right, etc.
                  if ((dxSign<0 ? endPoint[0] >= clipMaxX-slack : endPoint[0] <= clipMinX+slack)
                   || (dySign<0 ? endPoint[1] >= clipMaxY-slack : endPoint[1] <= clipMinY+slack)) {
                    continue;
                  }
              }
          }
          CHECK_LE(partStart, partEnd);
          if (verbose >= 2) System.out.println("              calling smartDrawArcNonClipped...");
          smartDrawArcNonClipped(focusX,focusY, focusAngleRadians, c, partStart,partEnd,
                                 antiAlias);
          if (verbose >= 2) System.out.println("              returned from smartDrawArcNonClipped.");
        }

        if (verbose >= 2) System.out.println("            out smartDrawArcClipped");
    } // smartDrawArcClipped

    public void smartDrawArc_(
        double focusX, double focusY, // a point on the arc
        double focusAngleRadians,     // from center to focus
        double c,                     // curvature, i.e. 1/radius
        double start, double end,     // arc goes from focusAngle+start to focusAngle+end in arc length
        boolean antiAlias)
    {
        if (verbose >= 2) System.out.println("        in smartDrawArc_");
        if (verbose >= 2) System.out.println("          focusX="+focusX);
        if (verbose >= 2) System.out.println("          focusY="+focusY);
        if (verbose >= 2) System.out.println("          focusAngleRadians="+focusAngleRadians);
        if (verbose >= 2) System.out.println("          c="+c);
        if (verbose >= 2) System.out.println("          start="+start);
        if (verbose >= 2) System.out.println("          end="+end);

        double clipX0 = (0-translateX)/scaleX;
        double clipX1 = (gsize.width-translateX)/scaleX;
        double clipY0 = (0-translateY)/scaleY;
        double clipY1 = (gsize.height-translateY)/scaleY;

        if (debugClip)
        {
            // debug by setting clip to half what it was
            clipX0 *= .95;
            clipX1 *= .95;
            clipY0 *= .95;
            clipY1 *= .95;
        }

        if (verbose >= 2) System.out.println("          calling smartDrawArcClipped...");
        smartDrawArcClipped(focusX, focusY, focusAngleRadians, c, start, end,
                            antiAlias,
                            clipX0, clipX1, clipY0, clipY1,
                            2./((Math.abs(scaleX)+Math.abs(scaleY))*.5));   // 2 pixels
        if (verbose >= 2) System.out.println("          returned from smartDrawArcClipped...");
        if (verbose >= 2) System.out.println("        out smartDrawArc_");
    } // smartDrawArc_

    //
    // Thickness is in pixels.  This will probably do something not-right
    // if scaleX != scaleY.
    //
    public void smartDrawThickArc(
        double thicknessInPixels,
        double focusX, double focusY, // a point on the arc
        double focusAngleRadians,     // from center to focus
        double c,                     // curvature, i.e. 1/radius
        double start, double end,     // arc goes from focusAngle+start to focusAngle+end in arc length
        boolean antiAlias) // should be false-- don't know what weird behavior will happen if it's true
    {
        if (verbose >= 2) System.out.println("    in smartDrawThickArc");
        double n = (int)Math.ceil(2.*thicknessInPixels-1.);
        if (n <= 1)
        {
            smartDrawArc_(focusX, focusY, focusAngleRadians, c, start, end, antiAlias);
            if (verbose >= 2) System.out.println("    out smartDrawThickArc (thickness<=1)");
            return;
        }

        double scale = .5 * (Math.abs(scaleX) + Math.abs(scaleY)); // XXX not really right unless scaleX == scaleY, but that's usually the case
        double onePixel = 1./scale;
        double dx = Math.cos(focusAngleRadians);
        double dy = Math.sin(focusAngleRadians);

        FORI (i, n)
        {
            double s = LERP(-(thicknessInPixels-1)/2, (thicknessInPixels-1)/2,
                            i/(n-1.)) * onePixel;
            double foo = 1. + c*s;
            if (foo <= 0.) // XXX should use some threshold?
                continue;
            smartDrawArc_(
                    focusX + s * dx,
                    focusY + s * dy,
                    focusAngleRadians,
                    c / foo,
                    start * foo,
                    end * foo,
                    antiAlias);
        }
        if (verbose >= 2) System.out.println("    out smartDrawThickArc");
    } // smartDrawThickArc




    // Arc drawing on Linux/Netscape is so broken it's unbelievable...
    // so, even though the simple finitistic API is inherently bad for
    // circles of unlimited radius,
    // this is still much much better than Netscape's.
    public void drawThickArc(double x, double y, double width, double height,
                        double startRadians, double arcRadians,
                        double thicknessInPixels,
                        boolean antiAlias) // hmm, according to smartDrawThickArc doc, this should always be false?
    {
        if (verbose >= 2) System.out.println("in drawThickArc");
        double centerX = x + width*.5;
        double centerY = y + height*.5;
        double radius = .25*(width+height); // XXX ignoring aspect for now
        double curvature = 1./radius;
        double focusAngleRadians = startRadians;
        double start = 0.;
        double end = arcRadians * radius;
        double focusX = centerX + radius * Math.cos(focusAngleRadians);
        double focusY = centerY + radius * Math.sin(focusAngleRadians);
        smartDrawThickArc(
                     thicknessInPixels,
                     focusX, focusY,
                     focusAngleRadians,
                     curvature,
                     start, end,
                     antiAlias);
        if (verbose >= 2) System.out.println("out drawThickArc");
        return;
    } // drawThickArc

    public java.awt.Color getColor()
    {
        return g.getColor();
    }
    public void setColor(java.awt.Color color)
    {
        g.setColor(color);
    }

    private java.awt.Graphics g;
    private java.awt.Dimension gsize;
    private double scaleX = 1;
    private double scaleY = 1;
    private double translateX = 0;
    private double translateY = 0;
    public boolean debugClip = false;
    public int verbose = 0; // caller can set this before making calls, to debug

    public double getScaleX() { return scaleX; }
    public double getScaleY() { return scaleY; }
    public double getTranslateX() { return translateX; }
    public double getTranslateY() { return translateY; }


        //
        // Return an array of the given Color
        // with each of 256 transparencies.
        // The array is cached from one call to the next,
        // so consecutive calls using the same color
        // will not suffer alllocation overhead.
        //
            private java.awt.Color[/*256*/] cache = null;
            private java.awt.Color cacheColor = null;
            private int cacheRGB;
        private java.awt.Color[/*256*/] getTransparentColorCache(java.awt.Color color)
        {
            if (color != cacheColor)
            {
                cacheColor = color;

                int colorRGB = color.getRGB();

                if (cache == null || colorRGB != cacheRGB)
                {
                    cacheRGB = colorRGB;
                    if (cache == null)
                        cache = new java.awt.Color[256];
                    int r = (colorRGB >> 16) & 0xff;
                    int g = (colorRGB >> 8) & 0xff;
                    int b = (colorRGB >> 0) & 0xff;
                    for (int i = 0; i < 256; ++i)
                    {
                        // XXX Note this will barf in 1.1; colors didn't have alpha
                        cache[i] = new java.awt.Color(r, g, b, i);
                        //System.out.println(""+i+": "+cache[i]+"");
                    }
                    //System.out.println("MISS");
                }
                else
                {
                    //System.out.println("    HIT (colors equal)");
                }
            }
            else
            {
                //System.out.println("    HIT (address equal)");
            }

            return cache;
        } // getTransparencyColorCache

    // Utility...
        private static void findPointOnArc(double t,
                                           double focusX, double focusY,
                                           double c,
                                           double normalAndTangent[][],
                                           double scratch[/*2*/],
                                           double result[/*2*/])
        {
            // coeff of normal vector: -(1-cos(t*c))/c
            //scratch[0] = -MyMath.cosf1_over_x(t*c) * t;
            scratch[0] = -MyMath.cosf1_over_xx(t*c) * (t*c) * t;
            // coeff of tangent vector: sin(t*c)/c
            scratch[1] = MyMath.sin_over_x(t*c) * t;
            VecMath.vxm(result, scratch, normalAndTangent);
            result[0] += focusX;
            result[1] += focusY;
        } // findPointOnArc

        /*
        private static String spaces(int n)
        {
            String s = "";
            for (int i = 0; i < n; ++i)
                s += " ";
            return s;
        } // spaces
        */

    //
    // Utilities to replace macros...
    //
        /*
        private static double LERP(double a, double b, double t)
        {
            return a + t * (b-a);
        }
        private static double MAX(double a, double b) // same as Math.max
        {
            return a >= b ? a : b;
        }
        private static int MAX(int a, int b) // same as Math.max
        {
            return a >= b ? a : b;
        }
        private static double MIN(double a, double b) // same as Math.min
        {
            return a <= b ? a : b;
        }
        private static int MIN(int a, int b) // same as Math.min
        {
            return a <= b ? a : b;
        }
        private static double ABS(double x) // same as Math.abs
        {
            return x >= 0. ? x : -x;
        }
        private static double MAX4(double a, double b, double c, double d)
        {
            return MAX(MAX(a,b),MAX(c,d));
        }
        */
    // Subclasses might want to do something here...
    public void flush()
    {
    }

    // Fun little test program.  Makes lots of different arcs with different curvatures and endpoints,
    // and lets you drag the clip bounds around.
    public static void main(String[] args)
    {
        if (false)
        {
          // Attempt to prevent the java window from stealing focus.
          // Doesn't work; gives a HeadlessException :-(
          System.setProperty("java.awt.headless", "true"); // Equivalent to -Djava.awt.headless=true
        }

        new javax.swing.JFrame() {{
          this.add(new javax.swing.JPanel() {

            private double clipX0 = -1.75;
            private double clipX1 = 1.75;
            private double clipY0 = -1.75;
            private double clipY1 = 1.75;

            // These were causing an assert fail, now fixed
            //private double clipX0 = -0.7466340931508219;
            //private double clipX1 = 1.253365906849178;
            //private double clipY0 = -1.1993769470404987;
            //private double clipY1 = 0.8006230529595016;

            // Then these were, now fixed too
            //private double clipX0 = -1.2699800646753538;
            //private double clipX1 = -0.968777702401811;
            //private double clipY0 = -1.1744548286604364;
            //private double clipY1 = 0.9169262720664589;

            private MyGraphics mostRecentMyGraphics = null;

            @Override protected void paintComponent(java.awt.Graphics g) {
              System.out.println("    in paintComponent");
              long t0millis = System.currentTimeMillis();

              if (true) {

                java.awt.Dimension size = getSize();
                double x0 = -2.;
                double x1 = 2.;
                double y0 = -2.;
                double y1 = 2.;

                MyGraphics mg;
                {
                  // CBB: think of a way to make this a clean function
                  double x0Fudged = x0;
                  double x1Fudged = x1;
                  double y0Fudged = y0;
                  double y1Fudged = y1;
                  if (size.width > size.height) {
                    // wide; adjust x0Fudged and x1Fudged
                    x0Fudged *= (double)size.width / (double)size.height;
                    x1Fudged *= (double)size.width / (double)size.height;
                  } else {
                    // tall; adjust y0Fudged and y1Fudged
                    y0Fudged *= (double)size.height / (double)size.width;
                    y1Fudged *= (double)size.height / (double)size.width;
                  }
                  mg = new MyGraphics(g,
                                      size,
                                      x0Fudged, x1Fudged, y0Fudged, y1Fudged);
                  mostRecentMyGraphics = mg;
                }

                mg.verbose = 0;
                //mg.verbose = 2;

                mg.setColor(java.awt.Color.WHITE);
                mg.fillWindow();

                mg.setColor(java.awt.Color.RED);
                mg.drawLineNonClipped(clipX0,clipY0, clipX1,clipY0, /*antiAlias=*/false);
                mg.drawLineNonClipped(clipX1,clipY0, clipX1,clipY1, /*antiAlias=*/false);
                mg.drawLineNonClipped(clipX1,clipY1, clipX0,clipY1, /*antiAlias=*/false);
                mg.drawLineNonClipped(clipX0,clipY1, clipX0,clipY0, /*antiAlias=*/false);

                // CBB: make a drawThickLine?  not sure
                // CBB: make a drawThickRectangle?  not sure
                double onePixelX = 1./Math.abs(mg.scaleX);
                double onePixelY = 1./Math.abs(mg.scaleY);
                for (int i = 1; i <= 1; ++i) {  // CBB: doesn't look good with more than one extra pixel width of thickness, since it's biased inward.  if it wasn't biased, it would probably look good.
                  if (draggingClipX0) mg.drawLineNonClipped(clipX0+i*onePixelX,clipY0, clipX0+i*onePixelX,clipY1, /*antiAlias=*/false);
                  if (draggingClipX1) mg.drawLineNonClipped(clipX1-i*onePixelX,clipY0, clipX1-i*onePixelX,clipY1, /*antiAlias=*/false);
                  if (draggingClipY0) mg.drawLineNonClipped(clipX0,clipY0+i*onePixelX, clipX1,clipY0+i*onePixelX, /*antiAlias=*/false);
                  if (draggingClipY1) mg.drawLineNonClipped(clipX0,clipY1-i*onePixelX, clipX1,clipY1-i*onePixelX, /*antiAlias=*/false);
                }
                for (int i = 1; i <= 1; ++i) {  // CBB: doesn't look good with more than one extra pixel width of thickness, since it's biased inward.  if it wasn't biased, it would probably look good.
                  if (hoveringClipX0) mg.drawLineNonClipped(clipX0+i*onePixelX,clipY0, clipX0+i*onePixelX,clipY1, /*antiAlias=*/false);
                  if (hoveringClipX1) mg.drawLineNonClipped(clipX1-i*onePixelX,clipY0, clipX1-i*onePixelX,clipY1, /*antiAlias=*/false);
                  if (hoveringClipY0) mg.drawLineNonClipped(clipX0,clipY0+i*onePixelX, clipX1,clipY0+i*onePixelX, /*antiAlias=*/false);
                  if (hoveringClipY1) mg.drawLineNonClipped(clipX0,clipY1-i*onePixelX, clipX1,clipY1-i*onePixelX, /*antiAlias=*/false);
                }

                mg.setColor(java.awt.Color.BLACK);

                int nRowsCols = 10;
                //int nRowsCols = 2;
                CHECK_GT(nRowsCols, 2);  // since we devide by nRowsCols-2
                double maxRadius = (x1-x0)/nRowsCols / 2;
                maxRadius *= .75;  // make it smaller still, since negative curvature stuff makes it extra busy
                int verboseLevel = 0;
                for (int iRow = 0; iRow < nRowsCols; ++iRow) {
                  for (int iCol = 0; iCol < nRowsCols; ++iCol) {
                    //if (!(iRow == 0 && iCol == 1)) continue;
                    //if (!(iRow == 0 && iCol == nRowsCols-1)) continue;
                    if (verboseLevel >= 1) System.out.println("          iRow="+iRow+" iCol="+iCol);
                    double centerX = LERP(x0, x1, (iCol+.5)/nRowsCols);
                    double centerY = LERP(y0, y1, (iRow+.5)/nRowsCols);
                    if (verboseLevel >= 2) System.out.println("              centerX="+centerX+" centerY="+centerY);
                    double startDeltaRadians = 1.*LERP(-Math.PI, Math.PI, iRow/(nRowsCols-2.));  // not really; will scale by circle radius
                    double endDeltaRadians = 1.*LERP(-Math.PI, Math.PI, iCol/(nRowsCols-2.));  // not really; will scale by circle radius
                    int nConcentric = 17;
                    //int nConcentric = 4;
                    for (int i = 0; i < nConcentric; ++i) {
                      double radius = (i+1.)/nConcentric * maxRadius;
                      double c = 1. / radius;  // TODO: exercise c=0
                      double slack = .01;  // somewhat arbitrary
                      double focusAngleRadians = LERP(-Math.PI, Math.PI, i / (nConcentric-1.));
                      if (verboseLevel >= 3) System.out.println("                  i="+i+": radius="+radius+" c="+c+" focusAngleDegrees="+RTOD(focusAngleRadians));
                      double focusX = centerX + radius * Math.cos(focusAngleRadians);
                      double focusY = centerY + radius * Math.sin(focusAngleRadians);
                      double[] curvatureScales = {1., .5, 0., -.5};
                      for (int iCurvatureScale = 0; iCurvatureScale < curvatureScales.length; ++iCurvatureScale) {
                        double curvatureScale = curvatureScales[iCurvatureScale];
                        mg.smartDrawArcClipped(focusX,
                                               focusY,
                                               focusAngleRadians,
                                               c * curvatureScale,
                                               startDeltaRadians*radius,
                                               endDeltaRadians*radius,
                                               /*antiAlias=*/false,
                                               /*clipX0=*/clipX0,
                                               /*clipX1=*/clipX1,
                                               /*clipY0=*/clipY0,
                                               /*clipY1=*/clipY1,
                                               /*slack=*/slack);
                      }
                    }
                  }
                }
              }
              System.out.println("      maxItersEver = "+maxItersEver);  // never seems to get more than 5
              long t1millis = System.currentTimeMillis();
              System.out.println("    out paintComponent in "+(t1millis-t0millis)/1000.+" secs.");
            }  // paintComponent

            private boolean draggingClipX0 = false;
            private boolean draggingClipX1 = false;
            private boolean draggingClipY0 = false;
            private boolean draggingClipY1 = false;
            private boolean hoveringClipX0 = false;
            private boolean hoveringClipX1 = false;
            private boolean hoveringClipY0 = false;
            private boolean hoveringClipY1 = false;
            private double prevX = 0.;
            private double prevY = 0.;
            final private double threshold = .025;  // CBB: measure in pixels?  not sure

            private double distanceToSegment(double x, double y, double x0, double y0, double x1, double y1) {
              double segLength2 = SQR(x1-x0)+SQR(y1-y0);
              if (segLength2 == 0.) {
                return Math.hypot(x-x0, y-y0);
              }
              double t = ((x-x0)*(x1-x0)+(y-y0)*(y1-y0)) / segLength2;
              if (t <= 0.) return Math.hypot(x-x0, y-y0);
              if (t >= 1.) return Math.hypot(x-x1, y-y1);
              double xProjected = LERP(x0, x1, t);
              double yProjected = LERP(y0, y1, t);
              return Math.hypot(x-xProjected, y-yProjected);
            }  // distanceToSegment


            {
              this.setFocusable(true);
              this.addKeyListener(new java.awt.event.KeyListener() {
                @Override public void keyPressed(java.awt.event.KeyEvent e) {
                  //System.out.println("in keyPressed(e="+e+")");
                  if (e.getKeyChar() == 'q') {
                    System.out.println("Bye!");
                    System.exit(0);
                  }
                  //System.out.println("out keyPressed(e="+e+")");
                }
                @Override public void keyReleased(java.awt.event.KeyEvent e) {
                }
                @Override public void keyTyped(java.awt.event.KeyEvent e) {
                }
              });
              this.addMouseListener(new java.awt.event.MouseListener() {
                @Override public void mouseEntered(java.awt.event.MouseEvent e) {
                   if (mostRecentMyGraphics != null) {
                     double[] xy = new double[2];
                     mostRecentMyGraphics.pick(e.getX()+.5, e.getY()+.5, xy);
                     System.out.println("  mouse entered at "+VecMath.toString(xy));
                     prevX = xy[0];
                     prevY = xy[1];
                   }
                }

                @Override public void mousePressed(java.awt.event.MouseEvent e) {
                   if (mostRecentMyGraphics != null) {
                     double[] xy = new double[2];
                     mostRecentMyGraphics.pick(e.getX()+.5, e.getY()+.5, xy);
                     System.out.println("          mouse pressed at "+VecMath.toString(xy));
                     hoveringClipX0 = false;
                     hoveringClipX1 = false;
                     hoveringClipY0 = false;
                     hoveringClipY1 = false;
                     // CBB: pick closest of X0,X1, and of Y0,Y1
                     draggingClipX0 = distanceToSegment(xy[0], xy[1], clipX0,clipY0, clipX0,clipY1) <= threshold;
                     draggingClipX1 = !draggingClipX0 && distanceToSegment(xy[0], xy[1], clipX1,clipY0, clipX1,clipY1) <= threshold;
                     draggingClipY0 = distanceToSegment(xy[0], xy[1], clipX0,clipY0, clipX1,clipY0) <= threshold;
                     draggingClipY1 = !draggingClipY0 && distanceToSegment(xy[0], xy[1], clipX0,clipY1, clipX1,clipY1) <= threshold;
                     if (!draggingClipX0 && !draggingClipX1 && !draggingClipY0 && !draggingClipY1
                      && (INRANGE(clipX0 <=, xy[0], <= clipX1) || INRANGE(clipX1 <=, xy[0], <= clipX0))
                      && (INRANGE(clipY0 <=, xy[1], <= clipY1) || INRANGE(clipY1 <=, xy[1], <= clipY0))) {
                        // In interior-- pan whole clip region
                       draggingClipX0 = true;
                       draggingClipX1 = true;
                       draggingClipY0 = true;
                       draggingClipY1 = true;
                     }

                     PRINT(draggingClipX0);
                     PRINT(draggingClipX1);
                     PRINT(draggingClipY0);
                     PRINT(draggingClipY1);

                     repaint();

                     prevX = xy[0];
                     prevY = xy[1];
                   }
                }
                @Override public void mouseReleased(java.awt.event.MouseEvent e) {
                   if (mostRecentMyGraphics != null) {
                     double[] xy = new double[2];
                     mostRecentMyGraphics.pick(e.getX()+.5, e.getY()+.5, xy);
                     System.out.println("          mouse released at "+VecMath.toString(xy));
                     hoveringClipX0 = draggingClipX0;
                     hoveringClipX1 = draggingClipX1;
                     hoveringClipY0 = draggingClipY0;
                     hoveringClipY1 = draggingClipY1;
                     draggingClipX0 = false;
                     draggingClipX1 = false;
                     draggingClipY0 = false;
                     draggingClipY1 = false;
                     repaint();
                     prevX = xy[0];
                     prevY = xy[1];
                   }
                }
                @Override public void mouseClicked(java.awt.event.MouseEvent e) {
                   if (mostRecentMyGraphics != null) {
                     double[] xy = new double[2];
                     mostRecentMyGraphics.pick(e.getX()+.5, e.getY()+.5, xy);
                     System.out.println("      mouse clicked at "+VecMath.toString(xy));
                     prevX = xy[0];
                     prevY = xy[1];
                   }
                }
                @Override public void mouseExited(java.awt.event.MouseEvent e) {
                   if (mostRecentMyGraphics != null) {
                     double[] xy = new double[2];
                     mostRecentMyGraphics.pick(e.getX()+.5, e.getY()+.5, xy);
                     System.out.println("  mouse exited at "+VecMath.toString(xy));
                     prevX = xy[0];
                     prevY = xy[1];
                   }
                }
              });
              this.addMouseMotionListener(new java.awt.event.MouseMotionListener() {
                @Override public void mouseMoved(java.awt.event.MouseEvent e) {
                   if (mostRecentMyGraphics != null) {
                     double[] xy = new double[2];
                     mostRecentMyGraphics.pick(e.getX()+.5, e.getY()+.5, xy);
                     System.out.println("      mouse moved to "+VecMath.toString(xy));

                     draggingClipX0 = false;
                     draggingClipX1 = false;
                     draggingClipY0 = false;
                     draggingClipY1 = false;

                     // CBB: pick closest of X0,X1, and of Y0,Y1
                     boolean newHoveringClipX0 = distanceToSegment(xy[0], xy[1], clipX0,clipY0, clipX0,clipY1) <= threshold;
                     boolean newHoveringClipX1 = !draggingClipX0 && distanceToSegment(xy[0], xy[1], clipX1,clipY0, clipX1,clipY1) <= threshold;
                     boolean newHoveringClipY0 = distanceToSegment(xy[0], xy[1], clipX0,clipY0, clipX1,clipY0) <= threshold;
                     boolean newHoveringClipY1 = !draggingClipY0 && distanceToSegment(xy[0], xy[1], clipX0,clipY1, clipX1,clipY1) <= threshold;
                     if (newHoveringClipX0 != hoveringClipX0
                      || newHoveringClipX1 != hoveringClipX1
                      || newHoveringClipY0 != hoveringClipY0
                      || newHoveringClipY1 != hoveringClipY1) {
                       hoveringClipX0 = newHoveringClipX0;
                       hoveringClipX1 = newHoveringClipX1;
                       hoveringClipY0 = newHoveringClipY0;
                       hoveringClipY1 = newHoveringClipY1;
                       repaint();
                     }

                     prevX = xy[0];
                     prevY = xy[1];
                   }
                }
                @Override public void mouseDragged(java.awt.event.MouseEvent e) {
                   if (mostRecentMyGraphics != null) {
                     double[] xy = new double[2];
                     mostRecentMyGraphics.pick(e.getX()+.5, e.getY()+.5, xy);
                     System.out.println("              mouse dragged to "+VecMath.toString(xy));
                     if (draggingClipX0) clipX0 += xy[0] - prevX;
                     if (draggingClipX1) clipX1 += xy[0] - prevX;
                     if (draggingClipY0) clipY0 += xy[1] - prevY;
                     if (draggingClipY1) clipY1 += xy[1] - prevY;
                     if (draggingClipX0 || draggingClipX1 || draggingClipY0 || draggingClipY1) {
                       repaint();
                     }
                     prevX = xy[0];
                     prevY = xy[1];
                  }
                }
              });
            }  // construction block of new JPanel
          });  // new JPanel
          //this.setSize(/*width=*/100, /*height=*/100);
          this.setSize(/*width=*/800, /*height=*/800);
          this.setVisible(true);
          this.setDefaultCloseOperation(EXIT_ON_CLOSE);
        }};  // new JFrame
    }  // main
} // class MyGraphics
