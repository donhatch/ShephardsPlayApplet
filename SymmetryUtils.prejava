#include "macros.h"

import com.donhatchsw.util.Arrays;
import com.donhatchsw.util.VecMath;

class SymmetryUtils {
        // =============== BEGIN: stolen from CSG.prejava

            // greatest common divisor
            private static int gcd(int a, int b)
            {
                return b==0 ? a : gcd(b, a%b);
            }

            // sin(pi*n/d) squared times sign, but do it without trig if it's a nice angle
            private static double sinSquaredPiTimes(int n, int d)
            {
                assert(d != 0);
                int sign = 1;
                if (n < 0)
                {
                    n *= -1;
                    sign *= -1;
                }
                if (d < 0)
                {
                    d *= -1;
                    sign *= -1;
                }
                int gcd = gcd(n,d);
                n /= gcd;
                d /= gcd;
                n %= 2*d;
                // so now 0 <= n/d < 2, i.e. in [0..360] degrees
                if (n > d)
                {
                    n = 2*d - n;
                    sign *= -1;
                }
                // so now 0 <= n/d <= 1, i.e. in [0..180] degrees
                if (2*n > d)
                {
                    n = d - n;
                }
                // so now 0 <= n/d <= 1/2, i.e. in [0..90] degrees
                if (4*n > d)
                    return sign*(1 - cosSquaredPiTimes(n, d));
                // so now 0 <= n/d <= 1/4, i.e. in [0..45] degrees
                assert_le(0, n);
                assert_le(4*n, d);
                //System.out.println("    "+n+"/"+d+"");
                if (true)
                {
                    // http://mathworld.wolfram.com/TrigonometryAngles.html
                    // TODO: lots more linked from there
                    // TODO: now there's a bunch more on http://en.wikipedia.org/wiki/Exact_trigonometric_constants
                    // http://mathworld.wolfram.com/TrigonometryAnglesPi5.html
                    //     2/5
                    // http://mathworld.wolfram.com/TrigonometryAnglesPi8.html
                    //     3/8
                    // http://mathworld.wolfram.com/TrigonometryAnglesPi10.html
                    //     3/10
                    // http://mathworld.wolfram.com/TrigonometryAnglesPi12.html
                    //     5/12
                    //     5/12
                    // http://mathworld.wolfram.com/TrigonometryAnglesPi15.html
                    //     1/15
                    //     2/15
                    //     4/15
                    //     7/15
                    // http://mathworld.wolfram.com/TrigonometryAnglesPi16.html
                    //     1/16
                    //     3/16
                    //     5/16
                    //     7/16
                    // http://mathworld.wolfram.com/TrigonometryAnglesPi17.html
                    //     1/17
                    //     2/17
                    //     4/17
                    //     8/17
                    //     (what about 3,5,6,7? hmm)
                    // http://mathworld.wolfram.com/TrigonometryAnglesPi20.html
                    //     1/20
                    //     3/20
                    //     7/20
                    //     9/20
                    // http://mathworld.wolfram.com/TrigonometryAnglesPi24.html
                    //     1/24
                    //     5/24
                    //     7/24
                    //     11/24
                    // http://mathworld.wolfram.com/TrigonometryAnglesPi30.html
                    //     1/30
                    //     7/30
                    //     11/30
                    //     13/30
                    // http://mathworld.wolfram.com/TrigonometryAnglesPi32.html
                    //     1/32
                    //     3/32
                    //     5/32
                    //     7/32
                    //     9/32
                    //     11/32
                    //     13/32
                    //     15/32
                    // hey, what about 1/60??
                    // even the mathematica calculator doesn't get it,
                    // but sin(pi/60) = sqrt((1-cos(pi/30))/2)
                    //                = sqrt((1-  sqrt(7+sqrt(5)+sqrt(6*(5+sqrt(5))))/4.  )/2.)
                    // hmm, maybe can do a lot of these recursively using the half-angle
                    // formula?
                    if (n==0)          // 0 degrees
                        return sign * 0;
                    if (n==1 && d==12) // 15 degrees
                        return sign * ((2.-Math.sqrt(3.))/4.);
                    if (n==1 && d==10) // 18 degrees
                        return sign * ((3.-Math.sqrt(5.))/8.);
                    if (n==1 && d==8) // 22.5 degrees
                        return sign * ((2.-Math.sqrt(2.))/4.);
                    if (n==1 && d==6)  // 30 degrees
                        return sign * (1./4.);
                    if (n==1 && d==5)  // 36 degrees
                        return sign * ((5.-Math.sqrt(5.))/8.);
                    if (n==1 && d==4)  // 45 degrees
                        return sign * (1./2.);
                }
                if (true)
                {
                    // half-assed attempt at patching up some of the holes...
                    // XXX none of this has been tested
                    // XXX shouldn't do this unless denominator is of form that can prevent a trig call at the end... not sure how to predict that easily
                    if (d % 2 == 0)
                    {
                        // use half-angle formula sin(a/2) = sqrt((1-cos(a))/2)
                        // this is recursively calling with a bigger angle pi*n/(d/2),
                        // but it's sign-safe since we know pi*n/d < 45 degrees
                        // which implies pi*n/(d/2) < 90 degrees.
                        return sign * ((1.-Math.sqrt(cosSquaredPiTimes(n, d/2))) / 2.);
                    }
                    else if (n % 2 == 0)
                    {
                        // use double-angle formula sin(2a) = 2 sin(a) cos(a)
                        double s = sinSquaredPiTimes(n/2, d);
                        return sign * (4 * s * (1-s));
                    }
                    else if (n % 3 == 0)
                    {
                        // use triple-angle formula sin(3a) = 3 sin a - 4 sin^3 a
                        double s = sinSquaredPiTimes(n/3, d);
                        return sign * (s * SQR(4*s-3));
                    }
                    else if (n > 3)
                    {
                        // use angle-sum identity: sin(a+b) = sin(a)cos(b) + cos(a)sin(b)
                        int a = (n+1)/2;
                        int b = (n-1)/2;
                        double s2a = sinSquaredPiTimes(a,d);
                        double s2b = sinSquaredPiTimes(b,d);
                        double s = Math.sqrt(s2a*(1-s2b)) + Math.sqrt((1-s2a)*s2b);
                        return sign * (s*s);
                    }
                }
                //System.out.println("    "+n+"/"+d+" !!!");
                double s = Math.sin(Math.PI*n/d);
                return sign*s*s;
            } // sinSquaredPiTimes

            // cos(pi*n/d) squared times sign, but do it without trig if it's a nice angle
            private static double cosSquaredPiTimes(int n, int d)
            {
                // cos(pi*n/d) = sin(pi/2 - pi*n/d)
                //             = sin(pi * (1/2 - n/d))
                //             = sin(pi * (d/(2*d) - 2*n/(2*d)))
                //             = sin(pi * (d-2*n)/(2*d))
                return sinSquaredPiTimes(d-2*n, 2*d);
            }

            // tan(pi*n/d) squared, but do it without trig if it's a nice angle
            private static double tanSquaredPiTimes(int n, int d)
            {
                double s = sinSquaredPiTimes(n, d);
                return s / (1 - s); // XXX pretty sure sign is wrong if anything negative
            }
            // cot(pi*n/d) squared, but do it without trig if it's a nice angle
            private static double cotSquaredPiTimes(int n, int d)
            {
                double s = sinSquaredPiTimes(n, d);
                return (1 - s) / s; // XXX pretty sure sign is wrong if anything negative
            }
        // =============== END: stolen from CSG.prejava

        private static double sinPiTimes(int n, int d)
        {
            double temp = sinSquaredPiTimes(n, d);
            return temp<0 ? -Math.sqrt(-temp)
                          :  Math.sqrt(temp);
        }
        private static double cosPiTimes(int n, int d)
        {
            double temp = cosSquaredPiTimes(n, d);
            return temp<0 ? -Math.sqrt(-temp)
                          :  Math.sqrt(temp);
        }
        private static double tanPiTimes(int n, int d)
        {
            double temp = tanSquaredPiTimes(n, d);
            return temp<0 ? -Math.sqrt(-temp)
                          :  Math.sqrt(temp);
        }
        private static double cotPiTimes(int n, int d)
        {
            double temp = cotSquaredPiTimes(n, d);
            return temp<0 ? -Math.sqrt(-temp)
                          :  Math.sqrt(temp);
        }


    // Note, it turns out this is only called with leftRightSymmetry=false, currently...
    // i.e. it always returns a quad, not a triangle.
    private static double[][] getFundamentalRegionVerts(int p, int q, boolean leftRightSymmetry)
    {
        assert(p >= 2);
        assert(q >= 2);
        assert((p-2)*(q-2) < 4);
        double answer[][];

        // Verts of schwarz triangle:
        //     V2 = +z axis, angle pi/p
        //     V0 = between +z and +y axis, angle pi/q
        //     V1 = somewhere in +x +y +z, angle pi/2
        // By https://en.wikipedia.org/wiki/Solution_of_triangles#Three_angles_given_.28spherical_AAA.29,
        // the corresponding spherical side lengths are:
        //     S01 = acos((cos(pi/p) + cos(pi/q)cos(pi/2)) / (sin(pi/q)sin(pi/2)))
        //         = acos((cos(pi/p) / sin(pi/q))
        //     S12 = acos((cos(pi/q) + cos(pi/2)cos(pi/p)) / (sin(pi/2)sin(pi/p)))
        //         = acos((cos(pi/q) / sin(pi/p))
        //         = (pi-dihedral{p,q})/2
        //     S20 = acos((cos(pi/2) + cos(pi/p)cos(pi/q)) / (sin(pi/p)sin(pi/q))
        //         = acos(cos(pi/p)cos(pi/q) / (sin(pi/p)sin(pi/q))
        //         = acos(cot(pi/p)cot(pi/q))
        double cosSqrdS12 = cosSquaredPiTimes(1,q) / sinSquaredPiTimes(1,p);
        double cosS12 = Math.sqrt(cosSqrdS12);
        double sinS12 = Math.sqrt(1.-cosSqrdS12);
        double cosSqrdS20 = cotSquaredPiTimes(1,p) * cotSquaredPiTimes(1,q);  // increases with p,q
        double cosS20 = Math.sqrt(cosSqrdS20);
        double sinS20 = Math.sqrt(1.-cosSqrdS20);

        double V2[] = {0,0,1};
        // V1 is: +z axis, rotated +z->+y by s12, rotated +y->+x by pi/p
        // = {0,cosS12,sinS12} rotated +y->+x by pi/p
        double V1[] = VecMath.vxm(new double[]{0,sinS12,cosS12},
                                  VecMath.makeRowRotMat(3, 1, 0, Math.PI/p));
        // V0 is: +z axis, rotated +z->+y by S20
        double V0[] = {0,sinS20,cosS20};


        if (leftRightSymmetry)
        {
            // fundamental region is a triangle
            return new double[][] {V2, V1, V0};
        }
        else
        {
            // fundamental region is a quad
            return new double[][] {V2, V1, V0, new double[]{-V1[0],V1[1],V1[2]}};
        }
    } // getFundamentalRegionVerts

    // 3d symmetry groups.
    // Rotation of order p around z axis,
    // and rotation of order q around some point between the +z and +y axis.
    // Note, we don't return a minimal set;
    // rather, we add in mathematically redundant generators
    // for all powers of p and q, since the math for generating them
    // is a bit more accurate than we'd get by products of the minimal set of generators.
    //
    // Instead of returning a flat list, we return a list of sub-lists;
    // each of the sub-lists are assumed to be powers of a single generator,
    // so there's no need to try more than one thing out of a given sub-list consecutively.
    //
    private static double[][][/*4*/][/*4*/] computeSymmetryGroupGenerators3d(int p, int q, boolean leftRightSymmetry, boolean sphereCentralSymmetry)
    {
        double genGroups[][][][] = new double[0][][][];

        // add reflection first, so it will get favored when generating,
        // since multiplying by it doesn't add any roundoff error.
        if (leftRightSymmetry)
            genGroups = (double[][][][])Arrays.append(genGroups, new double[][][]{{{-1,0,0,0},{0,1,0,0},{0,0,1,0},{0,0,0,1}}});

        if (sphereCentralSymmetry)
            genGroups = (double[][][][])Arrays.append(genGroups, new double[][][]{{{-1,0,0,0},{0,-1,0,0},{0,0,-1,0},{0,0,0,1}}});



        if (p > 1)
        {
            genGroups = (double[][][][])Arrays.append(genGroups, new double[p-1][][]);
            double subGens[][][] = genGroups[genGroups.length-1];

            for (int i = 1; i < p; ++i) // skip 0
            {
                double c = cosPiTimes(2*i,p); // cos(2*pi * i/p)
                double s = sinPiTimes(2*i,p); // sin(2*pi * i/p)
                double gen[][] = {
                    { c,s,0,0},
                    {-s,c,0,0},
                    { 0,0,1,0},
                    { 0,0,0,1},
                };
                subGens[i-1] = gen;
            }
        }
        if (q > 1)
        {
            genGroups = (double[][][][])Arrays.append(genGroups, new double[q-1][][]);
            double subGens[][][] = genGroups[genGroups.length-1];

            // The rotation of order p is centered on the z axis;
            // where do we want to center the rotation of order q?
            // Figure out the cosine and sine of the tilt,
            // that is, distance from vert to face center of spherical {p,q}.
            double cosSqrdTilt = MIN(p,q)==1 ? 1. : // angle = 0; just produce identity matrix so no effect   XXX think about this again
                                 cotSquaredPiTimes(1,p)*cotSquaredPiTimes(1,q);
            double cosTilt = Math.sqrt(cosSqrdTilt);
            double sinTilt = Math.sqrt(1.-cosSqrdTilt);
            // tilt from +z towards +y
            double tiltMat[][] = {
                {1,      0,       0,0},
                {0,cosTilt,-sinTilt,0},
                {0,sinTilt, cosTilt,0},
                {0,      0,       0,1},
            };
            for (int i = 1; i < q; ++i) // skip 0
            {
                double c = cosPiTimes(2*i,q); // cos(2*pi * i/q)
                double s = sinPiTimes(2*i,q); // sin(2*pi * i/q)
                double gen[][] = {
                    { c,s,0,0},
                    {-s,c,0,0},
                    { 0,0,1,0},
                    { 0,0,0,1},
                };
                gen = VecMath.mxmxm(VecMath.transpose(tiltMat), gen, tiltMat);
                subGens[i-1] = gen;
            }
        }

        return genGroups;
    } // computeSymmetryGroupGenerators3d

    // 3d symmetry groups that hold origin fixed.
    // rotation of order p around z axis,
    // and rotation of order q around some point between the +z and +y axis.
    private static double[][/*4*/][/*4*/] computeSymmetryGroup3d(int p, int q, boolean leftRightSymmetry, boolean sphereCentralSymmetry, boolean repeatSymmetryWorkInProgress)
    {
        double gens[][][][] = computeSymmetryGroupGenerators3d(p, q, leftRightSymmetry, sphereCentralSymmetry);

        if (false)
            System.out.println("gens = "+Arrays.toStringNonCompact(gens,
                                                                   "", // indentString
                                                                   "    "));  // indentIncr

        int nExpected = (MIN(p,q) == 1 ? MAX(p,q) :
                         MIN(p,q) == 2 ? 2*MAX(p,q) :
                         MIN(p,q)==3 && MAX(p,q)==3 ? 12 :
                         MIN(p,q)==3 && MAX(p,q)==4 ? 24 :
                         MIN(p,q)==3 && MAX(p,q)==5 ? 60 : -1);
        assert(nExpected != -1);
        if (leftRightSymmetry)
            nExpected *= 2;
        if (sphereCentralSymmetry)
            nExpected *= 2;
        // In some cases, leftRightSymmetry is redundant with sphereCentralSymmetry.
        // I don't know of any rhyme or reason to this, it just is.
        if (leftRightSymmetry && sphereCentralSymmetry)
            if ((MIN(p,q)==2 && MAX(p,q)%2==0) || MIN(p,q)==3&&MAX(p,q)>=4)
            {
                nExpected /= 2;
            }

        double group[][][] = new double[nExpected][4][4];
        int lastSubgroupIndex[] = new int[group.length];

        int n = 0;
        VecMath.identitymat(group[n]);
        lastSubgroupIndex[n] = -1; // so nothing will match it
        n++;

        double scratch[][] = new double[4][4];
        FORI (i, n) // while n is growing
        {
            FORI (iSubgroup, gens.length)
            {
                if (iSubgroup == lastSubgroupIndex[i])
                    continue; // no need to look at two in a row from the same subgroup
                double subgroupGens[][][] = gens[iSubgroup];
                FORI (iGen, subgroupGens.length)
                {
                    VecMath.mxm(scratch, subgroupGens[iGen], group[i]); // or other order? not sure it matters
                    int j;
                    FOR (j, n)
                        if (VecMath.equals(scratch, group[j], 1e-3))
                            break;
                    if (j == n) // if didn't find it
                    {
                        VecMath.copymat(group[n], scratch);
                        lastSubgroupIndex[n] = iSubgroup;
                        n++;
                    }
                }
            }
        }
        assert_eq(n, group.length);

        if (repeatSymmetryWorkInProgress)
        {
            // WORK IN PROGRESS
            // Experiment with planar repeat.
            int r = 2;
            double tileWidth = 1.;
            int multiplicity = SQR(2*r+1);
            double bigGroup[][][] = new double[group.length * multiplicity][4][4];
            int N = 0;
            int nReps = 10;
            for (int ix = -2; ix <= 2; ++ix)
            for (int iy = -2; iy <= 2; ++iy)
            {
                double translation[][] = {
                    {1,0,0,0},
                    {0,1,0,0},
                    {0,0,1,0},
                    {ix*tileWidth,iy*tileWidth,0,1},
                };
                FORI (iGroup, group.length)
                    VecMath.mxm(bigGroup[N++], group[iGroup], translation);
            }
            assert(N == bigGroup.length);
            group = bigGroup;
        }
        return group;
    } // computeSymmetryGroup3d

    private static double[][/*4*/][/*4*/] getSymmetryGroup(int p, int q, boolean leftRight, boolean sphereCentral,  boolean wrapAroundSphereFlag, double wrapSphereCurvature, boolean centerSphereFlag, boolean repeatSymmetryWorkInProgress)
    {
        double group[][][] = computeSymmetryGroup3d(p, q, leftRight, sphereCentral, repeatSymmetryWorkInProgress);

        if (!centerSphereFlag) // XXX TODO: wait a minute, this test can't be right when not wrapped, can it?
        {
            // un-center the symmetry group
            double wrapSphereRadius = 1./wrapSphereCurvature;
            double originToSphereCenter[][] = {
                {1,0,0,0},
                {0,1,0,0},
                {0,0,1,0},
                {0,0,-wrapSphereRadius,1},
            };
            double sphereCenterToOrigin[][] = {
                {1,0,0,0},
                {0,1,0,0},
                {0,0,1,0},
                {0,0,wrapSphereRadius,1},
            };
            FORI (iGroup, group.length)
            {
                group[iGroup] = VecMath.mxmxm(sphereCenterToOrigin,
                                              group[iGroup],
                                              originToSphereCenter);
            }
        }
        if (!wrapAroundSphereFlag)
        {
            // unwrap the symmetry group
            double wrapMat[][] = getWrapAroundSphereMatrix(wrapSphereCurvature, centerSphereFlag);
            double unwrapMat[][] = getUnwrapAroundSphereMatrix(wrapSphereCurvature, centerSphereFlag);
            FORI (iGroup, group.length)
                group[iGroup] = VecMath.mxmxm(wrapMat,
                                              group[iGroup],
                                              unwrapMat);
        }
        return group;
    } // getTheSymmetryGroup

    // Wait, what? shouldn't we multiply the whole thing by wrapSphereCurvature so it can be zero?
    // Hmm, maybe not, then center-and-uncenter wouldn't be identity.  Weird.
    // I don't think the xform is invertible in the curvature=0 case anyway,
    // so shouldn't be centering the sphere in that case.
    private static double[][] getCenterSphereMatrix(double wrapSphereCurvature)
    {
        return new double[][] {
            {1,0,0,0},
            {0,1,0,0},
            {0,0,1,0},
            {0,0,1./wrapSphereCurvature,1},
        };
    }
    private static double[][] getUncenterSphereMatrix(double wrapSphereCurvature)
    {
        return new double[][] {
            {1,0,0,0},
            {0,1,0,0},
            {0,0,1,0},
            {0,0,-1./wrapSphereCurvature,1},
        };
    }
    private static double[][] getWrapAroundSphereMatrix(double wrapSphereCurvature, boolean centerSphereFlag)
    {
        // inverse of getUnwrapAroundSphereMatrix, I don't claim to understand it directly
        double m[][] = {
            {1,0,0,0},
            {0,1,0,0},
            {0,0,wrapSphereCurvature,-.5*SQR(wrapSphereCurvature)},
            {0,0,0,1},
        };
        if (centerSphereFlag)
        {
            // end by moving center from -r to origin
            m = VecMath.mxm(m, getCenterSphereMatrix(wrapSphereCurvature));
        }
        return m;
    } // getWrapAroundSphereMatrix
    private static double[][] getUnwrapAroundSphereMatrix(double wrapSphereCurvature, boolean centerSphereFlag)
    {
        /*
        // divide by wrap sphere radius, to wrap around unit sphere
           1/r 0 0 0
           0 1/r 0 0
           0 0 1/r 0
           0 0  0  1
        // divide by 1+z/2, to send far point to infinity
            1  0  0  0
            0  1  0  0
            0  0  1  .5
            0  0  0  1
        // multiply by wrap sphere radius, to get original scale and curvature at origin
           r 0 0 0
           0 r 0 0
           0 0 r 0
           0 0 0 1
        i.e. 
            1  0  0  0
            0  1  0  0
            0  0  1  .5/r
            0  0  0  1
        // Then, since we want paraboloid to have curvature 1 instead of 1/r,
        // multiply by:
           1 0 0 0
           0 1 0 0
           0 0 r 0
           0 0 0 1
        // i.e. (if we cared, which we probably don't since we don't unwrap around infinite radius sphere, do we?)
           1/r 0  0  0
           0  1/r 0  0
           0   0  1  0
           0   0  0 1/r
        */

        double m[][] = {
            {1,0,0,0},
            {0,1,0,0},
            {0,0,1./wrapSphereCurvature,.5*wrapSphereCurvature},
            {0,0,0,1},
        };
        if (centerSphereFlag)
        {
            // start by moving center from origin to -r
            m = VecMath.mxm(getUncenterSphereMatrix(wrapSphereCurvature), m);
        }
        return m;
    } // getUnwrapAroundSphereMatrix


} // class SymmetryUtils
