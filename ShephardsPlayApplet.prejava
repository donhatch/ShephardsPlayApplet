/*
Trying to make a little applet
that will let me play with triangulations with heights,
and produce the dual diagrams with heights.

For starters, always triangulates entire convex hull.
User should be able to:
    left click - add a vertex
                   - if inside a triangle, trisects the triangle
                   - if outside the convex hull, connects up
                     to all visible other vertices
    right click - delete a vertex that's on the convex hull
                  or that's only connected to three neighbors
    middle drag - move a vertex
    's' - swap a diagonal

TO DO:
    - save/load
    - simple translation from simple lists and back... creating that sample scene was a nightmare!
    - fix optimization problem
    - figure out simpler math behind the mapping from vert heights to edge lengths
    - animation of optimization
    - animation of swap
    - animation of delete vertex (maybe-- might have to triangulate the face to get this to work, which wouldn't be a bad thing)
    - delaunayize?
    - help
    - don't draw crap when resizing (and fix whatever other applet I got this from too)
    - figure out why stack traces show .java on top even after renumbering
    - gui
    - write a generic applet to reduce pain each time
    - other mesh editing operations (split face by edge, split edge by vertex, join adjacent vertices, separate a vertex into two (but how to assign the neighbors?))
    - BUG: figure out how to make it not repaint continuously when resizing (my other appets too)
    - BUG: when only part of window gets exposed, only the exposed part gets painted?  hmm, not sure I have control over this
    - look at this, maybe clues about positive octant penalty functions...
        http://www.cs.indiana.edu/~yingfeng/ABSURDIST/javadoc/penalty/PenaltyMinimizer.html
      something about "translating into a positive orthant problem" and "optimizing over the positive orthant"
      intersection of a linear subspace witht the positive orthant
      http://projecteuclid.org/Dienst/UI/1.0/Summarize/euclid.mmj/1028988894
      The knee-jerk mapping:
      http://www.math.dartmouth.edu/~doyle/docs/jerk/jerk.pdf
*/

#include "macros.h"

// So can compile in pre-1.4,
// we use these instead of java.awt.event.MouseEvent.BUTTON1 etc.
#define java_awt_event_MouseEvent_BUTTON1 1
#define java_awt_event_MouseEvent_BUTTON2 2
#define java_awt_event_MouseEvent_BUTTON3 3


import com.donhatchsw.util.Arrays;
import com.donhatchsw.util.VecMath;
import com.donhatchsw.util.LinearProgramming;
import com.donhatchsw.util.UndoTreeSquirrel;
import com.donhatchsw.compat.ArrayList;

public class ShephardsPlayApplet
    extends java.applet.Applet
    implements java.awt.event.MouseListener,
               java.awt.event.MouseMotionListener,
               java.awt.event.KeyListener
{
    //
    // Utilities for applet stuff...
    //
        private String getParameterString(String paramName,
                                       String defaultValue)
        {
            String paramValueString = getParameter(paramName);
            if (paramValueString != null)
                return paramValueString;
            else
                return defaultValue;
        }
        private int getParameterInt(String paramName,
                                    int defaultValue)
        {
            String paramValueString = getParameter(paramName);
            if (paramValueString != null)
            {
                try
                {
                    return Integer.decode(paramValueString).intValue();
                }
                catch (NumberFormatException e)
                {
                    return 0;
                }
            }
            else
                return defaultValue;
        }
        private double getParameterDouble(String paramName,
                                          double defaultValue)
        {
            String paramValueString = getParameter(paramName);
            if (paramValueString != null)
            {
                try
                {
                    return Double.parseDouble(paramValueString);
                }
                catch (NumberFormatException e)
                {
                    return 0;
                }
            }
            else
                return defaultValue;
        }
        private boolean getParameterBoolean(String paramName,
                                            boolean defaultValue)
        {
            String paramValueString = getParameter(paramName);
            if (paramValueString != null)
            {
                // Too simplistic, only honors case-sensitive "true"
                //return Boolean.valueOf(paramValueString).booleanValue();

                try
                {
                    int n = Integer.decode(paramValueString).intValue();
                    return n != 0;
                }
                catch (NumberFormatException e)
                {
                    if (paramValueString.equalsIgnoreCase("true")
                     || paramValueString.equalsIgnoreCase("yes")
                     || paramValueString.equalsIgnoreCase("t")
                     || paramValueString.equalsIgnoreCase("y"))
                        return true;
                    return false;
                }
            }
            else
                return defaultValue;
        }

    //
    // Implementing Applet methods...
    //
        ShephardsPlayApplet()
        {
            setLayout(new java.awt.GridBagLayout());
        } // ShephardsPlayApplet ctor

        public void init()
        {
            eventVerbose = getParameterInt("EventVerbose", eventVerbose);
            if (eventVerbose >= 1) System.out.println("in init");

            // These (and eventVerbose) can be specified on the command line as, e.g. doLabels=true
            doLabels = getParameterBoolean("doLabels", doLabels);
            doOptimize = getParameterBoolean("doOptimize", doOptimize);
            doShowPositiveOrthantnessVisualization = getParameterBoolean("doShowPositiveOrthantnessVisualization", doShowPositiveOrthantnessVisualization);
            // XXX this is kind of messed up, we don't get to know whether the user misspelled something

            // Specify an "event listener" object
            // to respond to events.
            // (>= Java 1.1 event model).
            this.addMouseListener(this);
            this.addMouseMotionListener(this);
            this.addKeyListener(this);

            graphicsAntiAliasingSetter = new GraphicsAntiAliasingSetter();

            //doCannedThingHexesSpiral(); // XXX get rid of this probably
            doCannedThingNetless9(); // XXX get rid of this probably

            if (eventVerbose >= 1) System.out.println("out init");
        } // init

        public void start()
        {
            if (eventVerbose >= 1) System.out.println("in start");
            if (eventVerbose >= 1) System.out.println("out start");
        }
        public void stop()
        {
            if (eventVerbose >= 1) System.out.println("in stop");
            if (eventVerbose >= 1) System.out.println("out stop");
        }
        public void destroy()
        {
            if (eventVerbose >= 1) System.out.println("in destroy");
            if (eventVerbose >= 1) System.out.println("out destroy");
        }

        //
        // Button behavor changed incompatibly between Java 1.1 and 1.4
        // (not sure exactly what version it changed in though).
        // (I think it was 1.4 since that's when getButton() was added
        // to MouseEvent).
        //
        private static int getButton(java.awt.event.MouseEvent e)
        {
            // gag me! we can't even query the java spec version number
            // since System.getProperty() throws a security exception
            // in netscape!
            // so use empirical evidence...
            int mods = e.getModifiers();
#if 0 // can't seem to get this to work under IE at all, so don't try for now, it will just be wrong under 1.4
            boolean is_1_4_or_greater = ((mods & ~0x1fff) != 0);
            if (is_1_4_or_greater)
            {
                try
                {
                    return e.getButton();
                }
                catch (NoSuchMethodError err)
                {
                    // this only happens in IE, not netscape. fall through...
                }
            }
#endif

            if ((mods & java.awt.event.InputEvent.ALT_MASK) != 0)
                return java_awt_event_MouseEvent_BUTTON2;
            if ((mods & java.awt.event.InputEvent.META_MASK) != 0)
                return java_awt_event_MouseEvent_BUTTON3;
            return java_awt_event_MouseEvent_BUTTON1;
        } // getButton

        //
        // MouseListener and MouseMotionListener methods...
        // 
        public void mousePressed(java.awt.event.MouseEvent e)
        {
            if (eventVerbose >= 1) System.out.println("in mousePressed: "+e);
            if (eventVerbose >= 1)
            {
                if (getButton(e) == java_awt_event_MouseEvent_BUTTON1)
                    System.out.println("    (left mouse)");
                if (getButton(e) == java_awt_event_MouseEvent_BUTTON2)
                    System.out.println("    (middle mouse)");
                if (getButton(e) == java_awt_event_MouseEvent_BUTTON3)
                    System.out.println("    (right mouse)");
            }

            double thisP[] = new double[2];
            mostRecentGraphics.pick(e.getX(), e.getY(), thisP);

            stateWhenPressed = new UndoItem.State(mesh, doOptimize, optimizationTypeIndex);

            int whichButton = getButton(e);
            if (whichButton == java_awt_event_MouseEvent_BUTTON1)
            {
                button1IsDown = true;

                //
                // Add a vertex
                //
                System.out.println("    Adding a vertex at "+thisP[0]+" "+thisP[1]+" "+0+"");
                mesh.addIsolatedVertex(thisP[0], thisP[1], 0);

                //
                // If it's the second vertex, add an edge
                //
                Mesh.Vertex verts[] = mesh.verts; // after we added one
                if (verts.length == 2)
                {
                    System.out.println("Adding an edge between first two verts");
                    mesh.addEdgeBetweenTwoIsolatedVertices(verts[0], verts[1]);
                }

                //
                // If it's the third or more vertex,
                // find out which face we are on
                // (all triangles CCW), and kis that face.
                // if we are not inside any face by that criterion,
                // then assume we are inside the outer face
                // and connect the new vertex to every vertex
                // that's visible from it.
                //
                if (verts.length >= 3)
                {
                    boolean kissed = false;
                    double twiceMostNegativeFaceArea = Double.POSITIVE_INFINITY;
                    Mesh.Edge edgeOnMostNegativeFace = null;
                    // XXX traverses each face of size n n times!  need to keep track of what we've done already
                    FORI (iEdge, mesh.edges.length)
                    {
                        boolean thisFaceIsGoodSoFar = true;
                        Mesh.Edge edgeI = mesh.edges[iEdge];
                        double twiceThisFaceArea = 0.;
                        for (Mesh.Edge edge = edgeI;;)
                        {
                            double twiceThisTriArea = twiceTriArea(
                                                    thisP[0],thisP[1],
                                                    edge.initialVertex().x,
                                                    edge.initialVertex().y,
                                                    edge.finalVertex().x,
                                                    edge.finalVertex().y);
                            if (twiceThisTriArea < 0)
                            {
                                thisFaceIsGoodSoFar = false; // it's bad!
                            }
                            twiceThisFaceArea += twiceThisTriArea;

                            if ((edge = edge.next()) == edgeI)
                                break;
                        }
                        if (thisFaceIsGoodSoFar)
                        {
                            // I'm inside this face;
                            // kis it and done
                            mesh.kisIsolatedVertex(verts[verts.length-1],
                                                   edgeI);
                            kissed = true;
                            break;
                        }
                        if (twiceThisFaceArea < twiceMostNegativeFaceArea)
                        {
                            twiceMostNegativeFaceArea = twiceThisFaceArea;
                            edgeOnMostNegativeFace = mesh.edges[iEdge];
                        }
                    }
                    if (!kissed)
                    {
                        System.out.println("In the outer face");
                        //
                        // It wasn't inside any face.
                        // Assume it's in the outer face.
                        // In this case,
                        // make a kiss to the outer face
                        // and then delete all newly added edges
                        // that cross the boundary of the outer face.
                        //
                        Mesh.Edge oldOuterFaceBoundary[];
                        {
                            {
                                int iOldBoundaryEdge = 0;
                                for (Mesh.Edge edge = edgeOnMostNegativeFace;;)
                                {
                                    iOldBoundaryEdge++;
                                    if ((edge = edge.next()) == edgeOnMostNegativeFace)
                                        break;
                                }
                                oldOuterFaceBoundary = new Mesh.Edge[iOldBoundaryEdge];
                            }
                            {
                                int iOldBoundaryEdge = 0;
                                for (Mesh.Edge edge = edgeOnMostNegativeFace;;)
                                {
                                    oldOuterFaceBoundary[iOldBoundaryEdge++] = edge;
                                    if ((edge = edge.next()) == edgeOnMostNegativeFace)
                                        break;
                                }
                                assert(iOldBoundaryEdge == oldOuterFaceBoundary.length);
                            }
                        }

                        int oldNumEdges = mesh.edges.length;
                        mesh.kisIsolatedVertex(verts[verts.length-1],
                                               edgeOnMostNegativeFace);
                        for (int iEdge = oldNumEdges;
                             iEdge < mesh.edges.length;
                             iEdge += 2)
                        {
                            for (int iOldBoundaryEdge = 0;
                                 iOldBoundaryEdge < oldOuterFaceBoundary.length;
                                 ++iOldBoundaryEdge)
                            {
                                Mesh.Edge oldEdge = oldOuterFaceBoundary[iOldBoundaryEdge];
                                Mesh.Edge newEdge = mesh.edges[iEdge];

                                if (newEdge.initialVertex() == oldEdge.initialVertex()
                                 || newEdge.initialVertex() == oldEdge.finalVertex()
                                 || newEdge.finalVertex() == oldEdge.initialVertex()
                                 || newEdge.finalVertex() == oldEdge.finalVertex())
                                    continue;
                                //System.out.println("    Seeing whether new edge v"+newEdge.initialVertex().myIndex()+" -> v"+newEdge.finalVertex().myIndex()+" crosses old boundary edges v"+oldEdge.initialVertex().myIndex()+" -> v"+oldEdge.finalVertex().myIndex()+"");
                                if (edgesCrossOrCloseToIt(
                                                oldEdge.initialVertex().x,
                                                oldEdge.initialVertex().y,
                                                oldEdge.finalVertex().x,
                                                oldEdge.finalVertex().y,
                                                newEdge.initialVertex().x,
                                                newEdge.initialVertex().y,
                                                newEdge.finalVertex().x,
                                                newEdge.finalVertex().y,
                                                1e-6))
                                {
                                    //System.out.println("        It does.");
                                    mesh.deleteEdge(newEdge);
                                    iEdge -= 2; // so we don't skip the one that gets moved into the deleted spot
                                    break;
                                }
                                else
                                {
                                    //System.out.println("        It doesn't.");
                                }
                            }
                        }
                    }
                } // if verts.length >= 3

                mesh.sanityCheck();

                selectedVertIndex = verts.length-1;
            }
            else if (whichButton == java_awt_event_MouseEvent_BUTTON2)
            {
                button2IsDown = true;

                //
                // Select closest vertex
                //
                selectedVertIndex = mesh.indexOfClosestVert(thisP[0],thisP[1]);

                System.out.println("Selected vertex "+selectedVertIndex+"");
            }
            else if (whichButton == java_awt_event_MouseEvent_BUTTON3)
            {
                button3IsDown = true;

                //
                // Delete closest vertex
                //
                selectedVertIndex = mesh.indexOfClosestVert(thisP[0],thisP[1]);
                if (selectedVertIndex != -1)
                    mesh.deleteVertex(mesh.verts[selectedVertIndex]);
                selectedVertIndex = -1;

                mesh.sanityCheck();

            } // right mouse

            prevP = thisP;

            repaint();

            if (eventVerbose >= 1) System.out.println("out mousePressed: "+e);
        } // mousePressed
        public void mouseReleased(java.awt.event.MouseEvent e)
        {
            if (eventVerbose >= 1) System.out.println("in mouseReleased: "+e);

            int whichButton = getButton(e);
            if (whichButton == java_awt_event_MouseEvent_BUTTON1)
            {
                button1IsDown = false;
            }
            else if (whichButton == java_awt_event_MouseEvent_BUTTON2)
            {
                button2IsDown = false;
            }
            else if (whichButton == java_awt_event_MouseEvent_BUTTON3)
            {
                button3IsDown = false;
            }

            if (stateWhenPressed != null)
            {
                UndoItem.State stateWhenReleased = new UndoItem.State(mesh, doOptimize, optimizationTypeIndex);
                undoTreeSquirrel.Do(new UndoItem(stateWhenPressed, stateWhenReleased));
                stateWhenPressed = null;
            }

            repaint();

            if (eventVerbose >= 1) System.out.println("out mouseReleased: "+e);
        }
        public void mouseEntered(java.awt.event.MouseEvent e)
        {
            if (eventVerbose >= 1) System.out.println("in mouseEntered: "+e);
            if (eventVerbose >= 1) System.out.println("out mouseEntered: "+e);
        }
        public void mouseExited(java.awt.event.MouseEvent e)
        {
            if (eventVerbose >= 1) System.out.println("in mouseExited: "+e);
            if (eventVerbose >= 1) System.out.println("out mouseExited: "+e);
        }
        public void mouseClicked(java.awt.event.MouseEvent e)
        {
            if (eventVerbose >= 1) System.out.println("in mouseClicked: "+e);
            if (eventVerbose >= 1) System.out.println("out mouseClicked: "+e);
        }
        public void mouseDragged(java.awt.event.MouseEvent e)
        {
            if (eventVerbose >= 2) System.out.println("  in mouseDragged: "+e);

            double thisP[] = new double[2];
            mostRecentGraphics.pick(e.getX(), e.getY(), thisP);

            if (button1IsDown || button2IsDown)
            {
                if (e.isShiftDown())
                {
                    // Drag all the verts
                    FORI (iVert, mesh.verts.length)
                    {
                        mesh.verts[iVert].x += thisP[0]-prevP[0];
                        mesh.verts[iVert].y += thisP[1]-prevP[1];
                    }
                }
                else if (selectedVertIndex != -1)
                {
                    // Drag just the selected vert
                    mesh.verts[selectedVertIndex].x += thisP[0]-prevP[0];
                    mesh.verts[selectedVertIndex].y += thisP[1]-prevP[1];
                    // XXX what do do with h???
                    if (nonEventVerbose >= 1)
                    {
                        double verts[][] = new double[mesh.verts.length][];
                        FORI (iVert, mesh.verts.length)
                            verts[iVert] = new double[] {mesh.verts[iVert].x,
                                                         mesh.verts[iVert].y,
                                                         mesh.verts[iVert].h};
                        int edges[][] = new int[mesh.edges.length][];
                        FORI (iEdge, mesh.edges.length)
                            edges[iEdge] = new int[] {mesh.edges[iEdge].initialVertex().myIndex(),
                                                      mesh.edges[iEdge].finalVertex().myIndex()};
                        PRINTARRAY(verts);
                        PRINTARRAY(edges);
                    }
                }
            }

            if (button3IsDown) // right mouse
            {
            }

            repaint();

            prevP = thisP;

            if (eventVerbose >= 2) System.out.println("  out mouseDragged: "+e);
        }
        public void mouseMoved(java.awt.event.MouseEvent e)
        {
            if (eventVerbose >= 3) System.out.println("    in mouseMoved: "+e);

            if (mostRecentGraphics != null)
            {
                double thisP[] = new double[2];
                mostRecentGraphics.pick(e.getX(), e.getY(), thisP);
                prevP = thisP;
            }

            if (eventVerbose >= 3) System.out.println("    out mouseMoved: "+e);
        }

        //
        // KeyListener methods...
        //
        public void keyPressed(java.awt.event.KeyEvent e)
        {
            if (eventVerbose >= 1) System.out.println("in keyPressed: "+e);
            double incr = .005;
            switch(e.getKeyCode())
            {
                case java.awt.event.KeyEvent.VK_UP:
                {
                    UndoItem.State before = new UndoItem.State(mesh, doOptimize, optimizationTypeIndex);
                    if (doOptimize)
                    {
                        doOptimize ^= true;
                        System.out.println("doOptimize -> "+doOptimize+" ('O' to turn back on)");
                    }
                    System.out.print("Up");
                    System.out.flush();
                    int iVert = mesh.indexOfClosestVert(prevP[0], prevP[1]);
                    if (e.isControlDown())
                        mesh.verts[iVert].h += incr*.1;
                    else
                        mesh.verts[iVert].h += incr;
                    UndoItem.State after = new UndoItem.State(mesh, doOptimize, optimizationTypeIndex);
                    undoTreeSquirrel.Do(new UndoItem(before, after));
                    repaint();
                    break;
                }
                case java.awt.event.KeyEvent.VK_DOWN:
                {
                    UndoItem.State before = new UndoItem.State(mesh, doOptimize, optimizationTypeIndex);
                    if (doOptimize)
                    {
                        doOptimize ^= true;
                        System.out.println("doOptimize -> "+doOptimize+" ('O' to turn back on)");
                    }
                    System.out.print("Down");
                    System.out.flush();
                    int iVert = mesh.indexOfClosestVert(prevP[0], prevP[1]);
                    if (e.isControlDown())
                        mesh.verts[iVert].h -= incr*.1;
                    else
                        mesh.verts[iVert].h -= incr;
                    UndoItem.State after = new UndoItem.State(mesh, doOptimize, optimizationTypeIndex);
                    undoTreeSquirrel.Do(new UndoItem(before, after));
                    repaint();
                    break;
                }
                case java.awt.event.KeyEvent.VK_LEFT:
                {
                    translateFudgeX -= .1;
                    System.out.println("translateFudgeX -> "+translateFudgeX);
                    repaint();
                    break;
                }
                case java.awt.event.KeyEvent.VK_RIGHT:
                {
                    translateFudgeX += .1;
                    System.out.println("translateFudgeX -> "+translateFudgeX);
                    repaint();
                    break;
                }

                default:
                    break;
            }
            if (eventVerbose >= 1) System.out.println("out keyPressed: "+e);
        }
        public void keyReleased(java.awt.event.KeyEvent e)
        {
            if (eventVerbose >= 1) System.out.println("in keyReleased: "+e);
            if (eventVerbose >= 1) System.out.println("out keyReleased: "+e);
        }
        public void keyTyped(java.awt.event.KeyEvent e)
        {
            if (eventVerbose >= 1) System.out.println("in keyTyped: "+e);
            char c = e.getKeyChar();

            // In java 1.6, apparently ctrl-letter
            // started coming out as just the letter
            // (with ke.isControlDown() true).
            // Detect this and change it to the old behavior...
            // XXX need to do something else, or nothing at all here, for old javas (1.1) in which isControlDown doesn't exist... or else just stop trying to support 1.1 at all
            if (c >= 'a' && c <= 'z' && e.isControlDown())
            {
                c -= ('a'-1);
            }

            switch (c)
            {
                case 'V': // cycle verbosity-- upper-case to minimize possibility of hitting it by accident thus causing subsequent perfomance degradation with no visible reason if Java Console is not visible
                    System.out.print("eventVerbose "+eventVerbose);
                    eventVerbose = (eventVerbose+1) % 4;
                    System.out.println(" -> "+eventVerbose);
                    break;

                case ' ': // just repaint (i.e. mark dirty)
                    repaint();
                    break;
                case 'A': // toggle doAntiAliasing
                    doAntiAliasing ^= true;
                    System.out.println("doAntiAliasing -> "+doAntiAliasing+" (if this platform supports it)");
                    repaint();
                    break;

                case 't': // increase lineThicknessInPixels
                    System.out.print("lineThicknessInPixels "+lineThicknessInPixels);
                    lineThicknessInPixels += 1.;
                    System.out.println(" -> "+lineThicknessInPixels);
                    repaint();
                    break;
                case 'T': // decrease lineThicknessInPixels
                    System.out.print("lineThicknessInPixels "+lineThicknessInPixels);
                    lineThicknessInPixels -= 1.;
                    System.out.println(" -> "+lineThicknessInPixels);
                    repaint();
                    break;

                case 'B': // toggle doDoubleBuffer
                    doDoubleBuffer ^= true;
                    System.out.println("doDoubleBuffer -> "+doDoubleBuffer);
                    repaint();
                    break;

                case 'i': case '+': case '=': // zoom in
                {
                    UndoItem.State before = new UndoItem.State(mesh, doOptimize, optimizationTypeIndex);
                    FORI (iVert, mesh.verts.length)
                    {
                        double scale = Math.sqrt(2.);
                        mesh.verts[iVert].x *= scale;
                        mesh.verts[iVert].y *= scale;
                        mesh.verts[iVert].h *= scale*scale;
                    }
                    UndoItem.State after = new UndoItem.State(mesh, doOptimize, optimizationTypeIndex);
                    undoTreeSquirrel.Do(new UndoItem(before, after));
                    repaint();
                    break;
                }
                case 'o': case '-':           // zoom out
                {
                    UndoItem.State before = new UndoItem.State(mesh, doOptimize, optimizationTypeIndex);
                    FORI (iVert, mesh.verts.length)
                    {
                        double scale = Math.sqrt(.5);
                        mesh.verts[iVert].x *= scale;
                        mesh.verts[iVert].y *= scale;
                        mesh.verts[iVert].h *= scale*scale;
                    }
                    UndoItem.State after = new UndoItem.State(mesh, doOptimize, optimizationTypeIndex);
                    undoTreeSquirrel.Do(new UndoItem(before, after));
                    repaint();
                    break;
                }

                case 's': // swap diagonal
                {
                    UndoItem.State before = new UndoItem.State(mesh, doOptimize, optimizationTypeIndex);
                    int closestEdgeIndex = mesh.indexOfClosestEdge(prevP[0],prevP[1]);
                    if (closestEdgeIndex != -1)
                    {
                        System.out.println("Swapping diagonal edge e"+closestEdgeIndex);
                        mesh.swapDiagonal(mesh.edges[closestEdgeIndex]);
                        mesh.sanityCheck();
                    }
                    UndoItem.State after = new UndoItem.State(mesh, doOptimize, optimizationTypeIndex);
                    undoTreeSquirrel.Do(new UndoItem(before, after));
                    repaint();
                    break;
                }
                case 'd': // delete closest edge
                {
                    UndoItem.State before = new UndoItem.State(mesh, doOptimize, optimizationTypeIndex);
                    int closestEdgeIndex = mesh.indexOfClosestEdge(prevP[0],prevP[1]);
                    if (closestEdgeIndex != -1)
                    {
                        System.out.println("Deleting edge e"+closestEdgeIndex);
                        mesh.deleteEdge(mesh.edges[closestEdgeIndex]);
                        mesh.sanityCheck();
                    }
                    UndoItem.State after = new UndoItem.State(mesh, doOptimize, optimizationTypeIndex);
                    undoTreeSquirrel.Do(new UndoItem(before, after));
                    repaint();
                    break;
                }
                case 'S': // turn off optimize, and re-sphereize
                {
                    UndoItem.State before = new UndoItem.State(mesh, doOptimize, optimizationTypeIndex);
                    if (doOptimize)
                    {
                        doOptimize ^= true;
                        System.out.println("doOptimize -> "+doOptimize+" ('O' to turn back on)");
                    }
                    FORI (iVert, mesh.verts.length)
                        mesh.verts[iVert].h = 0.;
                    UndoItem.State after = new UndoItem.State(mesh, doOptimize, optimizationTypeIndex);
                    undoTreeSquirrel.Do(new UndoItem(before, after));
                    repaint();
                    break;
                }

                case 'l': // toggle doLabels
                    doLabels ^= true;
                    System.out.println("doLabels -> "+doLabels);
                    repaint();
                    break;

                case 'O': // toggle doOptimize
                {
                    UndoItem.State before = new UndoItem.State(mesh, doOptimize, optimizationTypeIndex);
                    doOptimize ^= true;
                    System.out.println("doOptimize -> "+doOptimize);
                    UndoItem.State after = new UndoItem.State(mesh, doOptimize, optimizationTypeIndex);
                    undoTreeSquirrel.Do(new UndoItem(before, after));
                    repaint();
                    break;
                }

                case 'a': // toggle doArrowsTowardsSharpestDihedrals or doArrowsTowardsShortestEdges
                {
                    if (e.isAltDown())
                    {
                        doArrowsTowardsShortestEdges ^= true;
                        System.out.println("doArrowsTowardsShortestEdges -> "+doArrowsTowardsShortestEdges);
                    }
                    else
                    {
                        doArrowsTowardsSharpestDihedrals ^= true;
                        System.out.println("doArrowsTowardsSharpestDihedrals -> "+doArrowsTowardsSharpestDihedrals);
                    }
                    repaint();
                    break;
                }


#define CTRL(lowerCaseLetter) ((lowerCaseLetter)-'a' + 1)

                case 'u': case CTRL('z'): // undo
                {
                    UndoItem item = (UndoItem)undoTreeSquirrel.undo();
                    if (item != null)
                    {
                        mesh = new Mesh(item.before.mesh);
                        doOptimize = item.before.doOptimize;
                        optimizationTypeIndex = item.before.optimizationTypeIndex;
                        optimizationType = availableOptimizationTypes[optimizationTypeIndex];
                    }
                    else
                    {
                        System.out.println("Nothing to undo!");
                    }
                    repaint();
                    break;
                }
                case 'r': case 'U': case CTRL('r'): case CTRL('y'): // redo
                {
                    UndoItem item = (UndoItem)undoTreeSquirrel.redo();
                    if (item != null)
                    {
                        mesh = new Mesh(item.after.mesh);
                        doOptimize = item.after.doOptimize;
                        optimizationTypeIndex = item.after.optimizationTypeIndex;
                        optimizationType = availableOptimizationTypes[optimizationTypeIndex];
                    }
                    else
                    {
                        System.out.println("Nothing to redo!");
                    }
                    repaint();
                    break;
                }
                case 'c':
                {
                    UndoItem.State before = new UndoItem.State(mesh, doOptimize, optimizationTypeIndex);
                    mesh = new Mesh();
                    UndoItem.State after = new UndoItem.State(mesh, doOptimize, optimizationTypeIndex);
                    undoTreeSquirrel.Do(new UndoItem(before, after));
                    repaint();
                    break;
                }

                case 'h': // help
                    System.out.println("===================================================================");
                    System.out.println("Mouse:");
                    System.out.println("    left click: add a vertex and drag it");
                    System.out.println("    middle drag: move a vertex");
                    System.out.println("    right click: delete a vertex");
                    System.out.println("    shift-middle drag: pan entire picture");
                    System.out.println("Keys:");
                    System.out.println("    'V' - cycle verbosity (to java console or system output)");
                    System.out.println("    ' ' - just repaint");
                    System.out.println("    'A' - toggle doAntiAliasing");
                    // System.out.println("    't' - increase lineThicknessInPixels"); // not used, I don't think
                    // System.out.println("    'T' - decrease lineThicknessInPixels"); // not used, I don't think
                    System.out.println("    'B' - toggle doDoubleBuffer");
                    System.out.println("    'i'/'+'/'=' - zoom in");
                    System.out.println("    'o'/'-' - zoom out");
                    System.out.println("    's' - swap a diagonal");
                    System.out.println("    'O' - toggle doOptimize");
                    System.out.println("    'l' - toggle doLabels");
                    System.out.println("    'a' - toggle doArrowsTowardsSharpestDihedrals (green)");
                    System.out.println("    alt-'a' - toggle doArrowsTowardsShortestEdges (cyan)");
                    System.out.println("    'S' - turn off optimize, and re-spherize");
                    System.out.println("    'd' - delete closest edge");
                    System.out.println("    ctrl-'i' - toggle doShowInsideOutDualVerts");
                    System.out.println("    ctrl-'o' - cycle optimizationType");
                    System.out.println("    ctrl-'v' - toggle nonEventVerbose");
                    System.out.println("    Up arrow: pull face plane of closest vertex out");
                    System.out.println("    Down arrow: push face plane of closest vertex in");
                    System.out.println("    Left/right arrow: translate fudge");
                    System.out.println("    'c' - clear");
                    System.out.println("    ctrl-'c' - example in which cutting the sharpest dihedral at each vertex does not lead to a solution");
                    System.out.println("    'u' / ctrl-'z' - undo");
                    System.out.println("    'r' / 'U' / ctrl-'r' / ctrl-'y' - redo");
                    System.out.println("===================================================================");
                    break;

                case CTRL('i'): // toggle doShowInsideOutDualVerts
                    doShowInsideOutDualVerts ^= true;
                    System.out.println("doShowInsideOutDualVerts -> "+doShowInsideOutDualVerts);
                    repaint();
                    break;

                case CTRL('o'): // cycle optimizationType
                    optimizationTypeIndex = (optimizationTypeIndex+1)%availableOptimizationTypes.length;
                    optimizationType = availableOptimizationTypes[optimizationTypeIndex];
                    System.out.println("optimizationType -> "+optimizationTypeNames[optimizationType]);
                    repaint();
                    break;

                case CTRL('v'): // toggle nonEventVerbose
                    nonEventVerbose = (nonEventVerbose+1)%2;
                    System.out.println("nonEventVerbose -> "+nonEventVerbose);
                    repaint();
                    break;

                case CTRL('c'): // very special case canned... netless9 example
                {
                    UndoItem.State before = new UndoItem.State(mesh, doOptimize, optimizationTypeIndex);

                    if (e.isAltDown())
                        doCannedThingHexesSpiral();
                    else
                        doCannedThingNetless9();

                    UndoItem.State after = new UndoItem.State(mesh, doOptimize, optimizationTypeIndex);
                    undoTreeSquirrel.Do(new UndoItem(before, after));
                    repaint();
                    break;
                }

                default:
                    System.out.println("Unknown key '"+c+"'("+(int)e.getKeyChar()+") typed");
                    break;
            }
            if (eventVerbose >= 1) System.out.println("out keyTyped: "+e);
        } // keyTyped

        // Make the mesh into netless9
        private void doCannedThingNetless9()
        {
            if (true)
            {
                // s = how much bigger each edge is from the previous
                double s = 1.05;
                //double s = 1.001;
                double sliceAngle;
                {
                    // In the initial 6 slice pie,
                    // the southwest triangle has sides a=1, b=s^5, c=s^6.
                    // what are its angles?
                    // http://www.teacherschoice.com.au/Maths_Library/Trigonometry/solve_trig_SSS.htm
                    double a = 1;
                    double b = s*s*s*s*s;
                    double c = s*s*s*s*s*s;
                    double C = triangleAngle(a, b, c);
                    // All right, the southwest angle at the center
                    // is C, a bit more than pi/3.
                    // Distribute the rest of the spokes evenly.
                    sliceAngle = (2*Math.PI-C) / 5;
                }
                PRINT(RTOD(sliceAngle));
                int nVerts = 19;
                //int nVerts = 40;
                //int nVerts = 1000;
                double verts[][] = new double[nVerts][3];
                int nNeighbors[] = new int[nVerts]; // zeros
                ArrayList facesList = new ArrayList();

                // Seed with verts 0 and 1, and an edge between them.
                verts[0][0] = 0;
                verts[0][1] = 0;
                verts[0][2] = 0;
                // Had the seed on the -y axis, changing it to +x axis for the hell of it
                verts[1][0] = 1;
                verts[1][1] = 0;
                verts[1][2] = 0;
                nNeighbors[0] = 1;
                nNeighbors[1] = 1;

                PRINT(VecMath.dist(verts[1], verts[6]));
                PRINT(Math.pow(s, 6));

                int oldestPerimeterEdge[] = {0,1};

                for (int i = 2; i < nVerts; ++i)
                {
                    //PRINT(i);
                    int arity = nNeighbors[oldestPerimeterEdge[0]];
                    assert(arity < 6);
                    double angFrac = 1./(6-arity);
                    //PRINT(1./angFrac);
                    double largestEdge = VecMath.dist(verts[i-1], verts[oldestPerimeterEdge[0]]);
                    //PRINT(largestEdge);
                    //PRINT(Math.pow(s, facesList.size()));

                    double c = VecMath.dist(verts[oldestPerimeterEdge[0]],
                                            verts[oldestPerimeterEdge[1]]);
                    double a = largestEdge * Math.pow(s, 1./angFrac);
                    double b = a*s;
                    //PRINT(a);
                    //PRINT(b);
                    double target[] = completeTriangle(verts[oldestPerimeterEdge[1]],
                                                       verts[oldestPerimeterEdge[0]],
                                                       a, b);
                    double ang0 = Math.atan2(verts[i-1][1]-verts[oldestPerimeterEdge[0]][1],
                                             verts[i-1][0]-verts[oldestPerimeterEdge[0]][0]);
                    double ang1 = Math.atan2(target[1]-verts[oldestPerimeterEdge[0]][1],
                                             target[0]-verts[oldestPerimeterEdge[0]][0]);
                    //PRINT(RTOD(ang0));
                    //PRINT(RTOD(ang1));
                    //PRINT(angFrac);
                    while (ang1 < ang0) ang1 += 2*Math.PI;
                    double ang = LERP(ang0, ang1, angFrac);
                    double length = largestEdge * s;
                    verts[i][0] = verts[oldestPerimeterEdge[0]][0] + length*Math.cos(ang);
                    verts[i][1] = verts[oldestPerimeterEdge[0]][1] + length*Math.sin(ang);
                    facesList.add(new int[]{oldestPerimeterEdge[0], i-1, i});
                    nNeighbors[oldestPerimeterEdge[0]]++;
                    nNeighbors[i-1]++;
                    nNeighbors[i] = 2;
                    if (nNeighbors[oldestPerimeterEdge[0]] == 6)
                    {
                        //System.out.println("COMPLETING at "+i);
                        facesList.add(new int[]{oldestPerimeterEdge[1], oldestPerimeterEdge[0], i});
                        nNeighbors[oldestPerimeterEdge[1]]++;
                        nNeighbors[i]++;
                        oldestPerimeterEdge[0]++;
                        oldestPerimeterEdge[1]++;
                    }
                }

                {
                    int nPerimeterVerts = 0;
                    FORI (i, nVerts)
                        if (nNeighbors[i] < 6)
                            nPerimeterVerts++;
                    int perimeterVerts[] = new int[nPerimeterVerts];
                    nPerimeterVerts = 0;
                    FORI (i, nVerts)
                        if (nNeighbors[i] < 6)
                            perimeterVerts[perimeterVerts.length-1-nPerimeterVerts++] = i;
                    facesList.add(perimeterVerts);
                    PRINT(nPerimeterVerts);
                }


                int faces[][] = new int[facesList.size()][];
                facesList.toArray(faces);
                mesh = new Mesh(verts, faces);
                //PRINTARRAY(nNeighbors);
                //PRINTARRAY(verts);
                //PRINTARRAY(faces);
            }
            FORI (iVert, mesh.verts.length)
            {
                double scale = .2;
                mesh.verts[iVert].x *= scale;
                mesh.verts[iVert].y *= scale;
                mesh.verts[iVert].h *= scale*scale;
            }
        } // doCannedThingNetless9

        private void doCannedThingHexesSpiral()
        {
            if (true)
            {
                // s = how much bigger each edge is from the previous
                //double s = 1.05;
                //double s = 1.001;
                double s = 1.;
                double sliceAngle;
                {
                    // In the initial 6 slice pie,
                    // the southwest triangle has sides a=1, b=s^5, c=s^6.
                    // what are its angles?
                    // http://www.teacherschoice.com.au/Maths_Library/Trigonometry/solve_trig_SSS.htm
                    double a = 1;
                    double b = s*s*s*s*s;
                    double c = s*s*s*s*s*s;
                    double C = triangleAngle(a, b, c);
                    // All right, the southwest angle at the center
                    // is C, a bit more than pi/3.
                    // Distribute the rest of the spokes evenly.
                    sliceAngle = (2*Math.PI-C) / 5;
                }
                PRINT(RTOD(sliceAngle));
                //int nVerts = 19;
                //int nVerts = 18;
                //int nVerts = 100;
                int nVerts = 500;
                //int nVerts = 1000;
                double verts[][] = new double[nVerts][3];
                int nNeighbors[] = new int[nVerts]; // zeros
                ArrayList facesList = new ArrayList();

                // Seed with verts 0 and 1, and an edge between them.
                verts[0][0] = 0;
                verts[0][1] = 0;
                verts[0][2] = 0;
                // Had the seed on the -y axis, changing it to +x axis for the hell of it
                verts[1][0] = 1;
                verts[1][1] = 0;
                verts[1][2] = 0;
                nNeighbors[0] = 1;
                nNeighbors[1] = 1;

                PRINT(VecMath.dist(verts[1], verts[6]));
                PRINT(Math.pow(s, 6));

                int oldestPerimeterEdge[] = {0,1};

                for (int i = 2; i < nVerts; ++i)
                {
                    //PRINT(i);
                    int arity = nNeighbors[oldestPerimeterEdge[0]];
                    assert(arity < 6);
                    double angFrac = 1./(6-arity);
                    //PRINT(1./angFrac);
                    double largestEdge = VecMath.dist(verts[i-1], verts[oldestPerimeterEdge[0]]);
                    //PRINT(largestEdge);
                    //PRINT(Math.pow(s, facesList.size()));

                    double c = VecMath.dist(verts[oldestPerimeterEdge[0]],
                                            verts[oldestPerimeterEdge[1]]);
                    double a = largestEdge * Math.pow(s, 1./angFrac);
                    double b = a*s;
                    //PRINT(a);
                    //PRINT(b);
                    double target[] = completeTriangle(verts[oldestPerimeterEdge[1]],
                                                       verts[oldestPerimeterEdge[0]],
                                                       a, b);
                    double ang0 = Math.atan2(verts[i-1][1]-verts[oldestPerimeterEdge[0]][1],
                                             verts[i-1][0]-verts[oldestPerimeterEdge[0]][0]);
                    double ang1 = Math.atan2(target[1]-verts[oldestPerimeterEdge[0]][1],
                                             target[0]-verts[oldestPerimeterEdge[0]][0]);
                    //PRINT(RTOD(ang0));
                    //PRINT(RTOD(ang1));
                    //PRINT(angFrac);
                    while (ang1 < ang0) ang1 += 2*Math.PI;
                    double ang = LERP(ang0, ang1, angFrac);
                    double length = largestEdge * s;
                    verts[i][0] = verts[oldestPerimeterEdge[0]][0] + length*Math.cos(ang);
                    verts[i][1] = verts[oldestPerimeterEdge[0]][1] + length*Math.sin(ang);
                    facesList.add(new int[]{oldestPerimeterEdge[0], i-1, i});
                    nNeighbors[oldestPerimeterEdge[0]]++;
                    nNeighbors[i-1]++;
                    nNeighbors[i] = 2;
                    if (nNeighbors[oldestPerimeterEdge[0]] == 6)
                    {
                        //System.out.println("COMPLETING at "+i);
                        facesList.add(new int[]{oldestPerimeterEdge[1], oldestPerimeterEdge[0], i});
                        nNeighbors[oldestPerimeterEdge[1]]++;
                        nNeighbors[i]++;
                        oldestPerimeterEdge[0]++;
                        oldestPerimeterEdge[1]++;
                    }
                }

                {
                    int nPerimeterVerts = 0;
                    FORI (i, nVerts)
                        if (nNeighbors[i] < 6)
                            nPerimeterVerts++;
                    int perimeterVerts[] = new int[nPerimeterVerts];
                    nPerimeterVerts = 0;
                    FORI (i, nVerts)
                        if (nNeighbors[i] < 6)
                            perimeterVerts[perimeterVerts.length-1-nPerimeterVerts++] = i;
                    facesList.add(perimeterVerts);
                    PRINT(nPerimeterVerts);
                }


                int faces[][] = new int[facesList.size()][];
                facesList.toArray(faces);
                mesh = new Mesh(verts, faces);
                //PRINTARRAY(nNeighbors);
                //PRINTARRAY(verts);
                //PRINTARRAY(faces);
            }
            FORI (iVert, mesh.verts.length)
            {
                double scale = .2;
                mesh.verts[iVert].x *= scale;
                mesh.verts[iVert].y *= scale;
                mesh.verts[iVert].h *= scale*scale;
            }
            //double heightIncr = .005*.14;
            double heightIncr = .005*.01;
            FORI (iVert, mesh.verts.length)
            {
                mesh.verts[iVert].h -= heightIncr * iVert;
            }
        } // doCannedThingHexesSpiral

        //
        // Make it so we get keyboard focus on startup,
        // without having to click first.  Thanks, Melinda!
        // The state of things seems to be:
        //      - Buttons and TextFields are apparently "focus traversable"
        //        by default.  Canvases and Applets aren't,
        //        implying (not obvious) that you need to click to type
        //        when the app starts,
        //        which is almost never the desired behavior.
        //        You can change this by overriding isFocusTraversable(),
        //        which we do below.
        //      - Other approaches using requestFocus():
        //        A Canvas calling requestFocus() doesn't seem to do
        //        anything.  An Applet calling requestFocus() doesn't
        //        do anything during init(), but I think it works
        //        if you put it in the mouseEntered handler or something,
        //        though this can lead to various unpredictabilities.
        // In this applet we are drawing directly on the Applet (not a Canvas),
        // so presumably the requestFocus() approach would work,
        // but the isFocusTraversable() fix is better in any case.
        //
        public boolean isFocusTraversable()
        {
            return true;
        }

        // override to not clear...
        public void update(java.awt.Graphics g)
        {
            paint(g);
        }


        // PAINT
	public void paint(java.awt.Graphics frontBufferGraphics)
	{
	    if (eventVerbose >= 1) System.out.println("in paint");

            makeSureBackBufferIsRight();
            java.awt.Graphics g;
            if (doDoubleBuffer)
                g = backBufferImage.getGraphics();
            else
                g = frontBufferGraphics;


            java.awt.Dimension size = getSize();
            double minSize = MIN(size.width, size.height);
            MyGraphics mg = new MyGraphics(g, size,
                                    -size.width/minSize,size.width/minSize,
                                    -size.height/minSize,size.height/minSize);
            mostRecentGraphics = mg;

            if (implementAntiAliasingInHardware)
            {
                graphicsAntiAliasingSetter.setAntiAliasing(g,
                                                           doAntiAliasing,
                                                           //1
                                                           eventVerbose
                                                           );
            }


            //
            // Clear to black...
            //
            mg.setColor(java.awt.Color.black);
            mg.fillWindow();



            //
            // Draw the mesh...
            //
            {
                mg.setColor(java.awt.Color.white);

                Mesh.Vertex verts[] = mesh.verts;
                FORI (iVert, verts.length)
                {
                    mg.drawPoint(verts[iVert].x,
                                 verts[iVert].y, 3);
                }

                Mesh.Edge edges[] = mesh.edges;
                FORI (iEdge, edges.length/2)
                {
                    Mesh.Vertex v0 = edges[iEdge*2].initialVertex();
                    Mesh.Vertex v1 = edges[iEdge*2].finalVertex();
                    mg.drawLine(v0.x,v0.y,v1.x,v1.y,doAntiAliasing);
                }
            }

            //
            // Try optimizing the heights...
            //
            if (doOptimize)
            {
                double optimalVertexHeights[] = mesh.findOptimalVertexHeights(optimizationType);
                FORI (iVert, mesh.verts.length)
                {
                    //PRINTSUB(optimalVertexHeights,iVert);
                    mesh.verts[iVert].h = optimalVertexHeights[iVert];
                }
            }

            //
            // Draw the dual diagram...
            //
            {
                //
                // Draw and store the dual verts...
                //
                mg.setColor(java.awt.Color.red);
                double dualVerts[][] = new double[mesh.edges.length][];
                FORI (iEdge, mesh.edges.length)
                {
                    if (dualVerts[iEdge] != null)
                        continue; // already did this triangle

                    Mesh.Edge e0 = mesh.edges[iEdge];
                    Mesh.Edge e1 = e0.next();
                    Mesh.Edge e2 = e1.next();
                    if (e2.next() != e0)
                        continue; // not a triangle

                    Mesh.Vertex v0 = e0.initialVertex();
                    Mesh.Vertex v1 = e1.initialVertex();
                    Mesh.Vertex v2 = e2.initialVertex();

                    if (!doShowInsideOutDualVerts)
                    {
                        if (twiceTriArea(v0.x,v0.y,
                                         v1.x,v1.y,
                                         v2.x,v2.y) < 0)
                            continue; // the triangle is inside out; it's the boundary
                    }

                    // XXX fudge-- experiment with translations and scales
                    double fudgeTranslate[] = {translateFudgeX, 0};
                    double coords0[] = {v0.x,v0.y};
                    double coords1[] = {v1.x,v1.y};
                    double coords2[] = {v2.x,v2.y};
                    double fudge0 = VecMath.dot(fudgeTranslate, coords0);
                    double fudge1 = VecMath.dot(fudgeTranslate, coords1);
                    double fudge2 = VecMath.dot(fudgeTranslate, coords2);
                    double fudgeScale = 1.;

                    double dualVert[] = new double[3];
                    SolveForDualPoint(v0.x, v0.y, fudge0 + v0.h - (2-fudgeScale) * .5 * (SQR(v0.x)+SQR(v0.y)),
                                      v1.x, v1.y, fudge1 + v1.h - (2-fudgeScale) * .5 * (SQR(v1.x)+SQR(v1.y)),
                                      v2.x, v2.y, fudge2 + v2.h - (2-fudgeScale) * .5 * (SQR(v2.x)+SQR(v2.y)),
                                      dualVert);

                    //System.out.println("    drawing dual vert at "+Arrays.toStringCompact(dualVert));
                    mg.drawPoint(dualVert[0],
                                 dualVert[1], 5);
                    int ind0 = iEdge;
                    int ind1 = e1.myIndex();
                    int ind2 = e2.myIndex();
                    assert(dualVerts[ind0] == null);
                    assert(dualVerts[ind1] == null);
                    assert(dualVerts[ind2] == null);
                    dualVerts[ind0] = dualVert;
                    dualVerts[ind1] = dualVert;
                    dualVerts[ind2] = dualVert;
                }

                //
                // Now try connecting the dual verts
                //
                FORI (iEdge, mesh.edges.length)
                {
                    if (dualVerts[iEdge] == null)
                        continue; // not a triangle, or insie out
                    int jEdge = mesh.edges[iEdge].opposite().myIndex();
                    if (dualVerts[jEdge] != null)
                    {
                        mg.drawLine(dualVerts[iEdge][0],dualVerts[iEdge][1],
                                    dualVerts[jEdge][0],dualVerts[jEdge][1],
                                    doAntiAliasing);
                    }
                    else
                    {
                        double v0[] = {mesh.edges[iEdge].initialVertex().x,
                                       mesh.edges[iEdge].initialVertex().y};
                        double v1[] = {mesh.edges[iEdge].finalVertex().x,
                                       mesh.edges[iEdge].finalVertex().y};
                        double toEdgeVec[] = VecMath.xv2(
                                                 VecMath.vmv(v0, v1));
                        VecMath.normalize(toEdgeVec, toEdgeVec);
                        double rayLength = 1.;
                        double destPoint[] = {dualVerts[iEdge][0]+rayLength*toEdgeVec[0],
                                              dualVerts[iEdge][1]+rayLength*toEdgeVec[1]};
                        mg.drawLine(dualVerts[iEdge][0],dualVerts[iEdge][1],
                                    destPoint[0],destPoint[1],
                                    doAntiAliasing);
                                                             
                    }
                }

                //
                // Now try marking the sharpest dihedral dual edge
                // out of each dual vertex.
                // I.e. the dual edge opposite the largest dual angle.
                // I.e. the dual edge corresponding to the longest of the three primal
                // triangle sides.
                // We draw it 3 times, to make sure we get the same logic from each direction. If there are ties, it will get drawn in each place I think.
                //
                if (doArrowsTowardsSharpestDihedrals)
                {
                    mg.setColor(java.awt.Color.green);
                    FORI (iEdge, mesh.edges.length)
                    {
                        if (dualVerts[iEdge] == null)
                            continue; // not a triangle, or inside out
                        Mesh.Edge e0 = mesh.edges[iEdge];
                        Mesh.Edge e1 = e0.next();
                        Mesh.Edge e2 = e1.next();
                        assert(e2.next() == e0);
                        Mesh.Vertex triVerts[] = {e0.initialVertex(),
                                                  e1.initialVertex(),
                                                  e2.initialVertex()};
                        double sideLengths[] = new double[3];
                        FORI (i, 3)
                            sideLengths[i] = Math.sqrt(SQR(triVerts[i].x-triVerts[(i+1)%3].x)
                                                     + SQR(triVerts[i].y-triVerts[(i+1)%3].y));
                        int bestSide = MAXI3(sideLengths[0], sideLengths[1], sideLengths[2]);
                        double triCenterDualVert[] = dualVerts[e0.myIndex()]; // huh? using an edge index to index into the dual verts?
                        double v0[] = {triVerts[bestSide].x, triVerts[bestSide].y};
                        double v1[] = {triVerts[(bestSide+1)%3].x, triVerts[(bestSide+1)%3].y};
                        double toEdgeVec[] = VecMath.xv2(
                                                 VecMath.vmv(v0, v1));
                        VecMath.normalize(toEdgeVec, toEdgeVec);
                        // XXX be smarter!  maybe 1/3 of the way along the edge, or somethin
                        double whereToDrawMark[] = {
                            triCenterDualVert[0] + .02 * toEdgeVec[0],
                            triCenterDualVert[1] + .02 * toEdgeVec[1],
                        };
                        //VecMath.vpsxv(whereToDrawMark, whereToDrawMark, .004, VecMath.random(2));
                        mg.drawPoint(whereToDrawMark[0],
                                     whereToDrawMark[1], 5);
                    }
                }
                if (doArrowsTowardsShortestEdges)
                {
                    mg.setColor(java.awt.Color.cyan);
                    FORI (iEdge, mesh.edges.length)
                    {
                        if (dualVerts[iEdge] == null)
                            continue; // not a triangle, or inside out

                        Mesh.Edge e0 = mesh.edges[iEdge];
                        Mesh.Edge e1 = e0.next();
                        Mesh.Edge e2 = e1.next();
                        assert(e2.next() == e0);
                        Mesh.Vertex triVerts[] = {e0.initialVertex(),
                                                  e1.initialVertex(),
                                                  e2.initialVertex()};
                        double triCenterDualVert[] = dualVerts[e0.myIndex()];
                        double neighborDualVerts[][] = {
                            dualVerts[e0.opposite().myIndex()],
                            dualVerts[e1.opposite().myIndex()],
                            dualVerts[e2.opposite().myIndex()],
                        };
                        double dualSideLengths[] = new double[3];
                        FORI (i, 3)
                        {
                            if (neighborDualVerts[i] == null)
                                dualSideLengths[i] = Double.POSITIVE_INFINITY;
                            else
                                dualSideLengths[i] = VecMath.dist(triCenterDualVert, neighborDualVerts[i]);
                        }
                        int bestSide = MINI3(dualSideLengths[0], dualSideLengths[1], dualSideLengths[2]);
                        double v0[] = {triVerts[bestSide].x, triVerts[bestSide].y};
                        double v1[] = {triVerts[(bestSide+1)%3].x, triVerts[(bestSide+1)%3].y};
                        double toEdgeVec[] = VecMath.xv2(
                                                 VecMath.vmv(v0, v1));
                        VecMath.normalize(toEdgeVec, toEdgeVec);
                        // XXX be smarter!  maybe 1/3 of the way along the edge, or somethin
                        double whereToDrawMark[] = {
                            triCenterDualVert[0] + .02 * toEdgeVec[0],
                            triCenterDualVert[1] + .02 * toEdgeVec[1],
                        };
                        //VecMath.vpsxv(whereToDrawMark, whereToDrawMark, .005, VecMath.random(2));
                        mg.drawPoint(whereToDrawMark[0],
                                     whereToDrawMark[1], 5);

                    }
                }
            }

            //
            // Draw the labels last...
            //
            if (doLabels)
            {
                mg.setColor(java.awt.Color.white);

                boolean trySmartVertexAngles = true;

                double smartVertexAngles[] = null;
                if (trySmartVertexAngles)
                {
                    int nVerts = mesh.verts.length;
                    int nEdges = mesh.edges.length;
                    smartVertexAngles = new double[nVerts]; // initialized to 0

                    FORI (iEdge0, nEdges)
                    {
                        Mesh.Edge edge0 = mesh.edges[iEdge0];
                        Mesh.Vertex vert = edge0.initialVertex();
                        if (smartVertexAngles[vert.myIndex()] != 0.)
                            continue; // already saw this one for sure

                        double biggestGap = -1.;
                        double angOfBiggestGap = 0.;
                        // walk CCW around vertex
                        Mesh.Edge thisEdge = edge0;
                        Mesh.Edge nextEdge;
                        do {
                            assert(thisEdge.initialVertex() == vert);
                            nextEdge = thisEdge.prev().opposite();
                            double nextAng = Math.atan2(nextEdge.finalVertex().y-nextEdge.initialVertex().y,
                                                        nextEdge.finalVertex().x-nextEdge.initialVertex().x);
                            double thisAng = Math.atan2(thisEdge.finalVertex().y-thisEdge.initialVertex().y,
                                                        thisEdge.finalVertex().x-thisEdge.initialVertex().x);
                            double thisGap = nextAng - thisAng;
                            if (thisGap < 0)
                                thisGap += 2*Math.PI;
                            if (thisGap > biggestGap)
                            {
                                biggestGap = thisGap;
                                angOfBiggestGap = thisAng+thisGap/2;
                            }
                        } while ((thisEdge = nextEdge) != edge0);
                        smartVertexAngles[vert.myIndex()] = angOfBiggestGap;
                    }
                }



                if (true)
                {
                    Mesh.Vertex verts[] = mesh.verts;
                    FORI (iVert, verts.length)
                    {
                        double x = verts[iVert].x;
                        double y = verts[iVert].y;
                        double ang;
                        if (trySmartVertexAngles)
                        {
                            ang = smartVertexAngles[iVert];
                        }
                        else
                        {
                            ang = Math.random() * 2*Math.PI;
                        }
                        double offr = 5/mg.getScaleX(); // pixels
                        double offx = offr*Math.cos(ang);
                        double offy = offr*Math.sin(ang);
                        double offmax = MAX(ABS(offx),ABS(offy));

                        mg.drawString("v"+iVert,
                                      x+offx,
                                      y+offy,
                                      -offx/offmax, offy/offmax);
                    }
                }

                if (false) // edges are too busy, maybe should be separate option
                {
                    Mesh.Edge edges[] = mesh.edges;
                    FORI (iEdge, edges.length)
                    {
                        Mesh.Vertex v0 = edges[iEdge].initialVertex();
                        Mesh.Vertex v1 = edges[iEdge].finalVertex();
                        double x = (v0.x+v1.x)/2;
                        double y = (v0.y+v1.y)/2;
                        double ang = Math.PI/2 + Math.atan2(v1.y-v0.y, v1.x-v0.x);
                        double offr = 2/mg.getScaleX(); // pixels
                        double offx = offr*Math.cos(ang);
                        double offy = offr*Math.sin(ang);
                        double offmax = MAX(ABS(offx),ABS(offy));
                        mg.drawString("e"+iEdge,
                                      x+offx,
                                      y+offy,
                                      -offx/offmax, offy/offmax);
                    }
                }
            }

            if (doShowPositiveOrthantnessVisualization)
            {
                int nPoints = 5000;
                int nLabels = 100;
                double M[][] = new double[3][3];
                {
                    // XXX should add a function to VecMath for random orthonormal matrix?
                    FORI (i, 2)
                    FORI (j, 3)
                        M[i][j] = 2*Math.random() - 1.;
                    VecMath.normalize(M[0], M[0]);
                    VecMath.vpsxv(M[1],
                                  M[1],
                                  -VecMath.dot(M[0], M[1]),
                                  M[0]);
                    VecMath.normalize(M[1], M[1]);
                    VecMath.vxv3(M[2], M[0], M[1]);
                }

                double v[] = new double[3];
                double Mv[] = new double[3];
                FORI (iPoint, nLabels+nPoints)
                {
                    VecMath.random(v);

                    if (iPoint == 0 || iPoint == nLabels+nPoints-1)
                        VecMath.fillvec(v, 1.);
                    else if (iPoint == 1 || iPoint == nLabels+nPoints-2)
                        VecMath.fillvec(v, -1);


                    VecMath.normalize(v, v);
                    VecMath.mxv(Mv, M, v);
                    if (Mv[2] < 0.)
                    {
                        VecMath.sxv(v, -1., v);
                        VecMath.sxv(Mv, -1., Mv);
                    }
                    double goodness = VecMath.positiveOrthantness(v, true); // true means use "synopsis"
                    //double incrDegrees = 10.;
                    double incrDegrees = 5.;
                    double dN = goodness * 180 / Math.PI / incrDegrees;
                    int iN = (int)Math.round(dN);
                    if (iPoint <= 1
                     || iPoint >= nLabels+nPoints-2
                     || ABS(iN-dN) < .01)
                    {
                        if (iN == 0)
                            mg.setColor(java.awt.Color.red);
                        else if (iN % 2 == 0)
                            mg.setColor(java.awt.Color.green);
                        else
                            mg.setColor(java.awt.Color.blue);

                        if (iPoint == 0
                         || iPoint == nLabels+nPoints-1)
                            mg.drawString(""+(dN*incrDegrees),
                                          Mv[0],Mv[1], -1., 1.);
                        else if (iPoint < nLabels)
                            mg.drawString(""+(int)Math.round(dN*incrDegrees),
                                          Mv[0],Mv[1], -1., 1.);
                        else
                            mg.drawPoint(Mv[0],Mv[1], 1);
                    }
                    else
                        iPoint--; // cancel loop iteration
                }
            }


            if (g != frontBufferGraphics)
            {
                frontBufferGraphics.drawImage(backBufferImage, 0, 0, this);
            }

	    if (eventVerbose >= 1) System.out.println("out paint");
	} // paint

        private void makeSureBackBufferIsRight()
        {
            if (doDoubleBuffer)
            {
                java.awt.Dimension size = getSize();
                if (backBufferImage == null
                 || backBufferImage.getWidth(this) != size.width
                 || backBufferImage.getHeight(this) != size.height)
                {
                    if (eventVerbose >= 1)
                    {
                        System.out.println("Creating back buffer " + size.width + "x" + size.height);
                    }
                    backBufferImage = createImage(size.width, size.height);
                }
            }
            else
                backBufferImage = null;
        } // makeSureBackBufferIsRight


    //
    // Definition of stuff for this particular app...
    //
        private static class Mesh
        {
            public String toString()
            {
                StringBuffer sb = new StringBuffer();
                sb.append(""+verts.length+" verts:\n");
                FORI (iVert, verts.length)
                    sb.append("    "+verts[iVert].x+" "+verts[iVert].y+" "+verts[iVert].h+"\n");
                sb.append(""+edges.length+" edges:\n");
                FORI (iEdge, edges.length)
                    sb.append("    v"+edges[iEdge].initialVertex().myIndex()+" -> v"+edges[iEdge].finalVertex().myIndex()+"\n");
                return sb.toString();
            }

            public class Vertex
            {
                public double x, y, h;
                private int _myIndex = -1;
                public Vertex(double x, double y, double h)
                {
                    this.x = x;
                    this.y = y;
                    this.h = h;
                    verts = (Vertex[])Arrays.append(verts, this);
                    fixVertIndices(verts.length-1);
                }

                public int myIndex()
                {
                    //return Arrays.indexOfUsingEqualsSymbol(verts, this);
                    return _myIndex;
                }
            } // public class Vertex
            public class Edge
            {
                private Vertex _initialVertex;
                private Edge _opposite; // opposite edge
                private Edge _next; // next edge CCW around the face to my left
                private Edge _prev; // prev edge (next edge CW) around the face to my left
                private int _myIndex = -1;

                public Edge(boolean andBack)
                {
                    this._myIndex = -1; // will get fixed
                    edges = (Edge[])Arrays.append(edges, this);
                    fixEdgeIndices(edges.length-1);
                    if (andBack)
                    {
                        Edge opposite = new Edge(false);
                        setOpposite(opposite, true);
                    }
                }

                //
                // Accessor methods...
                //
                public Vertex initialVertex()
                {
                    return _initialVertex;
                }
                public Edge opposite()
                {
                    return _opposite;
                }
                public Edge next()
                {
                    return _next;
                }
                public Edge prev()
                {
                    return _prev;
                }

                public void setInitialVertex(Vertex v)
                {
                    _initialVertex = v;
                }

                public void setOpposite(Edge opposite, boolean andBack)
                {
                    _opposite = opposite;
                    if (andBack)
                        _opposite.setOpposite(this, false);
                }
                public void setNext(Edge next, boolean andBack)
                {
                    _next = next;
                    if (andBack)
                        next.setPrev(this, false);
                }
                public void setPrev(Edge prev, boolean andBack)
                {
                    _prev = prev;
                    if (andBack)
                        prev.setNext(this, false);
                }

                //
                // Helper methods...
                // From the caller's point of view,
                // these are just like the accessor methods
                //
                public Vertex finalVertex()
                {
                    return _opposite._initialVertex;
                }


                public int myIndex()
                {
                    //return Arrays.indexOfUsingEqualsSymbol(edges, this);
                    return _myIndex;
                }
            } // public class Edge

            // Called whenever verts array changes
            private void fixVertIndices(int i0)
            {
                for (int iVert = i0; iVert < verts.length; ++iVert)
                    verts[iVert]._myIndex = iVert;
            }
            // Called whenever edges array changes
            private void fixEdgeIndices(int i0)
            {
                for (int iEdge = i0; iEdge < edges.length; ++iEdge)
                    edges[iEdge]._myIndex = iEdge;
            }

            public void sanityCheck()
            {
                boolean sawVertAsInitial[] = new boolean[verts.length]; // all false
                boolean sawEdgeAsOpposite[] = new boolean[edges.length]; // all false
                boolean sawEdgeAsNext[] = new boolean[edges.length]; // all false
                boolean sawEdgeAsPrev[] = new boolean[edges.length]; // all false
                FORI (iEdge, edges.length)
                {
                    Edge e = edges[iEdge];
                    assert(e.myIndex() == iEdge);
                    assert(e.initialVertex() != null);
                    assert(e.opposite() != null);
                    assert(e.opposite() != e);
                    assert(e.initialVertex() != null);
                    assert(e.next() != null);
                    assert(e.prev() != null);
                    assert(e.opposite().opposite() == e);
                    assert(e.next().prev() == e);
                    assert(e.prev().next() == e);

                    // XXX use hash table if going to do this on big things
                    int initialVertIndex = Arrays.indexOfUsingEqualsSymbol(verts, e.initialVertex());
                    int oppositeIndex = Arrays.indexOfUsingEqualsSymbol(edges, e.opposite());
                    int nextIndex = Arrays.indexOfUsingEqualsSymbol(edges, e.next());
                    int prevIndex = Arrays.indexOfUsingEqualsSymbol(edges, e.prev());
                    assert(initialVertIndex != -1);
                    assert(oppositeIndex != -1);
                    assert(nextIndex != -1);
                    assert(prevIndex != -1);

                    // Okay for a vert to be initial more than once...
                    sawVertAsInitial[initialVertIndex] = true;

                    // But not the others...
                    assert(!sawEdgeAsOpposite[oppositeIndex]);
                    sawEdgeAsOpposite[oppositeIndex] = true;
                    assert(!sawEdgeAsNext[nextIndex]);
                    sawEdgeAsNext[nextIndex] = true;
                    assert(!sawEdgeAsPrev[prevIndex]);
                    sawEdgeAsPrev[prevIndex] = true;
                }

                FORI (iVert, verts.length)
                {
                    assert(verts[iVert].myIndex() == iVert);
                    if (false) // can have isolated verts
                        assert(sawVertAsInitial[iVert]);
                }
                FORI (iEdge, edges.length)
                {
                    assert(sawEdgeAsOpposite[iEdge]);
                    assert(sawEdgeAsNext[iEdge]);
                    assert(sawEdgeAsPrev[iEdge]);
                }
            } // sanityCheck




            /*                    ^
                 insertThisEdge   | beforeThisEdge
                <-----------------*
                                 /|\
                                / | \
            */
            public void insertEdgeBefore(Edge insertThisEdge, Edge beforeThisEdge)
            {
                if (nonEventVerbose >= 1)
                    System.out.println("        In insertEdgeBefore(insertThisEdge="+insertThisEdge.myIndex()+", beforeThisEdge="+beforeThisEdge.myIndex()+"");
                beforeThisEdge.prev().setNext(insertThisEdge, true);
                insertThisEdge.opposite().setNext(beforeThisEdge, true);
                insertThisEdge.setInitialVertex(beforeThisEdge.initialVertex());
                if (nonEventVerbose >= 1)
                    System.out.println("        Out insertEdgeBefore(insertThisEdge="+insertThisEdge.myIndex()+", beforeThisEdge="+beforeThisEdge.myIndex()+"");
            }
            public void addWhisker(Edge beforeThisEdge,
                                   Vertex v) // to this vertex
            {
                Edge e = new Edge(true);
                e.opposite().setInitialVertex(v);
                e.setNext(e.opposite(), true);
                insertEdgeBefore(e, beforeThisEdge);
            }
            public void addDiagonal(Edge beforeThisEdge, Edge beforeThatEdge)
            {
                if (nonEventVerbose >= 1)
                    System.out.println("    In addDiagonal(beforeThisEdge="+beforeThisEdge.myIndex()+", beforeThatEdge="+beforeThatEdge.myIndex()+"");
                Edge e = new Edge(true);
                insertEdgeBefore(e, beforeThisEdge);
                insertEdgeBefore(e.opposite(), beforeThatEdge);
                if (nonEventVerbose >= 1)
                    System.out.println("    Out addDiagonal(beforeThisEdge="+beforeThisEdge.myIndex()+", beforeThatEdge="+beforeThatEdge.myIndex()+"");
            }
            public void swapDiagonal(Edge e)
            {
                if (e.next().next().next() != e
                 || e.opposite().next().next().next() != e.opposite())
                {
                    System.out.println("    Can't swap diagonal, it's not on a quad");
                    return;
                }

                Edge beforeThisEdge = e.prev();
                Edge beforeThatEdge = e.opposite().prev();

                //
                // Another subtle thing to check...
                // Make sure the other diagonal doesn't
                // already exist.
                //
                {
                    Vertex v0 = beforeThisEdge.initialVertex();
                    Vertex v1 = beforeThatEdge.initialVertex();
                    // XXX could do this faster by walking around the vert,
                    // XXX but whatever
                    FORI (iEdge, edges.length)
                    {
                        if (edges[iEdge].initialVertex() == v0
                         && edges[iEdge].finalVertex() == v1)
                        {
                            System.out.println("    Can't swap diagonal, the other diagonal already exists");
                            return;
                        }
                    }
                }

                deleteEdge(e);
                addDiagonal(beforeThisEdge, beforeThatEdge);
            }
            public void addEdgeBetweenTwoIsolatedVertices(Vertex v0, Vertex v1)
            {
                Edge e = new Edge(true);
                e.setInitialVertex(v0);
                e.opposite().setInitialVertex(v1);
                e.setNext(e.opposite(), true);
                e.setPrev(e.opposite(), true);
            }
            public void addIsolatedVertex(double x, double y, double h)
            {
                new Vertex(x,y,h); // adds itself to verts
            }
            // This is the "kis" operation, the dual of truncating a vertex.
            public void kisIsolatedVertex(Vertex v, Edge someEdgeOnFace)
            {
                if (nonEventVerbose >= 1)
                    System.out.println("In kis(v="+v.myIndex()+", someEdgeOnFac="+someEdgeOnFace.myIndex()+"");
                //
                // Start by attaching a single whisker to the new vertex...
                //
                if (nonEventVerbose >= 1)
                    System.out.println("    adding a whisker from edge "+someEdgeOnFace.myIndex()+" to vert "+v.myIndex());
                addWhisker(someEdgeOnFace, v);
                if (nonEventVerbose >= 1)
                {
                    System.out.println("    did that at least.");
                    PRINT(this);
                }

                //
                // Now fill in with triangles,
                // connecting everything to the new vertex v.
                //
                while (someEdgeOnFace.next()
                                     .next()
                                     .next() != someEdgeOnFace)
                {
                    if (nonEventVerbose >= 1)
                        System.out.println("    adding diagonal from start of edge "+someEdgeOnFace.prev().myIndex()+" to start of edge "+someEdgeOnFace.prev().prev().prev().myIndex()+"");
                    addDiagonal(someEdgeOnFace.prev(),
                                someEdgeOnFace.prev()
                                              .prev()
                                              .prev());
                    if (nonEventVerbose >= 1)
                    {
                        System.out.println("    did that diagonal.");
                        PRINT(this);
                    }
                }
                if (nonEventVerbose >= 1)
                    System.out.println("Out kis(v="+v.myIndex()+", someEdgeOnFac="+someEdgeOnFace.myIndex()+"");
            }
            public void deleteEdge(Edge e)
            {
                e.prev().setNext(e.opposite().next(), true);
                e.opposite().prev().setNext(e.next(), true);
                /*
                assert(e.next() == e.opposite());
                assert(e.prev() == e.opposite());
                */
                int i = e.myIndex();
                edges = (Edge[])Arrays.concat(Arrays.subarray(edges,0,i), Arrays.subarray(edges,i+1,edges.length-i-1)); // XXX should be Arrays.remove when it exists
                fixEdgeIndices(i);

                int j = e.opposite().myIndex();
                edges = (Edge[])Arrays.concat(Arrays.subarray(edges,0,j), Arrays.subarray(edges,j+1,edges.length-j-1)); // XXX should be Arrays.remove when it exists
                fixEdgeIndices(j);
            }
            public void deleteVertex(Vertex v)
            {
                FORI (iEdge, edges.length)
                {
                    if (edges[iEdge].initialVertex() == v
                     || edges[iEdge].finalVertex() == v)
                    {
                        deleteEdge(edges[iEdge]);
                        iEdge--; // so when we incrememnt we get back to here
                    }
                }
                int iVert = v.myIndex();
                verts = (Vertex[])Arrays.concat(Arrays.subarray(verts,0,iVert), Arrays.subarray(verts,iVert+1,verts.length-iVert-1));
                fixVertIndices(iVert);
            }

            public int indexOfClosestVert(double x, double y)
            {
                double closestDistSqrd = Double.POSITIVE_INFINITY;
                int closestVertIndex = -1;
                FORI (iVert, verts.length)
                {
                    double thisDistSqrd = SQR(verts[iVert].x-x)
                                        + SQR(verts[iVert].y-y);
                    if (thisDistSqrd < closestDistSqrd)
                    {
                        closestDistSqrd = thisDistSqrd;
                        closestVertIndex = iVert;
                    }
                }
                return closestVertIndex; // -1 if none
            } // indexOfClosestVert

            public int indexOfClosestEdge(double x, double y)
            {
                double closestDistSqrd = Double.POSITIVE_INFINITY;
                int closestEdgeIndex = -1;
                FORI (iEdge, edges.length)
                {
                    double thisDistSqrd = distSqrdFromPointToSeg(x,y,
                                             edges[iEdge].initialVertex().x,
                                             edges[iEdge].initialVertex().y,
                                             edges[iEdge].finalVertex().x,
                                             edges[iEdge].finalVertex().y);
                    if (thisDistSqrd < closestDistSqrd)
                    {
                        closestDistSqrd = thisDistSqrd;
                        closestEdgeIndex = iEdge;
                    }
                }
                return closestEdgeIndex; // -1 if none
            } // indexOfClosestEdge

            public double[] findOptimalVertexHeights(int optimizationType)
            {
                if (verts.length < 3)
                    return new double[verts.length]; // zeros

                if (nonEventVerbose >= 1)
                    System.out.println("In findOptimalVertexHeights");

                int nDependentVerts = 3;
                int dependentVertIndices[] = {0,1,2};
                // Prefer the triangle that contains the origin...
                {
                    FORI (iEdge, edges.length)
                    {
                        Edge edge = edges[iEdge];
                        if (edge.next().next().next() != edge)
                            continue;
                        Vertex v0 = edge.initialVertex();
                        Vertex v1 = edge.next().initialVertex();
                        Vertex v2 = edge.next().next().initialVertex();
                        if (twiceTriArea(0,0,
                                         v0.x,v0.y,
                                         v1.x,v1.y) >= 0
                         && twiceTriArea(0,0,
                                         v1.x,v1.y,
                                         v2.x,v2.y) >= 0
                         && twiceTriArea(0,0,
                                         v2.x,v2.y,
                                         v0.x,v0.y) >= 0)
                        {
                            dependentVertIndices[0] = v0.myIndex();
                            dependentVertIndices[1] = v1.myIndex();
                            dependentVertIndices[2] = v2.myIndex();
                            break; // origin is inside this tri CCW
                        }
                    }
                }

                // Figure out the desired dualEdgeLength...
                // XXX just hard code for now
                double desiredDualEdgeLength = .25;

                int edge2dualVert[] = VecMath.fillvec(edges.length, -1);
                int nDualVerts;
                {
                    nDualVerts = 0;
                    FORI (iEdge, edges.length)
                    {
                        if (edge2dualVert[iEdge] != -1)
                            continue; // already saw some other edge on this tri
                        Edge edge = edges[iEdge];
                        Edge edge1 = edge.next();
                        Edge edge2 = edge1.next();
                        boolean thisIsATri = (edge2.next() == edge);
                        if (thisIsATri)
                        {
                            edge2dualVert[iEdge] = nDualVerts;
                            edge2dualVert[edge1.myIndex()] = nDualVerts;
                            edge2dualVert[edge2.myIndex()] = nDualVerts;
                            nDualVerts++;
                        }
                    }
                }
                int edge2dualEdge[] = VecMath.fillvec(edges.length, -1);
                int nDualEdges;
                {
                    nDualEdges = 0;
                    FORI (iEdge, edges.length)
                    {
                        if (edge2dualEdge[iEdge] != -1)
                            continue; // already seen it from the opposite edge

                        Edge edge = edges[iEdge];
                        if (edge2dualVert[iEdge] != -1
                         && edge2dualVert[edge.opposite().myIndex()] != -1)
                        {
                            // Opposite edge is also on a tri
                            // that we haven't counted yet
                            edge2dualEdge[iEdge] = nDualEdges;
                            edge2dualEdge[edge.opposite().myIndex()] = nDualEdges;
                            nDualEdges++;
                        }
                    }
                }

                int dualVert2verts[][] = VecMath.fillmat(nDualVerts, 3, -1);
                int dualEdge2edge[] = VecMath.fillvec(nDualEdges, -1); // XXX not used?
                int dualEdge2dualVerts[][] = VecMath.fillmat(nDualEdges, 2, -1);
                {
                    FORI (iEdge, edges.length)
                    {
                        int iDualEdge = edge2dualEdge[iEdge];
                        if (iDualEdge != -1 // if it has a dual edge
                         && dualEdge2dualVerts[iDualEdge][0] == -1) // if we didn't already do this dual edge from the opposite
                        {
                            dualEdge2edge[iDualEdge] = iEdge;
                            dualEdge2dualVerts[iDualEdge][0] = edge2dualVert[iEdge];
                            dualEdge2dualVerts[iDualEdge][1] = edge2dualVert[edges[iEdge].opposite().myIndex()];
                        }

                        int iDualVert = edge2dualVert[iEdge];
                        if (iDualVert != -1 // if this edge is on a triangle
                         && dualVert2verts[iDualVert][0] == -1) // if we didn't already do this dual vert
                        {
                            dualVert2verts[iDualVert][0] = edges[iEdge].initialVertex().myIndex();
                            dualVert2verts[iDualVert][1] = edges[iEdge].next().initialVertex().myIndex();
                            dualVert2verts[iDualVert][2] = edges[iEdge].next().next().initialVertex().myIndex();
                        }
                    }
                    FORI (iDualVert, nDualVerts)
                        FORI (j, 3)
                            assert(dualVert2verts[iDualVert][j] != -1);

                    FORI (iDualEdge, nDualEdges)
                    {
                        assert(dualEdge2edge[iDualEdge] != -1);
                        assert(dualEdge2dualVerts[iDualEdge][0] != -1);
                        assert(dualEdge2dualVerts[iDualEdge][1] != -1);
                    }
                }


                // can optimize positions or lengths.  I think optimizing positions is more robust.
                boolean optimizingBarycentrics = optimizationType == OPTIMIZE_BARYCENTRICS_LEAST_SQUARES
                                              || optimizationType == OPTIMIZE_BARYCENTRICS_MAX_MIN
                                              || optimizationType == OPTIMIZE_BARYCENTRICS_INFINITY_NORM;
                if (optimizingBarycentrics)
                {
                    nDependentVerts = 1; // XXX not right in general, should be number of connected components maybe
                    dependentVertIndices = new int[] {0};
                }

                int nIndependentVerts = verts.length - nDependentVerts;

                if (nIndependentVerts > (optimizingBarycentrics ? 2*nDualVerts : nDualEdges))
                {
                    //PRINT((optimizingBarycentrics ? 2*nDualVerts : nDualEdges));
                    System.out.println("Out findOptimalVertexHeights (too many independent verts, it's underconstrained)");
                    return new double[verts.length]; // zeros
                }

                int vert2independentVert[] = new int[verts.length];
                int independentVert2verts[] = new int[nIndependentVerts];
                {
                    int iIndependentVert = 0;
                    FORI (iVert, verts.length)
                    {
                        if (Arrays.indexOf(dependentVertIndices, iVert) == -1)
                        {
                            vert2independentVert[iVert] = iIndependentVert;
                            independentVert2verts[iIndependentVert] = iVert;
                            iIndependentVert++;
                        }
                        else
                            vert2independentVert[iVert] = -1;
                    }
                    assert(iIndependentVert == nIndependentVerts);
                }


                int nSamples = nIndependentVerts+1;
                double sampleResultVerts[][][] = new double[nSamples][nDualVerts][2];
                {
                    double sampleHeights[][] = new double[nIndependentVerts+1][nIndependentVerts];
                    VecMath.identitymat(sampleHeights); // the unit basis vectors, and a row of zeros at the end

                    FORI (iSample, nSamples)
                    {
                        //
                        // Input sampleHeights[iSample]
                        // and get out sampleResultVerts[iSample]
                        //
                        FORI (iDualVert, nDualVerts)
                        {
                            int iVert0 = dualVert2verts[iDualVert][0];
                            int iVert1 = dualVert2verts[iDualVert][1];
                            int iVert2 = dualVert2verts[iDualVert][2];
                            int iIndependentVert0 = vert2independentVert[iVert0];
                            int iIndependentVert1 = vert2independentVert[iVert1];
                            int iIndependentVert2 = vert2independentVert[iVert2];
                            double h0 = (iIndependentVert0 == -1 ? 0. : sampleHeights[iSample][iIndependentVert0]);
                            double h1 = (iIndependentVert1 == -1 ? 0. : sampleHeights[iSample][iIndependentVert1]);
                            double h2 = (iIndependentVert2 == -1 ? 0. : sampleHeights[iSample][iIndependentVert2]);
                            Vertex v0 = verts[iVert0];
                            Vertex v1 = verts[iVert1];
                            Vertex v2 = verts[iVert2];
                            SolveForDualPoint(v0.x,v0.y,h0 - .5 * (SQR(v0.x)+SQR(v0.y)),
                                              v1.x,v1.y,h1 - .5 * (SQR(v1.x)+SQR(v1.y)),
                                              v2.x,v2.y,h2 - .5 * (SQR(v2.x)+SQR(v2.y)),
                                              sampleResultVerts[iSample][iDualVert]);
                        }
                    }
                    //PRINTMAT(sampleHeights);
                }

                double solvedHeights[];

                if (optimizingBarycentrics)
                {
                    // We want to maximize the minimum barycentric occurring
                    // anywhere in the result.
                    double sampleBarycentrics[][][] = new double[nSamples][nDualVerts][3];
                    FORI (iSample, nSamples)
                    {
                        FORI (iDualVert, nDualVerts)
                        {
                            int tri[] = dualVert2verts[iDualVert];
                            double wholeArea = twiceTriArea(verts[tri[0]].x, verts[tri[0]].y,
                                                            verts[tri[1]].x, verts[tri[1]].y,
                                                            verts[tri[2]].x, verts[tri[2]].y);
                            double dualVert[] = sampleResultVerts[iSample][iDualVert];
                            FORI (iVertOnTri, 3)
                            {
                                sampleBarycentrics[iSample][iDualVert][iVertOnTri] =
                                        twiceTriArea(dualVert[0], dualVert[1],
                                                     verts[tri[(iVertOnTri+1)%3]].x,
                                                     verts[tri[(iVertOnTri+1)%3]].y,
                                                     verts[tri[(iVertOnTri+2)%3]].x,
                                                     verts[tri[(iVertOnTri+2)%3]].y)
                                      / wholeArea;
                            }
                        }
                    }
                    double sampleResultVectors[][] = (double[][])Arrays.flatten(sampleBarycentrics, 1, 2);
                    double desiredResultVector[] = VecMath.fillvec(sampleResultVectors[0].length,
                                        optimizationType==OPTIMIZE_BARYCENTRICS_MAX_MIN ? 0. : 1./3.);

                    //
                    // Find C and d
                    // such that x -> C x - d
                    // maps heights to barycentrics.
                    //

                    //
                    // Column i of C is the result from the i'th basis sample,
                    // minus the result from the 0 vector.
                    //
                    double C[][] = new double[sampleResultVectors.length-1][sampleResultVectors[0].length]; // start transposed...
                    FORI (iSample, sampleResultVectors.length-1)
                        VecMath.vmv(C[iSample],
                                    sampleResultVectors[iSample],
                                    sampleResultVectors[sampleResultVectors.length-1]);
                    C = VecMath.transpose(C);

                    //
                    // d is the desired result minus the result from the zero vector.
                    //
                    double d[] = VecMath.vmv(desiredResultVector,
                                             sampleResultVectors[sampleResultVectors.length-1]);

                    // XXX could get clean up the dependent/intependent lookup tables if we want by expressing the independent vertex's constraints here...
                    double A[][] = {}; // no equality constraints
                    double b[] = {}; // no equality constraints

                    LinearProgramming.debugLevel = 0;

                    if (optimizationType == OPTIMIZE_BARYCENTRICS_LEAST_SQUARES)
                    {
                        if (nonEventVerbose >= 1)
                        {
                            System.out.print("    Solving barycentrics least squares from all 1/3's...");
                            System.out.flush();
                        }
                        solvedHeights = VecMath.invmxv(C,d);
                        if (nonEventVerbose >= 1)
                            System.out.println("    done.");
                    }
                    else if (optimizationType == OPTIMIZE_BARYCENTRICS_INFINITY_NORM)
                    {
                        solvedHeights = new double[sampleResultVectors.length-1];
                        if (nonEventVerbose >= 1)
                        {
                            System.out.print("    Solving barycentrics infinity norm from all 1/3's...");
                            System.out.flush();
                        }
                        int result = LinearProgramming.LInfinitySolve(solvedHeights, C,d);
                        if (nonEventVerbose >= 1)
                            System.out.println("    done.");
                        if (result != 0)
                            System.out.println("WARNING: LPSolve returned "+result);
                    }
                    else if (optimizationType == OPTIMIZE_BARYCENTRICS_MAX_MIN)
                    {
                        solvedHeights = new double[sampleResultVectors.length-1];
                        if (nonEventVerbose >= 1)
                        {
                            System.out.print("    Solving barycentrics maximizing minimal element...");
                            System.out.flush();
                        }
                        int result = LinearProgramming.maximizeMinimum(solvedHeights,
                                                                       A, b,
                                                                       C, d);
                        if (nonEventVerbose >= 1)
                            System.out.println("    done.");
                        if (false)
                        {
                            PRINTMAT(A);
                            PRINTVEC(b);
                            PRINTMAT(C);
                            PRINTVEC(d);
                            PRINT(result);
                            PRINTVEC(solvedHeights);
                        }
                        if (result != 0)
                            System.out.println("WARNING: LPSolve returned "+result);
                    }
                    else
                    {
                        assert(false);
                    }
                }
                else // optimize lengths
                {
                    double sampleResultVectors[][];
                    double desiredResultVector[];

                    {
                        double sampleResultLengths[][] = new double[nSamples][nDualEdges];
                        FORI (iSample, nSamples)
                        {
                            //
                            // Calculate sampleResultLengths[iSample]
                            // from sampleResultVerts[iSample]
                            //
                            FORI (iDualEdge, nDualEdges)
                            {
                                sampleResultLengths[iSample][iDualEdge] =
                                    VecMath.dist(sampleResultVerts[iSample][dualEdge2dualVerts[iDualEdge][0]],
                                                 sampleResultVerts[iSample][dualEdge2dualVerts[iDualEdge][1]]);
                                // Need to figure out the sign.
                                // If dual edge length is positive,
                                // it will point from the original edge's left face
                                // to the original edge's right face.
                                // So the dual edge dir cross the original edge dir
                                // should be > 0.
                                double dualEdgeDir[] = VecMath.vmv(sampleResultVerts[iSample][dualEdge2dualVerts[iDualEdge][1]], sampleResultVerts[iSample][dualEdge2dualVerts[iDualEdge][0]]);
                                double originalEdgeDir[] = VecMath.vmv(
                                    new double[] {edges[dualEdge2edge[iDualEdge]].finalVertex().x,
                                                  edges[dualEdge2edge[iDualEdge]].finalVertex().y},
                                    new double[] {edges[dualEdge2edge[iDualEdge]].initialVertex().x,
                                                  edges[dualEdge2edge[iDualEdge]].initialVertex().y}
                                );
                                if (VecMath.vxv2(dualEdgeDir, originalEdgeDir) < 0)
                                {
                                    sampleResultLengths[iSample][iDualEdge] *= -1;
                                }
                            }
                        }
                        //PRINTMAT(sampleResultLengths);
                        sampleResultVectors = sampleResultLengths;
                    }
                    desiredResultVector = VecMath.fillvec(nDualEdges, desiredDualEdgeLength);

                    // the following is general, could optimize something else if desired
                    {

                        //
                        // Row i of A is the result from the i'th basis sample,
                        // minus the result from the 0 vector.
                        //
                        double A[][] = new double[sampleResultVectors.length-1][sampleResultVectors[0].length];
                        FORI (iSample, sampleResultVectors.length-1)
                            VecMath.vmv(A[iSample],
                                        sampleResultVectors[iSample],
                                        sampleResultVectors[sampleResultVectors.length-1]);
                        //
                        // b is the desired result
                        // minus the result from the 0 vector.
                        //
                        double b[] = VecMath.vmv(desiredResultVector,
                                                 sampleResultVectors[sampleResultVectors.length-1]);

                        //PRINTMAT(A);
                        //PRINTVEC(b);

                        double leastSquaresSolution[];
                        if (optimizationType == OPTIMIZE_LENGTHS_LEAST_SQUARES)
                        {
                            if (nonEventVerbose >= 1)
                            {
                                System.out.print("    Solving for lengths least squares from all "+desiredDualEdgeLength+" ...");
                                System.out.flush();
                            }
                            leastSquaresSolution = VecMath.vxinvm(b, A);
                            if (nonEventVerbose >= 1)
                                System.out.println("    done.");
                        }
                        else if (optimizationType == OPTIMIZE_LENGTHS_INFINITY_NORM)
                        {
                            leastSquaresSolution = new double[sampleResultVectors.length-1];
                            if (nonEventVerbose >= 1)
                            {
                                System.out.print("    Solving lengths infinity norm from all .25's...");
                                System.out.flush();
                            }
                            int result = LinearProgramming.LInfinitySolve(leastSquaresSolution, VecMath.transpose(A),b);
                            if (nonEventVerbose >= 1)
                                System.out.println("    done.");
                            if (result != 0)
                                System.out.println("WARNING: LPSolve returned "+result);
                        }
                        else
                            assert(false);

                        //PRINTVEC(leastSquaresSolution);
                        double gotLengths[] = VecMath.vxm(leastSquaresSolution, A);
                        //PRINTVEC(gotLengths);

                        boolean doCheckLeastSquaresSolution = false; // I'm convinced it works
                        if (doCheckLeastSquaresSolution)
                        {
                            System.out.print("    Checking");
                            System.out.flush();

                            int nTests = 100;
                            FORI (iTest, nTests)
                            {
                                System.out.print(".");

                                //
                                // Perturb each element of the solution
                                // by a random amount
                                //
                                double foo[] = VecMath.copyvec(leastSquaresSolution);
                                double dir[] = VecMath.random(leastSquaresSolution.length);
                                VecMath.normalize(dir);
                                double fudges[] = {.01, -.01};
                                FORI (iFudge, fudges.length)
                                {
                                    VecMath.vpsxv(foo, leastSquaresSolution, fudges[iFudge], dir);
                                    double bar[] = VecMath.vxm(foo, A);
                                    //PRINT(VecMath.dist(bar, b));
                                    if (foo.length > 0)
                                        assert(VecMath.dist(gotLengths, b) < VecMath.dist(bar, b));
                                }
                            }
                            System.out.println("    done.");
                        }
                        solvedHeights = leastSquaresSolution;
                    }
                } // optimize lengths

                assert(solvedHeights.length == independentVert2verts.length);
                double optimalVertexHeights[] = new double[verts.length];
                FORI (iIndex, independentVert2verts.length)
                {
                    optimalVertexHeights[independentVert2verts[iIndex]] = solvedHeights[iIndex];
                }
                FORI (iDependentVert, dependentVertIndices.length)
                    optimalVertexHeights[dependentVertIndices[iDependentVert]] = 0.;

                if (nonEventVerbose >= 1)
                    System.out.println("Out findOptimalVertexHeights");

                return optimalVertexHeights;
            } // findOptimalVertexHeights

            private Mesh()
            {
            }

            private Mesh(double vertPositions[][],
                         int faceIndices[][])
            {
                FORI (i, vertPositions.length)
                {
                    // adds itself to verts...
                    new Vertex(vertPositions[i][0],  // x
                               vertPositions[i][1],  // y
                               vertPositions[i].length == 2 ? 0 : vertPositions[i][2]); // h
                }
                java.util.Hashtable vertIndsToEdge = new java.util.Hashtable();
                FORI (i, faceIndices.length)
                FORI (j, faceIndices[i].length)
                {
                    int v0 = faceIndices[i][j];
                    int v1 = faceIndices[i][(j+1)%faceIndices[i].length];
                    assert(INRANGE(0 <=, v0, < vertPositions.length));
                    assert(INRANGE(0 <=, v1, < vertPositions.length));
                    String v0_v1 = ""+v0+"_"+v1;
                    String v1_v0 = ""+v1+"_"+v0;
                    if (vertIndsToEdge.get(v0_v1) == null)
                    {
                        Edge edge = new Edge(true); // adds itself, and opposite, to verts
                        vertIndsToEdge.put(v0_v1, edge);
                        vertIndsToEdge.put(v1_v0, edge.opposite());
                        edge.setInitialVertex(verts[v0]);
                        edge.opposite().setInitialVertex(verts[v1]);
                    }
                }
                FORI (i, faceIndices.length)
                FORI (j, faceIndices[i].length)
                {
                    int v0 = faceIndices[i][j];
                    int v1 = faceIndices[i][(j+1)%faceIndices[i].length];
                    int v2 = faceIndices[i][(j+2)%faceIndices[i].length];
                    String v0_v1 = ""+v0+"_"+v1;
                    String v1_v2 = ""+v1+"_"+v2;
                    Edge e01 = (Edge)vertIndsToEdge.get(v0_v1);
                    Edge e12 = (Edge)vertIndsToEdge.get(v1_v2);
                    e01.setNext(e12, true);
                }
            } // Mesh from vertex positions and face indices

            private Mesh(Mesh original)
            {
                FORI (i, original.verts.length)
                    new Vertex(original.verts[i].x,
                               original.verts[i].y,
                               original.verts[i].h); // adds itself to verts
                FORI (i, original.edges.length)
                    new Edge(false); // adds itself to edges
                assert(verts.length == original.verts.length);
                assert(edges.length == original.edges.length);
                java.util.Hashtable oldToNew = new java.util.Hashtable();
                FORI (i, verts.length)
                    oldToNew.put(original.verts[i], verts[i]);
                FORI (i, edges.length)
                    oldToNew.put(original.edges[i], edges[i]);
                FORI (i, edges.length)
                {
                    edges[i]._initialVertex = (Vertex)oldToNew.get(original.edges[i]._initialVertex);
                    edges[i]._opposite = (Edge)oldToNew.get(original.edges[i]._opposite);
                    edges[i]._prev = (Edge)oldToNew.get(original.edges[i]._prev);
                    edges[i]._next = (Edge)oldToNew.get(original.edges[i]._next);
                }
            } // Mesh copy constructor

            // XXX should really make these vectors or something,
            // XXX so that all operations will be constant time.
            public Vertex verts[] = {};
            public Edge edges[] = {};
        } // class Mesh

        // Holds the information needed to undo and redo a mesh editing operation.
        // This implementation is very simple and inefficient;
        // it just stores a complete copy of the mesh before and after
        // the editing operation.
        private static class UndoItem
        {
            public static class State
            {
                public Mesh mesh;
                public boolean doOptimize;
                public int optimizationTypeIndex;
                public State(Mesh mesh, boolean doOptimize, int optimizationTypeIndex)
                {
                    this.mesh = new Mesh(mesh);
                    this.doOptimize = doOptimize;
                    this.optimizationTypeIndex = optimizationTypeIndex;
                }
            }
            public State before;
            public State after;
            public UndoItem(State before, State after)
            {
                this.before = before;
                this.after = after;
            }
        } // class UndoItem


        /*
            Given:
                x0,y0,h0
                x1,y1,h1
                x2,y2,h2
            representing an infinitesimal triangle
            whose vertices are infinitesimally-squared away from the unit sphere:
                x0 eps, y0 eps, 1 + h0 eps^2
                x1 eps, y1 eps, 1 + h1 eps^2
                x2 eps, y2 eps, 1 + h2 eps^2
            we want to find x,y,h
            representing the point:
                x eps, y eps, h eps^2
            that is the intersection point of the 3 planes
            whose closest-points-to-origin are the original 3 points.
            If we write this out, it's equivalent to solving:
                [x0 y0 1] [x]   [x0^2 + y0^2 + h0]
                [x1 y1 1] [y] = [x1^2 + y1^2 + h1]
                [x2 y2 1] [h]   [x0^2 + y2^2 + h2]
        */
        private static void SolveForDualPoint(double x0, double y0, double h0,
                                              double x1, double y1, double h1,
                                              double x2, double y2, double h2,
                                              double result[])
        {
            double M[][] = {
                {x0,y0,1},
                {x1,y1,1},
                {x2,y2,1},
            };
            double b[] = {
                x0*x0 + y0*y0 + h0,
                x1*x1 + y1*y1 + h1,
                x2*x2 + y2*y2 + h2,
            };
            if (result.length == 3)
                VecMath.invmxv(result,M,b);
            else // result.length == 2, just copy the first two
                VecMath.copyvec(result, VecMath.invmxv(M,b));

        } // SolveForDualPoint

        // Calculate the angle C, opposite side c,
        // given side lengths a, b, c,
        // using c^2 = a^2 + b^2 - 2*a*b*cos(C)
        private static double triangleAngle(double a, double b, double c)
        {
            return Math.acos((a*a + b*b - c*c) / (2*a*b));
        }

        // Find vertex v2 that completes the triangle with given edge lengths,
        // such that v0,v1,v2 are CCW.
        private static double[] completeTriangle(double v0[],
                                                 double v1[],
                                                 double dist12,
                                                 double dist20)
        {
            // Make sure has only 2 entries
            v0 = new double[]{v0[0],v0[1]};
            v1 = new double[]{v1[0],v1[1]};
            double ang0 = triangleAngle(VecMath.dist(v0,v1), dist20, dist12);
            double dir01[] = VecMath.normalize(VecMath.vmv(v1,v0));
            double v2[] = VecMath.sxvpsxvpsxv(
                1.,                    v0,
                dist20*Math.cos(ang0), dir01,
                dist20*Math.sin(ang0), VecMath.xv2(dir01));
            return v2;
        } // completeTriangle

        private static double twiceTriArea(double x0, double y0,
                                           double x1, double y1,
                                           double x2, double y2)
        {
            return (x1-x0)*(y2-y0) - (x2-x0)*(y1-y0);
        }

        // eps is in linear units
        private static boolean edgesCrossOrCloseToIt(double a0x, double a0y,
                                                     double a1x, double a1y,
                                                     double b0x, double b0y,
                                                     double b1x, double b1y,
                                                     double eps)
        {
            return twiceTriArea(a0x,a0y,
                                a1x,a1y,
                                b1x,b1y)
                 * twiceTriArea(a1x,a1y,
                                a0x,a0y,
                                b0x,b0y) >= -eps*eps*eps*eps
                && twiceTriArea(b0x,b0y,
                                b1x,b1y,
                                a0x,a0y)
                 * twiceTriArea(b1x,b1y,
                                b0x,b0y,
                                a1x,a1y) >= -eps*eps*eps*eps;
        } // edgesCrossOrCloseToIt

        private static double distSqrdFromPointToSeg(double x, double y,
                                                     double x0, double y0,
                                                     double x1, double y1)
        {
            double v[] = {x-x0,y-y0};
            double v1[] = {x1-x0,y1-y0};
            if (VecMath.normsqrd(v1) == 0.)
                return VecMath.normsqrd(v);
            double t = VecMath.dot(v,v1)
                     / VecMath.dot(v1,v1);
            t = CLAMP(t, 0., 1.);
            double vprojectedOntoV1[] = VecMath.sxv(t, v1);
            return VecMath.distsqrd(v, vprojectedOntoV1);
        }


    //
    // App-specific variables...
    //
        private UndoTreeSquirrel undoTreeSquirrel = new UndoTreeSquirrel();
        private Mesh mesh = new Mesh();
        private int selectedVertIndex = -1;
        private boolean doOptimize = false;
            private static final int OPTIMIZE_BARYCENTRICS_LEAST_SQUARES = 0;
            private static final int OPTIMIZE_BARYCENTRICS_INFINITY_NORM = 1;
            private static final int OPTIMIZE_BARYCENTRICS_MAX_MIN = 2;
            private static final int OPTIMIZE_LENGTHS_LEAST_SQUARES = 3;
            private static final int OPTIMIZE_LENGTHS_INFINITY_NORM = 4;
            private static final String optimizationTypeNames[] = {
                "OPTIMIZE_BARYCENTRICS_LEAST_SQUARES from all 1/3's",
                "OPTIMIZE_BARYCENTRICS_INFINITY_NORM from all 1/3's",
                "OPTIMIZE_BARYCENTRICS_MAX_MIN",
                "OPTIMIZE_LENGTHS_LEAST_SQUARES from all .25's",
                "OPTIMIZE_LENGTHS_INFINITY_NORM from all .25's",
            };
            private static final int availableOptimizationTypes[] = {
                OPTIMIZE_BARYCENTRICS_LEAST_SQUARES,
                OPTIMIZE_BARYCENTRICS_INFINITY_NORM,
                OPTIMIZE_BARYCENTRICS_MAX_MIN,
                OPTIMIZE_LENGTHS_LEAST_SQUARES,
                OPTIMIZE_LENGTHS_INFINITY_NORM,
            };
        private int optimizationTypeIndex = 0;
        int optimizationType = availableOptimizationTypes[optimizationTypeIndex];

        private boolean doLabels = false;
        private boolean doArrowsTowardsSharpestDihedrals = true;
        private boolean doArrowsTowardsShortestEdges = true;
        private boolean doShowInsideOutDualVerts = false; // might also be nice to have option for implicit primal vertex in middle of outer face, so that dual will be single-face-bounded... and maybe ctrl-up,ctrl-down will adjust the height of that face

        private boolean doShowPositiveOrthantnessVisualization = false; // XXX total hack-- it's cool but put it somewhere else!!

    //
    // Applet-generic member variables...
    //
        private GraphicsAntiAliasingSetter graphicsAntiAliasingSetter;
        private int eventVerbose = 0; // can set with eventVerbose=1 on command line
        private static int nonEventVerbose = 0; // so static classes can refer to it
        private boolean doAntiAliasing = false;
        private boolean implementAntiAliasingInHardware = true; // XXX should have a better name for this-- really mean let java runtime do it
        private double lineThicknessInPixels = 1.;
        private boolean doDoubleBuffer = true;
        private java.awt.Image backBufferImage = null;
        private MyGraphics mostRecentGraphics = null;
        private double translateFudgeX = 0.;

        private double prevP[] = null;

    //
    // Track mouse state...
    // (I think java newer versions of java (XXX starting when?)
    // let you query from the events themselves,
    // but e.g. in 1.1 there is no way to tell whether button1
    // is down during a drag without keeping state
    //
        private boolean button1IsDown = false;
        private boolean button2IsDown = false;
        private boolean button3IsDown = false;
        private UndoItem.State stateWhenPressed = null;


    //
    // Main...
    //
    public static void main(final String args[])
    {
        System.out.println("in main");

        final java.awt.Frame frame = new java.awt.Frame("Shephards Play Applet") {
            public boolean handleEvent(java.awt.Event event)
            {
                switch(event.id)
                {
                    case java.awt.Event.WINDOW_DESTROY:
                        System.out.println("bye!");
                        // Empirically, either of the following
                        // cause the app to exit-- do both to be safe!
                        // (XXX I've heard rumors that just doing dispose()
                        //  messes up the debugger)
                        // (XXX but doing exit is evil)
                        dispose(); // hide() doesn't delete the windows
                        System.exit(0);
                        return true;
                }
                return super.handleEvent(event);
            }
        };

        // ARGH! The above no longer works in java 1.5!
        // have to use a listener I guess...
        frame.addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent we) {
                System.out.println("ciao!");
                frame.dispose(); // hide() doesn't delete the windows
                System.exit(0);
            }
        });

        final ShephardsPlayApplet applet = new ShephardsPlayApplet();

        // XXX the following seems to be necessary, or getParameter() will crash, at least in 1.4.  Want to send params from command line anyway.
        applet.setStub(new java.applet.AppletStub() {
             public void appletResize(int width, int height)
                 { /* should resize frame, but a ShephardsPlayApplet never asks to be resized */ }
             public java.applet.AppletContext getAppletContext() { return null;}             public java.net.URL getCodeBase() { return null; }
             public java.net.URL getDocumentBase() { return null; }
             public String getParameter(String name)
             {
                 // case insensitive... and unfortunately there's no
                 // startsWithIgnoreCase
                 String prefix = name.toLowerCase() + "=";
                 int i;
                 FOR (i, args.length)
                     if (args[i].toLowerCase().startsWith(prefix))
                         return args[i].substring(prefix.length());
                 return null;
             }
             public boolean isActive() { return true; }
        });

        frame.add(applet);

        applet.init();
        applet.start();

        frame.move(400, 20);
        frame.resize(512, 512);
        frame.show();

        System.out.println("out main");
    } // main
} // class ShephardsPlayApplet
