/*
Trying to make a little applet
that will let me play with triangulations with heights,
and produce the dual diagrams with heights.

For starters, always triangulates entire convex hull.
User should be able to:
    left click - add a vertex
                   - if inside a triangle, trisects the triangle
                   - if outside the convex hull, connects up
                     to all visible other vertices
    right click - delete a vertex that's on the convex hull
                  or that's only connected to three neighbors
    middle drag - move a vertex
    's' - swap a diagonal


BUGS:

TO DO:
    - when dragging a cut edge:
        - show it dragging (edge or fold)
        - legit targets should be lowlighted: good dark green, bad dark red. (only cut; I don't think this makes sense for fold)

    - showNet should go in the undo item, otherwise it's weird when you do something
      that changes it but undo doesn't change it back

    - put in dump files:
        - selected verts
        - net

    - try to maintain selection when swapping diagonals and stuff

    - think about which optimization types to retain if any
        - maybe optimization should always be max min length, but choice should be how to match scale and translate afterwards.
          Translate:
              - match overall cg of verts to cg of tris
              - match overall cg of verts to circumcenter of tris (can be tricky if degenerate)
          Scale:
              - match variance in some sense?
              - match total length?
              - match bbox?

    - improve kaleidescope:
        - detect and use center
        - detect and use complete symmetry group
        - key to increase or decrease period (requires vertex in center?)
        - snap closest image to exact image? hmm, not sure
        - mode to place new verts in kaleidescope? (draw dots at images of cursor?)

    - +/- should maybe look at undo and redo stack, and use it if possible, to save memory

    - show perpendicular of edges, somehow, so can see when and how off balance
    - mode to highlight all good ways out of given lagoon

    - animation of optimization
    - animation of swap (what was I talking about here?)
    - animation of delete vertex (maybe-- might have to triangulate the face to get this to work, which wouldn't be a bad thing)
    - key to delaunayize?
    - don't draw crap when resizing (and fix whatever other applet I got this from too)
    - figure out why stack traces show .java on top even after renumbering
    - write a generic applet to reduce pain each time
    - other mesh editing operations (split face by edge, split edge by vertex, join adjacent vertices, separate a vertex into two (but how to assign the neighbors?))  (idea: same interface as split face by edge... but only works if on two different faces... maybe connec dual verts?)
    - BUG: figure out how to make it not repaint continuously when resizing (my other appets too)
    - BUG: when only part of window gets exposed, only the exposed part gets painted?  hmm, not sure I have control over this
    - BUG: can't reconnect an isolated vertex to the rest
    - look at this, maybe clues about positive octant penalty functions...
        http://www.cs.indiana.edu/~yingfeng/ABSURDIST/javadoc/penalty/PenaltyMinimizer.html
      something about "translating into a positive orthant problem" and "optimizing over the positive orthant"
      intersection of a linear subspace witht the positive orthant
      http://projecteuclid.org/Dienst/UI/1.0/Summarize/euclid.mmj/1028988894
      The knee-jerk mapping:
      http://www.math.dartmouth.edu/~doyle/docs/jerk/jerk.pdf
*/

#include "macros.h"

// So can compile in pre-1.4,
// we use these instead of java.awt.event.MouseEvent.BUTTON1 etc.
#define java_awt_event_MouseEvent_BUTTON1 1
#define java_awt_event_MouseEvent_BUTTON2 2
#define java_awt_event_MouseEvent_BUTTON3 3


import com.donhatchsw.util.Arrays;
import com.donhatchsw.util.MyMath;
import com.donhatchsw.util.VecMath;
import com.donhatchsw.util.SortStuff;
import com.donhatchsw.util.ConvexHull;
import com.donhatchsw.util.LinearProgramming;
import com.donhatchsw.util.MergeFind;
import com.donhatchsw.util.UndoTreeSquirrel;
import com.donhatchsw.util.TriangulationOptimizer;
import com.donhatchsw.util.Minimizer;
import com.donhatchsw.util.Listenable;
import com.donhatchsw.compat.ArrayList;
import com.donhatchsw.compat.IntArrayList;
import com.donhatchsw.compat.DoubleArrayList;
import com.donhatchsw.awt.Row;
import com.donhatchsw.awt.Col;
import com.donhatchsw.awt.TablePanel;
import com.donhatchsw.awt.RowLayout;
import com.donhatchsw.awt.ColLayout;
import com.donhatchsw.awt.TableLayout;

public class ShephardsPlayApplet
    extends java.applet.Applet
{
    //
    // Utilities for applet stuff...
    //
        private String getParameterString(String paramName,
                                       String defaultValue)
        {
            String paramValueString = getParameter(paramName);
            if (paramValueString != null)
                return paramValueString;
            else
                return defaultValue;
        }
        private int getParameterInt(String paramName,
                                    int defaultValue)
        {
            String paramValueString = getParameter(paramName);
            if (paramValueString != null)
            {
                try
                {
                    return Integer.decode(paramValueString).intValue();
                }
                catch (NumberFormatException e)
                {
                    return 0;
                }
            }
            else
                return defaultValue;
        }
        private double getParameterDouble(String paramName,
                                          double defaultValue)
        {
            String paramValueString = getParameter(paramName);
            if (paramValueString != null)
            {
                try
                {
                    return Double.parseDouble(paramValueString);
                }
                catch (NumberFormatException e)
                {
                    return 0;
                }
            }
            else
                return defaultValue;
        }
        private boolean getParameterBoolean(String paramName,
                                            boolean defaultValue)
        {
            String paramValueString = getParameter(paramName);
            if (paramValueString != null)
            {
                // Too simplistic, only honors case-sensitive "true"
                //return Boolean.valueOf(paramValueString).booleanValue();

                try
                {
                    int n = Integer.decode(paramValueString).intValue();
                    return n != 0;
                }
                catch (NumberFormatException e)
                {
                    if (paramValueString.equalsIgnoreCase("true")
                     || paramValueString.equalsIgnoreCase("yes")
                     || paramValueString.equalsIgnoreCase("t")
                     || paramValueString.equalsIgnoreCase("y"))
                        return true;
                    return false;
                }
            }
            else
                return defaultValue;
        }

    //
    // Implementing Applet methods...
    //
        public ShephardsPlayApplet()
        {
            // used as "fill" argument to add()
            final java.awt.GridBagConstraints stretchx = new java.awt.GridBagConstraints(){{fill=HORIZONTAL;weightx=1.;}};
            final java.awt.GridBagConstraints stretchy = new java.awt.GridBagConstraints(){{fill=VERTICAL;weighty=1.;}};
            final java.awt.GridBagConstraints stretchxy = new java.awt.GridBagConstraints(){{fill=BOTH;weightx=weighty=1.;}};

            setLayout(new ColLayout());

            add(theCanvas = new TheCanvas() {
                },
                stretchxy
            );

            add(new Row() {{ // first row of buttons

                add(new java.awt.Button("Clear") {
                    public boolean isFocusTraversable() { return false; } // so doesn't steal from canvas
                {
                    addActionListener(new java.awt.event.ActionListener() {
                        public void actionPerformed(java.awt.event.ActionEvent e)
                        {
                            UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);

                            mesh = new Mesh();
                            selectedTris = new int[][] {};
                            selectedDualVertIndices = new int[] {};
                            if (doContinuouslyDelaunayize.get()) delaunayize();

                            UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);
                            undoTreeSquirrel.Do(new UndoItem(before, after));

                            theCanvas.repaint();
                        }
                    });
                }});

                add(new java.awt.Label("    "), stretchx);

                add(new java.awt.Button("Hexes Spiral") {
                    public boolean isFocusTraversable() { return false; } // so doesn't steal from canvas
                {
                    addActionListener(new java.awt.event.ActionListener() {
                        public void actionPerformed(java.awt.event.ActionEvent e)
                        {
                            UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);

                            doCannedThingHexesSpiral();

                            UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);
                            undoTreeSquirrel.Do(new UndoItem(before, after));

                            theCanvas.repaint();
                        }
                    });
                }});

                add(new java.awt.Button("Hexes Spiral Alt") {
                    public boolean isFocusTraversable() { return false; } // so doesn't steal from canvas
                {
                    addActionListener(new java.awt.event.ActionListener() {
                        public void actionPerformed(java.awt.event.ActionEvent e)
                        {
                            UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);

                            doCannedThingHexesSpiralOther();

                            UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);
                            undoTreeSquirrel.Do(new UndoItem(before, after));

                            theCanvas.repaint();
                        }
                    });
                }});

                add(new java.awt.Button("netless8 symmetric") {
                    public boolean isFocusTraversable() { return false; } // so doesn't steal from canvas
                {
                    addActionListener(new java.awt.event.ActionListener() {
                        public void actionPerformed(java.awt.event.ActionEvent e)
                        {
                            UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);

                            doCannedThingNetless8Symmetric();

                            UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);
                            undoTreeSquirrel.Do(new UndoItem(before, after));

                            theCanvas.repaint();
                        }
                    });
                }});

                add(new java.awt.Button("netless8") {
                    public boolean isFocusTraversable() { return false; } // so doesn't steal from canvas
                {
                    addActionListener(new java.awt.event.ActionListener() {
                        public void actionPerformed(java.awt.event.ActionEvent e)
                        {
                            UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);

                            doCannedThingNetless8();

                            UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);
                            undoTreeSquirrel.Do(new UndoItem(before, after));

                            theCanvas.repaint();
                        }
                    });
                }});

                add(new java.awt.Button("netless9") {
                    public boolean isFocusTraversable() { return false; } // so doesn't steal from canvas
                {
                    addActionListener(new java.awt.event.ActionListener() {
                        public void actionPerformed(java.awt.event.ActionEvent e)
                        {
                            UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);

                            doCannedThingNetless9();

                            UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);
                            undoTreeSquirrel.Do(new UndoItem(before, after));

                            theCanvas.repaint();
                        }
                    });
                }});

                add(new java.awt.Button("Crack Killer") {
                    public boolean isFocusTraversable() { return false; } // so doesn't steal from canvas
                {
                    addActionListener(new java.awt.event.ActionListener() {
                        public void actionPerformed(java.awt.event.ActionEvent e)
                        {
                            UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);

                            doCannedThingCrackKiller();

                            UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);
                            undoTreeSquirrel.Do(new UndoItem(before, after));

                            theCanvas.repaint();
                        }
                    });
                }});

                add(new java.awt.Button("Sweep Killer") {
                    public boolean isFocusTraversable() { return false; } // so doesn't steal from canvas
                {
                    addActionListener(new java.awt.event.ActionListener() {
                        public void actionPerformed(java.awt.event.ActionEvent e)
                        {
                            UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);

                            doCannedThingSweepKiller0();

                            UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);
                            undoTreeSquirrel.Do(new UndoItem(before, after));

                            theCanvas.repaint();
                        }
                    });
                }});
                add(new java.awt.Button("Sweep Killer 1") {
                    public boolean isFocusTraversable() { return false; } // so doesn't steal from canvas
                {
                    addActionListener(new java.awt.event.ActionListener() {
                        public void actionPerformed(java.awt.event.ActionEvent e)
                        {
                            UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);

                            doCannedThingSweepKiller1();

                            UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);
                            undoTreeSquirrel.Do(new UndoItem(before, after));

                            theCanvas.repaint();
                        }
                    });
                }});
                add(new java.awt.Button("Sweep Killer 2") {
                    public boolean isFocusTraversable() { return false; } // so doesn't steal from canvas
                {
                    addActionListener(new java.awt.event.ActionListener() {
                        public void actionPerformed(java.awt.event.ActionEvent e)
                        {
                            UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);

                            doCannedThingSweepKiller2();

                            UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);
                            undoTreeSquirrel.Do(new UndoItem(before, after));

                            theCanvas.repaint();
                        }
                    });
                }});

                add(new java.awt.Button("Algorithm5 Killer0") {
                    public boolean isFocusTraversable() { return false; } // so doesn't steal from canvas
                {
                    addActionListener(new java.awt.event.ActionListener() {
                        public void actionPerformed(java.awt.event.ActionEvent e)
                        {
                            UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);

                            doCannedThingAlgorithm5Killer0();

                            UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);
                            undoTreeSquirrel.Do(new UndoItem(before, after));

                            theCanvas.repaint();
                        }
                    });
                }});

                add(new java.awt.Button("Algorithm5 Killer1") {
                    public boolean isFocusTraversable() { return false; } // so doesn't steal from canvas
                {
                    addActionListener(new java.awt.event.ActionListener() {
                        public void actionPerformed(java.awt.event.ActionEvent e)
                        {
                            UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);

                            doCannedThingAlgorithm5Killer1();

                            UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);
                            undoTreeSquirrel.Do(new UndoItem(before, after));

                            theCanvas.repaint();
                        }
                    });
                }});

                add(new java.awt.Button("Lagoon Killer") {
                    public boolean isFocusTraversable() { return false; } // so doesn't steal from canvas
                {
                    addActionListener(new java.awt.event.ActionListener() {
                        public void actionPerformed(java.awt.event.ActionEvent e)
                        {
                            UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);

                            doCannedThingBlindLagoonExitKiller();

                            UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);
                            undoTreeSquirrel.Do(new UndoItem(before, after));

                            theCanvas.repaint();
                        }
                    });
                }});

                add(new java.awt.Button("Far Lagoon Killer 1") {
                    public boolean isFocusTraversable() { return false; } // so doesn't steal from canvas
                {
                    addActionListener(new java.awt.event.ActionListener() {
                        public void actionPerformed(java.awt.event.ActionEvent e)
                        {
                            UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);

                            doCannedThingFarthestLagoonExitKiller();

                            UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);
                            undoTreeSquirrel.Do(new UndoItem(before, after));

                            theCanvas.repaint();
                        }
                    });
                }});
                add(new java.awt.Button("Far Lagoon Killer 2") {
                    public boolean isFocusTraversable() { return false; } // so doesn't steal from canvas
                {
                    addActionListener(new java.awt.event.ActionListener() {
                        public void actionPerformed(java.awt.event.ActionEvent e)
                        {
                            UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);

                            doCannedThingFarthestLagoonExitKillerAltB();

                            UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);
                            undoTreeSquirrel.Do(new UndoItem(before, after));

                            theCanvas.repaint();
                        }
                    });
                }});

            }}, stretchx); // first row of buttons

            add(new Row() {{ // second row: col, table, col
                add(new Col() {{
                    add(new Row() {{
                        add(new java.awt.Button("Load DUMP.off") {
                            public boolean isFocusTraversable() { return false; } // so doesn't steal from canvas
                        {
                            addActionListener(new java.awt.event.ActionListener() {
                                public void actionPerformed(java.awt.event.ActionEvent e)
                                {
                                    UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);

                                    load("DUMP.off");

                                    UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);
                                    undoTreeSquirrel.Do(new UndoItem(before, after));

                                    theCanvas.repaint();
                                }
                            });
                        }});

                        add(new java.awt.Button("Save DUMP.off") {
                            public boolean isFocusTraversable() { return false; } // so doesn't steal from canvas
                        {
                            addActionListener(new java.awt.event.ActionListener() {
                                public void actionPerformed(java.awt.event.ActionEvent e)
                                {
                                    save("DUMP.off");
                                }
                            });
                        }});

                        add(new java.awt.Button("Save DUALVERTS.txt") {
                            public boolean isFocusTraversable() { return false; } // so doesn't steal from canvas
                        {
                            addActionListener(new java.awt.event.ActionListener() {
                                public void actionPerformed(java.awt.event.ActionEvent e)
                                {
                                    dualSave("DUALVERTS.txt");
                                }
                            });
                        }});

                        add(new java.awt.Label(""), stretchx);
                    }}, stretchxy);
                    add(new Row() {{
                        add(new java.awt.Checkbox("Optimize", doOptimize.get()) {
                            public boolean isFocusTraversable() { return false; } // so doesn't steal from canvas
                            {
                                addItemListener(new java.awt.event.ItemListener() {
                                    public void itemStateChanged(java.awt.event.ItemEvent e)
                                    {
                                        UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);
                                        doOptimize.set(getState());
                                        System.out.println("doOptimize -> "+doOptimize.get());
                                        if (doContinuouslyDelaunayize.get()) delaunayize();
                                        UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);
                                        undoTreeSquirrel.Do(new UndoItem(before, after));
                                        theCanvas.repaint();
                                    }
                                });
                                doOptimize.addListener(doOptimizeListener = new Listenable.Listener() {
                                    public void valueChanged()
                                    {
                                        setState(doOptimize.get()); // of the checkbox
                                    }
                                });
                            }
                        });
                        add(new java.awt.Choice() {
#if 0 // doing this makes the Choice inoperable! (javac 1.3, runtime 1.6)
                            //public boolean isFocusTraversable() { return false; } // so doesn't steal from canvas
#endif
                            {
                                FORI (i, optimizationTypeNames.length)
                                    insert(optimizationTypeNames[availableOptimizationTypes[i]], i);
                                select(optimizationTypeIndex.get());
                                addItemListener(new java.awt.event.ItemListener() {
                                    public void itemStateChanged(java.awt.event.ItemEvent e)
                                    {
                                        UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);


                                        optimizationTypeIndex.set(getSelectedIndex());
                                        optimizationType = availableOptimizationTypes[optimizationTypeIndex.get()];
                                        System.out.println("optimizationType -> "+optimizationTypeNames[optimizationType]);


                                        if (doContinuouslyDelaunayize.get()) delaunayize();
                                        UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);
                                        undoTreeSquirrel.Do(new UndoItem(before, after));
                                        theCanvas.repaint();
                                    }
                                });
                                optimizationTypeIndex.addListener(optimizationTypeIndexListener = new Listenable.Listener() {
                                    public void valueChanged()
                                    {
                                        select(optimizationTypeIndex.get());
                                    }
                                });
                            }
                        });
                        add(new java.awt.Label(""), stretchxy);
                        add(new java.awt.Checkbox("Delaunayize", doContinuouslyDelaunayize.get()) {
                            public boolean isFocusTraversable() { return false; } // so doesn't steal from canvas
                            {
                                addItemListener(new java.awt.event.ItemListener() {
                                    public void itemStateChanged(java.awt.event.ItemEvent e)
                                    {
                                        UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);
                                        doContinuouslyDelaunayize.set(getState());
                                        System.out.println("doContinuouslyDelaunayize -> "+doContinuouslyDelaunayize.get());
                                        if (doContinuouslyDelaunayize.get()) delaunayize();
                                        UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);
                                        undoTreeSquirrel.Do(new UndoItem(before, after));
                                        theCanvas.repaint();
                                    }
                                });
                                doContinuouslyDelaunayize.addListener(doContinuouslyDelaunayizeListener = new Listenable.Listener() {
                                    public void valueChanged()
                                    {
                                        setState(doContinuouslyDelaunayize.get()); // of the checkbox
                                    }
                                });
                            }
                        });
                        add(new java.awt.Label(""), stretchxy);
                        add(new java.awt.Checkbox("Net", doContinuouslyDelaunayize.get()) {
                            public boolean isFocusTraversable() { return false; } // so doesn't steal from canvas
                            {
                                addItemListener(new java.awt.event.ItemListener() {
                                    public void itemStateChanged(java.awt.event.ItemEvent e)
                                    {
                                        showNet.set(getState());
                                        theCanvas.repaint();
                                    }
                                });
                                showNet.addListener(showNetListener = new Listenable.Listener() {
                                    public void valueChanged()
                                    {
                                        setState(showNet.get()); // of the checkbox


                                        // XXX TODO: arguably this should be in a different listener... it should happen even if we decided not to have this checkbox
                                        if (showNet.get() && showNetFlow)
                                        {
                                            Runnable runnable = new Runnable() {
                                                public void run()
                                                {
                                                    System.out.println("starting animator thread");
                                                    int fps = 10; // XXX need user control of this?
                                                    while (showNet.get()) // XXX need to protect with synchronize or something I think?
                                                    {
                                                        theCanvas.repaint();
                                                        //System.out.println("    sleeping for "+(1000/fps)+" ms");
                                                        try {
                                                            Thread.sleep(1000/fps);
                                                        } catch (InterruptedException e) {
                                                            break;
                                                        }
                                                    }
                                                    System.out.println("terminating animator thread");
                                                    // XXX TODO: does master thread need to join?
                                                }
                                            };
                                            Thread animatorThread = new Thread(runnable);
                                            animatorThread.setDaemon(true); // make it so the java vm won't wait for it to finish before exiting
                                            animatorThread.start();
                                        }

                                    }
                                });
                            }
                        });
                        add(new java.awt.Choice() {
#if 0 // doing this makes the Choice inoperable! (javac 1.3, runtime 1.6)
                            //public boolean isFocusTraversable() { return false; } // so doesn't steal from canvas
#endif
                            {
                                FORI (i, netMethodNames.length)
                                    insert(netMethodNames[i], i);
                                select(netMethod.get());
                                addItemListener(new java.awt.event.ItemListener() {
                                    public void itemStateChanged(java.awt.event.ItemEvent e)
                                    {
                                        netMethod.set(getSelectedIndex());
                                        System.out.println("netMethod -> "+netMethodNames[netMethod.get()]);
                                        theNet = null;
                                        theCanvas.repaint();
                                    }
                                });
                                netMethod.addListener(netMethodListener = new Listenable.Listener() {
                                    public void valueChanged()
                                    {
                                        select(netMethod.get());
                                    }
                                });
                            }
                        });
                        add(new java.awt.Label(""), stretchxy);
                    }}, stretchx);
                }}, stretchy);

                add(new TablePanel() {{
                    add(new java.awt.Button("") {
                        public boolean isFocusTraversable() { return false; } // so doesn't steal from canvas
                        public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(15,19); }
                        public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(15,19); }
                        public void paint(java.awt.Graphics g)
                        {
                            g.setColor(java.awt.Color.black);
                            drawBitmapCentered(g, size(),
                                               new String[] {
                                                  "      *      ",
                                                  "     ***     ",
                                                  "    ** **    ",
                                                  "             ",
                                                  "  *       *  ",
                                                  "  **     **  ",
                                                  "   **   **   ",
                                                  "  **     **  ",
                                                  "  *       *  ",
                                                  "             ",
                                                  "    ** **    ",
                                                  "     ***     ",
                                                  "      *      ",
                                               });
                        }
                    {
                        addActionListener(new java.awt.event.ActionListener() {
                            public void actionPerformed(java.awt.event.ActionEvent e)
                            {
                                rescale(Math.sqrt(.5), Math.sqrt(2.));
                            }
                        });
                    }}, stretchxy);
                    add(new java.awt.Button("") {
                        public boolean isFocusTraversable() { return false; } // so doesn't steal from canvas
                        public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(11,19); }
                        public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(11,19); }
                        public void paint(java.awt.Graphics g)
                        {
                            g.setColor(java.awt.Color.black);
                            drawBitmapCentered(g, size(),
                                               new String[] {
                                                  "      *      ",
                                                  "     ***     ",
                                                  "    ** **    ",
                                                  "             ",
                                                  "             ",
                                                  "             ",
                                                  "             ",
                                                  "             ",
                                                  "             ",
                                                  "             ",
                                                  "    ** **    ",
                                                  "     ***     ",
                                                  "      *      ",
                                               });
                        }
                    {
                        addActionListener(new java.awt.event.ActionListener() {
                            public void actionPerformed(java.awt.event.ActionEvent e)
                            {
                                rescale(1., Math.sqrt(2.));
                            }
                        });
                    }}, stretchxy);
                    add(new java.awt.Button("") {
                        public boolean isFocusTraversable() { return false; } // so doesn't steal from canvas
                        public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(19,19); }
                        public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(19,19); }
                        public void paint(java.awt.Graphics g)
                        {
                            g.setColor(java.awt.Color.black);
                            drawBitmapCentered(g, size(),
                                               new String[] {
                                                  "      *      ",
                                                  "     ***     ",
                                                  "    ** **    ",
                                                  "             ",
                                                  "  *       *  ",
                                                  " **       ** ",
                                                  "**         **",
                                                  " **       ** ",
                                                  "  *       *  ",
                                                  "             ",
                                                  "    ** **    ",
                                                  "     ***     ",
                                                  "      *      ",
                                                  "             ",
                                               });
                        }
                    {
                        addActionListener(new java.awt.event.ActionListener() {
                            public void actionPerformed(java.awt.event.ActionEvent e)
                            {
                                rescale(Math.sqrt(2.), Math.sqrt(2.));
                            }
                        });
                    }}, stretchxy);
                    advanceRow();
                    add(new java.awt.Button("") {
                        public boolean isFocusTraversable() { return false; } // so doesn't steal from canvas
                        public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(15,11); }
                        public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(15,11); }
                        public void paint(java.awt.Graphics g)
                        {
                            g.setColor(java.awt.Color.black);
                            drawBitmapCentered(g, size(),
                                               new String[] {
                                                  "             ",
                                                  "             ",
                                                  "             ",
                                                  "             ",
                                                  "  *       *  ",
                                                  "  **     **  ",
                                                  "   **   **   ",
                                                  "  **     **  ",
                                                  "  *       *  ",
                                                  "             ",
                                                  "             ",
                                                  "             ",
                                                  "             ",
                                               });
                        }
                    {
                        addActionListener(new java.awt.event.ActionListener() {
                            public void actionPerformed(java.awt.event.ActionEvent e)
                            {
                                rescale(Math.sqrt(.5), 1.);
                            }
                        });
                    }}, stretchxy);
                    add(new java.awt.Button("f") {
                        public boolean isFocusTraversable() { return false; } // so doesn't steal from canvas
                        public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(17,17); }
                        public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(17,17); }
                    {
                        addActionListener(new java.awt.event.ActionListener() {
                            public void actionPerformed(java.awt.event.ActionEvent e)
                            {
                                frame();
                            }
                        });
                    }}, stretchxy);
                    add(new java.awt.Button("") {
                        public boolean isFocusTraversable() { return false; } // so doesn't steal from canvas
                        public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(19,11); }
                        public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(19,11); }
                        public void paint(java.awt.Graphics g)
                        {
                            g.setColor(java.awt.Color.black);
                            drawBitmapCentered(g, size(),
                                               new String[] {
                                                  "             ",
                                                  "             ",
                                                  "             ",
                                                  "             ",
                                                  "  *       *  ",
                                                  " **       ** ",
                                                  "**         **",
                                                  " **       ** ",
                                                  "  *       *  ",
                                                  "             ",
                                                  "             ",
                                                  "             ",
                                                  "             ",
                                               });
                        }
                    {
                        addActionListener(new java.awt.event.ActionListener() {
                            public void actionPerformed(java.awt.event.ActionEvent e)
                            {
                                rescale(Math.sqrt(2.), 1.);
                            }
                        });
                    }}, stretchxy);
                    advanceRow();
                    add(new java.awt.Button("") {
                        public boolean isFocusTraversable() { return false; } // so doesn't steal from canvas
                        public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(15,15); }
                        public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(15,15); }
                        public void paint(java.awt.Graphics g)
                        {
                            g.setColor(java.awt.Color.black);
                            drawBitmapCentered(g, size(),
                                               new String[] {
                                                  "             ",
                                                  "             ",
                                                  "    ** **    ",
                                                  "     ***     ",
                                                  "  *   *   *  ",
                                                  "  **     **  ",
                                                  "   **   **   ",
                                                  "  **     **  ",
                                                  "  *   *   *  ",
                                                  "     ***     ",
                                                  "    ** **    ",
                                                  "             ",
                                                  "             ",
                                               });
                        }
                    {
                        addActionListener(new java.awt.event.ActionListener() {
                            public void actionPerformed(java.awt.event.ActionEvent e)
                            {
                                rescale(Math.sqrt(.5), Math.sqrt(.5));
                            }
                        });
                    }}, stretchxy);
                    add(new java.awt.Button("") {
                        public boolean isFocusTraversable() { return false; } // so doesn't steal from canvas
                        public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(11,15); }
                        public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(11,15); }
                        public void paint(java.awt.Graphics g)
                        {
                            g.setColor(java.awt.Color.black);
                            drawBitmapCentered(g, size(),
                                               new String[] {
                                                  "             ",
                                                  "             ",
                                                  "    ** **    ",
                                                  "     ***     ",
                                                  "      *      ",
                                                  "             ",
                                                  "             ",
                                                  "             ",
                                                  "      *      ",
                                                  "     ***     ",
                                                  "    ** **    ",
                                                  "             ",
                                                  "             ",
                                               });
                        }
                    {
                        addActionListener(new java.awt.event.ActionListener() {
                            public void actionPerformed(java.awt.event.ActionEvent e)
                            {
                                rescale(1., Math.sqrt(.5));
                            }
                        });
                    }}, stretchxy);
                    add(new java.awt.Button("") {
                        public boolean isFocusTraversable() { return false; } // so doesn't steal from canvas
                        public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(19,15); }
                        public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(19,15); }
                        public void paint(java.awt.Graphics g)
                        {
                            g.setColor(java.awt.Color.black);
                            drawBitmapCentered(g, size(),
                                               new String[] {
                                                  "             ",
                                                  "             ",
                                                  "    ** **    ",
                                                  "     ***     ",
                                                  "  *   *   *  ",
                                                  " **       ** ",
                                                  "**         **",
                                                  " **       ** ",
                                                  "  *   *   *  ",
                                                  "     ***     ",
                                                  "    ** **    ",
                                                  "             ",
                                                  "             ",
                                               });
                        }
                    {
                        addActionListener(new java.awt.event.ActionListener() {
                            public void actionPerformed(java.awt.event.ActionEvent e)
                            {
                                rescale(Math.sqrt(2.), Math.sqrt(.5));
                            }
                        });
                    }}, stretchxy);
                }}); // table

                add(new Col() {{
                    add(new Row() {{
                        add(new java.awt.Label(""), stretchx);

                        add(new java.awt.Button("Help") {
                            public boolean isFocusTraversable() { return false; } // so doesn't steal from canvas
                        {
                            addActionListener(new java.awt.event.ActionListener() {
                                public void actionPerformed(java.awt.event.ActionEvent e)
                                {
                                    help();
                                }
                            });
                        }});
                    }}, stretchxy);
                    add(new Row() {{
                        add(new java.awt.Label(""), stretchx);

                        add(new java.awt.Checkbox("Magnifying glass", showMag.get()) {
                            public boolean isFocusTraversable() { return false; } // so doesn't steal from canvas
                            {
                                addItemListener(new java.awt.event.ItemListener() {
                                    public void itemStateChanged(java.awt.event.ItemEvent e)
                                    {
                                        showMag.set(getState());
                                        System.out.println("showMag -> "+showMag.get());
                                        theCanvas.repaint();
                                    }
                                });
                                showMag.addListener(showMagListener = new Listenable.Listener() {
                                    public void valueChanged()
                                    {
                                        setState(showMag.get()); // of the checkbox
                                    }
                                });
                            }
                        });

                        add(new java.awt.Label(""), stretchx);

                        add(new java.awt.Button("Undo") {
                            public boolean isFocusTraversable() { return false; } // so doesn't steal from canvas
                        {
                            addActionListener(new java.awt.event.ActionListener() {
                                public void actionPerformed(java.awt.event.ActionEvent e)
                                {
                                    UndoItem item = (UndoItem)undoTreeSquirrel.undo();
                                    if (item != null)
                                    {
                                        mesh = new Mesh(item.before.mesh);
                                        meshOfSelectedTris = mesh; // hackish
                                        doContinuouslyDelaunayize.set(item.before.doContinuouslyDelaunayize);
                                        doOptimize.set(item.before.doOptimize);
                                        optimizationTypeIndex.set(item.before.optimizationTypeIndex);
                                        optimizationType = availableOptimizationTypes[optimizationTypeIndex.get()];
                                        selectedTris = (int[][])Arrays.copy(item.before.selectedTris, 2);
                                        selectedDualVertIndices = VecMath.copyvec(item.before.selectedDualVertIndices);
                                        dirtyDualMesh(); // *before* we restore theNet
                                        theNet = (item.before.netCuts==null ? null : new Net(getDualMesh(), mesh, item.before.netCuts));
                                    }
                                    else
                                    {
                                        System.out.println("Nothing to undo!");
                                    }
                                    theCanvas.repaint();
                                }
                            });
                        }});
                        add(new java.awt.Button("Redo") {
                            public boolean isFocusTraversable() { return false; } // so doesn't steal from canvas
                        {
                            addActionListener(new java.awt.event.ActionListener() {
                                public void actionPerformed(java.awt.event.ActionEvent e)
                                {
                                    UndoItem item = (UndoItem)undoTreeSquirrel.redo();
                                    if (item != null)
                                    {
                                        mesh = new Mesh(item.after.mesh);
                                        meshOfSelectedTris = mesh; // hackish
                                        doContinuouslyDelaunayize.set(item.after.doContinuouslyDelaunayize);
                                        doOptimize.set(item.after.doOptimize);
                                        optimizationTypeIndex.set(item.after.optimizationTypeIndex);
                                        optimizationType = availableOptimizationTypes[optimizationTypeIndex.get()];
                                        selectedTris = (int[][])Arrays.copy(item.after.selectedTris, 2);
                                        selectedDualVertIndices = VecMath.copyvec(item.after.selectedDualVertIndices);
                                        dirtyDualMesh(); // *before* we restore theNet
                                        theNet = (item.after.netCuts==null ? null : new Net(getDualMesh(), mesh, item.after.netCuts));
                                    }
                                    else
                                    {
                                        System.out.println("Nothing to redo!");
                                    }
                                    theCanvas.repaint();
                                }
                            });
                        }});
                    }}, stretchx);
                }}, stretchxy);
            }}, stretchx); // second row: col, table, col

            //randomlyColorize(this);
        } // ShephardsPlayApplet ctor

        private static void help()
        {
            System.out.println("===================================================================");
            System.out.println("Mouse:");
            System.out.println("    left click: add a vertex and drag it");
            System.out.println("    middle drag: drag a vertex");
            System.out.println("    right click: delete a vertex");
            System.out.println("    shift-middle drag: pan entire picture");
            System.out.println("    shift-left drag: create new edge between two vertices");
            System.out.println("    ctrl-left and ctrl-middle: add/drag vertex and all reflections of it");
            System.out.println("Keys:");
            System.out.println("    'V' - cycle verbosity (to java console or system output)");
            System.out.println("    ' ' - just repaint");
            System.out.println("    'A' - toggle doAntiAliasing");
            System.out.println("    't' - toggle primary (triangle) mesh");
            System.out.println("    'B' - toggle doDoubleBuffer");
            System.out.println("    'i'/'+'/'=' - zoom in");
            System.out.println("    'o'/'-' - zoom out");
            System.out.println("    'f' - frame picture");
            System.out.println("    '|' - flip left-right");
            System.out.println("    '_' - flip up-down");
            System.out.println("    '/' - flip upper-left lower-right");
            System.out.println("    '\' - flip lower-left upper-right");
            System.out.println("    's' - swap a diagonal");
            System.out.println("    ctrl-'s' - swap a diagonal if the result is more Delaunay");
            System.out.println("    'D' - Delaunay triangulate");
            System.out.println("    'w' - add or remove closest red point from list of points to show curvature center of");
            System.out.println("    'O' - toggle doOptimize");
            System.out.println("    'l' - toggle showLabels");
            System.out.println("    '0' - toggle showOrigin");
            System.out.println("    'g' - toggle showGrid");
            System.out.println("    'M'/'m' - increase/decrease magnification focus region");
            System.out.println("    'P'/'p' - increase/decrease magnified pixel size");
            System.out.println("    ctrl-'m' - toggle magnifying glass");
            System.out.println("    ctrl-'g' - toggle snapToGrid");
            System.out.println("    'a' - toggle doArrowsTowardsSharpestDihedrals (green)");
            System.out.println("    alt-'a' - toggle doArrowsTowardsShortestEdges (cyan)");
            System.out.println("    'n' - toggle showNet");
            System.out.println("    Left/Right arrow - rotate closest cut or fold CCW or CW around its lagoon in the net");
            System.out.println("    'S' - turn off optimize, and re-spherize");
            System.out.println("    'd' - delete closest edge");
            System.out.println("    ctrl-'i' - toggle doShowInsideOutDualVerts");
            System.out.println("    ctrl-'o' - cycle optimizationType");
            System.out.println("    ctrl-'v' - toggle nonEventVerbose");
            System.out.println("    Up arrow: pull face plane of closest vertex out");
            System.out.println("    Down arrow: push face plane of closest vertex in");
            System.out.println("    Left/right arrow: translate fudge");
            System.out.println("    'c' - clear");
            System.out.println("    ctrl-'c' - example in which cutting the sharpest dihedral at each vertex does not lead to a solution");
            System.out.println("    'u' / ctrl-'z' - undo");
            System.out.println("    'r' / 'U' / ctrl-'r' / ctrl-'y' - redo");
            System.out.println("    'h' - help");
            System.out.println("    ctrl-'q' - quit");
            System.out.println("===================================================================");
        } // help

        private static void randomlyColorize(java.awt.Component c)
        {
            c.setBackground(new java.awt.Color((float)Math.random(),
                                               (float)Math.random(),
                                               (float)Math.random()));
            c.setForeground(new java.awt.Color((float)Math.random(),
                                               (float)Math.random(),
                                               (float)Math.random()));
            if (c instanceof java.awt.Container)
            {
                java.awt.Container C = (java.awt.Container)c;
                int n = C.getComponentCount();
                for (int i = 0; i < n; ++i)
                    randomlyColorize(C.getComponent(i));
            }
        } // randomlyColorize

        public void dualSave(String fileName)
        {
            System.out.println("Saving dual verts to "+fileName+"... ");
            System.out.flush();
            try {
                java.io.PrintWriter writer = new java.io.PrintWriter(new java.io.BufferedWriter(new java.io.FileWriter(fileName)));
                // XXX want \r\n no matter which platform I'm on, I think

                Mesh dualMesh = getDualMesh();
                int nDualVerts = dualMesh.verts.size();
                FORI (iDualVert, nDualVerts)
                {
                    Mesh.Vertex dualVert = dualMesh.getVert(iDualVert);
                    if (dualVert.arity == 3
                     && (doShowInsideOutDualVerts
                      || dualVert.weight >= 0))
                        writer.println("        {" + dualVert.x
                                   + ", " + dualVert.y
                                   + ", " + dualVert.h
                                   + "},");
                    else
                        writer.println("null");
                }

                writer.flush();
                writer.close();
            }
            catch (Exception exc)
            {
                System.out.println("save to file "+fileName+" failed:" + exc);
            }
            System.out.println("done.");
        } // save
        public void save(String fileName)
        {
            System.out.println("Saving to "+fileName+"... ");
            System.out.flush();
            try {
                java.io.PrintWriter writer = new java.io.PrintWriter(new java.io.BufferedWriter(new java.io.FileWriter(fileName)));

                // XXX want \n\r no matter which platform I'm on!

                writer.println("OFF");

                // count faces
                int nFaces;
                {
                    boolean didEdge[] = new boolean[mesh.edges.size()]; // all false
                    nFaces = 0; // and counting
                    int nEdges = mesh.edges.size();
                    FORI (iEdge, nEdges)
                    {
                        if (didEdge[iEdge])
                            continue;
                        nFaces++;
                        Mesh.Edge e = mesh.getEdge(iEdge);
                        while (!didEdge[e.myIndex()])
                        {
                            didEdge[e.myIndex()] = true;
                            e = e.next();
                        }
                    }
                }
                writer.println("" + mesh.verts.size()
                            + " " + nFaces
                            + " " + 0);
                FORI (iVert, mesh.verts.size())
                {
                    Mesh.Vertex vert = mesh.getVert(iVert);
                    writer.println("" + vert.x + " " + vert.y + " " + vert.h);
                }

                // If we're going to output net cuts,
                // then we need to keep track of the order in which the edges
                // appear in the output, since that's the order
                // they'll be in when it gets read back in.
                int edgeToOutputIndex[] = (theNet==null ? null : Arrays.fill(mesh.edges.size(), -1));
                int outputIndex = 0;

                {
                    boolean didEdge[] = new boolean[mesh.edges.size()]; // all false
                    int nEdges = mesh.edges.size();
                    IntArrayList vertsThisFace = new IntArrayList();
                    FORI (iEdge, nEdges)
                    {
                        if (didEdge[iEdge])
                            continue;
                        vertsThisFace.clear();
                        Mesh.Edge e = mesh.getEdge(iEdge);
                        while (!didEdge[e.myIndex()])
                        {
                            if (edgeToOutputIndex != null
                             && edgeToOutputIndex[e.myIndex()] == -1) // if not already seen
                            {
                                edgeToOutputIndex[e.myIndex()] = outputIndex++;
                                edgeToOutputIndex[e.opposite().myIndex()] = outputIndex++;
                            }

                            didEdge[e.myIndex()] = true;
                            vertsThisFace.add(e.initialVertex().myIndex());
                            e = e.next();
                        }
                        writer.print("" + vertsThisFace.size() + " ");
                        FORI (iVertThisFace, vertsThisFace.size())
                            writer.print(" " + vertsThisFace.get(iVertThisFace));
                        writer.println();
                    }
                }

                if (theNet != null)
                {
                    writer.print("# Cuts:");
                    FORI (i, theNet._vertToParentEdgeInd.length)
                        if (!(i == theNet._vertToParentEdgeInd.length-1 && theNet._vertToParentEdgeInd[i] == -1)) // omit the final -1
                            writer.print(" "+edgeToOutputIndex[theNet._vertToParentEdgeInd[i]]);
                    writer.println();
                }


                writer.flush();
                writer.close();
            }
            catch (Exception exc)
            {
                System.out.println("save to file "+fileName+" failed:" + exc);
            }
            System.out.println("done.");
        } // save
        public void load(String fileName)
        {
            System.out.print("Loading from "+fileName+"... ");
            System.out.flush();
            try {
                java.io.LineNumberReader reader = new java.io.LineNumberReader(new java.io.FileReader(fileName)); // LineNumberReader is already a buffered reader
                String line;
                if ((line = reader.readLine()) == null)
                {
                    reader.close();
                    throw new Exception("premature EOF expecting OFF");
                }
                if (!line.equals("OFF"))
                {
                    reader.close();
                    throw new Exception("expected OFF, got \""+line+"\"");
                }
                if ((line = reader.readLine()) == null)
                {
                    reader.close();
                    throw new Exception("premature EOF expecting number of verts, faces, 0");
                }
                //String[] tokens = line.trim().split("\\s+");
                String[] tokens = com.donhatchsw.compat.regex.split(line.trim(), "\\s+");
                if (tokens.length != 3)
                {
                    reader.close();
                    throw new Exception("expected number of verts, number of faces, 0, got \""+line+"\"");
                }
                int nVerts = Integer.parseInt(tokens[0]);
                int nFaces = Integer.parseInt(tokens[1]);
                int zero = Integer.parseInt(tokens[2]);
                double verts[][] = new double[nVerts][3];
                int faces[][] = new int[nFaces][];

                FORI (iVert, nVerts)
                {
                    if ((line = reader.readLine()) == null)
                    {
                        reader.close();
                        throw new Exception("premature EOF trying to read vertex "+iVert+"/"+nVerts+"");
                    }
                    //tokens = line.trim().split("\\s+");
                    tokens = com.donhatchsw.compat.regex.split(line.trim(), "\\s+");
                    if (tokens.length != 3)
                    {
                        reader.close();
                        throw new Exception("expected 3 floating point numbers, got \""+line+"\"");
                    }
                    FORI (i, 3)
                        verts[iVert][i] = Double.parseDouble(tokens[i]);
                }
                FORI (iFace, nFaces)
                {
                    if ((line = reader.readLine()) == null)
                    {
                        reader.close();
                        throw new Exception("premature EOF trying to read face "+iFace+"/"+nFaces+"");
                    }
                    //tokens = line.trim().split("\\s+");
                    tokens = com.donhatchsw.compat.regex.split(line.trim(), "\\s+");
                    if (tokens.length == 0)
                    {
                        reader.close();
                        throw new Exception("expected a face, got \""+line+"\"");
                    }
                    int faceSize = Integer.parseInt(tokens[0]);
                    if (tokens.length != 1 + faceSize)
                    {
                        reader.close();
                        throw new Exception("expected a face, got \""+line+"\" (wrong number of indices)");
                    }
                    faces[iFace] = new int[faceSize];
                    FORI (i, faceSize)
                        faces[iFace][i] = Integer.parseInt(tokens[i+1]);
                }

                //System.out.println("reading another line");
                line = reader.readLine();

                reader.close();

                mesh = new Mesh(verts, faces);

                if (line != null)
                {
                    // XXX TODO: be more lenient with syntax
                    if (line.startsWith("# Cuts: "))
                    {
                        tokens = com.donhatchsw.compat.regex.split(line.substring(8).trim(), "\\s+");
                        //PRINTARRAY(tokens);
                        int cuts[] = new int[tokens.length];
                        FORI (iToken, tokens.length)
                            cuts[iToken] = Integer.parseInt(tokens[iToken]);
                        theNet = new Net(getDualMesh(), mesh, cuts);
                    }
                    else
                    {
                        System.out.println("WARNING: unrecognized line after OFF data: "+line);
                    }
                }

                if (doContinuouslyDelaunayize.get()) delaunayize();
            }
            catch (Exception exc)
            {
                exc.printStackTrace();
                System.out.println("load from file "+fileName+" failed:" + exc);            }
            System.out.println("done.");
        } // load

        public void rescale(double scaleX, double scaleY)
        {
            UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);
            Mesh dualMesh = getDualMesh(); // before scaling mesh!
            double scale = Math.sqrt(.5);
            FORIDOWN (iVert, mesh.verts.size())
            {
                Mesh.Vertex vert = mesh.getVert(iVert);
                vert.h -= .5 * (SQR(vert.x) + SQR(vert.y)); // convert to "actual"
                vert.x *= scaleX;
                vert.y *= scaleY;
                vert.h *= scaleX * scaleY;
                vert.h += .5 * (SQR(vert.x) + SQR(vert.y)); // convert from "actual"
                assert(vert.momentAndArea == null);
            }
            // don't recalculate dual mesh, rather, just rescale its points accordingly.
            // this makes it so we don't have to blow away the net.
            FORIDOWN(iDualVert, dualMesh.verts.size())
            {
                Mesh.Vertex dualVert = dualMesh.getVert(iDualVert);
                dualVert.h -= .5 * (SQR(dualVert.x) + SQR(dualVert.y)); // convert to "actual"
                dualVert.x *= scaleY; // converse
                dualVert.y *= scaleX; // converse
                dualVert.h *= scaleX * scaleY;
                dualVert.h += .5 * (SQR(dualVert.x) + SQR(dualVert.y)); // convert from "actual"
                assert(dualVert.momentAndArea.length == 4);
                dualVert.momentAndArea[0] *= scaleY; // converse
                dualVert.momentAndArea[1] *= scaleX; // converse
                dualVert.momentAndArea[2] *= scaleX * scaleY;
                // leave weights alone-- they are wrong, but all by the same constant scale factor
            }

            // should be no need to re-delaunayize if uniform scale
            if (scaleX != scaleY)
                if (doContinuouslyDelaunayize.get())
                {
                    delaunayize();
                    dirtyDualMesh();
                }
            UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);
            undoTreeSquirrel.Do(new UndoItem(before, after));
            theCanvas.repaint();
        } // rescale

        public void frame()
        {
            UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);

            {
                double minx = Double.POSITIVE_INFINITY;
                double miny = Double.POSITIVE_INFINITY;
                double maxx = Double.NEGATIVE_INFINITY;
                double maxy = Double.NEGATIVE_INFINITY;
                FORIDOWN(iVert, mesh.verts.size())
                {
                    Mesh.Vertex vert = mesh.getVert(iVert);
                    minx = MIN(minx, vert.x);
                    maxx = MAX(maxx, vert.x);
                    miny = MIN(miny, vert.y);
                    maxy = MAX(maxy, vert.y);
                }
                double center[] = {(minx+maxx)*.5, (miny+maxy)*.5};
                double maxsize = MAX(maxx-minx, maxy-miny);
                double scale = 2./maxsize;
                if (maxsize > 0.)
                {
                    FORIDOWN(iVert, mesh.verts.size())
                    {
                        Mesh.Vertex vert = mesh.getVert(iVert);
                        vert.x -= center[0];
                        vert.y -= center[1];

                        vert.x *= scale;
                        vert.y *= scale;
                        vert.h *= scale*scale;
                    }
                }
            }

            // should be no need to re-delaunayize, since uniform scale
            UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);
            undoTreeSquirrel.Do(new UndoItem(before, after));
            theCanvas.repaint();
        } // frame



        public void init()
        {
            eventVerbose = getParameterInt("EventVerbose", eventVerbose);
            if (eventVerbose >= 1) System.out.println("in init");

            // These (and eventVerbose) can be specified on the command line as, e.g. showLabels=true
            showLabels = getParameterBoolean("showLabels", showLabels);
            doContinuouslyDelaunayize.set(getParameterBoolean("doContinuouslyDelaunayize", doContinuouslyDelaunayize.get()));
            doOptimize.set(getParameterBoolean("doOptimize", doOptimize.get()));
            doShowPositiveOrthantnessVisualization = getParameterBoolean("doShowPositiveOrthantnessVisualization", doShowPositiveOrthantnessVisualization);
            // XXX this is kind of messed up, we don't get to know whether the user misspelled something


            graphicsAntiAliasingSetter = new GraphicsAntiAliasingSetter();

            //doCannedThingHexesSpiral();
            //doCannedThingNetless9();
            //doCannedThingEyeball();
            //doCannedThingNetless8();
            //doCannedThingCrackKiller();
            //doCannedThingHexesSpiralOther();
            //doCannedThingNetless8Symmetric();
            //doCannedThingNetless8Optimized();
            //doCannedThingSweepKiller0();
            //doCannedThingSweepKiller1();
            //doCannedThingAlgorithm5Killer0();
            //doCannedThingAlgorithm5Killer1();
            //doCannedThingBlindLagoonExitKiller();
            //doCannedThingFarthestLagoonExitKiller();
            doCannedThingFarthestLagoonExitKillerAltB();
            //doCannedThingFarthestLagoonExitKillerOptimized();
            //doBlueNoiseThing();
            //load("DUMP.off");

            if (eventVerbose >= 1) System.out.println("out init");
        } // init

        public void start()
        {
            if (eventVerbose >= 1) System.out.println("in start");
            if (eventVerbose >= 1) System.out.println("out start");
        }
        public void stop()
        {
            if (eventVerbose >= 1) System.out.println("in stop");
            if (eventVerbose >= 1) System.out.println("out stop");
        }
        public void destroy()
        {
            if (eventVerbose >= 1) System.out.println("in destroy");
            if (eventVerbose >= 1) System.out.println("out destroy");
        }

        //
        // Button behavor changed incompatibly between Java 1.1 and 1.4
        // (not sure exactly what version it changed in though).
        // (I think it was 1.4 since that's when getButton() was added
        // to MouseEvent).
        //
        private static int getButton(java.awt.event.MouseEvent e)
        {
            // gag me! we can't even query the java spec version number
            // since System.getProperty() throws a security exception
            // in netscape!
            // so use empirical evidence...
            int mods = e.getModifiers();
#if 0 // can't seem to get this to work under IE at all, so don't try for now, it will just be wrong under 1.4
            boolean is_1_4_or_greater = ((mods & ~0x1fff) != 0);
            if (is_1_4_or_greater)
            {
                try
                {
                    return e.getButton();
                }
                catch (NoSuchMethodError err)
                {
                    // this only happens in IE, not netscape. fall through...
                }
            }
#endif

            if ((mods & java.awt.event.InputEvent.ALT_MASK) != 0)
                return java_awt_event_MouseEvent_BUTTON2;
            if ((mods & java.awt.event.InputEvent.META_MASK) != 0)
                return java_awt_event_MouseEvent_BUTTON3;
            return java_awt_event_MouseEvent_BUTTON1;
        } // getButton

        private class TheCanvas
            extends java.awt.Canvas
            implements java.awt.event.MouseListener,
                       java.awt.event.MouseMotionListener,
                       java.awt.event.KeyListener
        {
            TheCanvas()
            {
                // Specify an "event listener" object
                // to respond to events.
                // (>= Java 1.1 event model).
                this.addMouseListener(this);
                this.addMouseMotionListener(this);
                this.addKeyListener(this);
            }

            //
            // MouseListener and MouseMotionListener methods...
            //
            public void mousePressed(java.awt.event.MouseEvent e)
            {
                if (eventVerbose >= 1) System.out.println("in mousePressed: "+e);
                if (eventVerbose >= 1)
                {
                    if (getButton(e) == java_awt_event_MouseEvent_BUTTON1)
                        System.out.println("    (left mouse)");
                    if (getButton(e) == java_awt_event_MouseEvent_BUTTON2)
                        System.out.println("    (middle mouse)");
                    if (getButton(e) == java_awt_event_MouseEvent_BUTTON3)
                        System.out.println("    (right mouse)");
                }

                double thisP[] = new double[2];
                mostRecentGraphics.pick((e.getX()+.5)/globalMagFactor, (e.getY()+.5)/globalMagFactor, thisP);
                double snappedThisP[] = !snapToGrid ? thisP : new double[] {
                    (double)Math.round(thisP[0]/gridSnapQuantum)*gridSnapQuantum,
                    (double)Math.round(thisP[1]/gridSnapQuantum)*gridSnapQuantum,
                };

                stateWhenPressed = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);

                int whichButton = getButton(e);

                if (whichButton == java_awt_event_MouseEvent_BUTTON1)
                {
                    button1IsDown = true;

                    if (e.isShiftDown())
                    {
                        //
                        // Add an edge from the closest vertex
                        //
                        System.out.println("    Adding an edge at "+thisP[0]+" "+thisP[1]+" "+0+"");

                        //
                        // If there are no vertices, add one
                        //
                        ArrayList verts = mesh.verts;
                        if (verts.size() == 0)
                        {
                            System.out.println("        (Adding a vertex first)");
                            mesh.addIsolatedVertex(snappedThisP[0], snappedThisP[1], 0);

                            // added something-- invalidate dual mesh
                            dirtyDualMesh();
                            if (doContinuouslyDelaunayize.get()) delaunayize();
                        }

                        //
                        // Select closest vertex
                        //
                        beingDraggedVertIndex = mesh.indexOfClosestVert(thisP[0],thisP[1]);
                        rubberBandingNewEdge = true;
                    }
                    else // shift is not down
                    {
                        if (showNet.get())
                        {
                            // begin dragging a net edge or fold
                            //PRINT(beingDraggedNetEdgeIndex);
                            beingDraggedNetEdgeIndex = getDualMesh().indexOfClosestEdge(prevP, true);
                            //PRINT(beingDraggedNetEdgeIndex);
                            theCanvas.repaint();
                        }
                        else
                        {
                            //
                            // Add a vertex
                            //

                            double vertsToAdd[][] = {
                                snappedThisP,
                            };

                            if (e.isControlDown())
                            {
                                // add a mirror image.
                                // prepend instead of appending, so that the last thing we do
                                // is the one that will be dragged.
                                vertsToAdd = (double[][])Arrays.concat(new double[][]{{-snappedThisP[0], snappedThisP[1]}}, vertsToAdd);
                                // TODO: detect entire symmetry group
                            }

                            FORI (iVertToAdd, vertsToAdd.length)
                            {
                                double vertToAdd[] = vertsToAdd[iVertToAdd];
                                double x = vertToAdd[0];
                                double y = vertToAdd[1];

                                System.out.println("    Adding vertex "+mesh.verts.size()+" at "+x+" "+y+" "+0+"");
                                mesh.addIsolatedVertex(x, y, 0);

                                ArrayList verts = mesh.verts;
                                ArrayList edges = mesh.edges;
                                if (verts.size() >= 2)
                                {
                                    //
                                    // If are no edges at all, add an edge.
                                    // XXX this is kind of lame when there were more than one isolated vertex, should connect to them all
                                    //
                                    if (edges.size() == 0)
                                    {
                                        System.out.println("Adding an edge between two verts");
                                        mesh.addEdgeBetweenTwoIsolatedVertices((Mesh.Vertex)verts.get(verts.size()-2),
                                                                               (Mesh.Vertex)verts.get(verts.size()-1));
                                    }
                                    else // edges.size() >= 1
                                    {
                                        // There was already an edge.
                                        // Find out which face we are on
                                        // (all triangles CCW), and kis that face.
                                        // if we are not inside any face by that criterion,
                                        // then assume we are inside the outer face
                                        // and connect the new vertex to every vertex
                                        // that's visible from it.
                                        //
                                        boolean kissed = false;
                                        double twiceMostNegativeFaceArea = Double.POSITIVE_INFINITY;
                                        Mesh.Edge edgeOnMostNegativeFace = null;
                                        // XXX traverses each face of size n n times!  need to keep track of what we've done already
                                        int nEdges = mesh.edges.size();
                                        FORI (iEdge, nEdges)
                                        {
                                            boolean thisFaceIsGoodSoFar = true;
                                            Mesh.Edge edgeI = mesh.getEdge(iEdge);
                                            double twiceThisFaceArea = 0.;
                                            for (Mesh.Edge edge = edgeI;;)
                                            {
                                                double twiceThisTriArea = twiceTriangleArea(
                                                                        x, y,
                                                                        edge.initialVertex().x,
                                                                        edge.initialVertex().y,
                                                                        edge.finalVertex().x,
                                                                        edge.finalVertex().y);
                                                if (twiceThisTriArea < 0)
                                                {
                                                    thisFaceIsGoodSoFar = false; // it's bad!
                                                }
                                                twiceThisFaceArea += twiceThisTriArea;

                                                if ((edge = edge.next()) == edgeI)
                                                    break;
                                            }
                                            if (thisFaceIsGoodSoFar)
                                            {
                                                // I'm inside this face;
                                                // kis it and done
                                                mesh.kisIsolatedVertex((Mesh.Vertex)verts.get(verts.size()-1),
                                                                       edgeI);
                                                kissed = true;
                                                break;
                                            }
                                            if (twiceThisFaceArea < twiceMostNegativeFaceArea)
                                            {
                                                twiceMostNegativeFaceArea = twiceThisFaceArea;
                                                edgeOnMostNegativeFace = edgeI;
                                            }
                                        }
                                        if (!kissed)
                                        {
                                            System.out.println("In the outer face");
                                            //
                                            // It wasn't inside any face.
                                            // Assume it's in the outer face.
                                            // In this case,
                                            // make a kiss to the outer face
                                            // and then delete all newly added edges
                                            // that cross the boundary of the outer face.
                                            //

                                            ArrayList/*<Mesh.Edge>*/ oldOuterFaceBoundary = new ArrayList();
                                            for (Mesh.Edge edge = edgeOnMostNegativeFace;;)
                                            {
                                                oldOuterFaceBoundary.add(edge);
                                                if ((edge = edge.next()) == edgeOnMostNegativeFace)
                                                    break;
                                            }
                                            int oldOuterFaceBoundarySize = oldOuterFaceBoundary.size();

                                            int oldNumEdges = mesh.edges.size();
                                            mesh.kisIsolatedVertex((Mesh.Vertex)verts.get(verts.size()-1),
                                                                   edgeOnMostNegativeFace);
                                            if (!doShowInsideOutDualVerts)
                                            {
                                                for (int iEdge = oldNumEdges;
                                                     iEdge < mesh.edges.size();
                                                     iEdge += 2) // only do one of an edge and its opposite
                                                {
                                                    for (int iOldBoundaryEdge = 0;
                                                         iOldBoundaryEdge < oldOuterFaceBoundarySize;
                                                         ++iOldBoundaryEdge)
                                                    {
                                                        Mesh.Edge oldEdge = (Mesh.Edge)oldOuterFaceBoundary.get(iOldBoundaryEdge);
                                                        Mesh.Edge newEdge = mesh.getEdge(iEdge);

                                                        if (newEdge.initialVertex() == oldEdge.initialVertex()
                                                         || newEdge.initialVertex() == oldEdge.finalVertex()
                                                         || newEdge.finalVertex() == oldEdge.initialVertex()
                                                         || newEdge.finalVertex() == oldEdge.finalVertex())
                                                            continue;
                                                        //System.out.println("    Seeing whether new edge v"+newEdge.initialVertex().myIndex()+" -> v"+newEdge.finalVertex().myIndex()+" crosses old boundary edges v"+oldEdge.initialVertex().myIndex()+" -> v"+oldEdge.finalVertex().myIndex()+"");
                                                        if (edgesCrossOrCloseToIt(
                                                                        oldEdge.initialVertex().x,
                                                                        oldEdge.initialVertex().y,
                                                                        oldEdge.finalVertex().x,
                                                                        oldEdge.finalVertex().y,
                                                                        newEdge.initialVertex().x,
                                                                        newEdge.initialVertex().y,
                                                                        newEdge.finalVertex().x,
                                                                        newEdge.finalVertex().y,
                                                                        1e-6))
                                                        {
                                                            //System.out.println("        It does.");
                                                            mesh.deleteEdge(newEdge);
                                                            iEdge -= 2; // so we don't skip the one that gets moved into the deleted spot
                                                            break;
                                                        }
                                                        else
                                                        {
                                                            //System.out.println("        It doesn't.");
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    } // if verts.length >= 3
                                } // if verts.size() >= 2 after adding the new vertex

                                mesh.sanityCheck();

                                beingDraggedVertIndex = verts.size()-1; // start dragging the one we just added
                            }

                            // added something-- invalidate dual mesh
                            dirtyDualMesh();
                            if (doContinuouslyDelaunayize.get()) delaunayize();
                        } // !showNet
                    } // shift not down

                }
                else if (whichButton == java_awt_event_MouseEvent_BUTTON2)
                {
                    button2IsDown = true;

                    //
                    // Select closest vertex
                    //
                    beingDraggedVertIndex = mesh.indexOfClosestVert(thisP[0],thisP[1]);
                    if (beingDraggedVertIndex == -1)
                        System.out.println("Dragging vertex "+beingDraggedVertIndex);
                    else
                    {
                        if (snapToGrid)
                        {
                            if (e.isShiftDown())
                            {
                                // Snap all the vertices we're about to drag
                                FORIDOWN (iVert, mesh.verts.size())
                                {
                                    Mesh.Vertex vert = mesh.getVert(iVert);
                                    vert.x = (double)Math.round(vert.x/gridSnapQuantum)*gridSnapQuantum;
                                    vert.y = (double)Math.round(vert.y/gridSnapQuantum)*gridSnapQuantum;
                                }
                            }
                            else
                            {
                                Mesh.Vertex vert = mesh.getVert(beingDraggedVertIndex);
                                System.out.println("Snapping vertex "+beingDraggedVertIndex+" from "+vert.x+" "+vert.y+" "+vert.h+"");
                                vert.x = (double)Math.round(vert.x/gridSnapQuantum)*gridSnapQuantum;
                                vert.y = (double)Math.round(vert.y/gridSnapQuantum)*gridSnapQuantum;
                                System.out.println("Dragging vertex "+beingDraggedVertIndex+" from "+vert.x+" "+vert.y+" "+vert.h+"");
                            }
                            if (doContinuouslyDelaunayize.get()) delaunayize();
                        }
                    }
                }
                else if (whichButton == java_awt_event_MouseEvent_BUTTON3)
                {
                    button3IsDown = true;

                    //
                    // Delete closest vertex
                    //
                    beingDraggedVertIndex = mesh.indexOfClosestVert(thisP[0],thisP[1]);
                    if (beingDraggedVertIndex != -1)
                        mesh.deleteVertex(mesh.getVert(beingDraggedVertIndex));
                    beingDraggedVertIndex = -1;

                    // vertices got re-ordered, so we must clear the selection (for now).
                    // XXX this can be improved maybe
                    if (true)
                    {
                        selectedTris = new int[][] {};
                        selectedDualVertIndices = new int[] {};
                    }

                    // deleted something-- invalidate dual mesh
                    dirtyDualMesh();

                    mesh.sanityCheck();

                    if (doContinuouslyDelaunayize.get()) delaunayize();

                } // right mouse

                prevP = thisP;

                theCanvas.repaint();

                if (eventVerbose >= 1) System.out.println("out mousePressed: "+e);
            } // mousePressed
            public void mouseReleased(java.awt.event.MouseEvent e)
            {
                if (eventVerbose >= 1) System.out.println("in mouseReleased: "+e);

                double thisP[] = new double[2];
                mostRecentGraphics.pick((e.getX()+.5)/globalMagFactor, (e.getY()+.5)/globalMagFactor, thisP);
                double snappedThisP[] = !snapToGrid ? thisP : new double[] {
                    (double)Math.round(thisP[0]/gridSnapQuantum)*gridSnapQuantum,
                    (double)Math.round(thisP[1]/gridSnapQuantum)*gridSnapQuantum,
                };

                int whichButton = getButton(e);
                if (whichButton == java_awt_event_MouseEvent_BUTTON1)
                {
                    if (rubberBandingNewEdge)
                    {
                        if (mesh.verts.size() == 1)
                        {
                            mesh.addIsolatedVertex(snappedThisP[0], snappedThisP[1], 0);
                        }
                        int finalVertIndex = mesh.indexOfClosestVert(thisP[0],thisP[1]);
                        if (beingDraggedVertIndex != -1
                         && finalVertIndex != -1
                         && beingDraggedVertIndex != finalVertIndex)
                        {
                            System.out.println("Trying to add an edge between "+beingDraggedVertIndex+" and "+finalVertIndex);
                            ArrayList verts = mesh.verts;
                            mesh.addEdgeBetweenTwoVertices(mesh.getVert(beingDraggedVertIndex),
                                                           mesh.getVert(finalVertIndex));
                            mesh.sanityCheck();

                            // added something-- invalidate dual mesh
                            dirtyDualMesh();
                        }
                        if (doContinuouslyDelaunayize.get()) delaunayize();
                    }
                    rubberBandingNewEdge = false;

                    if (beingDraggedNetEdgeIndex != -1
                     && showNet.get())
                    {
                        Mesh dualMesh = getDualMesh();
                        int targetEdgeIndex = dualMesh.indexOfClosestEdge(thisP, true);
                        if (targetEdgeIndex != -1
                         && targetEdgeIndex != beingDraggedNetEdgeIndex)
                        {
                            // could do this once on mouse down, and have them lowlighted or something
                            Mesh.Edge alternatives[] = theNet.alternatives(beingDraggedNetEdgeIndex);
                            if (Arrays.indexOfUsingEqualsSymbol(alternatives, dualMesh.getEdge(targetEdgeIndex)) != -1
                             || Arrays.indexOfUsingEqualsSymbol(alternatives, dualMesh.getEdge(targetEdgeIndex).opposite()) != -1)
                            {
                                theNet.swapCutAndFold(beingDraggedNetEdgeIndex,
                                                      targetEdgeIndex);
                            }
                            else
                            {
                                System.out.println("BONK!");
                            }
                        }
                    }

                    beingDraggedVertIndex = -1;
                    beingDraggedNetEdgeIndex = -1;

                    button1IsDown = false;
                }
                else if (whichButton == java_awt_event_MouseEvent_BUTTON2)
                {
                    button2IsDown = false;
                }
                else if (whichButton == java_awt_event_MouseEvent_BUTTON3)
                {
                    button3IsDown = false;
                }

                if (stateWhenPressed != null)
                {
                    UndoItem.State stateWhenReleased = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);
                    undoTreeSquirrel.Do(new UndoItem(stateWhenPressed, stateWhenReleased));
                    stateWhenPressed = null;
                }

                prevP = thisP;

                theCanvas.repaint();

                if (eventVerbose >= 1) System.out.println("out mouseReleased: "+e);
            }
            public void mouseEntered(java.awt.event.MouseEvent e)
            {
                if (eventVerbose >= 1) System.out.println("in mouseEntered: "+e);
                // steal keyboard focus!
                requestFocus(); // hey it works! (javac 1.3, runtime 1.6)
                if (eventVerbose >= 1) System.out.println("out mouseEntered: "+e);
            }
            public void mouseExited(java.awt.event.MouseEvent e)
            {
                if (eventVerbose >= 1) System.out.println("in mouseExited: "+e);
                if (eventVerbose >= 1) System.out.println("out mouseExited: "+e);
            }
            public void mouseClicked(java.awt.event.MouseEvent e)
            {
                if (eventVerbose >= 1) System.out.println("in mouseClicked: "+e);
                if (eventVerbose >= 1) System.out.println("out mouseClicked: "+e);
            }
            public void mouseDragged(java.awt.event.MouseEvent e)
            {
                if (eventVerbose >= 2) System.out.println("  in mouseDragged: "+e);

                double thisP[] = new double[2];
                mostRecentGraphics.pick((e.getX()+.5)/globalMagFactor, (e.getY()+.5)/globalMagFactor, thisP);
                double snappedThisP[] = !snapToGrid ? thisP : new double[] {
                    (double)Math.round(thisP[0]/gridSnapQuantum)*gridSnapQuantum,
                    (double)Math.round(thisP[1]/gridSnapQuantum)*gridSnapQuantum,
                };
                double snappedPrevP[] = !snapToGrid ? prevP : new double[] {
                    (double)Math.round(prevP[0]/gridSnapQuantum)*gridSnapQuantum,
                    (double)Math.round(prevP[1]/gridSnapQuantum)*gridSnapQuantum,
                };

                if (button1IsDown || button2IsDown)
                {
                    if (rubberBandingNewEdge)
                    {
                        // nothing, we'll just draw the rubberband in the new position when we repaint
                    }
                    else
                    {
                        if (beingDraggedNetEdgeIndex != -1)
                        {
                            // nothing, we'll just draw the dragged edge in the new position when we repaint
                        }
                        else if (e.isShiftDown())
                        {
                            // Drag all the verts
                            FORIDOWN (iVert, mesh.verts.size())
                            {
                                mesh.getVert(iVert).x += snappedThisP[0]-snappedPrevP[0];
                                mesh.getVert(iVert).y += snappedThisP[1]-snappedPrevP[1];
                            }
                            // moved something-- invalidate dual mesh XXX could retain structure and just update positions and angles?? then wouldn't have to invalidate net!
                            dirtyDualMesh();
                        }
                        else if (beingDraggedVertIndex != -1)
                        {
                            if (e.isControlDown())
                            {
                                // Drag all 6 points of kaleidoscope

                                // XXX should do it around whatever center we can find
                                // XXX should do it with whatever rotational periodicity we can find

#if 1
                                // rotation by 120 degrees, row-oriented
                                double A[][] = {
                                   { Math.cos(DTOR(120)), Math.sin(DTOR(120))},
                                   {-Math.sin(DTOR(120)), Math.cos(DTOR(120))},
                                };
                                // left-right reflection
                                double B[][] = {
                                    {-1,0},
                                    {0,1},
                                };
                                double AA[][] = VecMath.mxm(A,A);
                                double I[][] = VecMath.mxm(AA,A);
                                double AB[][] = VecMath.mxm(A,B);
                                double AAB[][] = VecMath.mxm(AA,B);
                                double group[][][] = {I,A,AA,B,AB,AAB};
#endif
#if 0
                                // rotation by 180 degrees, row-oriented
                                double A[][] = {
                                   { Math.cos(DTOR(180)), Math.sin(DTOR(180))},
                                   {-Math.sin(DTOR(180)), Math.cos(DTOR(180))},
                                };
                                // left-right reflection
                                double B[][] = {
                                    {-1,0},
                                    {0,1},
                                };
                                double I[][] = VecMath.mxm(A,A);
                                double group[][][] = {I,A};
#endif

                                double v[] = {mesh.getVert(beingDraggedVertIndex).x,
                                              mesh.getVert(beingDraggedVertIndex).y};
                                double dv[] = VecMath.vmv(thisP, prevP);


                                double newVertPositions[][] = new double[mesh.verts.size()][2];
                                FORI (i, newVertPositions.length)
                                {
                                    newVertPositions[i][0] = mesh.getVert(i).x;
                                    newVertPositions[i][1] = mesh.getVert(i).y;
                                }

                                // Whenever we can find a reflected image vertex in a mirror,
                                // apply the reflected dv to the reflected image vertex.
                                // In particular, if the vertex is its own image,
                                // that means the mirror passes through it;
                                // this will end up constraining it to the mirror
                                // (and moving it twice as far along the mirror as otherwise, which is fine).
                                FORI (iGroup, group.length)
                                {
                                    double image[] = VecMath.vxm(v,group[iGroup]);
                                    int iImage = mesh.indexOfClosestVert(
                                                    image[0], image[1]);

                                    double imageVertPosition[] = {
                                        mesh.getVert(iImage).x,
                                        mesh.getVert(iImage).y,
                                    };

                                    if (VecMath.equals(image, imageVertPosition, 1e-6))
                                    {
                                        // TODO: snap imageVertPosition to image, to prevent drift away from symmetry?
                                        double imageTweak[] = VecMath.vxm(dv, group[iGroup]);
                                        VecMath.vpv(newVertPositions[iImage],
                                                    newVertPositions[iImage],
                                                    imageTweak);
                                    }
                                }
                                FORI (i, newVertPositions.length)
                                {
                                    mesh.getVert(i).x = newVertPositions[i][0];
                                    mesh.getVert(i).y = newVertPositions[i][1];
                                }
                            }
                            else
                            {
                                // Drag just the selected vert
                                mesh.getVert(beingDraggedVertIndex).x += snappedThisP[0]-snappedPrevP[0];
                                mesh.getVert(beingDraggedVertIndex).y += snappedThisP[1]-snappedPrevP[1];
                            }

                            if (doContinuouslyDelaunayize.get()) delaunayize();
                            if (nonEventVerbose >= 1)
                            {
                                double verts[][] = new double[mesh.verts.size()][];
                                FORIDOWN (iVert, mesh.verts.size())
                                    verts[iVert] = new double[] {mesh.getVert(iVert).x,
                                                                 mesh.getVert(iVert).y,
                                                                 mesh.getVert(iVert).h};
                                int edges[][] = new int[mesh.edges.size()][];
                                FORIDOWN (iEdge, mesh.edges.size())
                                    edges[iEdge] = new int[] {(mesh.getEdge(iEdge)).initialVertex().myIndex(),
                                                              (mesh.getEdge(iEdge)).finalVertex().myIndex()};
                                PRINTARRAY(verts);
                                PRINTARRAY(edges);
                            }
                            // moved something-- invalidate dual mesh XXX could retain structure and just update positions and angles?? then wouldn't have to invalidate net!
                            dirtyDualMesh();
                        }
                    }
                }

                if (button3IsDown) // right mouse
                {
                }

                theCanvas.repaint();

                prevP = thisP;

                if (eventVerbose >= 2) System.out.println("  out mouseDragged: "+e);
            }
            public void mouseMoved(java.awt.event.MouseEvent e)
            {
                if (eventVerbose >= 3) System.out.println("    in mouseMoved: "+e);

                if (mostRecentGraphics != null)
                {
                    double thisP[] = new double[2];
                    mostRecentGraphics.pick((e.getX()+.5)/globalMagFactor, (e.getY()+.5)/globalMagFactor, thisP);
                    if (showNet.get())
                    {
                        int closestDualEdgeIndex = getDualMesh().indexOfClosestEdge(thisP, true);
                        if (closestDualEdgeIndex != highlightedDualEdgeIndex)
                        {
                            //System.out.println("    closest dual edge changed: "+getDualMesh().getEdge(closestDualEdgeIndex));
                            highlightedDualEdgeIndex = closestDualEdgeIndex;
                            theCanvas.repaint();
                        }
                    }
                    prevP = thisP;

                    if (showMag.get())
                        theCanvas.repaint();
                }

                if (eventVerbose >= 3) System.out.println("    out mouseMoved: "+e);
            }

            //
            // KeyListener methods...
            //
            public void keyPressed(java.awt.event.KeyEvent e)
            {
                if (eventVerbose >= 1) System.out.println("in keyPressed: "+e);
                double incr = .005;
                switch(e.getKeyCode())
                {
                    case java.awt.event.KeyEvent.VK_UP:
                    {
                        UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);
                        if (doOptimize.get())
                        {
                            doOptimize.set(false);
                            System.out.println("doOptimize -> "+doOptimize.get()+" ('O' to turn back on)");
                        }
                        System.out.print("Up");
                        System.out.flush();
                        int iVert = mesh.indexOfClosestVert(prevP[0], prevP[1]);
                        // pull the dual face *out* of the screen,
                        // i.e. increase its height,
                        // i.e. decrease height of primal vert.
                        if (e.isShiftDown())
                            mesh.getVert(iVert).h -= incr*10;
                        else if (e.isControlDown())
                            mesh.getVert(iVert).h -= incr*.1;
                        else
                            mesh.getVert(iVert).h -= incr;
                        System.out.println("    verts["+iVert+"].h -> "+mesh.getVert(iVert).h);
                        if (doContinuouslyDelaunayize.get()) delaunayize();
                        UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);
                        undoTreeSquirrel.Do(new UndoItem(before, after));
                        dirtyDualMesh();
                        theCanvas.repaint();
                        break;
                    }
                    case java.awt.event.KeyEvent.VK_DOWN:
                    {
                        UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);
                        if (doOptimize.get())
                        {
                            doOptimize.set(false);
                            System.out.println("doOptimize -> "+doOptimize.get()+" ('O' to turn back on)");
                        }
                        System.out.print("Down");
                        System.out.flush();
                        int iVert = mesh.indexOfClosestVert(prevP[0], prevP[1]);
                        // push the dual face *into* of the screen,
                        // i.e. decrease its height,
                        // i.e. increase height of primal vert.
                        if (e.isShiftDown())
                            mesh.getVert(iVert).h += incr*10;
                        else if (e.isControlDown())
                            mesh.getVert(iVert).h += incr*.1;
                        else
                            mesh.getVert(iVert).h += incr;
                        System.out.println("    verts["+iVert+"].h -> "+mesh.getVert(iVert).h);
                        if (doContinuouslyDelaunayize.get()) delaunayize();
                        UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);
                        undoTreeSquirrel.Do(new UndoItem(before, after));
                        dirtyDualMesh();
                        theCanvas.repaint();
                        break;
                    }
                    case java.awt.event.KeyEvent.VK_LEFT:
                    case java.awt.event.KeyEvent.VK_RIGHT:
                    {
                        showNet.set(true);
                        if (_dualMesh != null
                         && theNet != null
                         && highlightedDualEdgeIndex != -1)
                        {
                            if (theNet._edgeStatuses[highlightedDualEdgeIndex] == Net.CUT)
                            {
                                // It's a cut; direction matters.
                                // (for fold, we rely in the closest-edge picking
                                // to pick the correct one of the two half-edges)
                                // Make sure edge in question is pointing
                                // towards root of cut tree.  If not, switch to its opposite.
                                if (_dualMesh.getEdge(highlightedDualEdgeIndex).initialVertex() == null
                                 || theNet._vertToParentEdgeInd[_dualMesh.getEdge(highlightedDualEdgeIndex).initialVertex().myIndex()] != highlightedDualEdgeIndex)
                                    highlightedDualEdgeIndex = _dualMesh.getEdge(highlightedDualEdgeIndex).opposite().myIndex();
                                assert(theNet._vertToParentEdgeInd[_dualMesh.getEdge(highlightedDualEdgeIndex).initialVertex().myIndex()] == highlightedDualEdgeIndex);
                            }

                            Mesh.Edge alternatives[] = theNet.alternatives(highlightedDualEdgeIndex);
                            if (alternatives.length > 0)
                            {
                                int other = alternatives[(e.getKeyCode() == java.awt.event.KeyEvent.VK_LEFT ? 0 : alternatives.length-1)].myIndex();

                                UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);
                                theNet.swapCutAndFold(highlightedDualEdgeIndex,
                                                      other);
                                // make the highlighted one be the one we swapped with.
                                // that makes it so, if the user doesn't jiggle the mouse,
                                // hitting the key repeatedly will rotate around the lagoon.
                                highlightedDualEdgeIndex = other;
                                UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);
                                undoTreeSquirrel.Do(new UndoItem(before, after));
                                theCanvas.repaint();
                            }
                            else
                            {
                                System.out.println("HEY! edge "+_dualMesh.getEdge(highlightedDualEdgeIndex)+" has no alternative! status="+theNet._edgeStatuses[highlightedDualEdgeIndex]);
                                assert(theNet._edgeStatuses[highlightedDualEdgeIndex] == Net.FOLD);
                                assert(false); // wtf? this shouldn't happen
                            }

                            if (true)
                            {
                                // just sanity check that we can walk around the net tree starting from highlighted dual edge index

                                //System.out.println("===================");
                                //System.out.println("Walking around net tree:");
                                Mesh.Edge dualEdge = _dualMesh.getEdge(highlightedDualEdgeIndex);
                                // assert against infinite loop...
                                boolean seen[] = new boolean[_dualMesh.edges.size()]; // false initially
                                while (true)
                                {
                                    assert(!seen[dualEdge.myIndex()]);
                                    if (false)
                                        System.out.println("    "+dualEdge);
                                    seen[dualEdge.myIndex()] = true;
                                    assert(_dualMesh.getEdge(dualEdge.myIndex()) == dualEdge); // check that nextInTree didn't get confused and switch trees
                                    dualEdge = theNet.nextInTree(dualEdge);
                                    assert(_dualMesh.getEdge(dualEdge.myIndex()) == dualEdge); // check that nextInTree didn't get confused and switch trees
                                    if (dualEdge.myIndex() == highlightedDualEdgeIndex)
                                        break;
                                }
                                //System.out.println("===================");
                            }

                        }
                        break;
                    }

                    default:
                        // don't print anything, or we'll print too much (e.g. Shift, and any keys we handle in keyTyped())
                        //System.out.println("Unknown keycode "+java.awt.event.KeyEvent.getKeyText(e.getKeyCode())+" ("+e.getKeyCode()+")");
                        break;
                }
                if (eventVerbose >= 1) System.out.println("out keyPressed: "+e);
            }
            public void keyReleased(java.awt.event.KeyEvent e)
            {
                if (eventVerbose >= 1) System.out.println("in keyReleased: "+e);
                if (eventVerbose >= 1) System.out.println("out keyReleased: "+e);
            }
            public void keyTyped(java.awt.event.KeyEvent e)
            {
                if (eventVerbose >= 1) System.out.println("in keyTyped: "+e);
                char c = e.getKeyChar();

                // In java 1.6, apparently ctrl-letter
                // started coming out as just the letter
                // (with ke.isControlDown() true).
                // Detect this and change it to the old behavior...
                // XXX need to do something else, or nothing at all here, for old javas (1.1) in which isControlDown doesn't exist... or else just stop trying to support 1.1 at all
                if (c >= 'a' && c <= 'z' && e.isControlDown())
                {
                    c -= ('a'-1);
                }

    #define CTRL(lowerCaseLetter) ((lowerCaseLetter)-'a' + 1)
                switch (c)
                {
                    case 'V': // cycle verbosity-- upper-case to minimize possibility of hitting it by accident thus causing subsequent perfomance degradation with no visible reason if Java Console is not visible
                        System.out.print("eventVerbose "+eventVerbose);
                        eventVerbose = (eventVerbose+1) % 4;
                        System.out.println(" -> "+eventVerbose);
                        break;

                    case ' ': // just repaint (i.e. mark dirty)
                        theCanvas.repaint();
                        break;
                    case 'A': // toggle doAntiAliasing
                        doAntiAliasing ^= true;
                        System.out.println("doAntiAliasing -> "+doAntiAliasing+" (if this platform supports it)");
                        theCanvas.repaint();
                        break;

                    case 't': // toggle showTriangles
                        System.out.print("showTriangles "+showTriangles);
                        showTriangles = MOD(showTriangles-1, 3);
                        System.out.println(" -> "+showTriangles);
                        theCanvas.repaint();
                        break;

                    case 'n': // toggle showNet
                        showNet.set(!showNet.get());
                        System.out.println("showNet -> "+showNet.get());
                        theCanvas.repaint();
                        break;

                    case 'B': // toggle doDoubleBuffer
                        doDoubleBuffer ^= true;
                        System.out.println("doDoubleBuffer -> "+doDoubleBuffer);
                        theCanvas.repaint();
                        break;

                    case 'i': case '+': case '=': // zoom in
                    {
                        rescale(Math.sqrt(2.), Math.sqrt(2.));
                        break;
                    }
                    case 'o': case '-':           // zoom out
                    {
                        rescale(Math.sqrt(.5), Math.sqrt(.5));
                        break;
                    }
                    case 'f': // frame
                    {
                        frame();
                        break;
                    }
                    case '|': // left-to-right flip whole diagram
                    {
                        UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);
                        mesh.flipLeftRight();
                        dirtyDualMesh(); // flip doesn't work when verts missing
                        // should be no need to re-delaunayize
                        UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);
                        undoTreeSquirrel.Do(new UndoItem(before, after));
                        theCanvas.repaint();
                        break;
                    }
                    case '_': // up-to-down flip whole diagram
                    {
                        UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);
                        mesh.flipUpDown();
                        dirtyDualMesh(); // flip doesn't work when verts missing
                        // should be no need to re-delaunayize
                        UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);
                        undoTreeSquirrel.Do(new UndoItem(before, after));
                        theCanvas.repaint();
                        break;
                    }
                    case '\\': // lower-left to upper-right flip whole diagram
                    {
                        UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);
                        mesh.flipLowerLeftUpperRight();
                        dirtyDualMesh(); // flip doesn't work when verts missing
                        // should be no need to re-delaunayize
                        UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);
                        undoTreeSquirrel.Do(new UndoItem(before, after));
                        theCanvas.repaint();
                        break;
                    }
                    case '/': // upper-left to lower-right flip whole diagram
                    {
                        UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);
                        mesh.flipUpperLeftLowerRight();
                        dirtyDualMesh(); // flip doesn't work when verts missing
                        // should be no need to re-delaunayize
                        UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);
                        undoTreeSquirrel.Do(new UndoItem(before, after));
                        theCanvas.repaint();
                        break;
                    }

                    case 's': // swap diagonal
                    {
                        UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);
                        //
                        // Really would like everything selected
                        // that was selected before,
                        // except for the two dual verts that changed...
                        // the new two should both be selected
                        // if the original two were selected,
                        // or both unselected otherwise.
                        // XXX TODO: do this


                        int closestEdgeIndex = mesh.indexOfClosestEdge(prevP, false);
                        if (closestEdgeIndex != -1)
                        {
                            System.out.println("Swapping diagonal edge e"+closestEdgeIndex);
                            mesh.swapDiagonal(mesh.getEdge(closestEdgeIndex), /*onlyIfMoreDelaunay=*/false, /*verbose=*/true);
                            mesh.sanityCheck();
                        }
                        if (doContinuouslyDelaunayize.get()) delaunayize();

                        UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);
                        undoTreeSquirrel.Do(new UndoItem(before, after));
                        theCanvas.repaint();
                        break;
                    }

                    case CTRL('s'): // swap diagonal but only if it makes it closer to delaunay
                    {
                        // Swap diagonal but only if it makes it closer to delaunay
                        UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);
                        int closestEdgeIndex = mesh.indexOfClosestEdge(prevP, false);
                        if (closestEdgeIndex != -1)
                        {
                            System.out.println("Swapping diagonal edge e"+closestEdgeIndex);
                            mesh.swapDiagonal(mesh.getEdge(closestEdgeIndex), /*onlyIfMoreDelaunay=*/true, /*verbose=*/true);
                            mesh.sanityCheck();
                        }
                        if (doContinuouslyDelaunayize.get()) delaunayize(); // silly, it will just undo the swap in this case
                        UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);
                        undoTreeSquirrel.Do(new UndoItem(before, after));
                        theCanvas.repaint();
                        break;
                    }

                    case 'D': // delaunayize
                    {
                        UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);
                        delaunayize();
                        UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);
                        undoTreeSquirrel.Do(new UndoItem(before, after));
                        theCanvas.repaint();
                        break;
                    }

                    case 'w': // toggle closest dual vertex for weighting (think of better mnemonic)
                    {
                        UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);
                        {
                            Mesh dualMesh = getDualMesh();
                            double closestDistSqrd = Double.POSITIVE_INFINITY;
                            int closestIndex = -1;
                            int nDualVerts = dualMesh.verts.size();
                            PRINT(nDualVerts);
                            FORI (iDualVert, nDualVerts) // beginning to end, so we choose first of equal
                            {
                                Mesh.Vertex dualVert = dualMesh.getVert(iDualVert);
                                if (dualVert.arity != 3)
                                    continue; // not a triangle
                                if (!doShowInsideOutDualVerts)
                                {
                                    if (dualVert.weight < 0)
                                        continue; // the triangle is inside out; it's the boundary
                                }
                                double thisDistSqrd = VecMath.distsqrd(prevP, new double[]{dualVert.x,dualVert.y});
                                if (thisDistSqrd < closestDistSqrd)
                                {
                                    closestDistSqrd = thisDistSqrd;
                                    closestIndex = iDualVert;
                                }
                            }
                            if (closestIndex != -1)
                            {
                                PRINT(closestIndex);
                                // figure out the 3 primal verts
                                int closestTri[] = null;
                                {
                                    int nEdges = dualMesh.edges.size();
                                    assert(nEdges == mesh.edges.size());
                                    FORI (iEdge, nEdges)
                                    {
                                        Mesh.Edge dualEdge = dualMesh.getEdge(iEdge);
                                        Mesh.Vertex initialVertex = dualEdge.initialVertex();
                                        if (initialVertex != null
                                         && initialVertex.myIndex() == closestIndex)
                                        {
                                            Mesh.Edge primalEdge = (mesh.getEdge(iEdge)).opposite();
                                            // advance around triangle til initial vertex is smallest
                                            while (primalEdge.initialVertex().myIndex() > primalEdge.finalVertex().myIndex()
                                                || primalEdge.initialVertex().myIndex() > primalEdge.prev().initialVertex().myIndex())
                                                primalEdge = primalEdge.next();
                                            int i0 = primalEdge.initialVertex().myIndex();
                                            int i1 = primalEdge.finalVertex().myIndex();
                                            int i2 = primalEdge.prev().initialVertex().myIndex();
                                            closestTri = new int[] {i0,i1,i2};
                                        }
                                    }
                                }
                                assert(closestTri != null);
                                PRINTARRAY(closestTri);

                                int indInd = Arrays.indexOf(selectedDualVertIndices, closestIndex);
                                double closestDualVertWeight = (dualMesh.getVert(closestIndex)).weight;
                                double totalWeightBefore = 0.; FORIDOWN(iSelected, selectedDualVertIndices.length) if (selectedDualVertIndices[iSelected] != -1) totalWeightBefore += (dualMesh.getVert(selectedDualVertIndices[iSelected])).weight;

                                if (indInd != -1)
                                {
                                    System.out.println("    deselecting dual vert "+closestIndex);
                                    selectedTris = (int[][])Arrays.delete(selectedTris, indInd);
                                    selectedDualVertIndices = (int[])Arrays.delete(selectedDualVertIndices, indInd);
                                }
                                else
                                {
                                    System.out.println("    selecting dual vert "+closestIndex);
                                    selectedTris = (int[][])Arrays.append(selectedTris, closestTri);
                                    selectedDualVertIndices = (int[])Arrays.append(selectedDualVertIndices, closestIndex);
                                }
                                double totalWeightAfter = 0.; FORIDOWN(iSelected, selectedDualVertIndices.length) if (selectedDualVertIndices[iSelected] != -1) totalWeightAfter += (dualMesh.getVert(selectedDualVertIndices[iSelected])).weight;
                                System.out.println("    Total selected weight: "+totalWeightBefore+" "+(indInd!=-1?'-':'+')+" "+closestDualVertWeight+" = "+totalWeightAfter+"");
                            }
                        }
                        UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);
                        undoTreeSquirrel.Do(new UndoItem(before, after));
                        theCanvas.repaint();
                        break;
                    }
                    case 'd': // delete closest edge
                    {
                        UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);
                        int closestEdgeIndex = mesh.indexOfClosestEdge(prevP, false);
                        if (closestEdgeIndex != -1)
                        {
                            System.out.println("Deleting edge e"+closestEdgeIndex);
                            mesh.deleteEdge(mesh.getEdge(closestEdgeIndex));
                            mesh.sanityCheck();
                            // deleted something-- invalidate dual mesh
                            dirtyDualMesh();
                        }
                        doContinuouslyDelaunayize.set(false);
                        UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);
                        undoTreeSquirrel.Do(new UndoItem(before, after));
                        theCanvas.repaint();
                        break;
                    }
                    case 'S': // turn off optimize, and re-sphereize
                    {
                        UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);
                        if (doOptimize.get())
                        {
                            doOptimize.set(false);
                            System.out.println("doOptimize -> "+doOptimize.get()+" ('O' to turn back on)");
                        }
                        FORIDOWN (iVert, mesh.verts.size())
                            mesh.getVert(iVert).h = 0.;
                        if (doContinuouslyDelaunayize.get()) delaunayize();
                        UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);
                        undoTreeSquirrel.Do(new UndoItem(before, after));
                        theCanvas.repaint();
                        break;
                    }

                    case 'l': // toggle showLabels
                        showLabels ^= true;
                        System.out.println("showLabels -> "+showLabels);
                        theCanvas.repaint();
                        break;

                    case 'g': // toggle showGrid
                        showGrid ^= true;
                        System.out.println("showGrid -> "+showGrid);
                        theCanvas.repaint();
                        break;

                    case CTRL('g'): // toggle snapToGrid
                        snapToGrid ^= true;
                        System.out.println("snapToGrid -> "+snapToGrid);
                        // no need to repaint
                        break;

                    case 'M':
                        System.out.print("magWidth "+magWidth);
                        magWidth += 2;
                        System.out.println(" -> "+magWidth);
                        theCanvas.repaint();
                        break;
                    case 'm':
                        System.out.print("magWidth "+magWidth);
                        magWidth = MAX(1, magWidth-2);
                        System.out.println(" -> "+magWidth);
                        theCanvas.repaint();
                        break;
                    case 'P':
                        System.out.print("magFactor "+magFactor);
                        magFactor += 1;
                        System.out.println(" -> "+magFactor);
                        showMag.set(true); // so it's clear what happened
                        theCanvas.repaint();
                        break;
                    case 'p':
                        System.out.print("magFactor "+magFactor);
                        magFactor = MAX(0, magFactor-1);
                        System.out.println(" -> "+magFactor);
                        showMag.set(true); // so it's clear what happened
                        theCanvas.repaint();
                        break;

                    case CTRL('m'):
                    case CTRL('j'): // ARGH! ctrl-m comes out as ctrl-j!?
                        showMag.set(!showMag.get());
                        System.out.println("showMag -> "+showMag.get());
                        theCanvas.repaint();
                        break;




                    case '0': // toggle showOrigin
                        showOrigin ^= true;
                        System.out.println("showOrigin -> "+showOrigin);
                        theCanvas.repaint();
                        break;

                    case 'O': // toggle doOptimize
                    {
                        UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);
                        doOptimize.set(!doOptimize.get());
                        System.out.println("doOptimize -> "+doOptimize.get());
                        if (doContinuouslyDelaunayize.get()) delaunayize();
                        UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);
                        undoTreeSquirrel.Do(new UndoItem(before, after));
                        theCanvas.repaint();
                        break;
                    }

                    case 'a': // toggle doArrowsTowardsSharpestDihedrals or doArrowsTowardsShortestEdges
                    {
                        if (e.isAltDown())
                        {
                            doArrowsTowardsShortestEdges ^= true;
                            System.out.println("doArrowsTowardsShortestEdges -> "+doArrowsTowardsShortestEdges);
                        }
                        else
                        {
                            doArrowsTowardsSharpestDihedrals ^= true;
                            System.out.println("doArrowsTowardsSharpestDihedrals -> "+doArrowsTowardsSharpestDihedrals);
                        }
                        theCanvas.repaint();
                        break;
                    }

                    case CTRL('d'): // swap primal and dual
                    {
                        UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);

                        boolean heightsWereAllZero = true;
                        FORI (iVert, mesh.verts.size())
                            if (mesh.getVert(iVert).h != 0.)
                            {
                                heightsWereAllZero = false;
                                break;
                            }

                        mesh = makeDualMesh(mesh,
                                            true,  // includeNonArity3 (so we get full mesh)
                                            true); // includeInsideOut

                        // this seems to make it a bit better, though I don't really understand.
                        if (heightsWereAllZero)
                        {
                            FORI (iVert, mesh.verts.size())
                                mesh.getVert(iVert).h = 0.;
                        }

                        selectedTris = new int[][] {};
                        selectedDualVertIndices = new int[] {};
                        if (doContinuouslyDelaunayize.get()) delaunayize();
                        UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);
                        undoTreeSquirrel.Do(new UndoItem(before, after));
                        theCanvas.repaint();
                        break;
                    }

                    case 'u': case CTRL('z'): // undo
                    {
                        UndoItem item = (UndoItem)undoTreeSquirrel.undo();
                        if (item != null)
                        {
                            mesh = new Mesh(item.before.mesh);
                            meshOfSelectedTris = mesh; // hackish
                            doContinuouslyDelaunayize.set(item.before.doContinuouslyDelaunayize);
                            doOptimize.set(item.before.doOptimize);
                            optimizationTypeIndex.set(item.before.optimizationTypeIndex);
                            optimizationType = availableOptimizationTypes[optimizationTypeIndex.get()];
                            selectedTris = (int[][])Arrays.copy(item.before.selectedTris, 2);
                            selectedDualVertIndices = VecMath.copyvec(item.before.selectedDualVertIndices);
                            dirtyDualMesh(); // *before* we restore theNet
                            theNet = (item.before.netCuts==null ? null : new Net(getDualMesh(), mesh, item.before.netCuts));
                        }
                        else
                        {
                            System.out.println("Nothing to undo!");
                        }
                        theCanvas.repaint();
                        break;
                    }
                    case 'r': case 'U': case CTRL('r'): case CTRL('y'): // redo
                    {
                        UndoItem item = (UndoItem)undoTreeSquirrel.redo();
                        if (item != null)
                        {
                            mesh = new Mesh(item.after.mesh);
                            meshOfSelectedTris = mesh; // hackish
                            doContinuouslyDelaunayize.set(item.after.doContinuouslyDelaunayize);
                            doOptimize.set(item.after.doOptimize);
                            optimizationTypeIndex.set(item.after.optimizationTypeIndex);
                            optimizationType = availableOptimizationTypes[optimizationTypeIndex.get()];
                            selectedTris = (int[][])Arrays.copy(item.after.selectedTris, 2);
                            selectedDualVertIndices = VecMath.copyvec(item.after.selectedDualVertIndices);
                            dirtyDualMesh(); // *before* we restore theNet
                            theNet = (item.after.netCuts==null ? null : new Net(getDualMesh(), mesh, item.after.netCuts));
                        }
                        else
                        {
                            System.out.println("Nothing to redo!");
                        }
                        theCanvas.repaint();
                        break;
                    }
                    case 'c': // clear
                    {
                        UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);
                        showNet.set(false); // so user won't get confused when clicking doesn't make verts appear
                        mesh = new Mesh();
                        selectedTris = new int[][] {};
                        selectedDualVertIndices = new int[] {};
                        if (doContinuouslyDelaunayize.get()) delaunayize();
                        dirtyDualMesh(); // before snapping after state, so theNet will be cleared XXX aren't there a zillion places we're neglecting to take this into account?
                        UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);
                        undoTreeSquirrel.Do(new UndoItem(before, after));
                        theCanvas.repaint();
                        break;
                    }
                    case CTRL('q'): // quit
                    {
                        System.out.println("Aww.");
                        System.exit(1);
                    }

                    case 'h': // help
                        help();
                        break;

                    case CTRL('i'): // toggle doShowInsideOutDualVerts
                        doShowInsideOutDualVerts ^= true;
                        System.out.println("doShowInsideOutDualVerts -> "+doShowInsideOutDualVerts);
                        theCanvas.repaint();
                        break;

                    case CTRL('o'): // cycle optimizationType
                        optimizationTypeIndex.set((optimizationTypeIndex.get()+1)%availableOptimizationTypes.length);
                        optimizationType = availableOptimizationTypes[optimizationTypeIndex.get()];
                        System.out.println("optimizationType -> "+optimizationTypeNames[optimizationType]);
                        theCanvas.repaint();
                        break;

                    case CTRL('v'): // toggle nonEventVerbose
                        nonEventVerbose = (nonEventVerbose+1)%2;
                        System.out.println("nonEventVerbose -> "+nonEventVerbose);
                        theCanvas.repaint();
                        break;

                    case '7': case '&': case '8': case '*':
                    {
                        int oldIndex = netless8OptimizationIndex;
                        switch (c)
                        {
                            case '&': netless8OptimizationIndex = 0; break;
                            case '7': netless8OptimizationIndex = MAX(netless8OptimizationIndex-1, 0); break;
                            case '8': netless8OptimizationIndex = MIN(netless8OptimizationIndex+1, netless8OptimizationPath.length-1); break;
                            case '*': netless8OptimizationIndex = netless8OptimizationPath.length-1; break;
                        }
                        System.out.println("netless8OptimizationIndex "+oldIndex+" -> "+netless8OptimizationIndex+"");

                        if (netless8OptimizationIndex != oldIndex)
                        {
                            double verts[][] = netless8OptimizationPath[netless8OptimizationIndex];
                            if (mesh.verts.size() == verts.length)
                            {
                                FORI (iVert, verts.length)
                                {
                                    mesh.getVert(iVert).x = verts[iVert][0];
                                    mesh.getVert(iVert).y = verts[iVert][1];
                                    mesh.getVert(iVert).h = verts[iVert][2];
                                }
                            }

                            theCanvas.repaint();
                        }
                        break;
                    }

                    case CTRL('b'): // blue noise pattern
                    {
                        UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);

                        doBlueNoiseThing();

                        if (doContinuouslyDelaunayize.get()) delaunayize();
                        UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);
                        undoTreeSquirrel.Do(new UndoItem(before, after));
                        theCanvas.repaint();
                        break;
                    }

                    case CTRL('c'): // very special case canned... netless9 example
                    {
                        UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);

                        if (e.isAltDown())
                            doCannedThingHexesSpiral();
                        else
                            doCannedThingNetless9();

                        if (doContinuouslyDelaunayize.get()) delaunayize();
                        UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);
                        undoTreeSquirrel.Do(new UndoItem(before, after));
                        theCanvas.repaint();
                        break;
                    }
                    case CTRL('e'): // very special case canned eyeball example
                    {
                        UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);
                        doCannedThingEyeball();
                        if (doContinuouslyDelaunayize.get()) delaunayize();
                        UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);
                        undoTreeSquirrel.Do(new UndoItem(before, after));
                        theCanvas.repaint();
                        break;
                    }

                    case CTRL('l'): // optimize farthest lagoon exit killer XXX this should be temporary maybe
                    {
                        UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);
                        optimizeFarthestLagoonExitKiller();
                        if (doContinuouslyDelaunayize.get()) delaunayize();
                        UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedTris, selectedDualVertIndices, theNet);
                        undoTreeSquirrel.Do(new UndoItem(before, after));
                        theCanvas.repaint();
                        break;
                    }

                    case CTRL('t'): // analyze random spanning trees
                    {
                        analyzeRandomSpanningTrees(mesh);
                        break;
                    }


                    default:
                        System.out.println("Unknown key '"+c+"'("+(int)e.getKeyChar()+") typed");
                        break;
                }
                if (eventVerbose >= 1) System.out.println("out keyTyped: "+e);
            } // keyTyped






            //
            // Make it so we get keyboard focus on startup,
            // without having to click first.  Thanks, Melinda!
            // The state of things seems to be:
            //      - Buttons and TextFields are apparently "focus traversable"
            //        by default.  Canvases and Applets aren't,
            //        implying (not obvious) that you need to click to type
            //        when the app starts,
            //        which is almost never the desired behavior.
            //        You can change this by overriding isFocusTraversable(),
            //        which we do below.
            //      - Other approaches using requestFocus():
            //        A Canvas calling requestFocus() doesn't seem to do
            //        anything.  An Applet calling requestFocus() doesn't
            //        do anything during init(), but I think it works
            //        if you put it in the mouseEntered handler or something,
            //        though this can lead to various unpredictabilities.
            //
            public boolean isFocusTraversable()
            {
                return true;
            }

            // override to not clear...
            public void update(java.awt.Graphics g)
            {
                paint(g);
            }

                // common code used twice
                private void drawLabels(MyGraphics mg,
                                        Mesh mesh,
                                        boolean isDualMesh)
                {
                    boolean trySmartVertexAngles = true;

                    double smartVertexAngles[] = null;
                    if (trySmartVertexAngles)
                    {
                        int nVerts = mesh.verts.size();
                        int nEdges = mesh.edges.size();
                        smartVertexAngles = new double[nVerts]; // initialized to 0

                        FORI (iEdge0, nEdges)
                        {
                            Mesh.Edge edge0 = mesh.getEdge(iEdge0);
                            Mesh.Vertex vert = edge0.initialVertex();
                            if (vert == null)
                                continue;
                            if (smartVertexAngles[vert.myIndex()] != 0.)
                                continue; // already saw this one for sure

                            double biggestGap = -1.;
                            double angOfBiggestGap = 0.;
                            // walk CCW around vertex
                            Mesh.Edge thisEdge = edge0;
                            Mesh.Edge nextEdge;
                            do {
                                assert(thisEdge.initialVertex() == vert);
                                nextEdge = thisEdge.prev().opposite();
                                double nextAng =
                                    nextEdge.direction != null
                                  ? Math.atan2(nextEdge.direction[1],
                                               nextEdge.direction[0])
                                  : Math.atan2(nextEdge.finalVertex().y-nextEdge.initialVertex().y,
                                               nextEdge.finalVertex().x-nextEdge.initialVertex().x);
                                double thisAng =
                                    thisEdge.direction != null
                                  ? Math.atan2(thisEdge.direction[1],
                                               thisEdge.direction[0])
                                  : Math.atan2(thisEdge.finalVertex().y-thisEdge.initialVertex().y,
                                               thisEdge.finalVertex().x-thisEdge.initialVertex().x);
                                double thisGap = nextAng - thisAng;
                                if (isDualMesh)
                                    thisGap = -thisGap;
                                if (thisGap < 0)
                                    thisGap += 2*Math.PI;
                                if (thisGap > biggestGap)
                                {
                                    biggestGap = thisGap;
                                    if (isDualMesh)
                                        angOfBiggestGap = thisAng - thisGap/2;
                                    else
                                        angOfBiggestGap = thisAng + thisGap/2;
                                }
                            } while ((thisEdge = nextEdge) != edge0);
                            smartVertexAngles[vert.myIndex()] = angOfBiggestGap;
                        }
                    }



                    if (true)
                    {
                        ArrayList verts = mesh.verts;
                        FORIDOWN (iVert, verts.size())
                        {
                            Mesh.Vertex vert = (Mesh.Vertex)verts.get(iVert);
                            double x = vert.x;
                            double y = vert.y;
                            double ang;
                            if (trySmartVertexAngles)
                            {
                                ang = smartVertexAngles[iVert];
                            }
                            else
                            {
                                ang = Math.random() * 2*Math.PI;
                            }
                            double offr = 5/mg.getScaleX(); // pixels
                            double offx = offr*Math.cos(ang);
                            double offy = offr*Math.sin(ang);
                            double offmax = MAX(ABS(offx),ABS(offy));

                            mg.drawString("v"+iVert,
                                          x+offx,
                                          y+offy,
                                          -offx/offmax, offy/offmax);
                        }
                    }

                    if (false) // edges are too busy, maybe should be separate option
                    {
                        ArrayList edges = mesh.edges;
                        FORIDOWN (iEdge, edges.size())
                        {
                            Mesh.Edge edge = (Mesh.Edge)edges.get(iEdge);
                            Mesh.Vertex v0 = edge.initialVertex();
                            Mesh.Vertex v1 = edge.finalVertex();
                            double rayLength = 1.;
                            double x0 = (v0!=null ? v0.x : v1.x - edge.direction[0]*rayLength);
                            double y0 = (v0!=null ? v0.y : v1.y - edge.direction[1]*rayLength);
                            double x1 = (v1!=null ? v1.x : v0.x + edge.direction[0]*rayLength);
                            double y1 = (v1!=null ? v1.y : v0.y + edge.direction[1]*rayLength);

                            double x = (x0+x1)/2;
                            double y = (y0+y1)/2;
                            double ang = Math.PI/2 + Math.atan2(y1-y0, x1-x0);
                            if (isDualMesh)
                                ang += Math.PI;
                            double offr = 2/mg.getScaleX(); // pixels
                            double offx = offr*Math.cos(ang);
                            double offy = offr*Math.sin(ang);
                            double offmax = MAX(ABS(offx),ABS(offy));
                            mg.drawString("e"+iEdge,
                                          x+offx,
                                          y+offy,
                                          -offx/offmax, offy/offmax);
                        }
                    }
                } // drawLabels

            // PAINT/DISPLAY/DRAW
            public void paint(java.awt.Graphics frontBufferGraphics)
            {
                if (eventVerbose >= 1) System.out.println("in paint");

                makeSureBackBufferIsRight();
                java.awt.Graphics g;
                java.awt.Dimension size;
                if (doDoubleBuffer)
                {
                    g = backBufferImage.getGraphics();
                    size = new java.awt.Dimension(backBufferImage.getWidth(null),
                                                  backBufferImage.getHeight(null));
                }
                else
                {
                    g = frontBufferGraphics;
                    size = getSize();
                }


                double minSize = (double)MIN(size.width, size.height);
                MyGraphics mg = new MyGraphics(g, size,
                                        -size.width/minSize,size.width/minSize,
                                        -size.height/minSize,size.height/minSize);
                mostRecentGraphics = mg;

                if (implementAntiAliasingInHardware)
                {
                    graphicsAntiAliasingSetter.setAntiAliasing(g,
                                                               doAntiAliasing,
                                                               //1
                                                               eventVerbose
                                                               );
                }


                //
                // Clear to black...
                //
                mg.setColor(java.awt.Color.black);
                mg.fillWindow();

                if (showGrid)
                {
                    // experiment with grids... not sure exactly what I want yet

                    // XXX get these for real
                    double xmax = 5.;
                    double ymax = 5.;

                    // level 0 : 1 apart
                    // level 1: 1/2 apart
                    // level 2: 1/4 apart
                    // etc.
                    int nLevels = 7;
                    FORIDOWN(iLevel, nLevels)
                    {
                        // tweaked til I like it...
                        double start = .09;
                        double speed = 1./3.;
                        float luminance = (float)(start * Math.pow(.5, iLevel*speed));
                        mg.setColor(new java.awt.Color(luminance,luminance,luminance));
                        int gridLinesPerUnit = 1 << iLevel;
                        FORI (iGridLine, gridLinesPerUnit * xmax)
                        {
                            if (iLevel == 0
                             || iGridLine % 2 == 1)
                            {
                                double x = iGridLine / (double)gridLinesPerUnit;
                                mg.drawLine(-ymax, x,
                                             ymax, x,
                                             doAntiAliasing);
                                mg.drawLine(-ymax, -x,
                                             ymax, -x,
                                             doAntiAliasing);
                            }
                        }
                        FORI (iGridLine, gridLinesPerUnit * ymax)
                        {
                            if (iLevel == 0
                             || iGridLine % 2 == 1)
                            {
                                double y = iGridLine / (double)gridLinesPerUnit;
                                mg.drawLine( y, -xmax,
                                             y,  xmax,
                                             doAntiAliasing);
                                mg.drawLine(-y, -xmax,
                                            -y,  xmax,
                                             doAntiAliasing);
                            }
                        }
                    }
                }





                //
                // Try optimizing the heights...
                // XXX paint is a funky place for this
                //
                if (doOptimize.get())
                    mesh.findAndApplyOptimalVertexHeights(optimizationType);

                boolean doMakeVert0CoplanarWith145 = false;
                if (doMakeVert0CoplanarWith145)
                {
                    // XXX total hack
                    Mesh.Vertex v0 = mesh.getVert(0);
                    Mesh.Vertex v1 = mesh.getVert(1);
                    Mesh.Vertex v4 = mesh.getVert(4);
                    Mesh.Vertex v5 = mesh.getVert(5);
                    double A[] = {v1.x, v1.y, v1.h - .5 * (SQR(v1.x) + SQR(v1.y))};
                    double B[] = {v4.x, v4.y, v4.h - .5 * (SQR(v4.x) + SQR(v4.y))};
                    double C[] = {v5.x, v5.y, v5.h - .5 * (SQR(v5.x) + SQR(v5.y))};
                    double N[] = VecMath.vxv3(VecMath.vmv(B,A),
                                              VecMath.vmv(C,A));
                    double desiredDot = VecMath.dot(N,A);
                    double D[] = {v0.x, v0.y, v0.h};
                    // Find D[2] such that N dot D == desiredDot
                    // I.e. N[0]*D[0] + N[1]*D[1] + N[2]*D[2] == desiredDot
                    D[2] = (desiredDot - (N[0]*D[0] + N[1]*D[1])) / N[2];

                    v0.h = D[2];
                    v0.h += .5 * (SQR(v0.x) + SQR(v0.y));
                }

                //
                // Draw the dual diagram in color...
                //
                java.awt.Color lightBlue = new java.awt.Color(128,128,255);
                /*
                java.awt.Color dualVertSelectionColor = java.awt.Color.green;
                java.awt.Color dualColor = java.awt.Color.red;
                java.awt.Color dualColorBothSelected = lightBlue;
                java.awt.Color dualColorOneSelectedBad = java.awt.Color.magenta;
                java.awt.Color dualColorOneSelectedGood = java.awt.Color.green;
                java.awt.Color perpColorBad = new java.awt.Color(64,0,64); // dark magenta
                java.awt.Color perpColorGood = new java.awt.Color(0,32,0); // dark green
                */
                java.awt.Color dualVertSelectionColor = java.awt.Color.yellow;
                java.awt.Color dualColor = lightBlue;
                java.awt.Color dualColorBothSelected = java.awt.Color.yellow;
                java.awt.Color dualColorOneSelectedBad = java.awt.Color.red;
                java.awt.Color dualColorOneSelectedGood = java.awt.Color.green;
                java.awt.Color perpColorBad = new java.awt.Color(64,0,0); // dark red
                java.awt.Color perpColorGood = new java.awt.Color(0,32,0); // dark green

                Mesh dualMesh = getDualMesh();

                if (true)
                {
                    //
                    // Compute and store the dual mesh if necessary
                    //
                    if (highlightedDualEdgeIndex >= dualMesh.edges.size())
                    {
                        // prevent indexing out of bounds later on
                        System.out.println("clearing highlightedDualEdgeIndex since it's obviously wrong");
                        highlightedDualEdgeIndex = -1;
                    }


                    if (meshOfSelectedTris != mesh)
                    {
                        if (selectedTris.length > 0) System.out.println("MESH CHANGED-- INVALIDATING SELECTION!");
                        selectedTris = new int[][] {};
                        selectedDualVertIndices = new int[] {};
                        meshOfSelectedTris = mesh;
                    }
                    if (true)
                    {
                        // Re-generate selectedDualVerts from selectedTris

                        // XXX SUBTLE BUG: if mesh topology changed e.g. a diagonal swap
                        // such that before there was 012 and after there is 013,
                        // we'll think 013 is selected

                        selectedDualVertIndices = new int[selectedTris.length];


                        java.util.Hashtable edgeEndsToEdge = new java.util.Hashtable();
                        int nEdges = mesh.edges.size();
                        assert(nEdges == dualMesh.edges.size());
                        FORI (iEdge, nEdges)
                        {
                            Mesh.Edge edge = mesh.getEdge(iEdge);
                            int i0 = edge.initialVertex().myIndex();
                            int i1 = edge.finalVertex().myIndex();
                            edgeEndsToEdge.put(""+i0+" "+i1, edge);
                        }
                        FORI (iSelectedTri, selectedTris.length)
                        {
                            int tri[] = selectedTris[iSelectedTri];
                            Mesh.Edge edge = (Mesh.Edge)edgeEndsToEdge.get(""+tri[0]+" "+tri[1]);
                            if (edge == null)
                            {
                                System.out.println("HEY! can't find dual vert");
                                selectedDualVertIndices[iSelectedTri] = -1;
                            }
                            else
                            {
                                Mesh.Edge dualEdge = dualMesh.getEdge(edge.myIndex()); // right to left
                                Mesh.Vertex dualVert = dualEdge.finalVertex();
                                if (dualVert != null)
                                    selectedDualVertIndices[iSelectedTri] = dualEdge.finalVertex().myIndex();
                                else
                                {
                                    System.out.println("HEY! selected dual vert disappeared");
                                    selectedDualVertIndices[iSelectedTri] = -1;
                                }
                            }
                        }
                        if (selectedTris.length > 0) PRINTARRAY(selectedTris);
                        if (selectedDualVertIndices.length > 0) PRINTARRAY(selectedDualVertIndices);
                    }

                    boolean isSelectedDualVert[] = new boolean[dualMesh.verts.size()]; // all false initially
                    FORI (i, selectedDualVertIndices.length)
                        if (selectedDualVertIndices[i] != -1)
                            isSelectedDualVert[selectedDualVertIndices[i]] = true;

                    java.awt.Color dualVertColors[] = new java.awt.Color[dualMesh.verts.size()];
                    FORI (i, dualVertColors.length)
                        dualVertColors[i] = dualColor; // default-- may change if special
                    java.awt.Color dualEdgeColors[] = new java.awt.Color[dualMesh.edges.size()];
                    FORI (i, dualEdgeColors.length)
                        dualEdgeColors[i] = dualColor; // default-- may change if special

                    //
                    // Compute center of curvature of selected dual vertices
                    //
                    double avg[] = null;
                    if (selectedDualVertIndices.length >= 1)
                    {
                        double areaSum = 0.;
                        double moment[] = {0.,0.};
                        double dualVertCoords[] = new double[2]; // scratch for loop
                        FORI (i, selectedDualVertIndices.length)
                        {
                            int ind = selectedDualVertIndices[i];
                            if (ind == -1)
                                continue;
                            dualVertColors[ind] = dualVertSelectionColor;
                            Mesh.Vertex dualVert = dualMesh.getVert(ind);
                            dualVertCoords[0] = dualVert.x;
                            dualVertCoords[1] = dualVert.y;
                            VecMath.vpsxv(moment,
                                          moment,
                                          dualVert.weight, dualVertCoords);
                            areaSum += dualVert.weight;
                        }
                        if (areaSum != 0.)
                            avg = VecMath.sxv(1./areaSum, moment);
                        PRINTVEC(avg);

                        if (true)
                        {
                            // Compute avg a different way, for curiosity
                            double momentAndAreaSum[] = new double[3]; // zeros
                            FORI (i, selectedDualVertIndices.length)
                            {
                                int ind = selectedDualVertIndices[i];
                                if (ind == -1)
                                    continue;
                                Mesh.Vertex dualVert = dualMesh.getVert(ind);
                                accumulateMomentAndArea(momentAndAreaSum, dualVert.momentAndArea);
                            }
                            PRINTVEC(momentAndAreaSum);
                            double A = momentAndAreaSum[2];
                            double avgAlternate[] = {
                                momentAndAreaSum[0] / A,
                                momentAndAreaSum[1] / A,
                            };
                            PRINTVEC(avgAlternate);
                        }
                    }




                    //
                    // If showing net, compute a net.
                    // For now, sweep upwards,
                    // color good edges green and off-balance ones red.
                    //
                    boolean dualEdgeIsCut[] = null;
                    boolean dualEdgeIsOffBalanceCut[] = null;
                    int topSortedDualVertIndices[] = null;
                    Mesh.Edge dualVertIndexToParentEdge[] = null;
                    // Hack for now... just one
                    Mesh.Edge theBadLagoonExitToDraw = null;
                    ArrayList offBalanceEdgeToGoodLagoonExits[] = new ArrayList[dualMesh.edges.size()]; // all nulls initially
                    ArrayList offBalanceEdgeToLagoonEdges[] = new ArrayList[dualMesh.edges.size()]; // all nulls initially
                    double offBalanceEdgeToLagoonCenter[][] = new double[dualMesh.edges.size()][]; // all nulls initially
                    if (showNet.get())
                    {
                        dualEdgeIsCut = new boolean[mesh.edges.size()]; // all false initially
                        dualEdgeIsOffBalanceCut = new boolean[mesh.edges.size()]; // all false initially
                        dualVertIndexToParentEdge = new Mesh.Edge[dualMesh.verts.size()]; // all null initially


                        if (theNet != null)
                        {
                            // copy from existing net to our ad-hoc structures
                            // (which will go away soon)
                            int nDualEdges = dualMesh.edges.size();
                            int nDualVerts = dualMesh.verts.size();
                            FORI (iDualEdge, nDualEdges)
                                dualEdgeIsCut[iDualEdge] = (theNet._edgeStatuses[iDualEdge] == Net.CUT);
                            FORI (iDualVert, nDualVerts)
                                dualVertIndexToParentEdge[iDualVert] = dualMesh.getEdge(theNet._vertToParentEdgeInd[iDualVert]);
                        }
                        else if (netMethod.get() == NETMETHOD_RANDOM)
                        {
                            boolean netVerbose = !(showNet.get() && showNetFlow);
                            if (netVerbose)
                                System.out.println("   computing random net");

                            int nDualEdges = dualMesh.edges.size();
                            int nDualVerts = dualMesh.verts.size();

                            // Use uniform random spanning tree algorithm, from David Bruce Wilson
                            // "Generating Random Spanning Trees More Quickly than the Cover Time"

                            Mesh.Edge edgesOut[][] = new Mesh.Edge[nDualVerts+1][];
                            {
                                int totalArity = 0;
                                FORI (iDualVert, nDualVerts) // all but vertex at infinity
                                {
                                    Mesh.Vertex dualVert = dualMesh.getVert(iDualVert);
                                    edgesOut[iDualVert] = new Mesh.Edge[dualVert.arity];
                                    totalArity += dualVert.arity;
                                }
                                // figure out arity of vertex at infinity.
                                // total arity of all verts *including* the one at infinity
                                // is twice num edges (i.e. num half-edges), so...
                                int arityOfVertexAtInfinity = nDualEdges - totalArity;
                                edgesOut[nDualVerts] = new Mesh.Edge[arityOfVertexAtInfinity];

                                int nEdgesOut[] = new int[nDualVerts+1]; // all zeros initially
                                FORI (iDualEdge, nDualEdges)
                                {
                                    Mesh.Edge dualEdge = dualMesh.getEdge(iDualEdge);
                                    Mesh.Vertex v0 = dualEdge.initialVertex();
                                    int i0 = v0==null ? nDualVerts : v0.myIndex();

                                    edgesOut[i0][nEdgesOut[i0]++] = dualEdge;
                                }
                                FORI (iDualVert, nDualVerts+1)
                                    assert(nEdgesOut[iDualVert] == edgesOut[iDualVert].length);
                            }

                            // It's unclear from the paper whether it's okay
                            // to start from an arbitrary vertex or what
                            // (and whether a non-random initial vertex
                            // results in skewing the distribution,
                            // or making it more inefficient, or what).
                            // The paper recommends starting at a random end
                            // of a random edge.
                            // But it seems to me that
                            //     (1) a non-random initial vertex will *not* skew the distribution
                            //         (since the trees rooted at any particular vertex
                            //         are the same, by simple re-rooting,
                            //         as the trees rooted at any other particular vertex)
                            //     (2) starting at a random end of a random edge
                            //         is the same as selecting an initial vertex
                            //         with probability proportional to its arity
                            //     (3) if doing that is advantageous for efficiency,
                            //         then simply starting with the highest-arity
                            //         vertex is even more advantageous
                            // Typically the dual graph's vertices all have arity 3
                            // except for the infinite vertex which has relatively high arity,
                            // so we'll just let the root (start of the algorithm) be the infinite vertex.
                            // Empirically (on delaunay triangulation of blue noise),
                            // this does keep the running time low...
                            // and furthermore the "next" data structure returned by using the infinite vertex
                            // as root is exactly the one we'll need later.

                            java.util.Random generator = new java.util.Random(0);
                            int r = nDualVerts; // start with the infinite vertex

                            // Algorithm RandomTreeWithRoot(r) from paper...
                            // Since the infinite vertex doesn't have a root,
                            // we can work directly with the final output array dualVertIndexToParentEdge
                            // of size nDualVerts (rather than nDualVerts+1,
                            // the size we'd need if starting at some other vertex),
                            // which is initially all nulls.
                            int nRandomCalls = 0;
                            {
                                boolean inTree[] = new boolean[nDualVerts+1]; // +1 to include infinite vertex; all false initially
                                inTree[r] = true;
                                FORI (iDualVert, nDualVerts+1)
                                {
                                    int u = iDualVert;
                                    while (!inTree[u])
                                    {
                                        nRandomCalls++;
                                        Mesh.Edge dualEdge = edgesOut[u][generator.nextInt(edgesOut[u].length)];
                                        dualVertIndexToParentEdge[u] = dualEdge;
                                        u = dualEdge.finalVertex() != null ? dualEdge.finalVertex().myIndex() : nDualVerts;
                                    }
                                    u = iDualVert;
                                    while (!inTree[u])
                                    {
                                        inTree[u] = true;
                                        Mesh.Edge dualEdge = dualVertIndexToParentEdge[u];
                                        dualEdgeIsCut[dualEdge.myIndex()] = true;
                                        dualEdgeIsCut[dualEdge.opposite().myIndex()] = true;
                                        u = dualEdge.finalVertex() != null ? dualEdge.finalVertex().myIndex() : nDualVerts;
                                    }
                                }
                            }
                            if (netVerbose)
                            {
                                PRINT(nDualVerts);
                                PRINT(nDualEdges);
                                PRINT(nRandomCalls);
                            }


                            if (netVerbose)
                                System.out.println("   done computing random net");
                        }
                        else // UPWARD or OUTWARD
                        {
                            FORIDOWN (iEdge, mesh.edges.size())
                            {
                                Mesh.Vertex triCenterDualVert = (dualMesh.getEdge(iEdge)).finalVertex();
                                if (triCenterDualVert == null)
                                    continue; // primal face was not a triangle, or inside out
                                if (dualVertIndexToParentEdge[triCenterDualVert.myIndex()] != null)
                                    continue; // definitely already did this vertex  XXX but root vertex stays null so it will be done 3 times :-(
                                double triCenterDualVertPos[] = {
                                    triCenterDualVert.x,
                                    triCenterDualVert.y,
                                };

                                Mesh.Edge e0 = mesh.getEdge(iEdge);
                                Mesh.Edge e1 = e0.next();
                                Mesh.Edge e2 = e1.next();
                                assert(e2.next() == e0);

                                double threeDirections[][] = {
                                    (dualMesh.getEdge(e0.myIndex())).opposite().direction,
                                    (dualMesh.getEdge(e1.myIndex())).opposite().direction,
                                    (dualMesh.getEdge(e2.myIndex())).opposite().direction,
                                };

                                Mesh.Edge threeDualEdges[] = {
                                    (dualMesh.getEdge(e0.myIndex())).opposite(),
                                    (dualMesh.getEdge(e1.myIndex())).opposite(),
                                    (dualMesh.getEdge(e2.myIndex())).opposite(),
                                };
                                double threeFinalPositions[][] = new double[3][];
                                FORI (i, 3)
                                {
                                    Mesh.Edge dualEdge = threeDualEdges[i];
                                    Mesh.Vertex finalVertex = dualEdge.finalVertex();
                                    if (finalVertex == null)
                                        threeFinalPositions[i] = new double[] {Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY};
                                    else
                                        threeFinalPositions[i] = new double[] {finalVertex.x, finalVertex.y};
                                }

                                int bestSide = netMethod.get()==NETMETHOD_OUTWARD ? 
                                               /*
                                               MAXI3(VecMath.dot(threeDirections[0], triCenterDualVertPos),
                                                     VecMath.dot(threeDirections[1], triCenterDualVertPos),
                                                     VecMath.dot(threeDirections[2], triCenterDualVertPos))
                                               */
                                               MAXI3(VecMath.normsqrd(threeFinalPositions[0]),
                                                     VecMath.normsqrd(threeFinalPositions[1]),
                                                     VecMath.normsqrd(threeFinalPositions[2]))
                                             : MAXI3(threeDirections[0][1],
                                                     threeDirections[1][1],
                                                     threeDirections[2][1]);
                                if (true)
                                {
                                    // Hack to simulate symbolic perterbation
                                    // by an infinitesimal rotation counterclockwise
                                    if (EQ(threeDirections[bestSide][1], threeDirections[(bestSide+1)%3][1], 1e-6)
                                     && LT(threeDirections[bestSide][0], threeDirections[(bestSide+1)%3][0], 1e-6))
                                    {
                                        bestSide = (bestSide+1)%3;
                                        if (EQ(threeDirections[bestSide][1], threeDirections[(bestSide+1)%3][1], 1e-6)
                                         && LT(threeDirections[bestSide][0], threeDirections[(bestSide+1)%3][0], 1e-6))
                                            bestSide = (bestSide+1)%3;
                                    }
                                    else
                                    {
                                        if (EQ(threeDirections[bestSide][1], threeDirections[(bestSide+2)%3][1], 1e-6)
                                         && LT(threeDirections[bestSide][0], threeDirections[(bestSide+2)%3][0], 1e-6))
                                            bestSide = (bestSide+2)%3;
                                    }
                                }
                                if (true)
                                {
                                    // Hack to ensure that a negative-weight (assume that means boundary)
                                    // vertex never has a positive-weight vertex as parent
                                    Mesh.Edge threeEdges[] = {
                                        (dualMesh.getEdge(e0.myIndex())).opposite(),
                                        (dualMesh.getEdge(e1.myIndex())).opposite(),
                                        (dualMesh.getEdge(e2.myIndex())).opposite(),
                                    };
                                    if (triCenterDualVert.weight < 0.
                                     && threeEdges[bestSide].finalVertex() != null
                                     && threeEdges[bestSide].finalVertex().weight >= 0.)
                                    {
                                        int origBestSide = bestSide;
                                        bestSide = (threeDirections[(bestSide+1)%3][1] >= threeDirections[(bestSide+2)%3][1] ? (bestSide+1)%3 : (bestSide+2)%3);
                                        if (triCenterDualVert.weight < 0.
                                         && threeEdges[bestSide].finalVertex() != null
                                         && threeEdges[bestSide].finalVertex().weight >= 0.)
                                        {
                                            bestSide = 3 - bestSide - origBestSide;
                                        }
                                    }
                                }

                                if (false) // set this to true to debug
                                {
                                    double whereToDrawMark[] = {
                                        triCenterDualVert.x + .05 * threeDirections[bestSide][0],
                                        triCenterDualVert.y + .05 * threeDirections[bestSide][1],
                                    };
                                    mg.drawPoint(whereToDrawMark[0],
                                                 whereToDrawMark[1], 5);
                                }


                                Mesh.Edge e = bestSide==0 ? e0 : bestSide==1 ? e1 : e2;
                                // remember each edge gets drawn in an arbitrary one of the two directions,
                                // so we have to set the flag on both of them
                                dualEdgeIsCut[e.myIndex()] = true;
                                dualEdgeIsCut[e.opposite().myIndex()] = true;

                                // Set parent... but only if the edge
                                // is really upwards.
                                // to avoid a cycle in the graph
                                {
                                    Mesh.Edge maybeParentEdge = (dualMesh.getEdge(e.myIndex())).opposite();
                                    if (netMethod.get() == NETMETHOD_OUTWARD)
                                        dualVertIndexToParentEdge[triCenterDualVert.myIndex()] = maybeParentEdge;
                                    else
                                        if (GT(maybeParentEdge.direction[1], 0, 1e-6)
                                         || (EQ(maybeParentEdge.direction[1], 0, 1e-6)
                                          && maybeParentEdge.direction[0] > 0.))
                                        dualVertIndexToParentEdge[triCenterDualVert.myIndex()] = maybeParentEdge;
                                }
                            }
                        } // UPWARD or OUTWARD

                        int nDualVerts = dualMesh.verts.size();
                        int nDualEdges = dualMesh.edges.size();

                        //
                        // Get a topsort of the verts,
                        // so we can traverse it in order for various purposes
                        // rather than having to write a whole bunch of recursive helper functions.
                        //
                        {
                            topSortedDualVertIndices = new int[nDualVerts];
                            int nSorted = 0;
                            int stackTop = nDualVerts; // we use the end of the array as a stack
                            boolean isSorted[] = new boolean[nDualVerts]; // all false initially
                            FORI(iDualVert, nDualVerts)
                            {
                                int jDualVert = iDualVert;
                                while (!isSorted[jDualVert])
                                {
                                    topSortedDualVertIndices[--stackTop] = jDualVert;
                                    isSorted[jDualVert] = true;

                                    Mesh.Edge parentEdge = dualVertIndexToParentEdge[jDualVert];
                                    if (parentEdge == null)
                                        break;
                                    Mesh.Vertex finalVertex = parentEdge.finalVertex();
                                    if (finalVertex == null)
                                        break;
                                    jDualVert = finalVertex.myIndex();
                                }
                                while (stackTop < nDualVerts)
                                    topSortedDualVertIndices[nSorted++] = topSortedDualVertIndices[stackTop++];
                            }
                            assert(nSorted == nDualVerts);
                            assert(stackTop == nDualVerts);
                            FORI (iDualVert, nDualVerts)
                                assert(isSorted[iDualVert]);
                        }


                        //
                        // Now figure out which ones are off balance.
                        //
                        // accumulate weights...
                        double momentAndWeightStrictlyBelowEachDualVertex[][] = new double[nDualVerts][3]; // initially zeros
                        {
                            FORIDOWN(iiChild, topSortedDualVertIndices.length) // leaves to roots
                            {
                                int iChild = topSortedDualVertIndices[iiChild];
                                Mesh.Vertex child = dualMesh.getVert(iChild);
                                Mesh.Edge parentEdge = dualVertIndexToParentEdge[iChild];
                                if (parentEdge != null)
                                {
                                    Mesh.Vertex parent = parentEdge.finalVertex();
                                    if (parent != null)
                                    {
                                        int iParent = parent.myIndex();
                                        accumulateMomentAndArea(momentAndWeightStrictlyBelowEachDualVertex[iParent],
                                                                momentAndWeightStrictlyBelowEachDualVertex[iChild]);
                                        accumulateMomentAndArea(momentAndWeightStrictlyBelowEachDualVertex[iParent],
                                                                child.momentAndArea);
                                    }
                                }
                            }
                        }

                        FORI (iDualVert, nDualVerts)
                        {
                            double momentAndWeightStrictlyBelowDualVertex[] = momentAndWeightStrictlyBelowEachDualVertex[iDualVert];
                            double weightStrictlyBelowDualVertex = momentAndWeightStrictlyBelowDualVertex[2];
                            if (weightStrictlyBelowDualVertex != 0.)
                            {
                                Mesh.Edge dualEdge = dualVertIndexToParentEdge[iDualVert];
                                if (dualEdge == null)
                                    continue; // this is the root / highest node
                                Mesh.Vertex dualVert = dualEdge.initialVertex();
                                assert(dualVert.myIndex() == iDualVert);
                                if (dualVert.weight < 0.)
                                    continue; // nodes on the boundary are automatically okay

                                double centerX = momentAndWeightStrictlyBelowDualVertex[0] / weightStrictlyBelowDualVertex;
                                double centerY = momentAndWeightStrictlyBelowDualVertex[1] / weightStrictlyBelowDualVertex;
                                // if dualEdge.direction dot (center - dualVert) > 0.
                                if (dualEdge.direction[0] * (centerX - dualVert.x)
                                  + dualEdge.direction[1] * (centerY - dualVert.y) > 0.)
                                {
                                    dualEdgeIsOffBalanceCut[dualEdge.myIndex()] = true;
                                    dualEdgeIsOffBalanceCut[dualEdge.opposite().myIndex()] = true;
                                    //System.out.println("    edge at dual vert "+iDualVert+" is off balance!");
                                }
                                else
                                {
                                    //System.out.println("    edge at dual vert "+iDualVert+" is balanced");
                                }
                            }
                        }

                        if (true) // start trying to use Net class
                        {
                            if (theNet == null)
                            {
                                theNet = new Net(dualMesh, mesh);
                                int nEdges = dualMesh.edges.size();
                                FORI(iEdge, nEdges)
                                {
                                    if (dualEdgeIsCut[iEdge])
                                        theNet.cut(iEdge);
                                    else
                                    {
                                        // this actually won't be necessary when I get auto-folding working
                                        theNet.fold(iEdge);
                                    }
                                }
                                int root = nDualVerts;
                                theNet.chooseDirections(root);
                            }

                            if (highlightedDualEdgeIndex != -1)
                            {
                                Mesh.Edge alternatives[] = theNet.alternatives(highlightedDualEdgeIndex);
                                //PRINT(dualMesh.getEdge(highlightedDualEdgeIndex));
                                //PRINTARRAY(alternatives);
                                FORI (iAlternative, alternatives.length)
                                {
                                    dualEdgeColors[alternatives[iAlternative].myIndex()] = java.awt.Color.white;
                                    dualEdgeColors[alternatives[iAlternative].opposite().myIndex()] = java.awt.Color.white;
                                }
                            }
                        }

                        if (false) // DEFUNCT-- remove eventually, but salvage some of the coloring scheme
                        {
                            //
                            // Start to try to make a data structure
                            // for net surgery.
                            //
                            Mesh.Edge nextDualEdgeInCutTree[] = new Mesh.Edge[nDualEdges];

                            FORI (iDualEdge, nDualEdges)
                            {
                                Mesh.Edge dualEdge = dualMesh.getEdge(iDualEdge);
                                // Is this dual edge a cut?
                                // well, could look it up in the dualEdgeIsCut
                                // array, but we don't need that
                                Mesh.Vertex initialVertex = dualEdge.initialVertex();
                                Mesh.Vertex finalVertex = dualEdge.finalVertex();
                                boolean isCut = (initialVertex != null
                                              && dualVertIndexToParentEdge[initialVertex.myIndex()] == dualEdge)
                                             || (finalVertex != null
                                              && dualVertIndexToParentEdge[finalVertex.myIndex()] == dualEdge.opposite());
                                if (!isCut)
                                    continue;

                                for (Mesh.Edge next = dualEdge.next();
                                     ;
                                     next = next.opposite().next())
                                {
                                    Mesh.Vertex nextInitialVertex = next.initialVertex();
                                    Mesh.Vertex nextFinalVertex = next.finalVertex();
                                    boolean nextIsCut = (nextInitialVertex != null
                                                      && dualVertIndexToParentEdge[nextInitialVertex.myIndex()] == next)
                                                     || (nextFinalVertex != null
                                                      && dualVertIndexToParentEdge[nextFinalVertex.myIndex()] == next.opposite());
                                    if (nextIsCut)
                                    {
                                        nextDualEdgeInCutTree[iDualEdge] = next;
                                        break;
                                    }
                                    assert(next.opposite() != dualEdge); // that would be endless loop... must have found a next by now, since an edge should be a cut iff its opposite is a cut
                                }
                            }

                            FORI (iDualEdge, nDualEdges)
                            {
                                assert((nextDualEdgeInCutTree[iDualEdge] != null)
                                    == dualEdgeIsCut[iDualEdge]);
                            }

                            if (false)
                            {
                                // Print it out
                                System.out.println("Walking around net tree:");
                                boolean seen[] = new boolean[nDualEdges]; // false initially
                                FORI (iPass, 1)
                                {
                                    FORI (iDualEdge, nDualEdges)
                                    {
                                        if (nextDualEdgeInCutTree[iDualEdge] == null)
                                            continue; // not a cut
                                        if (seen[iDualEdge])
                                            continue;
                                        assert(iPass == 0); // should have got everything in pass 0
                                        Mesh.Edge dualEdge = dualMesh.getEdge(iDualEdge);
                                        if (dualEdge.initialVertex() != null
                                         && dualVertIndexToParentEdge[dualEdge.initialVertex().myIndex()] != null)
                                            continue; // start connected components with roots (including or non-vertices) only XXX would be good to start with the extremal child, but that's hard to figure out
                                        System.out.print("    ");
                                        while (true)
                                        {
                                            System.out.print("(");
                                            if (dualEdge.initialVertex() != null)
                                                System.out.print(""+dualEdge.initialVertex().myIndex());
                                            else
                                                System.out.print("null");
                                            System.out.print("->");
                                            if (dualEdge.finalVertex() != null)
                                                System.out.print(""+dualEdge.finalVertex().myIndex());
                                            else
                                                System.out.print("null");
                                            System.out.print(")");
                                            seen[dualEdge.myIndex()] = true;
                                            dualEdge = nextDualEdgeInCutTree[dualEdge.myIndex()];
                                            if (dualEdge.myIndex() == iDualEdge)
                                                break;
                                        }
                                        System.out.println();
                                    }
                                }
                            }

                            // ARGH! this doesn't work for good lagoon exits, which is what I wrote it for, since those are not a partition!  (cyan edge can be exit for more than one lagoon)... TODO: remove it if it's not good for anything
                            class EdgesPartition
                            {
                                private Mesh.Edge firsts[];
                                private Mesh.Edge nexts[];
                                public EdgesPartition(int n,
                                                      Mesh mesh)
                                {
                                    firsts = new Mesh.Edge[n];
                                    nexts = new Mesh.Edge[mesh.edges.size()];
                                }
                                public Mesh.Edge first(int i)
                                {
                                    return firsts[i];
                                }
                                public Mesh.Edge next(Mesh.Edge e)
                                {
                                    return nexts[e.myIndex()];
                                }
                                public void add(int i, Mesh.Edge e)
                                {
                                    assert(nexts[e.myIndex()] == null);
                                    nexts[e.myIndex()] = firsts[i];
                                    firsts[i] = e;
                                }
                            }; // EdgesPartition


                            // Try to do some surgery.
                            //System.out.println("Trying surgery...");
                            FORI (iDualEdge, nDualEdges)
                            {
                                Mesh.Edge dualEdge = dualMesh.getEdge(iDualEdge);
                                Mesh.Vertex initialVertex = dualEdge.initialVertex();
                                if (dualEdgeIsOffBalanceCut[iDualEdge]
                                 && initialVertex != null
                                 && dualVertIndexToParentEdge[initialVertex.myIndex()] == dualEdge)
                                {
                                    //System.out.println("    Looking for alternatives to bad exit "+dualEdge+"");
                                    // It's an upward off-balance cut.
                                    // Starting with its opposite, walk around the lagoon
                                    // until we find a good exit.
                                    // In fact, record them all.
                                    offBalanceEdgeToGoodLagoonExits[iDualEdge] = new ArrayList();
                                    offBalanceEdgeToLagoonEdges[iDualEdge] = new ArrayList();

                                    double momentAndWeightStrictlyBelowDualVertex[] = momentAndWeightStrictlyBelowEachDualVertex[initialVertex.myIndex()];
                                    double lagoonMomentAndWeight[] = new double[3]; // zeros
                                    accumulateMomentAndArea(lagoonMomentAndWeight, momentAndWeightStrictlyBelowEachDualVertex[initialVertex.myIndex()]);
                                    accumulateMomentAndArea(lagoonMomentAndWeight, initialVertex.momentAndArea);
                                    double lagoonCenter[] = {
                                        lagoonMomentAndWeight[0] / lagoonMomentAndWeight[2],
                                        lagoonMomentAndWeight[1] / lagoonMomentAndWeight[2],
                                    };
                                    offBalanceEdgeToLagoonCenter[iDualEdge] = lagoonCenter;
                                    // begin with dualEdge.opposite() even though it's not really in the lagoon, so that we'll see the first exit from the same vertex if there is one
                                    for (Mesh.Edge lagoonEdge = dualEdge.opposite();
                                         lagoonEdge != dualEdge;
                                         lagoonEdge = nextDualEdgeInCutTree[lagoonEdge.myIndex()])
                                    {
                                        if (lagoonEdge != dualEdge.opposite()) // first one isn't really a lagoon edge
                                            offBalanceEdgeToLagoonEdges[iDualEdge].add(lagoonEdge);

                                        for (Mesh.Edge lagoonExitEdge = lagoonEdge.next();
                                             lagoonExitEdge != nextDualEdgeInCutTree[lagoonEdge.myIndex()];
                                             lagoonExitEdge = lagoonExitEdge.opposite().next())
                                        {
                                            // found a lagoon exit... see if it's a good one.
                                            Mesh.Vertex lagoonExitVertex = lagoonExitEdge.initialVertex();
                                            boolean isGood = VecMath.dot(lagoonExitEdge.direction,
                                                                         VecMath.vmv(lagoonCenter,
                                                                                     new double[]{lagoonExitVertex.x,
                                                                                                  lagoonExitVertex.y})) <= 0;
                                            if (isGood)
                                            {
                                                // At this point we're not sure if it's an exit.
                                                // Scan upwards to see if we find dualEdge.
                                                // if we do, then we're in the same lagoon.
                                                // (note, it would be more efficient asymptotically
                                                // to just turn on a bit for every node in the lagoon,
                                                // but this is simple for now, and probably not a bottleneck)
                                                boolean isExit = true; // until proven otherwise
                                                if (lagoonExitEdge.finalVertex() != null)
                                                {
                                                    //System.out.println("        is "+initialVertex.myIndex()+" downstream from "+lagoonExitEdge.finalVertex().myIndex()+"?");
                                                    for (int jVertex = lagoonExitEdge.finalVertex().myIndex();
                                                         dualVertIndexToParentEdge[jVertex] != null && dualVertIndexToParentEdge[jVertex].finalVertex() != null;
                                                         jVertex = dualVertIndexToParentEdge[jVertex].finalVertex().myIndex())
                                                        if (jVertex == initialVertex.myIndex()) // the original bad lagoon exit vertex
                                                        {
                                                            isExit = false;
                                                            //System.out.println("            oops! found vertex "+initialVertex.myIndex()+" scanning upwards from "+lagoonExitVertex.myIndex()+"");
                                                            break;
                                                        }
                                                }
                                                if (isExit)
                                                {
                                                    offBalanceEdgeToGoodLagoonExits[iDualEdge].add(lagoonExitEdge);
                                                    // could break here since we found one, if that's the way we were doing things
                                                }
                                            }
                                        }
                                    }
                                    if (false)
                                    {
                                        System.out.print("        bad cut "+dualEdge+" could be replaced by: ");
                                        FORI (iGoodExit, offBalanceEdgeToGoodLagoonExits[iDualEdge].size())
                                        {
                                            Mesh.Edge goodExit = (Mesh.Edge)offBalanceEdgeToGoodLagoonExits[iDualEdge].get(iGoodExit);
                                            System.out.print(" " + goodExit);
                                        }
                                        System.out.println();
                                    }

                                    if (dualEdge.myIndex() == highlightedDualEdgeIndex
                                     || dualEdge.opposite().myIndex() == highlightedDualEdgeIndex)
                                        theBadLagoonExitToDraw = dualEdge;
                                    if (offBalanceEdgeToGoodLagoonExits[iDualEdge].size() < 2)
                                    {
                                        System.out.println("        HEY!!! bad cut "+dualEdge+" has only "+offBalanceEdgeToGoodLagoonExits[iDualEdge].size()+" good lagoon exits! That's impossible!");
                                        //assert(false);
                                    }
                                }
                            }
                        }

                    }
                    else // !showNet
                    {
                        //
                        // Select colors for the good and bad ways out of the lagoon.
                        //

                        // first identify the edges out of the lagoon...
                        FORI (iDualEdge, dualMesh.edges.size())
                        {
                            Mesh.Edge dualEdge = dualMesh.getEdge(iDualEdge);
                            Mesh.Vertex initialVertex = dualEdge.initialVertex();
                            if (initialVertex == null)
                                continue; // no initial vertex
                            int iDualVert = initialVertex.myIndex();
                            if (!isSelectedDualVert[iDualVert])
                                continue; // doesn't originate in the lagoon
                            int iDualEdgeOpposite = dualEdge.opposite().myIndex();
                            Mesh.Vertex finalVertex = dualEdge.finalVertex();
                            if (finalVertex != null
                             && isSelectedDualVert[finalVertex.myIndex()])
                            {
                                // both ends are in the lagoon.
                                int jDualVert = finalVertex.myIndex();
                                if (iDualVert > jDualVert)
                                    continue; // only need to do it in canonical dir
                                dualEdgeColors[iDualEdge] = dualColorBothSelected;
                                dualEdgeColors[iDualEdgeOpposite] = dualColorBothSelected;
                            }
                            else
                            {
                                // starts in the lagoon, ends outside it.
                                // is it a good exit?
                                double initialVertexCoords[] = {initialVertex.x, initialVertex.y};
                                double goodness = VecMath.dot(dualEdge.direction,
                                                              VecMath.vmv(2, initialVertexCoords, avg));
                                boolean isGoodExit = GEQ(goodness, 0., SQR(1e-6));

                                if (true)
                                {
                                    if (selectedDualVertIndices.length > 1)
                                    {
                                        if (isGoodExit)
                                            mg.setColor(perpColorGood);
                                        else
                                            mg.setColor(perpColorBad);

                                        // draw perpendicular at the zero level
                                        double rayLength = 1.;
                                        mg.drawLine(initialVertex.x - rayLength * dualEdge.direction[1],
                                                    initialVertex.y + rayLength * dualEdge.direction[0],
                                                    initialVertex.x + rayLength * dualEdge.direction[1],
                                                    initialVertex.y - rayLength * dualEdge.direction[0],
                                                    doAntiAliasing);
                                    }
                                }

                                if (isGoodExit)
                                {
                                    dualEdgeColors[iDualEdge] = dualColorOneSelectedGood;
                                    dualEdgeColors[iDualEdgeOpposite] = dualColorOneSelectedGood;
                                }
                                else
                                {
                                    dualEdgeColors[iDualEdge] = dualColorOneSelectedBad;
                                    dualEdgeColors[iDualEdgeOpposite] = dualColorOneSelectedBad;
                                }

                            }
                        }
                    } // if (!showNet)

                    //PRINT(theBadLagoonExitToDraw);

                    //
                    // Draw dual edges, in chosen colors
                    // 

                    java.awt.Color darkBlue = new java.awt.Color(0.f,0.f,1/4.f);
                    //java.awt.Color darkBlue = new java.awt.Color(0.f,0.f,1/2.f);
                    //java.awt.Color darkBlue = new java.awt.Color(0.f,0.f,3/4.f);
                    //java.awt.Color darkBlue = new java.awt.Color(0.f,0.f,7/8.f);

                    if (dualEdgeIsCut != null)
                    {
                        // showing net-- different color scheme
                        FORIDOWN(iEdge, mesh.edges.size())
                        {
                            if (dualEdgeIsOffBalanceCut[iEdge])
                            {
                                dualEdgeColors[iEdge] = java.awt.Color.red;
                            }
                            else if (dualEdgeIsCut[iEdge])
                            {
                                dualEdgeColors[iEdge] = java.awt.Color.green;
                            }
                            else
                            {
                                dualEdgeColors[iEdge] = darkBlue;
                            }
                        }
                        if (theBadLagoonExitToDraw != null)
                        {
                            dualEdgeColors[theBadLagoonExitToDraw.myIndex()]            = java.awt.Color.magenta; // red turning blue
                            dualEdgeColors[theBadLagoonExitToDraw.opposite().myIndex()] = java.awt.Color.magenta; // red turning blue
                            int theBadLagoonExitToDrawIndex = theBadLagoonExitToDraw.myIndex();
                            FORIDOWN(iItem, offBalanceEdgeToGoodLagoonExits[theBadLagoonExitToDrawIndex].size())
                            {
                                Mesh.Edge dualEdge = (Mesh.Edge)offBalanceEdgeToGoodLagoonExits[theBadLagoonExitToDrawIndex].get(iItem);
                                dualEdgeColors[dualEdge.myIndex()]            = java.awt.Color.cyan; // blue turning green
                                dualEdgeColors[dualEdge.opposite().myIndex()] = java.awt.Color.cyan; // blue turning green
                            }
                            FORIDOWN(iItem, offBalanceEdgeToLagoonEdges[theBadLagoonExitToDrawIndex].size())
                            {
                                Mesh.Edge dualEdge = (Mesh.Edge)offBalanceEdgeToLagoonEdges[theBadLagoonExitToDrawIndex].get(iItem);
                                dualEdgeColors[dualEdge.myIndex()]            = java.awt.Color.yellow;
                                dualEdgeColors[dualEdge.opposite().myIndex()] = java.awt.Color.yellow;
                            }
                        }
                    }

                    //
                    // Dual edges.
                    // If showing the cut tree,
                    // we draw the non-cut edges first, then the cut edges--
                    // this makes the tree appear more connected.
                    //
                    FORI (iPass, dualEdgeIsCut!=null ? 2 : 1)
                        FORIDOWN (iDualEdge, mesh.edges.size())
                        {
                            if (dualEdgeIsCut != null
                             && dualEdgeIsCut[iDualEdge] != (iPass==1))
                                continue; // draw cuts iff iPass==1

                            Mesh.Edge dualEdge = dualMesh.getEdge(iDualEdge);
                            Mesh.Vertex leftDualVert = dualEdge.finalVertex();
                            if (leftDualVert == null)
                                continue; // primal face was not a triangle, or inside out

                            mg.setColor(dualEdgeColors[dualEdge.myIndex()]);

                            Mesh.Vertex rightDualVert = dualEdge.initialVertex();

                            if (rightDualVert != null)
                            {
                                if (leftDualVert.myIndex() < rightDualVert.myIndex()) // don't bother drawing it in both directions
                                    mg.drawLine(leftDualVert.x, leftDualVert.y,
                                                rightDualVert.x, rightDualVert.y,
                                                doAntiAliasing);
                            }
                            else
                            {
                                Mesh.Edge edge = mesh.getEdge(iDualEdge);
                                // Draw a ray out to infinity
                                double v0[] = {edge.initialVertex().x,
                                               edge.initialVertex().y};
                                double v1[] = {edge.finalVertex().x,
                                               edge.finalVertex().y};
                                double toEdgeVec[] = VecMath.xv2(
                                                         VecMath.vmv(v0, v1));
                                VecMath.normalize(toEdgeVec, toEdgeVec);
                                double rayLength = 1.; // for edges to infinity
                                double destPoint[] = {leftDualVert.x + rayLength*toEdgeVec[0],
                                                      leftDualVert.y + rayLength*toEdgeVec[1]};
                                mg.drawLine(leftDualVert.x, leftDualVert.y,
                                            destPoint[0],destPoint[1],
                                            doAntiAliasing);
                                                                   
                            }
                        }

                    //
                    // And, as polish for voronoi diagrams,
                    // draw perpendicular lines
                    // at each isolated edge or whisker.
                    // XXX should do this along hairs... or maybe every edge that is not on a triangle on either side? nah
                    //
                    mg.setColor(dualColor);
                    FORIDOWN (iEdge, mesh.edges.size())
                    {
                        Mesh.Edge edge = mesh.getEdge(iEdge);
                        if (edge.opposite().myIndex() < iEdge)
                            continue; // check in only one of the two directions

                        // TODO: which of these? argh
                        if (edge.next() == edge.opposite())

                        //Mesh.Edge dualEdge = dualMesh.getEdge(iEdge);
                        //if ((dualEdge.initialVertex() == null || dualEdge.initialVertex().weight == 0.)
                        // && (dualEdge.finalVertex() == null || dualEdge.finalVertex().weight == 0.))

                        {
                            double v0[] = {edge.initialVertex().x,
                                           edge.initialVertex().y};
                            double v1[] = {edge.finalVertex().x,
                                           edge.finalVertex().y};
                            double toEdgeVec[] = VecMath.xv2(
                                                     VecMath.vmv(v0, v1));
                            VecMath.normalize(toEdgeVec, toEdgeVec);
                            double midPoint[] = VecMath.lerp(v0, v1, .5);
                            double lineLength = 1.;
                            double fromPoint[] = VecMath.vpsxv(midPoint, -lineLength*.5, toEdgeVec);
                            double toPoint[] = VecMath.vpsxv(midPoint, lineLength*.5, toEdgeVec);
                            mg.drawLine(fromPoint[0],fromPoint[1],
                                        toPoint[0], toPoint[1],
                                        doAntiAliasing);
                        }
                    }


                    //
                    // Draw dual verts
                    // (only if NOT showing net flow)
                    //
                    FORIDOWN(iDualVert, dualMesh.verts.size())
                    {
                        // if showing flow, don't show normal verts (only show selected ones)
                        if (showNet.get() && showNetFlow && dualVertColors[iDualVert] != dualVertSelectionColor)
                            continue;


                        Mesh.Vertex dualVert = dualMesh.getVert(iDualVert);

                        //System.out.println("    drawing dual vert at "+Arrays.toStringCompact(dualVert));
                        mg.setColor(dualVertColors[iDualVert]); // TODO: only if changed?
                        mg.drawPoint(dualVert.x,
                                     dualVert.y, showNet.get() ? 2 : 5);

                    }

                    if (showNet.get() && showNetFlow)
                    {
                        //
                        // Figure out distance (both 2-norm and infinity-norm) from each vertex
                        // to the root-most one in its tree
                        //
                        int nDualVerts = dualMesh.verts.size();
                        double norm2s[] = new double[nDualVerts]; // zeros initially
                        double normInfs[] = new double[nDualVerts]; // zeros initially
                        FORI (iiChild, topSortedDualVertIndices.length) // roots to leaves
                        {
                            int iChild = topSortedDualVertIndices[iiChild];
                            Mesh.Vertex child = dualMesh.getVert(iChild);
                            Mesh.Edge parentEdge = dualVertIndexToParentEdge[iChild];
                            if (parentEdge != null)
                            {
                                Mesh.Vertex parent = parentEdge.finalVertex();
                                if (parent != null)
                                {
                                    int iParent = parent.myIndex();
                                    double dx = child.x - parent.x;
                                    double dy = child.y - parent.y;
                                    norm2s[iChild] = norm2s[iParent] + MyMath.hypot(dx,dy);
                                    normInfs[iChild] = normInfs[iParent] + MAX(dx,dy);
                                }
                            }
                        }

                        double unitsPerPixel = 1./mg.getScaleX(); // scale is uniform
                        int period = 9; // how many redraws to get back to original state, to traverse a step
                        double step = 9 * unitsPerPixel;

                        //mg.setColor(lightBlue);
                        mg.setColor(java.awt.Color.red); // lava

                        FORI (iChild, nDualVerts)
                        {
                            Mesh.Vertex child = dualMesh.getVert(iChild);
                            Mesh.Edge parentEdge = dualVertIndexToParentEdge[iChild];
                            if (parentEdge != null)
                            {
                                Mesh.Vertex parent = parentEdge.finalVertex();
                                if (parent != null)
                                {
                                    int iParent = parent.myIndex();
                                    // norm2s[parent] rounded up to multiple of step
                                    // TODO: screwy math, it works but could be made simpler probably
                                    double pos0 = Math.ceil(norm2s[iParent]/step)*step; // XXX should subtract some slack before taking ceil
                                    pos0 -= (netFlowIndex % period)/(double)period * step;
                                    if (pos0 < norm2s[iParent]-1e-6)
                                        pos0 += step;

                                    for (double pos = pos0; LEQ(pos, norm2s[iChild], 1e-6); pos += step)
                                    {
                                        double t = (pos-norm2s[iParent])/(norm2s[iChild]-norm2s[iParent]);
                                        double x = LERP(parent.x, child.x, t);
                                        double y = LERP(parent.y, child.y, t);
                                        mg.drawPoint(x, y, 3);
                                    }
                                }
                                else
                                {
                                    double rayLength = 1.;
                                    // TODO: screwy math, it works but could be made simpler probably
                                    double pos0 = ((period-netFlowIndex)%period)/(double)period * step;
                                    while (GT(pos0, 0, 1e-6))
                                        pos0 -= step;
                                    for (double pos = pos0; GEQ(pos, -rayLength, 1e-6); pos -= step)
                                    {
                                        double x = child.x - pos * parentEdge.direction[0];
                                        double y = child.y - pos * parentEdge.direction[1];
                                        mg.drawPoint(x, y, 3);
                                    }
                                }
                            }
                        }

                        netFlowIndex++;
                    }

                    //
                    // Draw center of curvature
                    if (avg != null)
                    {
                        mg.setColor(dualVertSelectionColor);
                        mg.drawPoint(avg[0],
                                     avg[1],
                                     7);
                    }

                    if (theBadLagoonExitToDraw != null)
                    {
                        double lagoonCenter[] = offBalanceEdgeToLagoonCenter[theBadLagoonExitToDraw.myIndex()];
                        mg.setColor(dualVertSelectionColor);
                        mg.drawPoint(lagoonCenter[0],
                                     lagoonCenter[1],
                                     3);
                    }




                    //
                    // Now try marking the sharpest dihedral dual edge
                    // out of each dual vertex.
                    // I.e. the dual edge opposite the largest dual angle.
                    // I.e. the dual edge corresponding to the longest of the three primal
                    // triangle sides.
                    // We draw it 3 times, to make sure we get the same logic from each direction. If there are ties, it will get drawn in each place I think.
                    //
                    if (doArrowsTowardsSharpestDihedrals)
                    {
                        if (showNet.get())
                            mg.setColor(dualColor);
                        else
                            mg.setColor(dualVertSelectionColor);
                        FORIDOWN (iEdge, mesh.edges.size())
                        {
                            Mesh.Vertex triCenterDualVert = (dualMesh.getEdge(iEdge)).finalVertex();
                            if (triCenterDualVert == null)
                                continue; // primary face was not a triangle, or inside out

                            Mesh.Edge e0 = mesh.getEdge(iEdge);
                            Mesh.Edge e1 = e0.next();
                            Mesh.Edge e2 = e1.next();
                            assert(e2.next() == e0);
                            Mesh.Vertex triVerts[] = {e0.initialVertex(),
                                                      e1.initialVertex(),
                                                      e2.initialVertex()};
                            double sideLengths[] = new double[3];
                            FORI (i, 3)
                                sideLengths[i] = Math.sqrt(SQR(triVerts[i].x-triVerts[(i+1)%3].x)
                                                         + SQR(triVerts[i].y-triVerts[(i+1)%3].y));
                            int bestSide = MAXI3(sideLengths[0], sideLengths[1], sideLengths[2]);

                            double v0[] = {triVerts[bestSide].x, triVerts[bestSide].y};
                            double v1[] = {triVerts[(bestSide+1)%3].x, triVerts[(bestSide+1)%3].y};
                            double toEdgeVec[] = VecMath.xv2(
                                                     VecMath.vmv(v0, v1));
                            VecMath.normalize(toEdgeVec, toEdgeVec);
                            // XXX be smarter!  maybe 1/3 of the way along the edge, or somethin
                            double whereToDrawMark[] = {
                                triCenterDualVert.x + .02 * toEdgeVec[0],
                                triCenterDualVert.y + .02 * toEdgeVec[1],
                            };
                            //VecMath.vpsxv(whereToDrawMark, whereToDrawMark, .004, VecMath.random(2));
                            mg.drawPoint(whereToDrawMark[0],
                                         whereToDrawMark[1], 5);
                        }
                    }
                    if (doArrowsTowardsShortestEdges)
                    {
                        // XXX we do this in 3 ways, possibly getting different answer each time, in case of a tie... should fix that
                        mg.setColor(java.awt.Color.cyan);
                        FORIDOWN (iEdge, mesh.edges.size())
                        {
                            Mesh.Vertex triCenterDualVert = (dualMesh.getEdge(iEdge)).finalVertex();
                            if (triCenterDualVert == null)
                                continue; // primary face was not a triangle, or inside out

                            Mesh.Edge e0 = mesh.getEdge(iEdge);
                            Mesh.Edge e1 = e0.next();
                            Mesh.Edge e2 = e1.next();
                            assert(e2.next() == e0);
                            Mesh.Vertex triVerts[] = {e0.initialVertex(),
                                                      e1.initialVertex(),
                                                      e2.initialVertex()};
                            double triCenterDualVertCoords[] = {triCenterDualVert.x, triCenterDualVert.y};
                            Mesh.Vertex neighborDualVerts[] = {
                                (dualMesh.getEdge(e0.myIndex())).initialVertex(),
                                (dualMesh.getEdge(e1.myIndex())).initialVertex(),
                                (dualMesh.getEdge(e2.myIndex())).initialVertex(),
                            };

                            double dualSideLengths[] = new double[3];
                            FORI (i, 3)
                            {
                                if (neighborDualVerts[i] == null)
                                    dualSideLengths[i] = Double.POSITIVE_INFINITY;
                                else
                                    dualSideLengths[i] = VecMath.dist(triCenterDualVertCoords,
                                                                      new double[]{neighborDualVerts[i].x,
                                                                                   neighborDualVerts[i].y});
                            }
                            int bestSide = MINI3(dualSideLengths[0], dualSideLengths[1], dualSideLengths[2]);
                            double v0[] = {triVerts[bestSide].x, triVerts[bestSide].y};
                            double v1[] = {triVerts[(bestSide+1)%3].x, triVerts[(bestSide+1)%3].y};
                            double toEdgeVec[] = VecMath.xv2(
                                                     VecMath.vmv(v0, v1));
                            VecMath.normalize(toEdgeVec, toEdgeVec);
                            // XXX be smarter!  maybe 1/3 of the way along the edge, or somethin
                            double whereToDrawMark[] = {
                                triCenterDualVert.x + .02 * toEdgeVec[0],
                                triCenterDualVert.y + .02 * toEdgeVec[1],
                            };
                            //VecMath.vpsxv(whereToDrawMark, whereToDrawMark, .005, VecMath.random(2));
                            mg.drawPoint(whereToDrawMark[0],
                                         whereToDrawMark[1], 5);

                        }
                    }
                } // if (true) (draw dual diagram)


                //
                // Draw the primal mesh in white
                //
                if (showTriangles >= 1)
                {
                    //mg.setColor(java.awt.Color.white);
                    mg.setColor(new java.awt.Color(240,240,240));

                    ArrayList verts = mesh.verts;
                    FORIDOWN (iVert, verts.size())
                    {
                        Mesh.Vertex vert = (Mesh.Vertex)verts.get(iVert);
                        mg.drawPoint(vert.x,
                                     vert.y, 3);
                    }

                    if (showTriangles >= 2)
                    {

                        ArrayList edges = mesh.edges;
                        FORIDOWN (iEdge, edges.size()/2)
                        {
                            Mesh.Edge edge = (Mesh.Edge)edges.get(iEdge*2);
                            Mesh.Vertex v0 = edge.initialVertex();
                            Mesh.Vertex v1 = edge.finalVertex();
                            mg.drawLine(v0.x,v0.y, v1.x,v1.y, doAntiAliasing);
                        }
                    }
                }

                //
                // Draw the labels last...
                //
                if (showLabels)
                {
                    if (showTriangles >= 1)
                    {
                        mg.setColor(java.awt.Color.white);
                        drawLabels(mg, mesh, false); // primal
                    }
                    //mg.setColor(java.awt.Color.red);
                    mg.setColor(dualColor);
                    drawLabels(mg, dualMesh, true); // dual
                } // if (showLabels)

                if (showOrigin)
                {
                    // draw a subtle dot at the origin
                    mg.setColor(java.awt.Color.white);
                    mg.drawPoint(0., 0., 1);
                }
                // if showing an optimization path, display a message about it
                if (netless8OptimizationIndex != -1)
                {
                    mg.setColor(java.awt.Color.white);
                    mg.drawString("Optimization step "+netless8OptimizationIndex+"/"+(netless8OptimizationPath.length-1)+":  goodness = "+netless8OptimizationPathGoodnesses[netless8OptimizationIndex],
                                  -1., -1.,
                                  -1., 1.1);
                }

                //
                // Draw the rubber band last last
                //
                if (rubberBandingNewEdge)
                {
                    mg.setColor(java.awt.Color.white);
                    Mesh.Vertex v0 = mesh.getVert(beingDraggedVertIndex);
                    mg.drawLine(v0.x, v0.y,
                                prevP[0], prevP[1], doAntiAliasing);
                } // if (rubberBandingNewEdge)

                if (doShowPositiveOrthantnessVisualization)
                {
                    int nPoints = 5000;
                    int nLabels = 100;
                    double M[][] = new double[3][3];
                    {
                        // XXX should add a function to VecMath for random orthonormal matrix?
                        FORI (i, 2)
                        FORI (j, 3)
                            M[i][j] = 2*Math.random() - 1.;
                        VecMath.normalize(M[0], M[0]);
                        VecMath.vpsxv(M[1],
                                      M[1],
                                      -VecMath.dot(M[0], M[1]),
                                      M[0]);
                        VecMath.normalize(M[1], M[1]);
                        VecMath.vxv3(M[2], M[0], M[1]);
                    }

                    double v[] = new double[3];
                    double Mv[] = new double[3];
                    FORI (iPoint, nLabels+nPoints)
                    {
                        VecMath.random(v);

                        if (iPoint == 0 || iPoint == nLabels+nPoints-1)
                            VecMath.fillvec(v, 1.);
                        else if (iPoint == 1 || iPoint == nLabels+nPoints-2)
                            VecMath.fillvec(v, -1);


                        VecMath.normalize(v, v);
                        VecMath.mxv(Mv, M, v);
                        if (Mv[2] < 0.)
                        {
                            VecMath.sxv(v, -1., v);
                            VecMath.sxv(Mv, -1., Mv);
                        }
                        double goodness = VecMath.positiveOrthantness(v, true); // true means use "synopsis"
                        //double incrDegrees = 10.;
                        double incrDegrees = 5.;
                        double dN = goodness * 180 / Math.PI / incrDegrees;
                        int iN = (int)Math.round(dN);
                        if (iPoint <= 1
                         || iPoint >= nLabels+nPoints-2
                         || ABS(iN-dN) < .01)
                        {
                            if (iN == 0)
                                mg.setColor(java.awt.Color.red);
                            else if (iN % 2 == 0)
                                mg.setColor(java.awt.Color.green);
                            else
                                mg.setColor(java.awt.Color.blue);

                            if (iPoint == 0
                             || iPoint == nLabels+nPoints-1)
                                mg.drawString(""+(dN*incrDegrees),
                                              Mv[0],Mv[1], -1., 1.);
                            else if (iPoint < nLabels)
                                mg.drawString(""+(int)Math.round(dN*incrDegrees),
                                              Mv[0],Mv[1], -1., 1.);
                            else
                                mg.drawPoint(Mv[0],Mv[1], 1);
                        }
                        else
                            iPoint--; // cancel loop iteration
                    }
                }


                if (g != frontBufferGraphics)
                {
                    if (showMag.get())
                    FORI (iMag, 2)
                    {
                        // can we zoom part of the image onto itself?
                        // it seems yes! (at least with javac 1.3, runtime 1.6)
                        // XXX TODO: should really do it into a different buffer, we get artifacts this way when magging over the mag

                        int bbWidth = backBufferImage.getWidth(null);
                        int bbHeight = backBufferImage.getHeight(null);

                        // odd -> center pixel, even -> a little to lower right
                        int focusX = bbWidth/2;
                        int focusY = bbHeight/2;
                        if (prevP != null)
                        {
                            // lame way of figuring out where the mouse was most recently
                            double focus[] = new double[2];
                            mg.unpick(prevP[0], prevP[1], focus);
                            focusX = (int)Math.round(focus[0]-.5);
                            focusY = (int)Math.round(focus[1]-.5);
                        }



                        assert(magWidth % 2 == 1);

                        int dx0 = bbWidth - (magFactor+1)*magWidth;
                        int dy0 = bbHeight - (magFactor+1)*magWidth;
                        int dx1 = bbWidth;
                        int dy1 = bbHeight;
                        int sx0 = focusX - (magWidth-1)/2;
                        int sy0 = focusY - (magWidth-1)/2;
                        int sx1 = focusX + (magWidth+1)/2;
                        int sy1 = focusY + (magWidth+1)/2;

                        {
                            // border around the real one (before copying,
                            // so it will get clobbered)
                            g.setColor(java.awt.Color.blue);
                            g.drawRect(focusX-(magWidth-1)/2 - 1,
                                       focusY-(magWidth-1)/2 - 1,
                                       magWidth+1,
                                       magWidth+1);
                        }


                        g.drawImage(backBufferImage,
                                    dx0,dy0,dx1,dy1,
                                    sx0,sy0,sx1,sy1,
                                    null);

                        //g.setColor(java.awt.Color.gray);
                        g.setColor(java.awt.Color.black);
                        FORI (i, magWidth+1)
                        {
                            int x = bbWidth-1 - i*(magFactor+1);
                            int y = bbHeight-1 - i*(magFactor+1);
                            g.drawLine(x,dy0-1, x,dy1);
                            g.drawLine(dx0-1,y, dx1,y);
                        }

                        {
                            // slighly bolden the grid box around the center cell
                            int x0 = bbWidth - (magWidth+1)/2 * (magFactor+1) - 1;
                            int y0 = bbHeight - (magWidth+1)/2 * (magFactor+1) - 1;
                            int boldWidth = 3;
                            java.awt.Color colors[] = {java.awt.Color.black, java.awt.Color.white, java.awt.Color.black};
                            FORI (i, boldWidth)
                            {
                                g.setColor(colors[i]);
                                g.drawRect(x0-i,y0-i, magFactor+1+2*i, magFactor+1+2*i);
                            }
                        }

                        {
                            // border around the magnified one
                            g.setColor(java.awt.Color.blue);
                            g.drawRect(dx0-1,dy0-1, dx1-dx0, dy1-dy0);
                        }

                        {

                            int[] pixels = new int[1];
                            java.awt.image.PixelGrabber pg = new java.awt.image.PixelGrabber(backBufferImage, focusX,focusY,1,1,pixels, 0, 1);
                            try
                            {
                                pg.grabPixels();
                            }
                            catch (InterruptedException e)
                            {
                                assert(false);
                            }
                            assert((pg.getStatus() & java.awt.image.ImageObserver.ABORT) == 0);
                            int alpha = (pixels[0]>>24) & 0xff;
                            int red =   (pixels[0]>>16) & 0xff;
                            int green = (pixels[0]>> 8) & 0xff;
                            int blue =  (pixels[0]    ) & 0xff;

                            mg.setColor(java.awt.Color.white);
                            mg.drawString(""+focusX+","+focusY+": "+red+","+green+","+blue+(alpha==255?"":" "+alpha),
                                          size.width/minSize,-size.height/minSize,
                                          1., 1.5,
                                          java.awt.Color.black); // background
                        }
                    }

                    frontBufferGraphics.drawImage(backBufferImage,
                                                  0, 0,
                                                  getWidth(),  // of canvas, not back buffer
                                                  getHeight(), // of canvas, not back buffer
                                                  this);
                }

                if (false) // hack-- uncomment this to mess around with crackkiller
                {
                    if (mesh.getVert(1).x
                      < mesh.getVert(0).x)
                        exploreCrackHead(mesh, 1, 0);
                    else
                        exploreCrackHead(mesh, 0, 1);
                }

                if (eventVerbose >= 1) System.out.println("out paint");
            } // paint

            private void makeSureBackBufferIsRight()
            {
                if (doDoubleBuffer)
                {
                    java.awt.Dimension size = getSize();
                    int shouldBeWidth = (int)Math.ceil((double)size.width/(double)globalMagFactor);
                    int shouldBeHeight = (int)Math.ceil((double)size.height/(double)globalMagFactor);
                    if (backBufferImage == null
                     || backBufferImage.getWidth(this) != shouldBeWidth
                     || backBufferImage.getHeight(this) != shouldBeHeight)
                    {
                        if (eventVerbose >= 1)
                        {
                            System.out.println("Creating back buffer " + shouldBeWidth + "x" + shouldBeHeight);
                        }
                        backBufferImage = createImage(shouldBeWidth,
                                                      shouldBeHeight);
                    }
                }
                else
                    backBufferImage = null;
            } // makeSureBackBufferIsRight
        } // class TheCanvas

            private void delaunayize()
            {
                //
                // Discard the mesh edges and replace it with
                // the Delaunay triangulation of the vertex set,
                // using 3d convex hull.
                // Project to a paraboloid tweaked by heights,
                // which is the right thing to do.
                //
                int nVerts = mesh.verts.size();
                double verts[][] = new double[nVerts][/*3*/];
                FORI (iVert, nVerts)
                {
                    Mesh.Vertex v = mesh.getVert(iVert);
                    verts[iVert] = new double[]{v.x, v.y, v.h};
                }

                double vertsForHull[][] = new double[nVerts][3];
                FORI (iVert, nVerts)
                {
                    vertsForHull[iVert][0] = verts[iVert][0];
                    vertsForHull[iVert][1] = verts[iVert][1];
                    vertsForHull[iVert][2] = verts[iVert][2] - .5 * (SQR(verts[iVert][0]) + SQR(verts[iVert][1]));
                }
                //PRINTARRAY(verts);
                //PRINTARRAY(vertsForHull);
                // normalize to range -1..1 in all three dimensions
                double bbox[][] = VecMath.bbox(vertsForHull);
                if (bbox != null)
                {
                    FORI (iDim, 3)
                    {
                        double bboxCenter = .5*(bbox[1][iDim]+bbox[0][iDim]);
                        double bboxRadius = .5*(bbox[1][iDim]-bbox[0][iDim]);
                        if (bboxRadius == 0.)
                            bboxRadius = 1.;
                        FORI (iVert, nVerts)
                            vertsForHull[iVert][iDim] = (vertsForHull[iVert][iDim] - bboxCenter) / bboxRadius;
                    }
                }
                //System.out.println("    computing convex hull");
                int hull[][] = ConvexHull.convexHull(vertsForHull, 1e-12);

                // correct it, if 2 verts
                if (nVerts == 2)
                    hull = new int[][]{{0,1},{0,1}};

                // ack! need to circumvent invalidation of selection
                boolean wasValid = (meshOfSelectedTris == mesh);

                mesh = new Mesh(verts, hull);

                if (wasValid)
                    meshOfSelectedTris = mesh;

                //
                // Now get rid of each edge
                // that separates two negative-area faces.
                // Analyze all the edges first before deleting any,
                // so that we are only looking at triangle areas.
                //
                {
                    ArrayList edgesToDelete = new ArrayList();
                    int nEdges = mesh.edges.size();
                    for (int iEdge = 0; iEdge < nEdges; iEdge += 2) // only one of an edge and its opposite
                    {
                        Mesh.Edge edge = mesh.getEdge(iEdge);
                        if (mesh.twiceFaceArea(edge) < 0
                         && mesh.twiceFaceArea(edge.opposite()) < 0)
                            edgesToDelete.add(edge);
                    }
                    int nEdgesToDelete = edgesToDelete.size();
                    //System.out.println("    removing "+nEdgesToDelete+" backside edges");
                    FORI (iEdgeToDelete, nEdgesToDelete)
                    {
                        Mesh.Edge edge = (Mesh.Edge)edgesToDelete.get(iEdgeToDelete);
                        mesh.deleteEdge(edge);
                    }
                }

                // XXX should get rid of unreferenced vertices? NO! But should get rid of dups maybe
            } // delaunayize

            private void doCannedThingAlgorithm5Killer0()
            {
                if (true)
                {
                    double verts[][] = {
                        {0,0},     // 0
                        //{0,14,-1.5},    // 1
                        {0,10.5,-.8},    // 1
                        {7,7},     // 2
                        {-7,7},    // 3
                        {31,-5,10},   // 4
                        {-31,-5,10},  // 5
                        {28,-14},  // 6
                        {-28,-14}, // 7
                        {52,-26},  // 8
                        {-52,-26}, // 9
                    };
                    // XXX lame, we are scaling heights wrong... picked heights empirically for this wrongness
                    VecMath.mxs(verts, verts,
                                .02);
                    int faces[][] = {
                        {0,2,1},
                        {0,6,2},
                        {2,6,4},
                        {4,6,8},
                        {0,1,3},
                        {0,3,7},
                        {3,5,7},
                        {5,9,7},
                        {0,7,9,5,3,1,2,4,8,6},
                    };
                    mesh = new Mesh(verts, faces);
                }



                if (true)
                {
                    double scale = .05;

                    //double topTilt = DTOR(2.);
                    //double topTilt = DTOR(45.);
                    //double topTilt = Math.atan2(1,2);
                    //double topTilt = Math.atan2(1,2)/2;
                    double topTilt = Math.atan2(1,4);
                    double q = 250;
                    double qq = 300;
                    double verts[][] = {
                        {0,0},     // 0
                        {0,7+7*Math.tan(topTilt)}, // 1
                        {7,7},     // 2
                        {-7,7},    // 3
                        {14,0},  // 4
                        {-14,0}, // 5
                        {15,3},   // 6
                        {-15,3},  // 7
                        {14.5+q*Math.cos(DTOR(30.)), 1.5-q*Math.sin(DTOR(30.))},  // 8
                        {-14.5-q*Math.cos(DTOR(30.)), 1.5-q*Math.sin(DTOR(30.))},  // 9
#define DO_OUTER
#ifdef DO_OUTER
                        {14.5+qq*Math.cos(DTOR(30.)), 1.5-qq*Math.sin(DTOR(30.))},  // 10
                        {-14.5-qq*Math.cos(DTOR(30.)), 1.5-qq*Math.sin(DTOR(30.))},  // 11
                        {0,50}, // 12     (will be adjusted)
#endif // DO_OUTER
                    };
#ifdef DO_OUTER
                    verts[12][1] = verts[10][1] + Math.sqrt(3.)*verts[10][0];
#endif // DO_OUTER
                    int faces[][] = {
                        {1,0,2},
                        {0,1,3},
                        {2,0,4},
                        {0,3,5},
                        {2,4,6},
                        {5,3,7},
                        {6,4,8},
                        {5,7,9},

#ifndef DO_OUTER // if NOT doing outer
                        {0,5,9,7,3,1,2,6,8,4},
#endif // DO_OUTER

#ifdef DO_OUTER
                        {6,8,10},
                        {9,7,11},
                        {10,0,11},
                        {10,8,4},
                        {10,4,0},
                        {11,5,9},
                        {11,0,5},

                        //{10,11,5,3,1,2,4},
                        {12,11,7},
                        {12,7,3},
                        {12,3,1},
                        {12,1,2},
                        {12,2,6},
                        {12,6,10},
                        {12,10,11},
#endif // DO_OUTER
                    };
                    // corresponding to the triangular faces... (some of them)
                    double desiredDualVerts[][] = {
                        {1,3},
                        {-1,3},
                        {3,1},
                        {-3,1},
                        {9,7},
                        {-9,7},

                        //{12,6},
                        //{-12,6},

                        //{15,5},
                        //{-15,5},

                        {18,4},
                        {-18,4},

#ifdef DO_OUTER
                        {12+.5*Math.cos(RTOD(60.))/Math.sin(RTOD(60.)), 6.5}, // this one is only approximate, and will be adjusted below
                        {-12-.5*Math.cos(RTOD(60.))/Math.sin(RTOD(60.)), 6.5}, // this one is only approximate, and will be adjusted below
#endif // DO_OUTER
                    };
#ifdef DO_OUTER
                    PRINTVEC(desiredDualVerts[desiredDualVerts.length-2]);
                    PRINTVEC(desiredDualVerts[desiredDualVerts.length-1]);
                    double height = (desiredDualVerts[desiredDualVerts.length-5][1]
                                   - desiredDualVerts[desiredDualVerts.length-3][1])/2.;
                    double length = height / Math.sin(RTOD(60.));
                    desiredDualVerts[desiredDualVerts.length-1][1] =
                    desiredDualVerts[desiredDualVerts.length-2][1] =
                        desiredDualVerts[desiredDualVerts.length-3][1] + height;
                    desiredDualVerts[desiredDualVerts.length-1][0] =
                    -(desiredDualVerts[desiredDualVerts.length-2][0] =
                         desiredDualVerts[desiredDualVerts.length-4][0] + length * Math.cos(RTOD(60.)));
                    PRINTVEC(desiredDualVerts[desiredDualVerts.length-2]);
                    PRINTVEC(desiredDualVerts[desiredDualVerts.length-1]);

                    boolean doBackface = true;
                    if (doBackface)
                    {
                        verts = (double[][])Arrays.append(verts,
                                                          VecMath.bary(verts[verts.length-3],
                                                                       verts[verts.length-2], 1/3.,
                                                                       verts[verts.length-1], 1/3.));
                        verts[verts.length-1] = (double[])Arrays.append(verts[verts.length-1], -6./(scale*scale)); // shameless hardcoding
                        // Replace the last face with 3 faces
                        faces[faces.length-1] = new int[]{10,11,13};
                        faces = (int[][])Arrays.append(faces, new int[]{11,12,13});
                        faces = (int[][])Arrays.append(faces, new int[]{12,10,13});
                    }
#endif // DO_OUTER
                    // make room for heights in the array
                    FORI (iVert, verts.length)
                        if (verts[iVert].length == 2)
                            verts[iVert] = (double[])Arrays.append(verts[iVert], 0.);
                    // adjust heights to make the dual verts right
                    FORI (iVert, desiredDualVerts.length+2)
                    {
                        if (iVert == 0)
                            verts[iVert][2] = 0.;
                        else if (iVert == 1)
                        {
                            // Get the y coord of desiredDualVerts[0] right
                            double sampleResultVerts[][] = new double[2][3];
                            int iDualVert = 0;
                            double v0[] = verts[faces[iDualVert][0]];
                            double v1[] = verts[faces[iDualVert][1]];
                            double v2[] = verts[faces[iDualVert][2]];
                            FORI (iSample, 2)
                            {
                                verts[iVert][2] = (double)iSample; // 0. or 1.
                                SolveForDualPoint(v0[0],v0[1],v0[2],
                                                  v1[0],v1[1],v1[2],
                                                  v2[0],v2[1],v2[2],
                                                  sampleResultVerts[iSample]);
                            }
                            double toDesired[] = VecMath.vmv(2, desiredDualVerts[iDualVert], sampleResultVerts[0]);
                            double toSample1[] = VecMath.vmv(2, sampleResultVerts[1], sampleResultVerts[0]);
                            double t = toDesired[1] / toSample1[1];
                            verts[iVert][2] = t;

                            // check...
                            double finalResultVert[] = new double[3];
                            SolveForDualPoint(v0[0],v0[1],v0[2],
                                              v1[0],v1[1],v1[2],
                                              v2[0],v2[1],v2[2],
                                              finalResultVert);
                            //PRINTVEC(desiredDualVerts[iDualVert]);
                            //PRINTVEC(finalResultVert);
                            assert(Math.abs(desiredDualVerts[iDualVert][1]-finalResultVert[1]) <= 1e-6);
                        }
                        else
                        {
                            assert(faces[iVert-2][2] == iVert);
                            double sampleResultVerts[][] = new double[2][3];
                            int iDualVert = iVert-2;
                            double v0[] = verts[faces[iDualVert][0]];
                            double v1[] = verts[faces[iDualVert][1]];
                            double v2[] = verts[faces[iDualVert][2]];
                            FORI (iSample, 2)
                            {
                                verts[iVert][2] = (double)iSample; // 0. or 1.
                                SolveForDualPoint(v0[0],v0[1],v0[2],
                                                  v1[0],v1[1],v1[2],
                                                  v2[0],v2[1],v2[2],
                                                  sampleResultVerts[iSample]);
                            }
                            double toDesired[] = VecMath.vmv(2, desiredDualVerts[iDualVert], sampleResultVerts[0]);
                            double toSample1[] = VecMath.vmv(2, sampleResultVerts[1], sampleResultVerts[0]);
                            double t = VecMath.dot(2, toDesired,toSample1) / VecMath.dot(2, toSample1,toSample1);
                            verts[iVert][2] = t;

                            // check...
                            double finalResultVert[] = new double[3];
                            SolveForDualPoint(v0[0],v0[1],v0[2],
                                              v1[0],v1[1],v1[2],
                                              v2[0],v2[1],v2[2],
                                              finalResultVert);
                            PRINTVEC(desiredDualVerts[iDualVert]);
                            PRINTVEC(finalResultVert);
                            //assert(VecMath.dist(desiredDualVerts[iDualVert], finalResultVert) <= 1e-6);
                        }
                    }
#ifdef DO_OUTER
                    // apex height is same as other outer heights
                    PRINT(verts[10][2]);
                    PRINT(verts[11][2]);
                    assert(Math.abs(verts[11][2]-verts[10][2]) <= 1e-6);
                    verts[12][2] = verts[11][2];
#endif
                    FORI (iVert, verts.length)
                    {
                        verts[iVert][0] *= scale;
                        verts[iVert][1] *= scale;
                        if (verts[iVert].length > 2)
                            verts[iVert][2] *= scale*scale;
                    }
                    mesh = new Mesh(verts, faces);
                }
            } // doCannedThingAlgorithm5Killer

            private void doCannedThingAlgorithm5Killer1()
            {
                if (true)
                {
                    double scale = 1/60000.;

                    double q = 30; // for working
                    //double q = 100; // the real thing
                    //double q = 60; // try not so extreme
                    double qq = 90;
                    //double qq = 300; // the real thing
                    //double qq = 180; // try not so extreme
                    double fudgeUp = 0; // fraction of big triangle height to move big triangle up
                    double verts[][] = {
                        {0,0},      // 0
                        {0,7},      // 1
                        {14,28},    // 2
                        {-14,28},   // 3

                        VecMath.lerp(new double[]{7,14},new double[]{392,-98},.8), // 4
                        VecMath.lerp(new double[]{-7,14},new double[]{-392,-98},.8), // 5



                        {392,-98},  // 6
                        {-392,-98}, // 7

                        {398,-68},  // 8
                        {-398,-68}, // 9

                        {q*395, -83},  // 10
                        {-q*395, -83}, // 11
                        {q*395, -83 + .25*q*395}, // 12
                        {-q*395, -83 + .25*q*395}, // 13

                        {q*395 + qq*395, -83 - qq*395}, // 14
                        {-q*395 - qq*395, -83 - qq*395}, // 15

                        {0, 1000}, // 16 -- will be adjusted
                    };
                    verts[16][1] = verts[14][1] + Math.sqrt(3.)*verts[14][0];
                    verts[14][1] += fudgeUp * verts[14][0];
                    verts[15][1] += fudgeUp * verts[14][0];
                    verts[16][1] += fudgeUp * verts[14][0];

                    int faces[][] = {
                        {1,0,2},
                        {0,1,3},
                        {1,2,3},

                        //{2,0,6},
                        {2,0,4},
                        {4,0,6},
                        {2,4,6},

                        {0,3,7},
                        //{0,3,5},
                        //{0,5,7},
                        //{5,3,7},

                        {2,6,8},
                        {7,3,9},
                        {8,6,10},
                        {7,9,11},

                        {8,10,12},
                        {11,9,13},

                        {6,0,14},
                        {0,7,15},


                        {2,12,16}, // moved up from below so can match with a desiredDualVert




                        {10,6,14},
                        {7,11,15},

                        {12,10,14},
                        {11,13,15},

                        {0,15,14},

                        {15,13,16},

                        {13,9,3},
                        {13,3,16},

                        {3,2,16},


                        {2,8,12},
                        //{2,12,16}, // moving this up

                        {12,14,16},
                        {14,15,16},
                    };
                    // corresponding to the triangular faces... (some of them)
                    double desiredDualVerts[][] = {
                        {3,0},
                        {-3,0},
                        {0,2},

                        //{5,-1},
                        {5,-1},
                        {4.75,-2},
                        {5.25,-.25},

                        {-5,-1},
                        //{-5,-1},
                        //{-4.75,-2},
                        //{-5.25,-.25},

                        {14,26},
                        {-14,26},
                        {19,25},
                        {-19,25},

                        {19,25.5},
                        {-19,25.5},

                        {4,-4},
                        {-4,-4},

                        //{14,46}, // approx
                        //{15,42}, // approx
                        {16,38}, // approx
                    };
                    VecMath.mxs(desiredDualVerts, desiredDualVerts,
                                80.);

                    boolean doBackface = true;
                    if (doBackface)
                    {
                        verts = (double[][])Arrays.append(verts,
                                                          VecMath.bary(verts[verts.length-3],
                                                                       verts[verts.length-2], 1/3.,
                                                                       verts[verts.length-1], 1/3.));
                        verts[verts.length-1] = (double[])Arrays.append(verts[verts.length-1], -.4/(scale*scale)); // shameless hardcoding
                        // Replace the last face with 3 faces
                        int oldLastFace[] = faces[faces.length-1];
                        faces[faces.length-1] = new int[]{oldLastFace[0],oldLastFace[1],verts.length-1};
                        faces = (int[][])Arrays.append(faces, new int[]{oldLastFace[1],oldLastFace[2],verts.length-1});
                        faces = (int[][])Arrays.append(faces, new int[]{oldLastFace[2],oldLastFace[0],verts.length-1});
                    }

                    // make room for heights in the array
                    FORI (iVert, verts.length)
                        if (verts[iVert].length == 2)
                            verts[iVert] = (double[])Arrays.append(verts[iVert], 0.);
                    // adjust heights to make the dual verts right
                    verts[0][2] = 0.;
                    {
                        int iVert = 1;
                        int iDualVert = 0;
                        // Get the y coord of desiredDualVerts[0] right
                        double sampleResultVerts[][] = new double[2][3];
                        double v0[] = verts[faces[iDualVert][0]];
                        double v1[] = verts[faces[iDualVert][1]];
                        double v2[] = verts[faces[iDualVert][2]];
                        FORI (iSample, 2)
                        {
                            verts[iVert][2] = (double)iSample; // 0. or 1.
                            SolveForDualPoint(v0[0],v0[1],v0[2],
                                              v1[0],v1[1],v1[2],
                                              v2[0],v2[1],v2[2],
                                              sampleResultVerts[iSample]);
                        }
                        double toDesired[] = VecMath.vmv(2, desiredDualVerts[iDualVert], sampleResultVerts[0]);
                        double toSample1[] = VecMath.vmv(2, sampleResultVerts[1], sampleResultVerts[0]);
                        double t = toDesired[1] / toSample1[1];
                        verts[iVert][2] = t;

                        // check...
                        double finalResultVert[] = new double[3];
                        SolveForDualPoint(v0[0],v0[1],v0[2],
                                          v1[0],v1[1],v1[2],
                                          v2[0],v2[1],v2[2],
                                          finalResultVert);
                        //PRINTVEC(desiredDualVerts[iDualVert]);
                        //PRINTVEC(finalResultVert);
                        assert(Math.abs(desiredDualVerts[iDualVert][1]-finalResultVert[1]) <= 1e-6);
                    }

                    FORI (iDualVert, desiredDualVerts.length)
                    {
                        int iVert = faces[iDualVert][2];
                        double sampleResultVerts[][] = new double[2][3];
                        double v0[] = verts[faces[iDualVert][0]];
                        double v1[] = verts[faces[iDualVert][1]];
                        double v2[] = verts[faces[iDualVert][2]];
                        FORI (iSample, 2)
                        {
                            verts[iVert][2] = (double)iSample; // 0. or 1.
                            SolveForDualPoint(v0[0],v0[1],v0[2],
                                              v1[0],v1[1],v1[2],
                                              v2[0],v2[1],v2[2],
                                              sampleResultVerts[iSample]);
                        }
                        double toDesired[] = VecMath.vmv(2, desiredDualVerts[iDualVert], sampleResultVerts[0]);
                        double toSample1[] = VecMath.vmv(2, sampleResultVerts[1], sampleResultVerts[0]);
                        double t = VecMath.dot(2, toDesired,toSample1) / VecMath.dot(2, toSample1,toSample1);
                        verts[iVert][2] = t;

                        // check...
                        double finalResultVert[] = new double[3];
                        SolveForDualPoint(v0[0],v0[1],v0[2],
                                          v1[0],v1[1],v1[2],
                                          v2[0],v2[1],v2[2],
                                          finalResultVert);
                        PRINTVEC(desiredDualVerts[iDualVert]);
                        PRINTVEC(finalResultVert);
                        //assert(VecMath.dist(desiredDualVerts[iDualVert], finalResultVert) <= 1e-6);
                    }

                    FORI (iVert, verts.length)
                    {
                        verts[iVert][0] *= scale;
                        verts[iVert][1] *= scale;
                        if (verts[iVert].length > 2)
                            verts[iVert][2] *= scale*scale;
                    }
                    mesh = new Mesh(verts, faces);
                }
            } // doCannedThingAlgorithm5Killer

            private void doBlueNoiseThing()
            {
                double stubbornness = 100;
                double overlappingDiskRadiusX = .2;
                double overlappingDiskRadiusY = .2;
                double verts[][] = generateBlueNoiseOnUnitSquare(stubbornness,
                                                                 overlappingDiskRadiusX,
                                                                 overlappingDiskRadiusY);
                VecMath.mmv(verts, verts, new double[]{.5,.5});
                FORI (iVert, verts.length)
                    verts[iVert] = (double[])Arrays.append(verts[iVert], 0.); // make room for heights
                mesh = new Mesh(verts, new int[][]{});
            } // doBlueNoiseThing

            //
            // Blind lagoon exiting goes into an endless loop:
            //     A is the upper-left horizontal edge
            //     B is the horizontal edge below A
            //     C is the middle edge
            // Bad exit A -> good exit B
            // Bad exit C -> good exit A
            // Bad exit B -> good exit C
            // and we're back to the beginning.
            //
            private void doCannedThingBlindLagoonExitKiller()
            {
                double verts[][] = {
                   { 0.15,  0.5, -0.155},
                   {-0.15,  0.2,  0.0},
                   {-0.15,  0.8,  0.0},
                   { 0.15, -0.2,  0.0},
                   {-0.15, -0.1,  0.0},
                   {-0.15, -0.5,  0.0},
                };
                int faces[][] = {
                    {0,1,3},
                    {1,0,2},
                    {3,1,4},
                    {0,3,5,4,1,2},
                    {3,4,5},
                };
                mesh = new Mesh(verts, faces);
            } // doCannedThingBlindLagoonExitKiller

            //
            // Farthest-from-center lagoon exiting goes into an endless loop:
            //     A is the upper-left almost-horizontal edge
            //     B is the lower-right edge
            //     C is the edge halfway between them
            // Only bad exit A -> farthest good exit B
            // Only bad exit C -> farthest good exit A
            // Only bad exit B -> farthest good exit C
            // and we're back to the beginning.
            //
            private void doCannedThingFarthestLagoonExitKiller()
            {
                /*
                // really simple verts, no hand-crafting-- see what happens.  hmm this sucks, it doesn't get there!
                double verts[][] = {
                    {.1, .3, 0},
                    {-.1, .1, 0},
                    {-.1, .5, 0},
                    {.1, -.1, 0},
                    {-.1, -.3, 0},
                    {.1, -.5, 0},
                };
                */

                /*
                // original hand-crafted verts: violated farthest-exit constraint for top 2-vertex lagoon
                double verts[][] = {
                    {0.254632748975815, 0.6613110539845769, 0.0},
                    {0.001985463846777679, 0.40848329048843174, 0.0050},
                    {-0.0016100400996860165, 0.8262841442469365, -0.0705},
                    {0.15968401023145556, 0.09537275064267343, -0.0050},
                    {0.053309106411296145, 0.1762210796915167, -0.01},
                    {-0.4317114578915699, -0.6837916370249981, -0.5450000000000002},
                };
                */

                /*
                // optimized 10 passes: goodness = .017256350831721664 (using VecMath.synopsis which I'm not thrilled with any more)
                double verts[][] = {
                    {0.1800525435129707, 0.4676175307461174, 0.0},
                    {0.13567357880860711, 0.42320686396714136, 0.0025000000000000022},
                    {-0.041882330900956, 0.7515699545002962, -0.03525000000000006},
                    {0.29423490241724615, -0.015297283324235564, -0.024256623978102798},
                    {0.2657663454311589, 0.0032808826682159285, -0.02535592252632536},
                    {0.027482624239009528, -0.5713757012317203, -0.09458036525466695},
                };
                */

                // optimized 50 passes: goodness = .019362280324644425 (using VecMath.synopsis which I'm not thrilled with any more)
                double verts[][] = {
                    {0.1800525435129707, 0.4676175307461174, 0.0},
                    {0.1093067590185278, 0.3968212090624114, 0.0025000000000000022},
                    {-0.3578608151777813, 1.1748461992103727, -0.03525000000000006},
                    {0.6348756548188554, -0.5552758689949323, 0.1838002721879618},
                    {0.5790169179568446, -0.523270452612108, 0.14986341969960895},
                    {0.20759453708056247, -1.6232499556679696, 0.4089344906614831},
                };


                int faces[][] = {
                    {1, 3, 0},
                    {3, 1, 4},
                    {0, 3, 5, 4, 1, 2},
                    {1, 0, 2},
                    {3, 4, 5},
                };
                mesh = new Mesh(verts, faces);

            } // doCannedThingFarthestLagoonExitKiller

            //
            // Farthest-from-center lagoon exiting goes into an endless loop:
            //     A is the upper-left almost-horizontal edge
            //     B is the lower-*left* edge
            //     C is the edge halfway between them
            // Only bad exit A -> farthest good exit B
            // Only bad exit C -> farthest good exit A
            // Only bad exit B -> farthest good exit C
            // and we're back to the beginning.
            //
            private void doCannedThingFarthestLagoonExitKillerAltB()
            {
/*
100 passes from original hand-crafted: simple synopsis = 0.0632903084802694
OFF
6 5 0
0.1273163744879075 0.3306555269922885 -1.3877787807814457E-17
0.007466950664434855 0.21072048883775582 0.0012499999999999976
0.063927946972354 0.45166494195664725 -0.01762500000000003
0.07725274705168253 0.017764193145660596 0.039682919717938775
0.019644371916512516 0.019129114462716725 0.013473915969745336
-0.2059752055364354 -0.6388679646686696 -0.06303872265462748
3  1 3 0
3  3 1 4
6  0 3 5 4 1 2
3  1 0 2
3  3 4 5

100 passed from 50 passes on original structure: simple synopsis = 0.08830543355804742
OFF
6 5 0
0.1800525435129707 0.4676175307461174 0.0
0.08303579636398613 0.37053147976867984 0.0025000000000000022
-0.1743207145354405 1.207926317312154 -0.03525000000000006
0.5935025616828306 -0.4786092404430522 0.20709150548025163
0.5086599164177077 -0.50309546392274 0.1310302693859244
0.5788838237668292 -1.7863394875007428 0.19118475261903686
3  1 3 0
3  3 1 4
6  0 3 5 4 1 2
3  1 0 2
3  3 4 5
*/
/*
                //100 passed from 50 passes on original structure: simple synopsis = 0.08830543355804742
                double verts[][] = {
                    {0.1800525435129707, 0.4676175307461174, 0.0},
                    {0.08303579636398613, 0.37053147976867984, 0.0025000000000000022},
                    {-0.1743207145354405, 1.207926317312154, -0.03525000000000006},
                    {0.5935025616828306, -0.4786092404430522, 0.20709150548025163},
                    {0.5086599164177077, -0.50309546392274, 0.1310302693859244},
                    {0.5788838237668292, -1.7863394875007428, 0.19118475261903686},
                };
                int faces[][] = {
                    {1, 3, 0},
                    {3, 1, 4},
                    {0, 3, 5, 4, 1, 2},
                    {1, 0, 2},
                    {3, 4, 5},
                };
*/

                // and then diagonally flipped and hand neatened
                double verts[][] = {
                    {-0.4375, 0.0625, 0},
                    {-0.375, 0.125, 0},
                    {-0.78125, 0.125, 0.0812},
                    {0.125, -0.125, 0.0518},
                    {0.140625, -0.078125, 0.0328},
                    {0.9375, -0.125, 0.0478},
                };
                int faces[][] = {
                    {0, 3, 1},
                    {4, 1, 3},
                    {2, 1, 4, 5, 3, 0},
                    {2, 0, 1},
                    {5, 4, 3},
                };

                mesh = new Mesh(verts, faces);

            } // doCannedThingFarthestLagoonExitKillerAltB

            private void doCannedThingFarthestLagoonExitKillerOptimized()
            {
                doCannedThingFarthestLagoonExitKiller();
                optimizeFarthestLagoonExitKiller();
            }
            private void optimizeFarthestLagoonExitKiller()
            {
                int fromsAndTos[][/*2*/][][/*3*/] = {
                    {{{0,2,1}}, {{0,2,1},{0,1,3},{1,4,3},{3,4,5}}}, // edge A must be a bad exit of everything
                    {{{0,1,3}}, {{0,1,3},{1,4,3},{3,4,5}}}, // upper inner edge must be good exit of 3-vert lagoon under it
                    {{{1,4,3}}, {{1,4,3},{3,4,5}}}, // edge C (center) must be a good exit for 2-vert lagoon under it
                    {{{3,4,5}}, {{0,2,1},{0,1,3},{1,4,3},{3,4,5}}}, // edge B must be a good exit of whole thing
                    {{{3,4,5}}, {{0,2,1},{0,1,3},{1,4,3},{3,4,5}}}, // edge B's evil twin must be a bad exit of whole thing

                    {{{0,1,3}}, {{0,2,1},{0,1,3}}}, // edge C (center) must be bad for upper 2-vert lagoon
                    {{{0,2,1}}, {{0,2,1},{0,1,3}}}, // edge A must be good for upper 2-vert lagoon
                    {{{0,2,1}}, {{0,2,1},{0,1,3}}}, // edge A's evil twin must be bad for upper 2-vert lagoon

                    {{{3,4,5}}, {{1,4,3},{3,4,5}}}, // edge B must be bad for lower 2-vert lagoon
                    {{{1,4,3}}, {{1,4,3},{3,4,5}}}, // edge C must be good for lower 2-vert lagoon
                    {{{1,4,3}}, {{1,4,3},{3,4,5}}}, // west edge must be bad for lower 2-vert lagoon
                };

                /*
                // ORIGINAL
                int toLeftOfEdgeEndIndices[][] = {
                    {1,2}, // edge A must be a bad exit of whole thing
                    {0,1}, // upper inner edge must be good exit of 3-vert lagoon under it
                    {3,1}, // edge C (center) must be a good exit for 2-vert lagoon under it
                    {5,3}, // edge B must be a good exit of whole thing
                    {5,4}, // edge B's evil twin must be a bad exit of whole thing

                    {3,1}, // edge C (center) must be bad for upper 2-vert lagoon
                    {2,1}, // edge A must be good for upper 2-vert lagoon
                    {2,0}, // edge A's evil twin must be bad for upper 2-vert lagoon

                    {3,5}, // edge B must be bad for lower 2-vert lagoon
                    {3,1}, // edge C must be good for lower 2-vert lagoon
                    {4,1}, // west edge must be bad for lower 2-vert lagoon
                };
                */


                // ALTERNATE B-- make B be the lower-left instead of lower-right
                int toLeftOfEdgeEndIndices[][] = {
                    {1,2}, // edge A must be a bad exit of whole thing
                    {0,1}, // upper inner edge must be good exit of 3-vert lagoon under it
                    {3,1}, // edge C (center) must be a good exit for 2-vert lagoon under it
                    {4,5}, // edge B must be a good exit of whole thing
                    {3,5}, // edge B's evil twin must be a bad exit of whole thing

                    {3,1}, // edge C (center) must be bad for upper 2-vert lagoon
                    {2,1}, // edge A must be good for upper 2-vert lagoon
                    {2,0}, // edge A's evil twin must be bad for upper 2-vert lagoon

                    {5,4}, // edge B must be bad for lower 2-vert lagoon
                    {3,1}, // edge C must be good for lower 2-vert lagoon
                    {4,1}, // west edge must be bad for lower 2-vert lagoon
                };

                /*
                // ALTERNATE AB-- make B be the lower-left instead of lower-right,
                //                make A be the upper-right instead of upper-left
                // (doesn't work :-( )
                int toLeftOfEdgeEndIndices[][] = {
                    {2,0}, // edge A must be a bad exit of whole thing
                    {0,1}, // upper inner edge must be good exit of 3-vert lagoon under it
                    {3,1}, // edge C (center) must be a good exit for 2-vert lagoon under it
                    {4,5}, // edge B must be a good exit of whole thing
                    {3,5}, // edge B's evil twin must be a bad exit of whole thing

                    {3,1}, // edge C (center) must be bad for upper 2-vert lagoon
                    {0,2}, // edge A must be good for upper 2-vert lagoon
                    {1,2}, // edge A's evil twin must be bad for upper 2-vert lagoon

                    {5,4}, // edge B must be bad for lower 2-vert lagoon
                    {3,1}, // edge C must be good for lower 2-vert lagoon
                    {4,1}, // west edge must be bad for lower 2-vert lagoon
                };
                */

                /*
                // ALTERNATE A-- make A be the upper-right instead of upper-left
                //               B is still lower-right
                // (doesn't work :-( )
                int toLeftOfEdgeEndIndices[][] = {
                    {2,0}, // edge A must be a bad exit of whole thing
                    {0,1}, // upper inner edge must be good exit of 3-vert lagoon under it
                    {3,1}, // edge C (center) must be a good exit for 2-vert lagoon under it
                    {5,3}, // edge B must be a good exit of whole thing
                    {5,4}, // edge B's evil twin must be a bad exit of whole thing

                    {3,1}, // edge C (center) must be bad for upper 2-vert lagoon
                    {0,2}, // edge A must be good for upper 2-vert lagoon
                    {1,2}, // edge A's evil twin must be bad for upper 2-vert lagoon

                    {3,5}, // edge B must be bad for lower 2-vert lagoon
                    {3,1}, // edge C must be good for lower 2-vert lagoon
                    {4,1}, // west edge must be bad for lower 2-vert lagoon
                };
                */

                boolean mustBeFarthestExit[] = {
                    false,
                    false,
                    false,
                    true,
                    false,

                    false,
                    true,
                    false,

                    false,
                    true,
                    false,
                };


                /*
                nice spec might look something like:
                    CCW lagoon boundary (can be in multiple pieces),   bad exits,    good exits, farthest exits

                    {{{0,2,1,4,5,3}}, {{2,1},{4,5}}, {{5,3}}, {{5,3}} }, // whole thing: A bad, B's evil twin bad, B good,  B farthest good from cg
                    {{{0,1,4,5,3}},   {},            {{0,1}}, {} }, // lower 3 vertices: upper inner edge good
                    {{{1,4,5,3}},     {{5,3},{1,4}}, {{3,1}}, {{3,1}} }, // lower 2 vertices: B bad, west edge bad, C good,  C farthest good from cg
                    {{{0,2,1,3}},     {{1,3},{0,2}}, {{2,1}}, {{2,1}} }, // upper 2 vertices: C bad, A's evil twin bad, A good,  A farthest good from cg


                */


                // doesn't seem to ever help much to consider edge lengths... weird.  also it's the 1-edgelength thing that hurts,  edgelength itself doesn't.  But, isn't that necessary to prevent it growing without bound?? dammit.
                boolean considerEdgeLengths = false;

                int nPasses = 2;
                //int maxCallsPerPass = 10*1000;
                //int maxCallsPerPass = 1*1000;
                //int maxCallsPerPass = 500;
                //int maxCallsPerPass = 255;
                //int maxCallsPerPass = 100;
                //int maxCallsPerPass = 53;
                //int maxCallsPerPass = 10;
                int maxCallsPerPass = 1;
                double initialDelta = .0001;

                Object optimizationPathVertsAndGoodnesses[/*2*/] = GeneralOptimizationStuff.optimizeVerts(mesh,
                    fromsAndTos,
                    toLeftOfEdgeEndIndices,
                    mustBeFarthestExit,
                    considerEdgeLengths,
                    nPasses,
                    maxCallsPerPass,
                    initialDelta);
                double optimizationPathVerts[][][] = (double[][][])optimizationPathVertsAndGoodnesses[0];
                double optimizationPathGoodnesses[] = (double[])optimizationPathVertsAndGoodnesses[1];
                                                                        
                PRINT(optimizationPathVerts.length);
                double verts[][] = optimizationPathVerts[optimizationPathVerts.length-1];
                assert(verts.length == 6);
                FORI (iVert, verts.length)
                {
                    Mesh.Vertex v = mesh.getVert(iVert);
                    v.x = verts[iVert][0];
                    v.y = verts[iVert][1];
                    v.h = verts[iVert][2];
                }

                // XXX misnomer now
                netless8OptimizationPath = optimizationPathVerts;
                netless8OptimizationPathGoodnesses = optimizationPathGoodnesses;
                netless8OptimizationIndex = optimizationPathVerts.length-1;
                PRINT(optimizationPathVerts.length);
                //PRINTARRAY(optimizationPathGoodnesses);

            } // doCannedThingFarthestLagoonExitKillerOptimized




            private void doCannedThingNetless8()
            {
                double Eps = .04;
                double slope = 1./16; // started with 1./100, 1/10 works but starts pushing outer point far away
                //     3   2
                //       1
                //      5 4
                //       0
                double verts[][] = {
                    {0*Eps, -7*Eps, 0},  // the "lowest" face, bottom point of dual
                    {0*Eps, 7*Eps, 1.64*Eps*Eps}, // empirical
                    {2*Eps, 9*Eps, 0},
                    {-2*Eps, 9*Eps, 0},
                    {7*slope*Eps, 0,  -23*Eps*Eps},
                    {-7*slope*Eps, 0, -23*Eps*Eps},
                };

                int faces[][] = {
                    {5,4,1},
                    {0,4,5},
                    {4,2,1},
                    {5,1,3},
                    {5,3,0},
                    {2,4,0},
                    {1,2,3},
                    {0,3,2},
                };

                mesh = new Mesh(verts, faces);
            } // doCannedThingNetless8

            // Counterexample to entire class of sweep algorithms
            // that cut each vertex to a higher vertex.
            // It contains two netless8's.
            private void doCannedThingSweepKiller0()
            {
                // cheap way of getting verts of netless8
                doCannedThingNetless8();
                double netless8Verts[][] = new double[mesh.verts.size()][3];
                FORI (i, netless8Verts.length)
                {
                    Mesh.Vertex vertex = mesh.getVert(i);
                    netless8Verts[i][0] = vertex.x;
                    netless8Verts[i][1] = vertex.y;
                    netless8Verts[i][2] = vertex.h;
                }

                double separation = 2;
                double verts[][] = new double[2*netless8Verts.length][3];
                FORI (i, netless8Verts.length)
                {
                    VecMath.copyvec(verts[i], netless8Verts[i]);
                    verts[i][0] -= separation/2;
                    VecMath.copyvec(verts[netless8Verts.length+i], netless8Verts[i]);
                    verts[netless8Verts.length+i][0] += separation/2;
                }

                double netless8TriHeight = verts[2][1] - verts[0][1];
                double y = verts[0][1] - netless8TriHeight;
                double Eps = .04; // same as netless8
                double h = -110*Eps*Eps; // not strictly necessary, but makes it easier to think about

                verts = (double[][])Arrays.append(verts, new double[]{verts[3][0],
                                                  y,
                                                  h});
                verts = (double[][])Arrays.append(verts, new double[]{verts[2][0],
                                                  y,
                                                  h});
                verts = (double[][])Arrays.append(verts, new double[]{verts[9][0],
                                                  y,
                                                  h});
                verts = (double[][])Arrays.append(verts, new double[]{verts[8][0],
                                                  y,
                                                  h});
                y -= (verts[2][0]-verts[3][0])*3/4;
                verts = (double[][])Arrays.append(verts, new double[]{0,
                                                  y,
                                                  0});
                verts = (double[][])Arrays.append(verts, new double[]{verts[1][0],
                                                  y,
                                                  h});
                verts = (double[][])Arrays.append(verts, new double[]{verts[7][0],
                                                  y,
                                                  h});
                y += (verts[2][0]-verts[3][0])*3/4;
                y -= netless8TriHeight;
                verts = (double[][])Arrays.append(verts, new double[]{verts[3][0]-2*(verts[2][0]-verts[3][0]),
                                                                      y,
                                                                      0});
                verts = (double[][])Arrays.append(verts, new double[]{-verts[verts.length-1][0],
                                                                      y,
                                                                      0});


                int faces[][] = new int[0][0];
                mesh = new Mesh(verts, faces);

                // temporarily fudge to prevent degenerate edges on boundary
                mesh.getVert(3).y -= 1/1024.;
                mesh.getVert(8).y -= 1/1024.;
                delaunayize();
                mesh.getVert(3).y += 1/1024.;
                mesh.getVert(8).y += 1/1024.;

            } // doCannedThingSweepKiller0

            // Counterexample to entire class of sweep algorithms
            // that cut each vertex to a higher vertex.
            // Slightly simpler than SweepKiller0.
            private void doCannedThingSweepKiller1()
            {
                double verts[][] = {
                    {0,0,0},
                    {9,-9,0},
                    {6,-3,0},
                    {7,24,0},
                    {-7,24,0},
                    {-6,-3,0},
                    {-9,-9,0},

                    {7,-6,0},
                    {3,-2,0},

                    {-3,-2,0},
                    {-7,-6,0},
                };
                int faces[][] = {
                    //{0,1,2},
                    {0,1,8},
                    {1,7,8},
                    {1,2,7},
                    {2,0,8},
                    {2,8,7},

                    //{6,0,5},
                    {0,5,9},
                    {0,9,6},
                    {5,10,9},
                    {5,6,10},
                    {9,10,6},

                    {1,3,2},
                    {2,3,0},
                    {0,3,4},
                    {0,4,5},
                    {4,6,5},
                    {0,6,1},
                    {1,6,4,3},
                };
                // argh, requires panning the whole picture around randomly a bit in order for it to come out symmetric...
                VecMath.mpv(verts, verts, new double[]{.1,.1,0});
                mesh = new Mesh(verts, faces);
                mesh.findAndApplyOptimalVertexHeights(OPTIMIZE_LENGTHS_INFINITY_NORM);
                // XXX argh, still requires use to set OPTIMIZE_LENGTHS_INFINITY_NORM and turn on and off Optimize, otherwise the dual picture is tiny... why??

            } // doCannedThingSweepKiller1

            // Counterexample to entire class of sweep algorithms
            // that cut each vertex to a higher vertex.
            // Slightly simpler than SweepKiller1.
            private void doCannedThingSweepKiller2()
            {
                double verts[][] = {
                    {0,0,0},
                    {9,-9,0},
                    {6,-3,0},
                    {7,24,0},
                    {-7,24,0},
                    {-6,-3,0},
                    {-9,-9,0},
                    {3,-2,0},
                    {-3,-2,0},
                };

                int faces[][] = {
                    {0,1,7},
                    {1,2,7},
                    {2,0,7},

                    {0,5,8},
                    {0,8,6},
                    {5,6,8},

                    {1,3,2},
                    {2,3,0},
                    {0,3,4},
                    {0,4,5},
                    {4,6,5},
                    {0,6,1},
                    {1,6,4,3},
                };
                // argh, requires panning the whole picture around randomly a bit in order for it to come out symmetric...
                VecMath.mpv(verts, verts, new double[]{.1,.1,0});
                mesh = new Mesh(verts, faces);
                mesh.findAndApplyOptimalVertexHeights(OPTIMIZE_LENGTHS_INFINITY_NORM);
                // XXX argh, still requires use to set OPTIMIZE_LENGTHS_INFINITY_NORM and turn on and off Optimize, otherwise the dual picture is tiny... why??

            } // doCannedThingSweepKiller2


            // VecMath.synopsis might be brain damaged, not sure... try simpler way
            static double simpleSynopsis(int n, double v[])
            {
                FORI (i, n)
                    if (v[i] <= 0) // non-strict so we do it this way if on the boundary of the positive orthant
                    {
                        //
                        // Outside the positive orthant,
                        // return minus the euclidean distance
                        // to the positive orthant.
                        //
                        double sum = 0.;
                        for (; i < n; i++)
                            if (v[i] < 0.)
                                sum += v[i]*v[i];
                        return -Math.sqrt(sum);
                    }
                //
                // Inside the positive orthant, return the min.
                //
                return VecMath.min(n, v);
            } // simpleSynopsis

            // XXX should put this into VecMath, I think?
            // For two vars, the graph should look like this
            // (the diagonals are actually quarter-circles):
            //   | | | | | |               //
            //   | | | | | +               //
            //   | | | | |  \              //
            //   | | | | |   \             //
            //   | | | | |    \            //
            //   | | | | +     \           //
            //   | | | |  \     \          //
            //   | | | |   \     +-        //
            //   | | | |    \              //
            //   | | | +     +-----        //
            //   | | |  \                  //
            //   | | |   +---------        //
            //   | | |                     //
            //   + + +-------------        //
            //    \ \                      //
            //     \ +-------------        //
            //      \                      //
            //       +-------------        //
            // It's differentiable everywhere except at 0.
            // (non-differentiability at 0 is unavoidable
            // if we want scale-invariance).
            // XXX DOESN'T WORK-- see bottom of function body
            static double synopsis(int n, double v[])
            {
                double min = Double.POSITIVE_INFINITY;
                FORI (i, n)
                {
                    double x = v[i];
                    if (x <= 0) // non-strict so we do it this way if on the boundary of the positive orthant
                    {
                        //
                        // Outside the positive orthant,
                        // return minus the euclidean distance
                        // to the positive orthant.
                        //
                        double sum2 = 0.;
                        for (; i < n; i++)
                            if (v[i] < 0.)
                                sum2 += v[i]*v[i];
                        return -Math.sqrt(sum2);
                    }
                    min = MIN(min, x);
                }

                // All are positive.
                // The ones that participate are those that are < twice the smallest.
                // Call those x0,x1,...
                // We want to solve:
                //     (2*q-x0)^2 + (2*q-x1)^2 + (2*q-x2)^2 + ... = q^2
                //     n*4*q^2 - 4*q*(x0 + x1 + ...) + (x0^2 + x1^2 + ...) = q^2
                //     (4*n-1)*q^2 - 4*q*(x0 + x1 + ...) + (x0^2 + x1^2 + ...) = 0
                // Using the quadratic formula with:
                //       a = 4*n-1
                //       b = -4*(x0+x1+...)
                //       c = x0^2 + x1^2 + ...
                // The solution is
                // (we want the bigger of the two possibilities, so + rather than -):
                //       q = (-b + sqrt(b^2 - 4*a*c) / (2*a)
                //         = (4*(x0+...) + sqrt((4*(x0+...))^2 - 4*(4*n-1)*(x0^2+...)) / (2*(4*n-1))
                //         = (2*(x0+...) + sqrt((2*(x0+...))^2 - (4*n-1)*(x0^2+...)) / (4*n-1)
                // check, if just one var (n=1), q should be x0:
                //       q = (2*x0 + sqrt(4*x0^2 - 3*x0^2)) / 3
                //         = (2*x0 + x0) / 3
                //         = x0  check.
                int nParticipants = 0;
                double sum1 = 0.;
                double sum2 = 0.;
                FORI (i, n)
                {
                    double x = v[i];
                    if (x < 2*min)
                    {
                        PRINT(x);
                        nParticipants++;
                        sum1 += x;
                        sum2 += x*x;
                    }
                }
                if (nParticipants == 1)
                    return min;
                double discr = SQR(2*sum1) - (4*nParticipants-1)*sum2;
                PRINTVEC((double[])Arrays.subarray(v,0,n));
                PRINT(min);
                PRINT(sum1);
                PRINT(sum2);
                PRINT(discr);
                PRINT(nParticipants);
                //assert(discr >= 0.); // should be safely so (should be at least sum2)... can we reformulate to make that obvious?  no wait, that's not even right :-(  may need to go back to the drawing board on this whole thing
                //assert(GEQ(discr, 0., 5.549966375204551E-4));
                //assert(GEQ(discr, 0., 5.549966375204551E-4));
                //assert(GEQ(discr, 0., 0.004241588576413768));
                assert(GEQ(discr, 0., 0.007445722649008779));
                if (discr < 0.) discr = 0.; // FUDGE

                double q = (2*sum1 + Math.sqrt(discr)) / (4*nParticipants-1);
                return q;
            } // synopsis









            // General optimization:
            // maximize the minimum over:
            //     - length of each primal edge
            //     - length of each finite dual edge
            //     - 1-length of each primal edge
            //     - 1-length of each finite dual edge
            //     - a set of specified goodness-of-balances
            //
            // can constrain three vertex heights to be zero, I think, and one vertex position
            // (and maybe one coord of a second vertex's position)
            //
            private static class GeneralOptimizationStuff
            {
                private static void getMeshVertCoords(Mesh mesh, double coords[/*nVerts*/][/*3*/])
                {
                    FORI (iVert, coords.length)
                    {
                        Mesh.Vertex v = mesh.getVert(iVert);
                        coords[iVert][0] = v.x;
                        coords[iVert][1] = v.y;
                        coords[iVert][2] = v.h;
                    }
                }

                private static void vertsToDualMomentsAndAreas(double primalCoords[/*nVerts*/][/*3*/],
                                                               int tris[/*nDualVerts*/][/*3*/],
                                                               double dualMomentsAndAreas[/*nDualVerts*/][/*3*/])
                {
                    FORI (iDualVert, dualMomentsAndAreas.length)
                    {
                        int tri[] = tris[iDualVert];
                        double A[] = primalCoords[tri[0]];
                        double B[] = primalCoords[tri[1]];
                        double C[] = primalCoords[tri[2]];
                        SolveForDualMomentAndArea(A[0],A[1],A[2],
                                                  B[0],B[1],B[2],
                                                  C[0],C[1],C[2],
                                                  dualMomentsAndAreas[iDualVert]);
                    }
                }

                private static void momentsAndAreasToCoords(double momentsAndAreas[][/*3*/],
                                                            double coordss[][/*2*/])
                {
                    FORI(i, momentsAndAreas.length)
                    {
                        double momentAndArea[/*3*/] = momentsAndAreas[i];
                        double coords[/*2*/] = coordss[i];
                        double A = momentAndArea[2];
                        if (A == 0.)
                        {
                            coords[0] = 0.;
                            coords[1] = 0.;
                        }
                        else
                        {
                            coords[0] = momentAndArea[0] / A;
                            coords[1] = momentAndArea[1] / A;
                        }
                    }
                }

                // params are:
                //     dist from x0,y0 to x1,y1
                //     x2
                //     y2
                //     x3,y3,h3
                //     x4,y4,h4
                //     ...
                // fixed:
                //     x0
                //     y0
                //     h0
                //     direction from x0,y0 to x1,y1
                //     h1
                //     h2
                private static double[] vertsToParams(double verts[][/*3*/])
                {
                    double params[] = new double[verts.length*3 - 6];
                    // verts to params...
                    int iParam = 0;
                    double x0, y0, h0, x1, y1, h1, h2; // XXX could store these so paramsToVerts doesn't have to keep looking them up
                    FORI (iVert, verts.length)
                    {
                        double v[] = verts[iVert];
                        if (iVert == 0)
                        {
                            x0 = v[0];
                            y0 = v[1];
                            h0 = v[2];
                        }
                        else if (iVert == 1)
                        {
                            params[iParam++] = MyMath.hypot(v[0]-verts[0][0], v[1]-verts[0][1]);
                            x1 = v[0];
                            y1 = v[1];
                            h1 = v[2];
                        }
                        else if (iVert == 2)
                        {
                            params[iParam++] = v[0];
                            params[iParam++] = v[1];
                            h2 = v[2];
                        }
                        else
                        {
                            params[iParam++] = v[0];
                            params[iParam++] = v[1];
                            params[iParam++] = v[2];
                        }
                    }
                    PRINT(params.length);
                    PRINT(iParam);
                    assert(iParam == params.length);
                    return params;
                }


                // needs to be fast-- no memory allocations
                private static void paramsToVerts(Mesh primal, // for verts that are fixed
                                                  double params[], double verts[][])
                {
                    PRINT(verts.length);
                    PRINT(params.length);
                    assert(params.length == verts.length*3 - 6);
                    int iParam = 0;

                    Mesh.Vertex v0 = primal.getVert(0);
                    Mesh.Vertex v1 = primal.getVert(1);
                    Mesh.Vertex v2 = primal.getVert(2);

                    verts[0][0] = v0.x;
                    verts[0][1] = v0.y;
                    verts[0][2] = v0.h;
                    double origDist01 = MyMath.hypot(v1.x-v0.x, v1.y-v0.y);
                    verts[1][0] = v0.x + (v1.x-v0.x)/origDist01 * params[iParam];
                    verts[1][1] = v0.y + (v1.y-v0.y)/origDist01 * params[iParam];
                    iParam++;
                    verts[1][2] = v1.h;

                    verts[2][0] = params[iParam++];
                    verts[2][1] = params[iParam++];
                    verts[2][2] = v2.h;

                    for (int iVert = 3; iVert < verts.length; ++iVert)
                    {
                        verts[iVert][0] = params[iParam++];
                        verts[iVert][1] = params[iParam++];
                        verts[iVert][2] = params[iParam++];
                    }
                    assert(iParam == params.length);
                } // paramsToVerts

                private static String[] getParamNames(int nVerts)
                {
                    int iParam = 0;
                    String paramNames[] = new String[nVerts * 3 - 6];
                    paramNames[iParam++] = "dist01";
                    paramNames[iParam++] = "x2";
                    paramNames[iParam++] = "y2";
                    for (int iVert = 3; iVert < nVerts; ++iVert)
                    {
                        paramNames[iParam++] = "x"+iVert;
                        paramNames[iParam++] = "y"+iVert;
                        paramNames[iParam++] = "h"+iVert;
                    }
                    assert(iParam == paramNames.length);
                    return paramNames;
                } // getParamNames




                // Returns the optimization path, better and better verts,
                // and the associated goodnesses.
                public static Object[/*2*/] optimizeVerts(
                    final Mesh primal,
                    final int fromsAndTosTris[][/*2*/][][/*3*/],
                    final int toLeftOfEdgeEndIndices[][/*2*/],
                    final boolean mustBeFarthestExit[],
                    final boolean considerEdgeLengths, // XXX we don't handle this correctly-- we hard-code ignoring the 1-edgelength thing. need to figure out why, I thought that was necessary to prevent edge lengths from growing without bound???
                    final int nPasses,
                    final int maxCallsPerPass,
                    final double initialDelta)
                {
                    assert(fromsAndTosTris.length        == toLeftOfEdgeEndIndices.length);
                    assert(mustBeFarthestExit.length == toLeftOfEdgeEndIndices.length);

                    final Mesh dual = makeDualMesh(primal,
                                                   false,  // includeNonArity3
                                                   false); // includeInsideOut
                    int nVerts = primal.verts.size();
                    int nDualVerts = dual.verts.size();
                    int nEdges = primal.edges.size();
                    assert(nEdges == dual.edges.size());

                    final int tris[][/*3*/] = new int[nDualVerts][3];
                    {
                        FORI (iEdge, nEdges)
                        {
                            Mesh.Edge dualEdge = dual.getEdge(iEdge);
                            Mesh.Vertex dualVert = dualEdge.finalVertex();
                            if (dualVert != null)
                            {
                                int iDualVert = dualVert.myIndex();

                                // Only do it if initial vertex is smallest indexed on the triangle.
                                // This avoids calculating the same vertex 3 times,
                                // and it also guarantees that the triangle will be in canonical order
                                // (smallest index first).
                                Mesh.Edge primalEdge = primal.getEdge(iEdge);
                                int i = primalEdge.initialVertex().myIndex();
                                int j = primalEdge.next().initialVertex().myIndex();
                                int k = primalEdge.prev().initialVertex().myIndex();
                                if (i < j && i < k)
                                {
                                    int tri[] = tris[iDualVert];
                                    assert(tri[0] == 0 && tri[1] == 0 && tri[2] == 0);
                                    tri[0] = i;
                                    tri[1] = j;
                                    tri[2] = k;
                                }
                            }
                        }
                        FORI (iTri, tris.length)
                            assert(tris[iTri][1] != 0 && tris[iTri][2] != 0);
                    }

                    java.util.Hashtable triToIndex = new java.util.Hashtable();
                    FORI (iTri, tris.length)
                    {
                        int tri[] = tris[iTri];
                        // really only first two are necessary, but third is sanity check
                        triToIndex.put(""+tri[0]+" "+tri[1]+" "+tri[2], new Integer(iTri));
                    }

                    final int fromsAndTosInds[][/*2*/][] = new int[fromsAndTosTris.length][2][];
                    FORI (iFromAndTo, fromsAndTosTris.length)
                        FORI (iFromOrTo, 2)
                        {
                            int fromOrToTris[][] = fromsAndTosTris[iFromAndTo][iFromOrTo];
                            int fromOrToInds[] = new int[fromOrToTris.length];
                            FORI(iTri, fromOrToTris.length)
                            {
                                int tri[] = fromOrToTris[iTri];
                                Integer ind = (Integer)triToIndex.get(""+tri[0]+" "+tri[1]+" "+tri[2]);
                                assert(ind != null);
                                fromOrToInds[iTri] = ind.intValue();
                            }
                            fromsAndTosInds[iFromAndTo][iFromOrTo] = fromOrToInds;
                        }


                    final double scratchVerts[][] = new double[nVerts][3];
                    final double scratchDualMomentsAndAreas[][] = new double[nDualVerts][3]; // x*A,y*A,A
                    final double scratchDualVerts[][] = new double[nDualVerts][2]; // x,y

                    getMeshVertCoords(primal, scratchVerts);
                    vertsToDualMomentsAndAreas(scratchVerts, tris, scratchDualMomentsAndAreas);


                    double initialGuessParams[] = vertsToParams(scratchVerts);
                    int nParams = initialGuessParams.length;

                    {
                        // Sanity check-- convert back to verts, should get original verts again
                        double shouldBeScratchVerts[][] = new double[nVerts][3];
                        paramsToVerts(primal, initialGuessParams, shouldBeScratchVerts);
                        PRINTMAT(scratchVerts);
                        PRINTVEC(initialGuessParams);
                        PRINTMAT(shouldBeScratchVerts);
                        PRINTMAT(VecMath.mmm(shouldBeScratchVerts, scratchVerts));
                        assert(VecMath.equals(shouldBeScratchVerts, scratchVerts, 1e-6));
                    }

                    final double saveBestParams[] = new double[nParams];
                    final double saveBestValue[] = {Double.POSITIVE_INFINITY};
                    final ArrayList optimizationPathList = new ArrayList();
                    final DoubleArrayList optimizationPathGoodnessesList = new DoubleArrayList();
                    final int iPassFinal[] = new int[1]; // just so fun can see iPass

                    Minimizer.VectorFunction fun = new Minimizer.VectorFunction() {
                        // VectorFunction interface
                        public double apply(double params[])
                        {
                            System.out.println("    in apply()");
                            System.out.println("        iPass="+iPassFinal[0]+"/"+nPasses);
                            paramsToVerts(primal, params, scratchVerts);
                            vertsToDualMomentsAndAreas(scratchVerts, tris, scratchDualMomentsAndAreas);
                            momentsAndAreasToCoords(scratchDualMomentsAndAreas, scratchDualVerts);


                            int nGoodness = 2*primal.edges.size()
                                          + 2*primal.edges.size() // at most this many dual edge constraints
                                          + fromsAndTosTris.length;
                            double goodnessVector[] = new double[nGoodness];
                            int iGoodness = 0;
                            int nEdges = primal.edges.size();

                            System.out.println("    -----------------------");

                            if (considerEdgeLengths) // considering edge lengths seems to prevent some nice optimization paths.  hmm.  (it might be just the 1-edgelength component though)
                            {
                                // Edge lengths...
                                FORI (iEdge, nEdges)
                                {
                                    Mesh.Edge edge = primal.getEdge(iEdge);
                                    int i0 = edge.initialVertex().myIndex();
                                    int i1 = edge.finalVertex().myIndex();
                                    if (i0 < i1) // canonical order only
                                    {
                                        double edgeLength = MyMath.hypot(scratchVerts[i1][0]-scratchVerts[i0][0],
                                                                         scratchVerts[i1][1]-scratchVerts[i0][1]);
                                        System.out.println("        primal edge "+i0+"->"+i1+": "+edgeLength+"");
                                        goodnessVector[iGoodness++] = edgeLength;
                                        //goodnessVector[iGoodness++] = 1. - edgeLength; // XXX needs to be a legit parameter
                                    }
                                }
                            }

                            if (true)
                            {
                                // Dual edge lengths...
                                FORI (iEdge, nEdges)
                                {
                                    Mesh.Edge dualEdge = dual.getEdge(iEdge);
                                    Mesh.Vertex dv0 = dualEdge.initialVertex();
                                    Mesh.Vertex dv1 = dualEdge.finalVertex();
                                    if (dv0 == null || dv1 == null)
                                        continue; // not a finite edge
                                    int dv0i = dv0.myIndex();
                                    int dv1i = dv1.myIndex();
                                    if (dv1i < dv0i)
                                        continue; // not in canonical order
                                    double dualEdgeVecX = scratchDualVerts[dv1i][0] - scratchDualVerts[dv0i][0];
                                    double dualEdgeVecY = scratchDualVerts[dv1i][1] - scratchDualVerts[dv0i][1];


                                    Mesh.Edge primalEdge = primal.getEdge(iEdge);
                                    int pv0i = primalEdge.initialVertex().myIndex();
                                    int pv1i = primalEdge.finalVertex().myIndex();
                                    double edgeDirX = scratchVerts[pv1i][0] - scratchVerts[pv0i][0];
                                    double edgeDirY = scratchVerts[pv1i][1] - scratchVerts[pv0i][1];
                                    double edgeLength = MyMath.hypot(edgeDirX, edgeDirY);
                                    assert(edgeLength != 0.);
                                    double invEdgeLength = 1./edgeLength;
                                    edgeDirX *= invEdgeLength;
                                    edgeDirY *= invEdgeLength;
                                    double dualEdgeDirX = -edgeDirY;
                                    double dualEdgeDirY =  edgeDirX;

                                    double dualEdgeLength = dualEdgeVecX*dualEdgeDirX
                                                          + dualEdgeVecY*dualEdgeDirY;

                                    System.out.println("        dual edge "+pv0i+"->"+pv1i+": "+dualEdgeLength+"");
                                    double dualEdgeMinLength = .05; // setting to > 0 keeps dual edge length constraints from jamming into corner with other constraints
                                    goodnessVector[iGoodness++] = dualEdgeLength - dualEdgeMinLength;
                                    goodnessVector[iGoodness++] = 1. - dualEdgeLength;
                                }
                            }

                            if (true)
                            {
                                // General froms and tos...

                                FORI (iFromAndTo, fromsAndTosTris.length)
                                {
                                    int fromAndTo[/*2*/][] = fromsAndTosInds[iFromAndTo];

                                    double v0[] = scratchVerts[toLeftOfEdgeEndIndices[iFromAndTo][0]];
                                    double v1[] = scratchVerts[toLeftOfEdgeEndIndices[iFromAndTo][1]];
                                    double edgeDirX = v1[0] - v0[0];
                                    double edgeDirY = v1[1] - v0[1];
                                    double edgeLength = MyMath.hypot(edgeDirX, edgeDirY);
                                    assert(edgeLength != 0.);
                                    double invEdgeLength = 1./edgeLength;
                                    edgeDirX *= invEdgeLength;
                                    edgeDirY *= invEdgeLength;
                                    double dualEdgeDirX = -edgeDirY;
                                    double dualEdgeDirY =  edgeDirX;


                                    double fromCenterX = 0.;
                                    double fromCenterY = 0.;
                                    double toCenterX = 0.;
                                    double toCenterY = 0.;
                                    FORI (iFromOrTo, 2)
                                    {
                                        int fromOrTo[] = fromAndTo[iFromOrTo];
                                        double totalMomentX = 0.;
                                        double totalMomentY = 0.;
                                        double totalArea = 0.;
                                        FORI (i, fromOrTo.length)
                                        {
                                            double dualVertMomentAndArea[/*3*/] = scratchDualMomentsAndAreas[fromOrTo[i]];
                                            totalMomentX += dualVertMomentAndArea[0];
                                            totalMomentY += dualVertMomentAndArea[1];
                                            totalArea += dualVertMomentAndArea[2];
                                        }
                                        if (iFromOrTo == 0)
                                        {
                                            fromCenterX = totalMomentX / totalArea;
                                            fromCenterY = totalMomentY / totalArea;
                                        }
                                        else
                                        {
                                            toCenterX = totalMomentX / totalArea;
                                            toCenterY = totalMomentY / totalArea;
                                        }
                                    }
                                    double goodness = (toCenterX-fromCenterX)*dualEdgeDirX
                                                    + (toCenterY-fromCenterY)*dualEdgeDirY;
                                    System.out.println("        another goodness: "+goodness);
                                    goodnessVector[iGoodness++] = goodness;

                                    if (true)
                                    {
                                        if (mustBeFarthestExit[iFromAndTo])
                                        {
                                            int from[] = fromAndTo[0];
                                            assert(from.length == 1);
                                            int desiredFarthestDualVertIndex = from[0];

                                            double thisDist2fromCenter = -1.;
                                            double largestOtherDist2fromCenter = -1.;
                                            int to[] = fromAndTo[1];
                                            FORI (iTo, to.length)
                                            {
                                                int iDualVert = to[iTo];
                                                double dualVert[] = scratchDualVerts[iDualVert];
                                                double dist2fromCenter = SQR(dualVert[0]-toCenterX)
                                                                       + SQR(dualVert[1]-toCenterY);
                                                if (iDualVert == desiredFarthestDualVertIndex)
                                                    thisDist2fromCenter = dist2fromCenter;
                                                else
                                                    largestOtherDist2fromCenter = MAX(largestOtherDist2fromCenter, dist2fromCenter);
                                            }
                                            assert(thisDist2fromCenter >= 0.);
                                            assert(largestOtherDist2fromCenter >= 0.); // i.e. lagoon size must be >= 2
                                            goodness = Math.sqrt(thisDist2fromCenter) - Math.sqrt(largestOtherDist2fromCenter);
                                            System.out.println("        yet another goodness: "+goodness);
                                            goodnessVector[iGoodness++] = goodness;
                                        }
                                    }
                                }
                            }


                            PRINT(nGoodness);
                            PRINT(iGoodness);
                            //double synopsis = VecMath.synopsis(iGoodness, goodnessVector);
                            double synopsis = simpleSynopsis(iGoodness, goodnessVector);
                            //double synopsis = synopsis(iGoodness, goodnessVector);
                            System.out.println("        synopsis = "+synopsis);
                            double answer = -synopsis; // trying to maximize synopsis, trying to minimize answer

                            if (answer < saveBestValue[0])
                            {
                                System.out.println("            improvement!");
                                saveBestValue[0] = answer;
                                optimizationPathList.add(Arrays.copy(scratchVerts, 2));
                                optimizationPathGoodnessesList.add(synopsis);
                            }
                            else
                            {
                                System.out.println("            (not an improvement, best is still "+-saveBestValue[0]+")");
                            }
                            System.out.println("    -----------------------");
                            System.out.println("    out apply()");
                            return answer;
                        }
                    }; // fun

                    PRINT(fun.apply(initialGuessParams));
                    String paramNames[] = getParamNames(primal.verts.size());
                    FORI (iPass, nPasses)
                    {
                        iPassFinal[0] = iPass;

                        System.out.println("-------------------------------------");
                        PRINT(iPass);

                        double answerParams[] = Minimizer.minimize(fun,
                                                                   initialGuessParams,
                                                                   initialDelta,
                                                                   maxCallsPerPass,
                                                                   paramNames);
                        if (true)
                        {
                            // See if we can get better by randomly jumping out of
                            // where we've wedged into
                            double bestParams[] = vertsToParams((double[][])optimizationPathList.get(optimizationPathList.size()-1));
                            double bestGoodness = optimizationPathGoodnessesList.get(optimizationPathList.size()-1);
                            double params0[] = VecMath.copyvec(bestParams);
                            double scratchParams[] = new double[bestParams.length];
                            FORI (iJump, 100)
                            {
                                // pick a random (infinity norm) distance between 1e-17 and 1
                                double a = Math.log(1e-17);
                                double b = Math.log(1);
                                double distance = Math.random();
                                distance = LERP(a,b,distance);
                                distance = Math.exp(distance);
                                PRINT(distance);
                                FORI (iParam, scratchParams.length)
                                {
                                    scratchParams[iParam] = params0[iParam] + (Math.random()*2-1)*distance;
                                }
                                double thisGoodness = -fun.apply(scratchParams);
                                // automatically appended to optimizationPathList if it's better
                                if (thisGoodness > bestGoodness)
                                {
                                    bestGoodness = thisGoodness;
                                    VecMath.copyvec(bestParams, scratchParams);
                                    System.out.println("    BETTER!");
                                }
                                else
                                {
                                    System.out.println("    not better");
                                }
                            }
                        }

                        // we don't really use answerParams
                        initialGuessParams = vertsToParams((double[][])optimizationPathList.get(optimizationPathList.size()-1));

                        PRINT(optimizationPathList.size());
                        //PRINTARRAY(optimizationPathGoodnessesList);
                        PRINT(iPass);
                        System.out.println("-------------------------------------");
                    }
                    double optimizationPath[][][] = new double[optimizationPathList.size()][][];
                    optimizationPathList.toArray(optimizationPath);
                    double optimizationPathGoodnesses[] = new double[optimizationPathGoodnessesList.size()];
                    optimizationPathGoodnessesList.toArray(optimizationPathGoodnesses);
                    PRINT(optimizationPath.length);
                    System.out.println("    out optimizeVerts");
                    return new Object[] {optimizationPath, optimizationPathGoodnesses};
                } // GeneralOptimizationStuff.optimizeVerts
            } // class GeneralOptimizationStuff



            private static class Netless8OptimizationStuff
            {
                // Returns the optimization path, better and better verts
                public static double[][][] optimizeNetless8Verts(
                    double initialGuessVerts[][])
                {
                    System.out.println("    in optimizeNetless8Verts");

                    double initialGuessParams[] = vertsToParams(initialGuessVerts);
                    PRINTARRAY(initialGuessVerts);
                    PRINTVEC(initialGuessVerts[4]);
                    PRINTARRAY(initialGuessParams);
                    PRINTARRAY(paramsToVerts(initialGuessParams));
                    PRINTARRAY(VecMath.mmm(paramsToVerts(initialGuessParams),initialGuessVerts));

                    final String paramNames[] = {
                        "y1",
                        "h1",
                        "x2",
                        "y2",
                        "x4",
                        "y4",
                    };

                    final double saveBestParams[] = new double[5];
                    final double saveBestValue[] = {Double.POSITIVE_INFINITY};
                    final ArrayList optimizationPathList = new ArrayList();

                    Minimizer.VectorFunction fun = new Minimizer.VectorFunction() {
                        // VectorFunction interface
                        public double apply(double params[])
                        {
                            double verts[][] = paramsToVerts(params);
                            double leftDualVerts[][] = vertsToDualVertsInNetless8(verts);
                            double dualEdgeLengths[] = vertsAndDualVertsToDualEdgeLengths(verts, leftDualVerts);

                            double dualEdgeLengthExponent = 2.;
                            double triAreaExponent = 1.;
                            double angleExponent = 2.;


                            double answer = 0.;
                            FORI (iDualEdge, dualEdgeLengths.length)
                            {
                                if (dualEdgeLengths[iDualEdge] <= 0.)
                                    return Double.POSITIVE_INFINITY;
                                answer += 1./Math.pow(dualEdgeLengths[iDualEdge], dualEdgeLengthExponent);
                            }

                            FORI (iTri, tris.length)
                            {
                                double area = twiceTriangleArea(
                                              verts[tris[iTri][0]],
                                              verts[tris[iTri][1]],
                                              verts[tris[iTri][2]]);
                                if (area <= 0.)
                                    return Double.POSITIVE_INFINITY;
                                answer += 1./Math.pow(area, triAreaExponent);
                            }

                            // Also add in a penalty for being too close
                            // to violating the alpha-beta thing
                            if (true)
                            {
                                int dualVertsBeingAveraged[] = {0, 2, 3};
                                double totalArea = 0.;
                                double center[] = {0.,0.};
                                FORI (i, 3)
                                {
                                    double area = twiceTriangleArea(
                                        verts[tris[dualVertsBeingAveraged[i]][0]],
                                        verts[tris[dualVertsBeingAveraged[i]][1]],
                                        verts[tris[dualVertsBeingAveraged[i]][2]]);
                                    PRINT(dualVertsBeingAveraged[i]);
                                    PRINT(area);
                                    if (area <= 0.)
                                        return Double.POSITIVE_INFINITY;
                                    totalArea += area;
                                    VecMath.vpsxv(center,
                                                  center, area, leftDualVerts[dualVertsBeingAveraged[i]]);
                                }
                                VecMath.vxs(center, center, 1./totalArea);

                                double height = VecMath.dot(
                                    2,
                                    VecMath.normalize(VecMath.vmv(leftDualVerts[4],
                                                                  leftDualVerts[1])),
                                    VecMath.vmv(center, leftDualVerts[1]));
                                if (height <= 0.)
                                    return Double.POSITIVE_INFINITY;
                                answer += 1./Math.pow(height, angleExponent);
                            }

                            if (answer < saveBestValue[0])
                            {
                                saveBestValue[0] = answer;
                                optimizationPathList.add(paramsToVerts(params)); // XXX TODO: um, why aren't we just adding verts?
                            }
                            return answer;
                        }
                    }; // fun

                    double initialDelta = .0001;
                    //int maxCalls = 10*1000;
                    int maxCalls = 1*1000;
                    //int maxCalls = 500;
                    //int maxCalls = 100;
                    //int maxCalls = 53;
                    PRINT(fun.apply(initialGuessParams));
                    double answerParams[] = Minimizer.minimize(fun,
                                                               initialGuessParams,
                                                               initialDelta,
                                                               maxCalls,
                                                               paramNames);
                    // we don't really use that
                    double optimizationPath[][][] = new double[optimizationPathList.size()][][];
                    optimizationPathList.toArray(optimizationPath);
                    System.out.println("    out optimizeNetless8Verts");
                    return optimizationPath;
                } // optimizeNetless8Verts

                private static double[] vertsToParams(double verts[][])
                {
                    double params[] = new double[6];
                    params[0] = verts[1][1];
                    params[1] = verts[1][2];
                    params[2] = verts[2][0];
                    params[3] = verts[2][1];
                    params[4] = verts[4][0];
                    params[5] = verts[4][1];
                    return params;
                } // vertsToParams

                private static double[][] paramsToVerts(double params[])
                {
                    //System.out.println("            in paramsToVerts");
                    //PRINTVEC(params);
                    double eps = 1e-6;
                    double verts[][] = new double[6][3];

                    //     3   2
                    //       1
                    //      5 4
                    //       0
                    verts[0][0] = 0;
                    verts[0][1] = 0;
                    verts[0][2] = 0;

                    verts[1][0] = 0;
                    verts[1][1] = params[0];
                    verts[1][2] = params[1];

                    verts[2][0] = params[2];
                    verts[2][1] = params[3];
                    verts[2][2] = 0;

                    verts[3][0] = -verts[2][0];
                    verts[3][1] = verts[2][1];
                    verts[3][2] = 0;

                    verts[4][0] = params[4];
                    verts[4][1] = params[5];
                    // verts[4][2] filled in below

                    verts[5][0] = -verts[4][0];
                    verts[5][1] = verts[4][1];
                    // verts[5][2] = verts[4][2] whenever we set it

                    verts[5][2] = verts[4][2] = 0;
                    double xradius0 = vertsToDualVertsInNetless8(verts)[0][0];
                    verts[5][2] = verts[4][2] = 1;
                    double xradius1 = vertsToDualVertsInNetless8(verts)[0][0];
                    verts[5][2] = verts[4][2] = (1.-xradius0)/(xradius1-xradius0);
                    assert(Math.abs(vertsToDualVertsInNetless8(verts)[0][0]-1.) < eps);

                    //System.out.println("            out paramsToVerts");
                    return verts;
                } // paramsToVerts

                private static int tris[][] = {
                    {0,2,4}, // 0: right
                    {4,2,1}, // 1: the vertex with the angle we care about
                    {5,4,1}, // 2: top of seg we care about
                    {0,4,5}, // 3: bottom of seg we care about
                    {1,2,3}, // 4: top
                    {0,5,3}, // 5: left
                    {5,1,3}, // 6: top left
                };
                private static double[][] vertsToDualVertsInNetless8(double verts[][])
                {
                    // Could optimize the hell out of this,
                    // by caching the linear transform
                    double leftDualVerts[][] = new double[tris.length][3];
                    FORI (iDualVert, leftDualVerts.length)
                    {
                        int tri[] = tris[iDualVert];
                        double x0 = verts[tri[0]][0];
                        double y0 = verts[tri[0]][1];
                        double h0 = verts[tri[0]][2];
                        double x1 = verts[tri[1]][0];
                        double y1 = verts[tri[1]][1];
                        double h1 = verts[tri[1]][2];
                        double x2 = verts[tri[2]][0];
                        double y2 = verts[tri[2]][1];
                        double h2 = verts[tri[2]][2];
                        SolveForDualPoint(x0,y0,h0,
                                          x1,y1,h1,
                                          x2,y2,h2,
                                          leftDualVerts[iDualVert]);
                    }
                    return leftDualVerts;
                } // vertsToDualVertsInNetless8


                private static int edge2verts[/*9*/][/*2*/] = null; // from, to
                private static int edge2tris[/*9*/][/*2*/] = null; // left, right

                private static double[] vertsAndDualVertsToDualEdgeLengths(double verts[][], double leftDualVerts[][])
                {
                    if (edge2verts == null)
                    {
                        edge2verts = new int[9][2]; // from, to
                        edge2tris = new int[9][2]; // left, right
                        {
                            int nEdges = 0;
                            FORI (iTri, tris.length)
                                FORI (jTri, iTri)
                                {
                                    // If they have two things in common...
                                    FORI (ii, 3)
                                        FORI (jj, 3)
                                            if (tris[iTri][ii] == tris[jTri][jj]
                                             && tris[iTri][(ii+1)%3] == tris[jTri][MOD(jj-1,3)])
                                            {
                                                edge2verts[nEdges][0] = tris[iTri][ii]; // from
                                                edge2verts[nEdges][1] = tris[iTri][(ii+1)%3]; // to
                                                edge2tris[nEdges][0] = iTri; // left
                                                edge2tris[nEdges][1] = jTri; // right
                                                nEdges++;
                                            }
                                }
                            PRINT(nEdges);
                            assert(nEdges == edge2verts.length);
                            assert(nEdges == edge2tris.length);
                            PRINTARRAY(edge2verts);
                            PRINTARRAY(edge2tris);
                        }
                    }

                    double dualEdgeLengths[] = new double[9];
                    FORI (iEdge, 9)
                    {
                        double fromVert[] = verts[edge2verts[iEdge][0]];
                        double toVert[] = verts[edge2verts[iEdge][1]];
                        double leftDualVert[] = leftDualVerts[edge2tris[iEdge][0]];
                        double rightDualVert[] = leftDualVerts[edge2tris[iEdge][1]];
                        assert(fromVert != toVert);
                        assert(leftDualVert != rightDualVert);
                        dualEdgeLengths[iEdge] = VecMath.dist(2,
                                                              leftDualVert,
                                                              rightDualVert);
                        // Test whether it's negative.
                        if (VecMath.vxv2(VecMath.vmv(rightDualVert,leftDualVert),
                                         VecMath.vmv(toVert,fromVert)) < 0.)
                            dualEdgeLengths[iEdge] *= -1;
                    }
                    return dualEdgeLengths;
                } // vertsToDualEdgeLengths

            } // class Netless8OptimizationStuff

            private void doCannedThingNetless8Optimized()
            {
                doCannedThingNetless8();

                double initialGuessVerts[][] = new double[6][3];
                {
                    double x0 = mesh.getVert(0).x;
                    double y0 = mesh.getVert(0).y;
                    double h0 = mesh.getVert(0).h;
                    FORI (iVert, initialGuessVerts.length)
                    {
                        initialGuessVerts[iVert][0] = mesh.getVert(iVert).x - x0;
                        initialGuessVerts[iVert][1] = mesh.getVert(iVert).y - y0;
                        initialGuessVerts[iVert][2] = mesh.getVert(iVert).h - h0;
                    }
                }
                PRINT("before scaling");
                PRINTARRAY(initialGuessVerts);
                PRINTVEC(initialGuessVerts[4]);

                if (false)
                {
                    // XXX TODO: why can't I put a fairly large number here?  not much of an optimization it seems :-(
                    initialGuessVerts[2][0] += .01; // WRENCH-- see what happens
                    initialGuessVerts[3][0] -= .02; // WRENCH-- see what happens
                }

                {
                    // scale so initial guess has radius 1
                    double xradius = Netless8OptimizationStuff.vertsToDualVertsInNetless8(initialGuessVerts)[0][0];
                    double scale = 1./xradius;
                    FORI (iVert, initialGuessVerts.length)
                    {
                        initialGuessVerts[iVert][0] *= scale;
                        initialGuessVerts[iVert][1] *= scale;
                        initialGuessVerts[iVert][2] *= (scale*scale);
                    }
                    assert(Math.abs(Netless8OptimizationStuff.vertsToDualVertsInNetless8(initialGuessVerts)[0][0] - 1.) < 1e-9);
                }
                PRINT("after scaling");
                PRINTARRAY(initialGuessVerts);
                PRINTVEC(initialGuessVerts[4]);

                PRINTVEC(Netless8OptimizationStuff.vertsToDualVertsInNetless8(initialGuessVerts));

                double initialGuessDualVerts[][] = Netless8OptimizationStuff.vertsToDualVertsInNetless8(initialGuessVerts);


                double optimizationPathVerts[][][] = Netless8OptimizationStuff.optimizeNetless8Verts(
                    initialGuessVerts);
                double verts[][] = optimizationPathVerts[optimizationPathVerts.length-1];
                FORI (iVert, 6)
                {
                    mesh.getVert(iVert).x = verts[iVert][0];
                    mesh.getVert(iVert).y = verts[iVert][1];
                    mesh.getVert(iVert).h = verts[iVert][2];
                }

                netless8OptimizationPath = optimizationPathVerts;
                netless8OptimizationIndex = optimizationPathVerts.length-1;
                PRINT(optimizationPathVerts.length);
            } // doCannedThingNetless8Optimized

            private static double[][] generateVertices(double vertGenerators[][],
                                                       double xforms[][][])
            {
                double eps = 1e-9;
                double verts[][] = vertGenerators; // make this an arraylist if we ever do a lot
                FORI (iVert, verts.length) // while verts is growing
                {
                    FORI (ixform, xforms.length)
                    {
                        double vert[] = VecMath.vxm(verts[iVert],
                                                    xforms[ixform]);
                        int jVert;
                        FOR (jVert, verts.length)
                            if (VecMath.equals(vert, verts[jVert], eps))
                                break;
                        if (jVert == verts.length)
                            verts = (double[][])Arrays.append(verts, vert);
                    }
                }
                return verts;
            } // generateVertices

            private void doCannedThingNetless8Symmetric()
            {
                double vertsGenerators[][] = new double[][] {
                    {0,-1},
                    //{0,1/5.}, // looks nice but doesn't work well
                    {0,3/8.},
                };
                double xforms[][][] = {
                    // left-right reflection
                    {
                        {-1,0},
                        {0,1},
                    },
                    // rotation by 120 degrees, row-oriented
                    {
                       { Math.cos(DTOR(120)), Math.sin(DTOR(120))},
                       {-Math.sin(DTOR(120)), Math.cos(DTOR(120))},
                    },
                };
                double verts[][] = generateVertices(vertsGenerators,
                                                    xforms);

                if (true)
                {
                    // hack to make the order the same as for netless8
                    double temp[] = verts[3];
                    verts[3] = verts[4];
                    verts[4] = verts[5];
                    verts[5] = temp;
                }

                if (false)
                {
                    // Hack to see what happens... maybe have key for this
                    FORI (iVert, verts.length)
                        verts[iVert][1] *= .1;
                }

                int faces[][] = {};
                mesh = new Mesh(verts, faces);
                delaunayize();
            } // doCannedThingNetless8Symmetric

            // Make the mesh into netless9
            private void doCannedThingNetless9()
            {
                if (true)
                {
                    // s = how much bigger each edge is from the previous
                    double s = 1.05;
                    //double s = 1.001;
                    double sliceAngle;
                    {
                        // In the initial 6 slice pie,
                        // the southwest triangle has sides a=1, b=s^5, c=s^6.
                        // what are its angles?
                        // http://www.teacherschoice.com.au/Maths_Library/Trigonometry/solve_trig_SSS.htm
                        double a = 1;
                        double b = s*s*s*s*s;
                        double c = s*s*s*s*s*s;
                        double C = triangleAngle(a, b, c);
                        // All right, the southwest angle at the center
                        // is C, a bit more than pi/3.
                        // Distribute the rest of the spokes evenly.
                        sliceAngle = (2*Math.PI-C) / 5;
                    }
                    PRINT(RTOD(sliceAngle));
                    int nVerts = 19;
                    //int nVerts = 40;
                    //int nVerts = 1000;
                    double verts[][] = new double[nVerts][3];
                    int nNeighbors[] = new int[nVerts]; // zeros
                    ArrayList/*<int[]>*/ facesList = new ArrayList();

                    // Seed with verts 0 and 1, and an edge between them.
                    verts[0][0] = 0;
                    verts[0][1] = 0;
                    verts[0][2] = 0;
                    // Had the seed on the -y axis, changing it to +x axis for the hell of it
                    verts[1][0] = 1;
                    verts[1][1] = 0;
                    verts[1][2] = 0;
                    nNeighbors[0] = 1;
                    nNeighbors[1] = 1;

                    PRINT(VecMath.dist(verts[1], verts[6]));
                    PRINT(Math.pow(s, 6));

                    int oldestPerimeterEdge[] = {0,1};

                    for (int i = 2; i < nVerts; ++i)
                    {
                        //PRINT(i);
                        int arity = nNeighbors[oldestPerimeterEdge[0]];
                        assert(arity < 6);
                        double angFrac = 1./(6-arity);
                        //PRINT(1./angFrac);
                        double largestEdge = VecMath.dist(verts[i-1], verts[oldestPerimeterEdge[0]]);
                        //PRINT(largestEdge);
                        //PRINT(Math.pow(s, facesList.size()));

                        double c = VecMath.dist(verts[oldestPerimeterEdge[0]],
                                                verts[oldestPerimeterEdge[1]]);
                        double a = largestEdge * Math.pow(s, 1./angFrac);
                        double b = a*s;
                        //PRINT(a);
                        //PRINT(b);
                        double target[] = completeTriangle(verts[oldestPerimeterEdge[1]],
                                                           verts[oldestPerimeterEdge[0]],
                                                           a, b);
                        double ang0 = Math.atan2(verts[i-1][1]-verts[oldestPerimeterEdge[0]][1],
                                                 verts[i-1][0]-verts[oldestPerimeterEdge[0]][0]);
                        double ang1 = Math.atan2(target[1]-verts[oldestPerimeterEdge[0]][1],
                                                 target[0]-verts[oldestPerimeterEdge[0]][0]);
                        //PRINT(RTOD(ang0));
                        //PRINT(RTOD(ang1));
                        //PRINT(angFrac);
                        while (ang1 < ang0) ang1 += 2*Math.PI;
                        double ang = LERP(ang0, ang1, angFrac);
                        double length = largestEdge * s;
                        verts[i][0] = verts[oldestPerimeterEdge[0]][0] + length*Math.cos(ang);
                        verts[i][1] = verts[oldestPerimeterEdge[0]][1] + length*Math.sin(ang);
                        facesList.add(new int[]{oldestPerimeterEdge[0], i-1, i});
                        nNeighbors[oldestPerimeterEdge[0]]++;
                        nNeighbors[i-1]++;
                        nNeighbors[i] = 2;
                        if (nNeighbors[oldestPerimeterEdge[0]] == 6)
                        {
                            //System.out.println("COMPLETING at "+i);
                            facesList.add(new int[]{oldestPerimeterEdge[1], oldestPerimeterEdge[0], i});
                            nNeighbors[oldestPerimeterEdge[1]]++;
                            nNeighbors[i]++;
                            oldestPerimeterEdge[0]++;
                            oldestPerimeterEdge[1]++;
                        }
                    }

                    {
                        int nPerimeterVerts = 0;
                        FORI (i, nVerts)
                            if (nNeighbors[i] < 6)
                                nPerimeterVerts++;
                        int perimeterVerts[] = new int[nPerimeterVerts];
                        nPerimeterVerts = 0;
                        FORI (i, nVerts)
                            if (nNeighbors[i] < 6)
                                perimeterVerts[perimeterVerts.length-1-nPerimeterVerts++] = i;
                        facesList.add(perimeterVerts);
                        PRINT(nPerimeterVerts);
                    }


                    int faces[][] = new int[facesList.size()][];
                    facesList.toArray(faces);
                    mesh = new Mesh(verts, faces);
                    //PRINTARRAY(nNeighbors);
                    //PRINTARRAY(verts);
                    //PRINTARRAY(faces);
                }
                FORIDOWN (iVert, mesh.verts.size())
                {
                    double scale = .2;
                    Mesh.Vertex vert = mesh.getVert(iVert);
                    vert.x *= scale;
                    vert.y *= scale;
                    vert.h *= scale*scale;
                }
            } // doCannedThingNetless9

            // Argh, short-lived brilliant idea
            // that's going nowhere, since a zig-zag
            // through the cornea is always possible.
            private void doCannedThingEyeball()
            {
                int n = 72;
                int nRows = 15;
                double r0 = .25;
                double aspect = 2;

                // empirically, fudges to make it kind of right for n=72, r0=.25, aspect=2
                double incr = .005;
                incr *= .25; // XXX argh! up and down arrows depend on current view scale! squared!

                double rowHeightFudges[] = {
                    -0*incr,
                               // +3
                     3*incr,          // -1
                               // +2         // -1
                     5*incr,          // -2
                               // +0         // -1
                     5*incr,          // -3
                               // -3         // -2
                     2*incr,          // -5
                               // -8         // -2.5
                    -6*incr,         // -7.5
                               // -15.5      // -4
                    -21.5*incr,       // -11.5
                               // -27        // -5.5
                    -48.5*incr,       // -17
                               // -44        // -8
                    -92.5*incr,       // -25
                               // -69        // -11
                    -161.5*incr,      // -36
                               // -105       // -16
                    -266.5*incr,      // -52
                               // -157       // -22
                    -423.5*incr,      // -74
                               // -231       // -31
                    -654.5*incr,      // -105
                               // -336       // -43
                    -990.5*incr,      // -148
                               // -484
                    -1474.5*incr,
                };  

                ArrayList vertsList = new ArrayList();
                ArrayList facesList = new ArrayList();

                vertsList.add(new double[]{0,0,0});
                FORI (iRow, nRows)
                {
                    double multiplier = 1 + aspect*2*Math.PI/n; // magic
                    double r = r0 * Math.pow(multiplier, iRow);
                    FORI (i, n)
                    {
                        double theta = 2*Math.PI*(i+iRow*.5)/n;
                        vertsList.add(new double[]{r*Math.cos(theta),
                                                   r*Math.sin(theta),
                                                   rowHeightFudges[iRow],
                                                   });
                        if (iRow == 0)
                            facesList.add(new int[]{1 + iRow*n + i,
                                                    1 + iRow*n + (i+1)%n,
                                                    0});
                        else
                        {
                            facesList.add(new int[]{1 + iRow*n + i,
                                                    1 + iRow*n + (i+1)%n,
                                                    1 + (iRow-1)*n + (i+1)%n});
                            facesList.add(new int[]{1 + iRow*n + i,
                                                    1 + (iRow-1)*n + (i+1)%n,
                                                    1 + (iRow-1)*n + i});
                        }
                        /*
                        else
                        {
                            facesList.add(new int[]{1 + iRow*n + i,
                                                    1 + (iRow-1)*n + (i+1)%n,
                                                    1 + (iRow-2)*n + (i+1)%n});
                            facesList.add(new int[]{1 + iRow*n + i,
                                                    1 + (iRow-2)*n + (i+1)%n,
                                                    1 + (iRow-1)*n + i});
                        }
                        if (iRow == nRows-1)
                            facesList.add(new int[]{1 + iRow*n + i,
                                                    1 + iRow*n + (i+1)%n,
                                                    1 + (iRow-1)*n + (i+1)%n});
                        */
                    }
                }
                int insideOutFace[] = new int[n];
                FORI (i, n)
                    insideOutFace[i] = vertsList.size()-1-i;
                facesList.add(insideOutFace);


                double verts[][] = new double[vertsList.size()][];
                vertsList.toArray(verts);
                int faces[][] = new int[facesList.size()][];
                facesList.toArray(faces);
                mesh = new Mesh(verts, faces);
            } // doCannedThingEyeball

            private static double[] triangleApex(double v0[], double ang0,
                                                 double v1[], double ang1)
            {
                double e01ang = Math.atan2(v1[1]-v0[1], v1[0]-v0[0]);
                double e02ang = e01ang + ang0;
                double e21ang = e01ang - ang1;
                double normal02[] = new double[]{Math.cos(e02ang+Math.PI/2),
                                                 Math.sin(e02ang+Math.PI/2)};
                double normal21[] = new double[]{Math.cos(e21ang+Math.PI/2),
                                                 Math.sin(e21ang+Math.PI/2)};
                // Find v2 satisfying:
                //    v2 dot normal02 == v0 dot normal02
                //    v2 dot normal21 == v1 dot normal21
                double A[][] = {normal02,
                                normal21};
                double b[] = {VecMath.dot(v0, normal02),
                              VecMath.dot(v1, normal21)};
                // Solve A v2 == b
                return VecMath.invmxv(A, b);
            } // triangleApex

            private void doCannedThingCrackKiller()
            {
                // any of the following sets of choices work

                int nSpokes = 9;
                double angle0 = DTOR(180.);
                double angleIncr = DTOR(-(360/(nSpokes-1) - .01));
                double length0 = .1;
                double lengthMultiplier = 2; // would be nice to be more scientific

                /*
                int nSpokes = 7;
                double angle0 = DTOR(180.);
                double angleIncr = DTOR(-(360/(nSpokes-1) - .01));
                double length0 = .1;
                double lengthMultiplier = 3; // would be nice to be more scientific
                */

                /*
                int nSpokes = 6;
                double angle0 = DTOR(180.);
                double angleIncr = DTOR(-(360/(nSpokes-1) - .001)); // argh, needs finer and finer apparently... although .01 works if we manually adjust the height of one of the faces
                double length0 = .1;
                double lengthMultiplier = 5; // would be nice to be more scientific
                */


                double verts[][] = new double[nSpokes+1][];

                verts[0] = new double[]{0,0};
                FORI (i, nSpokes)
                {
                    double length = length0 * Math.pow(lengthMultiplier, i);
                    double ang = angle0 + i*angleIncr;
                    verts[i+1] = new double[]{length*Math.cos(ang),
                                              length*Math.sin(ang)};
                }
                int faces[][] = new int[nSpokes+1][];
                FORI (i, nSpokes)
                {
                    faces[i] = new int[] {
                        1+i,
                        0,
                        1+(i+1)%nSpokes,
                    };
                }
                faces[nSpokes] = new int[nSpokes];
                FORI (i, nSpokes)
                    faces[nSpokes][i] = 1+i;

                PRINTARRAY(faces);

                mesh = new Mesh(verts, faces);

                // optimize
                mesh.findAndApplyOptimalVertexHeights(OPTIMIZE_LENGTHS_LEAST_SQUARES);

                exploreCrackHead(mesh, 1, 0);
            } // doCannedThingCrackKiller

                // little private utility
                private static double getTriCenterAndArea(Mesh.Edge edge,
                                                          double triCenter[])
                {
                    assert(edge.next().next().next() == edge);
                    Mesh.Vertex v0 = edge.initialVertex();
                    Mesh.Vertex v1 = edge.finalVertex();
                    Mesh.Vertex v2 = edge.next().finalVertex();
                    double twiceTriArea = twiceTriangleArea(v0.x,v0.y,
                                                            v1.x,v1.y,
                                                            v2.x,v2.y);
                    assert(twiceTriArea > 0);
                    SolveForDualPoint(v0.x, v0.y, v0.h,
                                      v1.x, v1.y, v1.h,
                                      v2.x, v2.y, v2.h,
                                      triCenter);
                    return .5*twiceTriArea;
                } // getTriCenterAndArea

            // Test whether the crack killer is really a crack killer
            private static boolean exploreCrackHead(Mesh mesh,
                                                    int i0, int i1) // from and to of tri edge that goes from left to right of first crack edge
            {
                System.out.println("    Exploring crack head, starting with left->right "+i0+"->"+i1+"");
                // Find the initial edge
                Mesh.Edge firstTriEdge = null;
                FORI (iEdge, mesh.edges.size())
                {
                    Mesh.Edge edge = mesh.getEdge(iEdge);
                    if (edge.initialVertex().myIndex() == i0
                     && edge.finalVertex().myIndex() == i1)
                    {
                        assert(firstTriEdge == null);
                        firstTriEdge = edge;
                    }
                }
                assert(firstTriEdge != null);

                double totalCenter[] = {0.,0.};
                double totalArea = 0.;
                Mesh.Edge thisTriEdge = firstTriEdge;

                java.util.Hashtable seenVerts = new java.util.Hashtable();
                {
                    int inds[] = {thisTriEdge.initialVertex().myIndex(),
                                  thisTriEdge.finalVertex().myIndex(),
                                  thisTriEdge.opposite().next().finalVertex().myIndex()};
                    SortStuff.sort(inds);
                    int item = (inds[0]*mesh.verts.size()+inds[1])*mesh.verts.size()+inds[2];
                    seenVerts.put(new Integer(item), "");
                }

                while (true)
                {
                    double prevTriCenter[] = new double[3]; // SolveForDualPoint needs 3
                    double prevTriArea = getTriCenterAndArea(thisTriEdge.opposite(),
                                                             prevTriCenter);
                    // Update totalCenter and totalArea
                    VecMath.lerp(2, totalCenter,
                                 totalCenter, prevTriCenter,
                                 prevTriArea / (totalArea + prevTriArea));
                    totalArea += prevTriArea;

                    //PRINT(totalArea);
                    //PRINTVEC(totalCenter);

                    // gag, duplicate work, whatever
                    double nextTriCenter[] = new double[3]; // SolveForDualPoint needs 3
                    getTriCenterAndArea(thisTriEdge,
                                        nextTriCenter);
                    //PRINTVEC(nextTriCenter);

                    // totalCenter and totalArea are now the total
                    // for all crack vertices BEFORE this tri edge.

                    Mesh.Vertex v0 = thisTriEdge.initialVertex();
                    Mesh.Vertex v1 = thisTriEdge.finalVertex();
                    Mesh.Vertex v2 = thisTriEdge.next().finalVertex();

                    {
                        int inds[] = {v0.myIndex(), v1.myIndex(), v2.myIndex()};
                        SortStuff.sort(inds);
                        int item = (inds[0]*mesh.verts.size()+inds[1])*mesh.verts.size()+inds[2];
                        if (seenVerts.put(new Integer(item), "") != null)
                            System.out.println("        HEY! saw this dual vertex "+v0.myIndex()+","+v1.myIndex()+","+v2.myIndex()+" before!");
                    }


                    System.out.println("    at tri edge "+v0.myIndex()+"->"+v1.myIndex()+"");
                    System.out.println("        left next tri edge: "+v0.myIndex()+"->"+v2.myIndex()+"");
                    System.out.println("        right next tri edge: "+v2.myIndex()+"->"+v1.myIndex()+"");
                    assert(thisTriEdge.next().next().next() == thisTriEdge);
                    double leftNextTriEdgeNormal[] = VecMath.normalize(VecMath.xv2(new double[]{v2.x-v0.x, v2.y-v0.y}));
                    double rightNextTriEdgeNormal[] = VecMath.normalize(VecMath.xv2(new double[]{v1.x-v2.x, v1.y-v2.y}));
                    //PRINTVEC(leftNextTriEdgeNormal);
                    //PRINTVEC(rightNextTriEdgeNormal);
                    double leftHeight = VecMath.dot(VecMath.vmv(totalCenter, nextTriCenter), leftNextTriEdgeNormal);
                    double rightHeight = VecMath.dot(VecMath.vmv(totalCenter, nextTriCenter), rightNextTriEdgeNormal);
                    //PRINT(leftHeight);
                    //PRINT(rightHeight);
                    assert(leftHeight != 0.);
                    assert(rightHeight != 0.);
                    assert(leftHeight < 0 || rightHeight < 0);
                    if (leftHeight < 0 && rightHeight > 0)
                    {
                        System.out.println("        left is good, right is bad, choosing left");
                        thisTriEdge = thisTriEdge.next().next().opposite();
                        assert(thisTriEdge.initialVertex() == v0);
                        assert(thisTriEdge.finalVertex() == v2);
                    }
                    else if (rightHeight < 0 && leftHeight > 0)
                    {
                        System.out.println("        right is good, left is bad, choosing right");
                        thisTriEdge = thisTriEdge.next().opposite();
                        assert(thisTriEdge.initialVertex() == v2);
                        assert(thisTriEdge.finalVertex() == v1);
                    }
                    else
                    {
                        System.out.println("    NO CLEAR CHOICE");
                        return false; // failure
                    }
                }

            } // exploreCrackHead

            // Generalization of netless9.
            // counterexample to "there is an unfolding
            // that uses the sharpest edge at each vertex"
            private void doCannedThingHexesSpiral()
            {
                if (true)
                {
                    // s = how much bigger each edge is from the previous
                    //double s = 1.05;
                    //double s = 1.01;
                    double s = 1.005;
                    //double s = 1.001;
                    //double s = 1.;
                    double sliceAngle;
                    {
                        // In the initial 6 slice pie,
                        // the southwest triangle has sides a=1, b=s^5, c=s^6.
                        // what are its angles?
                        // http://www.teacherschoice.com.au/Maths_Library/Trigonometry/solve_trig_SSS.htm
                        double a = 1;
                        double b = s*s*s*s*s;
                        double c = s*s*s*s*s*s;
                        double C = triangleAngle(a, b, c);
                        // All right, the southwest angle at the center
                        // is C, a bit more than pi/3.
                        // Distribute the rest of the spokes evenly.
                        sliceAngle = (2*Math.PI-C) / 5;
                    }
                    PRINT(RTOD(sliceAngle));
                    //int nVerts = 19;
                    //int nVerts = 18;
                    //int nVerts = 100;
                    int nVerts = 300;
                    //int nVerts = 500;
                    //int nVerts = 1000;
                    double verts[][] = new double[nVerts][3];
                    int nNeighbors[] = new int[nVerts]; // zeros
                    ArrayList/*<int[]>*/ facesList = new ArrayList();

                    // Seed with verts 0 and 1, and an edge between them.
                    verts[0][0] = 0;
                    verts[0][1] = 0;
                    verts[0][2] = 0;
                    // Had the seed on the -y axis, changing it to +x axis for the hell of it
                    verts[1][0] = 1;
                    verts[1][1] = 0;
                    verts[1][2] = 0;
                    nNeighbors[0] = 1;
                    nNeighbors[1] = 1;

                    PRINT(VecMath.dist(verts[1], verts[6]));
                    PRINT(Math.pow(s, 6));

                    int oldestPerimeterEdge[] = {0,1};

                    for (int i = 2; i < nVerts; ++i)
                    {
                        //PRINT(i);
                        int arity = nNeighbors[oldestPerimeterEdge[0]];
                        assert(arity < 6);
                        double angFrac = 1./(6-arity);
                        //PRINT(1./angFrac);
                        double largestEdge = VecMath.dist(verts[i-1], verts[oldestPerimeterEdge[0]]);
                        //PRINT(largestEdge);
                        //PRINT(Math.pow(s, facesList.size()));

                        double c = VecMath.dist(verts[oldestPerimeterEdge[0]],
                                                verts[oldestPerimeterEdge[1]]);
                        double a = largestEdge * Math.pow(s, 1./angFrac);
                        double b = a*s;
                        //PRINT(a);
                        //PRINT(b);
                        double target[] = completeTriangle(verts[oldestPerimeterEdge[1]],
                                                           verts[oldestPerimeterEdge[0]],
                                                           a, b);
                        double ang0 = Math.atan2(verts[i-1][1]-verts[oldestPerimeterEdge[0]][1],
                                                 verts[i-1][0]-verts[oldestPerimeterEdge[0]][0]);
                        double ang1 = Math.atan2(target[1]-verts[oldestPerimeterEdge[0]][1],
                                                 target[0]-verts[oldestPerimeterEdge[0]][0]);
                        //PRINT(RTOD(ang0));
                        //PRINT(RTOD(ang1));
                        //PRINT(angFrac);
                        while (ang1 < ang0) ang1 += 2*Math.PI;
                        double ang = LERP(ang0, ang1, angFrac);
                        double length = largestEdge * s;
                        verts[i][0] = verts[oldestPerimeterEdge[0]][0] + length*Math.cos(ang);
                        verts[i][1] = verts[oldestPerimeterEdge[0]][1] + length*Math.sin(ang);
                        facesList.add(new int[]{oldestPerimeterEdge[0], i-1, i});
                        nNeighbors[oldestPerimeterEdge[0]]++;
                        nNeighbors[i-1]++;
                        nNeighbors[i] = 2;
                        if (nNeighbors[oldestPerimeterEdge[0]] == 6)
                        {
                            //System.out.println("COMPLETING at "+i);
                            facesList.add(new int[]{oldestPerimeterEdge[1], oldestPerimeterEdge[0], i});
                            nNeighbors[oldestPerimeterEdge[1]]++;
                            nNeighbors[i]++;
                            oldestPerimeterEdge[0]++;
                            oldestPerimeterEdge[1]++;
                        }
                    }

                    {
                        int nPerimeterVerts = 0;
                        FORI (i, nVerts)
                            if (nNeighbors[i] < 6)
                                nPerimeterVerts++;
                        int perimeterVerts[] = new int[nPerimeterVerts];
                        nPerimeterVerts = 0;
                        FORI (i, nVerts)
                            if (nNeighbors[i] < 6)
                                perimeterVerts[perimeterVerts.length-1-nPerimeterVerts++] = i;
                        facesList.add(perimeterVerts);
                        PRINT(nPerimeterVerts);
                    }


                    int faces[][] = new int[facesList.size()][];
                    facesList.toArray(faces);
                    mesh = new Mesh(verts, faces);
                    //PRINTARRAY(nNeighbors);
                    //PRINTARRAY(verts);
                    //PRINTARRAY(faces);
                }
                FORIDOWN (iVert, mesh.verts.size())
                {
                    double scale = .2;
                    Mesh.Vertex vert = mesh.getVert(iVert);
                    vert.x *= scale;
                    vert.y *= scale;
                    vert.h *= scale*scale;
                }
                //double heightIncr = .005*.14;
                double heightIncr = .005*.01;
                FORIDOWN (iVert, mesh.verts.size())
                {
                    mesh.getVert(iVert).h -= heightIncr * iVert;
                }
            } // doCannedThingHexesSpiral

            // counterexample to "there is an unfolding
            // that uses the dullest edge on each face", // almost... needs some height adjustments... just hit O to optimize?
            private void doCannedThingHexesSpiralOther()
            {
                int nVerts = 50;
                double r = .7; // XXX actually this would have to gradually increase or decrease each time, to get a consistent direction
                double R = 1.;

                ArrayList vertsList = new ArrayList();
                vertsList.add(new double[]{0,0});
                vertsList.add(new double[]{r,0});
                vertsList.add(completeTriangle((double[])vertsList.get(0),
                                           (double[])vertsList.get(1), r, R));

                ArrayList facesList = new ArrayList();
                facesList.add(new int[]{0,1,2});


                int oldestOnBoundary = 0;
                while (vertsList.size() < nVerts)
                {
                    double newVertex[] = completeTriangle((double[])vertsList.get(oldestOnBoundary),
                                                          (double[])vertsList.get(vertsList.size()-1),
                                                          r, R);
                    if (VecMath.distsqrd((double[])vertsList.get(oldestOnBoundary+1),
                                         newVertex) <= R*R)
                    {
                        facesList.add(new int[]{oldestOnBoundary+1,
                                           oldestOnBoundary,
                                           vertsList.size()-1});
                        oldestOnBoundary++;
                    }
                    else
                    {
                        vertsList.add(newVertex);
                        facesList.add(new int[]{oldestOnBoundary,
                                           vertsList.size()-2,
                                           vertsList.size()-1});
                    }
                }
                // Now add the inside out one
                int insideOutFace[] = new int[vertsList.size() - oldestOnBoundary];
                FORI (i, insideOutFace.length)
                    insideOutFace[i] = vertsList.size()-1-i;
                facesList.add(insideOutFace);

                double verts[][] = new double[vertsList.size()][];
                vertsList.toArray(verts);
                int faces[][] = new int[facesList.size()][];
                facesList.toArray(faces);

                VecMath.mxs(verts, verts,
                            .75/VecMath.norm(verts[verts.length-1]));

                mesh = new Mesh(verts, faces);
                delaunayize(); // so faces were unnecessary, oh well
            } // doCannedThingHexesSpiralOther


    //
    // Definition of stuff for this particular app...
    //
        private static class Mesh
        {
            public String toString()
            {
                StringBuffer sb = new StringBuffer();
                sb.append(""+verts.size()+" verts:\n");
                FORI (iVert, verts.size())
                {
                    Vertex vert = (Vertex)verts.get(iVert);
                    sb.append("    "+vert.x+" "+vert.y+" "+vert.h);
                    if (vert.weight != 1.)
                        sb.append("  * "+vert.weight);

                    sb.append("\n");
                }
                sb.append(""+edges.size()+" edges:\n");
                FORI (iEdge, edges.size())
                {
                    Edge edge = (Edge)edges.get(iEdge);
                    Vertex v0 = edge.initialVertex();
                    Vertex v1 = edge.finalVertex();
                    sb.append("    "
                            + (v0==null ? "null" : "v"+v0.myIndex())
                            + " -> "
                            + (v1==null ? "null" : "v"+v1.myIndex())
                            + "\n");
                }
                return sb.toString();
            }

            public class Vertex
            {
                public double x, y, h; // x, y, "height"
                public double weight = 1.; // optional, if this is a computed dual vertex, this should be the original triangle area
                public double momentAndArea[/*4*/] = null; // optional... similar to weight. x*A,y*A,h*A^2,A where A is twice tri area
                public int arity = 0; // number of edges having this vertex as initial vertex

                private int _myIndex = -1;
                public Vertex(double x, double y, double h)
                {
                    this.x = x;
                    this.y = y;
                    this.h = h;
                    verts.add(this);
                    fixVertIndices(verts.size()-1);
                }

                // A Vertex can belong to only one Mesh.
                // myIndex() returns the index into the Mesh's edges.
                public int myIndex()
                {
                    //return Arrays.indexOfUsingEqualsSymbol(verts, this);
                    return _myIndex;
                }
            } // public class Vertex
            public class Edge
            {
                private Vertex _initialVertex;
                private Edge _opposite; // opposite edge
                private Edge _next; // next edge CCW around the face to my left
                private Edge _prev; // prev edge (next edge CW) around the face to my left
                private int _myIndex = -1;
                public double direction[] = null; // optional, not kept up to date by mesh editing operations, only really used in dual, which is constructed and not edited

                public Edge(boolean andBack)
                {
                    this._myIndex = -1; // will get fixed
                    edges.add(this);
                    fixEdgeIndices(edges.size()-1);
                    if (andBack)
                    {
                        Edge opposite = new Edge(false);
                        setOpposite(opposite, true);
                    }
                }

                //
                // Accessor methods...
                //
                public Vertex initialVertex()
                {
                    return _initialVertex;
                }
                public Edge opposite()
                {
                    return _opposite;
                }
                // next edge CCW around the face to my left
                public Edge next()
                {
                    return _next;
                }
                // prev edge (next edge CW) around the face to my left
                public Edge prev()
                {
                    return _prev;
                }

                //
                // Helper methods...
                // From the caller's point of view,
                // these are just like the accessor methods
                //
                public Vertex finalVertex()
                {
                    return _opposite._initialVertex;
                }


                // An Edge can belong to only one Mesh.
                // myIndex() returns the index into the Mesh's edges.
                public int myIndex()
                {
                    //return Arrays.indexOfUsingEqualsSymbol(edges, this);
                    return _myIndex;
                }


                public void setInitialVertex(Vertex v)
                {
                    assert(_initialVertex == null);
                    _initialVertex = v;
                    _initialVertex.arity++;
                }

                public void setOpposite(Edge opposite, boolean andBack)
                {
                    _opposite = opposite;
                    if (andBack)
                        _opposite.setOpposite(this, false);
                }
                public void setNext(Edge next, boolean andBack)
                {
                    _next = next;
                    if (andBack)
                        next.setPrev(this, false);
                }
                public void setPrev(Edge prev, boolean andBack)
                {
                    _prev = prev;
                    if (andBack)
                        prev.setNext(this, false);
                }

                public String toString()
                {
                    StringBuffer sb = new StringBuffer();
                    sb.append("e");
                    sb.append(myIndex());
                    sb.append(" (");

                    if (initialVertex() != null)
                    {
                        sb.append("v");
                        sb.append(initialVertex().myIndex());
                    }
                    else
                        sb.append("null");
                    sb.append("->");
                    if (finalVertex() != null)
                    {
                        sb.append("v");
                        sb.append(finalVertex().myIndex());
                    }
                    else
                        sb.append("null");

                    sb.append(")");
                    return sb.toString();
                }

            } // public class Edge

            // Called whenever verts array changes
            private void fixVertIndices(int i0)
            {
                for (int iVert = i0; iVert < verts.size(); ++iVert)
                    ((Vertex)verts.get(iVert))._myIndex = iVert;
            }
            // Called whenever edges array changes
            private void fixEdgeIndices(int i0)
            {
                for (int iEdge = i0; iEdge < edges.size(); ++iEdge)
                    ((Edge)edges.get(iEdge))._myIndex = iEdge;
            }

            public void sanityCheck()
            {
                int nVerts = this.verts.size();
                int nEdges = this.edges.size();

                Vertex verts[] = new Vertex[nVerts];
                Edge edges[] = new Edge[nEdges];

                FORI (iVert, nVerts)
                {
                    Vertex vert = (Vertex)this.getVert(iVert);
                    assert(vert.myIndex() == iVert);
                    verts[iVert] = vert;
                }
                FORI (iEdge, nEdges)
                {
                    Edge edge = (Edge)this.getEdge(iEdge);
                    assert(edge.myIndex() == iEdge);
                    edges[iEdge] = edge;
                }

                int nTimesSawVertAsInitial[] = new int[nVerts]; // all zero
                boolean sawEdgeAsOpposite[] = new boolean[nEdges]; // all false
                boolean sawEdgeAsNext[] = new boolean[nEdges]; // all false
                boolean sawEdgeAsPrev[] = new boolean[nEdges]; // all false
                FORI (iEdge, nEdges)
                {
                    Edge e = edges[iEdge];
                    Vertex initialVertex = e.initialVertex();
                    Edge opposite = e.opposite();
                    Edge next = e.next();
                    Edge prev = e.prev();

                    assert(initialVertex != null);
                    assert(opposite != null);
                    assert(next != null);
                    assert(prev != null);

                    int initialVertIndex = initialVertex.myIndex();
                    int oppositeIndex = opposite.myIndex();
                    int nextIndex = next.myIndex();
                    int prevIndex = prev.myIndex();

                    assert(verts[initialVertIndex] == initialVertex);
                    assert(edges[oppositeIndex] == opposite);
                    assert(edges[nextIndex] == next);
                    assert(edges[prevIndex] == prev);

                    assert(initialVertex != e.finalVertex());
                    assert(opposite != e);
                    assert(next != e);
                    assert(prev != e);
                    assert(opposite.opposite() == e);
                    assert(next.prev() == e);
                    assert(prev.next() == e);


                    // Okay for a vert to be initial more than once...
                    nTimesSawVertAsInitial[initialVertIndex]++;

                    // But not the others...
                    assert(!sawEdgeAsOpposite[oppositeIndex]);
                    sawEdgeAsOpposite[oppositeIndex] = true;
                    assert(!sawEdgeAsNext[nextIndex]);
                    sawEdgeAsNext[nextIndex] = true;
                    assert(!sawEdgeAsPrev[prevIndex]);
                    sawEdgeAsPrev[prevIndex] = true;
                }

                FORI (iVert, nVerts)
                {
                    assert(nTimesSawVertAsInitial[iVert] == verts[iVert].arity);
                }
                FORI (iEdge, nEdges)
                {
                    assert(sawEdgeAsOpposite[iEdge]);
                    assert(sawEdgeAsNext[iEdge]);
                    assert(sawEdgeAsPrev[iEdge]);
                }
            } // sanityCheck




            /*                    ^
                 insertThisEdge   | beforeThisEdge
                <-----------------*
                                 /|\
                                / | \
            */
            public void insertEdgeBefore(Edge insertThisEdge, Edge beforeThisEdge)
            {
                if (nonEventVerbose >= 1)
                    System.out.println("        In insertEdgeBefore(insertThisEdge="+insertThisEdge.myIndex()+", beforeThisEdge="+beforeThisEdge.myIndex()+"");
                beforeThisEdge.prev().setNext(insertThisEdge, true);
                insertThisEdge.opposite().setNext(beforeThisEdge, true);
                insertThisEdge.setInitialVertex(beforeThisEdge.initialVertex());
                if (nonEventVerbose >= 1)
                    System.out.println("        Out insertEdgeBefore(insertThisEdge="+insertThisEdge.myIndex()+", beforeThisEdge="+beforeThisEdge.myIndex()+"");
            }
            public void addWhisker(Edge beforeThisEdge,
                                   Vertex v) // to this vertex
            {
                Edge e = new Edge(true);
                e.opposite().setInitialVertex(v);
                e.setNext(e.opposite(), true);
                insertEdgeBefore(e, beforeThisEdge);
            }
            public void addDiagonal(Edge beforeThisEdge, Edge beforeThatEdge)
            {
                if (nonEventVerbose >= 1)
                    System.out.println("    In addDiagonal(beforeThisEdge="+beforeThisEdge.myIndex()+", beforeThatEdge="+beforeThatEdge.myIndex()+"");
                Edge e = new Edge(true);
                insertEdgeBefore(e, beforeThisEdge);
                insertEdgeBefore(e.opposite(), beforeThatEdge);
                if (nonEventVerbose >= 1)
                    System.out.println("    Out addDiagonal(beforeThisEdge="+beforeThisEdge.myIndex()+", beforeThatEdge="+beforeThatEdge.myIndex()+"");
            }
            // returns true iff did something
            public boolean swapDiagonal(Edge e, boolean onlyIfMoreDelaunay, boolean verbose)
            {
                if (e.next().next().next() != e
                 || e.opposite().next().next().next() != e.opposite())
                {
                    if (verbose)
                        System.out.println("    Can't swap diagonal, it's not on a quad");
                    return false;
                }

                Edge beforeThisEdge = e.prev();
                Edge beforeThatEdge = e.opposite().prev();

                //
                // Another subtle thing to check...
                // Make sure the other diagonal doesn't
                // already exist.
                //
                {
                    Vertex v0 = beforeThisEdge.initialVertex();
                    Vertex v1 = beforeThatEdge.initialVertex();
                    // Could do this faster by walking around the vert,
                    // but this is more complete since it checks for some pathological cases
                    FORIDOWN (iEdge, edges.size())
                    {
                        Edge edge = (Edge)edges.get(iEdge);
                        if (edge.initialVertex() == v0
                         && edge.finalVertex() == v1)
                        {
                            if (verbose)
                                System.out.println("    Can't swap diagonal, the other diagonal already exists");
                            return false;
                        }
                    }
                }

                if (onlyIfMoreDelaunay)
                {
                    Vertex a = beforeThisEdge.finalVertex();
                    Vertex b = beforeThatEdge.initialVertex();
                    Vertex c = beforeThatEdge.finalVertex();
                    Vertex d = beforeThisEdge.initialVertex();
                    // comfort of ac relative to bd
                    double comfort = TriangulationOptimizer.calcQuadComfort(new double[]{a.x,a.y},
                                                                            new double[]{b.x,b.y},
                                                                            new double[]{c.x,c.y},
                                                                            new double[]{d.x,d.y},
                                                                            0, 1);
                    // XXX TODO: take height into account!!!!!
                    if (verbose)
                        System.out.println("    comfort = "+comfort);
                    if (comfort >= 0) // should this be fuzzy? I won't worry about it for now
                    {
                        if (verbose)
                            System.out.println("    Swapping diagonal would not improve it");
                        return false;
                    }
                }

                if (true)
                {
                    // This works, but leaves dual verts in a different order
                    deleteEdge(e);
                    addDiagonal(beforeThisEdge, beforeThatEdge);
                }
                else
                {
                    // TODO: why did this work in temp branch but fails here?
                    // OH, it's because the assertion in setInitialVertex is new.
                    // hmm, can try to fix it, or just get rid of this case since it was somewhat ill-advised anyway.

                    // Aww fooey, still in different order :-(
                    beforeThatEdge.setNext(beforeThisEdge.prev(), true);
                    beforeThisEdge.setNext(beforeThatEdge.prev(), true);
                    insertEdgeBefore(e, beforeThisEdge);
                    insertEdgeBefore(e.opposite(), beforeThatEdge);
                    // no need to fix up edge indices
                }
                return true;
            } // swapDiagonal
            public void addEdgeBetweenTwoIsolatedVertices(Vertex v0, Vertex v1)
            {
                Edge e = new Edge(true);
                e.setInitialVertex(v0);
                e.opposite().setInitialVertex(v1);
                e.setNext(e.opposite(), true);
                e.setPrev(e.opposite(), true);
            }
            public void addEdgeBetweenTwoVertices(Vertex v0, Vertex v1)
            {
                assert(v0 != v1);
                if (verts.size() == 2)
                {
                    // XXX this case might not be necessary?
                    addEdgeBetweenTwoIsolatedVertices(v0, v1);
                    return;
                }
                // find the face containing both vertices
                // that has greatest area.
                Edge bestBeforeThisEdge = null;
                Edge bestBeforeThatEdge = null;
                double bestTwiceFaceArea = Double.NEGATIVE_INFINITY;
                int nEdges = edges.size();
                FORI (iEdge, nEdges)
                {
                    Edge e0 = (Edge)edges.get(iEdge);
                    if (e0.initialVertex() == v0)
                    {
                        if (e0.finalVertex() == v1)
                        {
                            return; // the vertices are neighbors... definitely don't do anything in this case
                        }
                        // walk around the face CCW looking for v1
                        for (Edge e = e0; e.finalVertex() != v0; e = e.next())
                        {
                            if (e.finalVertex() == v1)
                            {
                                double twiceFaceArea = twiceFaceArea(e0);
                                if (twiceFaceArea > bestTwiceFaceArea)
                                {
                                    bestBeforeThisEdge = e0;
                                    bestBeforeThatEdge = e.next();
                                    bestTwiceFaceArea = twiceFaceArea;
                                }
                                break;
                            }
                        }
                    }
                }
                if (bestBeforeThisEdge != null)
                {
                    addDiagonal(bestBeforeThisEdge,
                                bestBeforeThatEdge);
                    return;
                }
                // XXX TODO: more cases, if either or both of the vertices are isolated, or otherwise connecting two components
            } // addEdgeBetweenTwoVertices

            public double twiceFaceArea(Edge e0)
            {
                double sum = 0;
                Vertex v0 = e0.initialVertex();
                // All edges e not containing v0...
                for (Edge e = e0.next(); e.finalVertex() != v0; e = e.next())
                {
                    Vertex v1 = e.initialVertex();
                    Vertex v2 = e.finalVertex();
                    sum += twiceTriangleArea(v0.x, v0.y,
                                             v1.x, v1.y,
                                             v2.x, v2.y);
                }
                return sum;
            } // twiceFaceArea

            public void addIsolatedVertex(double x, double y, double h)
            {
                new Vertex(x,y,h); // adds itself to verts
            }
            // This is the "kis" operation, the dual of truncating a vertex.
            public void kisIsolatedVertex(Vertex v, Edge someEdgeOnFace)
            {
                if (nonEventVerbose >= 1)
                    System.out.println("In kis(v="+v.myIndex()+", someEdgeOnFac="+someEdgeOnFace.myIndex()+"");
                //
                // Start by attaching a single whisker to the new vertex...
                //
                if (nonEventVerbose >= 1)
                    System.out.println("    adding a whisker from edge "+someEdgeOnFace.myIndex()+" to vert "+v.myIndex());
                addWhisker(someEdgeOnFace, v);
                if (nonEventVerbose >= 1)
                {
                    System.out.println("    did that at least.");
                    PRINT(this);
                }

                //
                // Now fill in with triangles,
                // connecting everything to the new vertex v.
                //
                while (someEdgeOnFace.next()
                                     .next()
                                     .next() != someEdgeOnFace)
                {
                    if (nonEventVerbose >= 1)
                        System.out.println("    adding diagonal from start of edge "+someEdgeOnFace.prev().myIndex()+" to start of edge "+someEdgeOnFace.prev().prev().prev().myIndex()+"");
                    addDiagonal(someEdgeOnFace.prev(),
                                someEdgeOnFace.prev()
                                              .prev()
                                              .prev());
                    if (nonEventVerbose >= 1)
                    {
                        System.out.println("    did that diagonal.");
                        PRINT(this);
                    }
                }
                if (nonEventVerbose >= 1)
                    System.out.println("Out kis(v="+v.myIndex()+", someEdgeOnFac="+someEdgeOnFace.myIndex()+"");
            }
            public void deleteEdge(Edge e)
            {
                e.prev().setNext(e.opposite().next(), true);
                e.opposite().prev().setNext(e.next(), true);
                /*
                assert(e.next() == e.opposite());
                assert(e.prev() == e.opposite());
                */
                int i = e.myIndex();
                edges.remove(i);
                fixEdgeIndices(i);

                int j = e.opposite().myIndex();
                edges.remove(j);
                fixEdgeIndices(j);

                e._initialVertex.arity--;
                e._initialVertex = null;

                e.opposite()._initialVertex.arity--;
                e.opposite()._initialVertex = null;
            }
            public void deleteVertex(Vertex v)
            {
                FORI (iEdge, edges.size())
                {
                    Edge edge = (Edge)edges.get(iEdge);
                    if (edge.initialVertex() == v
                     || edge.finalVertex() == v)
                    {
                        deleteEdge(edge);
                        iEdge--; // so when we increment we get back to here
                    }
                }
                assert(v.arity == 0);
                int iVert = v.myIndex();
                verts.remove(iVert);
                fixVertIndices(iVert);
                // XXX should we do the fast remove, moving the last one into the slot?  well, is there an advantage to keeping the vertices in order?  Probably.
            }

            public int indexOfClosestVert(double x, double y)
            {
                double closestDistSqrd = Double.POSITIVE_INFINITY;
                int closestVertIndex = -1;
                FORI (iVert, verts.size()) // beginning to end, so we choose first of equal
                {
                    Vertex vert = (Vertex)verts.get(iVert);
                    double thisDistSqrd = SQR(vert.x-x)
                                        + SQR(vert.y-y);
                    if (thisDistSqrd < closestDistSqrd)
                    {
                        closestDistSqrd = thisDistSqrd;
                        closestVertIndex = iVert;
                    }
                }
                return closestVertIndex; // -1 if none
            } // indexOfClosestVert

            public int indexOfClosestEdge(double point[/*2*/], boolean isDualMesh)
            {
                double x = point[0], y = point[1];
                double closestDistSqrd = Double.POSITIVE_INFINITY;
                int closestEdgeIndex = -1;
                FORI (iEdge, edges.size()) // beginning to end, so we choose first of equal
                {
                    Edge edge = (Edge)edges.get(iEdge);
                    double thisDistSqrd =
                        edge.initialVertex() == null ? Double.POSITIVE_INFINITY : // no need to deal with edges whose initial vertex is NULL and final vertex isn't, since we'll encounter its opposite anyway
                        edge.finalVertex() == null ? distSqrdFromPointToRay(x,y,
                                                                            edge.initialVertex().x,
                                                                            edge.initialVertex().y,
                                                                            edge.direction[0],
                                                                            edge.direction[1]) :
                        edge.initialVertex().myIndex() > edge.finalVertex().myIndex() ? Double.POSITIVE_INFINITY
                                                    : distSqrdFromPointToSeg(x,y,
                                                                             edge.initialVertex().x,
                                                                             edge.initialVertex().y,
                                                                             edge.finalVertex().x,
                                                                             edge.finalVertex().y);
                    if (thisDistSqrd < closestDistSqrd)
                    {
                        closestDistSqrd = thisDistSqrd;
                        closestEdgeIndex = iEdge;
                    }
                }
                if (closestEdgeIndex != -1)
                {
                    // Make sure point is on left side of edge.
                    // If not, choose edge's opposite instead.
                    Edge edge = (Edge)edges.get(closestEdgeIndex);
                    Vertex v = edge.initialVertex();
                    if (v == null) v = edge.finalVertex();
                    double vToPoint[] = {point[0]-v.x, point[1]-v.y};
                    if (VecMath.vxv2(edge.direction, vToPoint) * (isDualMesh ? -1. : 1.) < 0.)
                    {
                        closestEdgeIndex = edge.opposite().myIndex();
                    }
                }
                return closestEdgeIndex; // -1 if none
            } // indexOfClosestEdge

            public double[] findOptimalVertexHeights(int optimizationType)
            {
                if (verts.size() < 3)
                    return new double[verts.size()]; // zeros

                if (nonEventVerbose >= 1)
                    System.out.println("in findOptimalVertexHeights");

                int nDependentVerts = 3;
                int dependentVertIndices[] = {0,1,2};
                // Prefer the triangle that contains the origin...
                {
                    FORI (iEdge, edges.size())
                    {
                        Edge edge = (Edge)edges.get(iEdge);
                        if (edge.next().next().next() != edge)
                            continue;
                        Vertex v0 = edge.initialVertex();
                        Vertex v1 = edge.next().initialVertex();
                        Vertex v2 = edge.next().next().initialVertex();
                        if (twiceTriangleArea(0,0,
                                              v0.x,v0.y,
                                              v1.x,v1.y) >= 0
                         && twiceTriangleArea(0,0,
                                              v1.x,v1.y,
                                              v2.x,v2.y) >= 0
                         && twiceTriangleArea(0,0,
                                              v2.x,v2.y,
                                              v0.x,v0.y) >= 0)
                        {
                            dependentVertIndices[0] = v0.myIndex();
                            dependentVertIndices[1] = v1.myIndex();
                            dependentVertIndices[2] = v2.myIndex();
                            break; // origin is inside this tri CCW
                        }
                    }
                }

                // Figure out the desired dualEdgeLength...
                // XXX just hard code for now
                double desiredDualEdgeLength = .25;

                // edge2dualVert[iEdge] will be the dual vert on the left of edges[iEdge]
                int edge2dualVert[] = VecMath.fillvec(edges.size(), -1);
                int nDualVerts;
                {
                    nDualVerts = 0;
                    FORI (iEdge, edges.size())
                    {
                        if (edge2dualVert[iEdge] != -1)
                            continue; // already saw some other edge on this tri
                        Edge e0 = (Edge)edges.get(iEdge);
                        Edge e1 = e0.next();
                        Edge e2 = e1.next();
                        boolean thisIsATri = (e2.next() == e0);
                        if (!thisIsATri)
                            continue;

                        Mesh.Vertex v0 = e0.initialVertex();
                        Mesh.Vertex v1 = e1.initialVertex();
                        Mesh.Vertex v2 = e2.initialVertex();

                        double dualVertArea = twiceTriangleArea(v0.x,v0.y,
                                                                v1.x,v1.y,
                                                                v2.x,v2.y);
                        if (dualVertArea < 0.)
                            continue; // triangle is inside out

                        edge2dualVert[iEdge] = nDualVerts;
                        edge2dualVert[e1.myIndex()] = nDualVerts;
                        edge2dualVert[e2.myIndex()] = nDualVerts;
                        nDualVerts++;
                    }
                }
                if (nonEventVerbose >= 1)
                    PRINT(nDualVerts);

                // there is only one dual edge per pair (edge,edge.opposite()).
                int edge2dualEdge[] = VecMath.fillvec(edges.size(), -1);
                int nDualEdges;
                {
                    nDualEdges = 0;
                    FORI (iEdge, edges.size())
                    {
                        if (edge2dualEdge[iEdge] != -1)
                            continue; // already seen it from the opposite edge

                        Edge edge = (Edge)edges.get(iEdge);
                        if (edge2dualVert[iEdge] != -1
                         && edge2dualVert[edge.opposite().myIndex()] != -1)
                        {
                            // Opposite edge is also on a tri
                            // that we haven't counted yet
                            edge2dualEdge[iEdge] = nDualEdges;
                            edge2dualEdge[edge.opposite().myIndex()] = nDualEdges;
                            nDualEdges++;
                        }
                    }
                }
                if (nonEventVerbose >= 1)
                    PRINT(nDualEdges);

                int dualVert2verts[][] = VecMath.fillmat(nDualVerts, 3, -1);
                int dualEdge2edge[] = VecMath.fillvec(nDualEdges, -1); // XXX not used?
                int dualEdge2dualVerts[][] = VecMath.fillmat(nDualEdges, 2, -1);
                {
                    FORI (iEdge, edges.size())
                    {
                        Edge edge = (Edge)edges.get(iEdge);
                        int iDualEdge = edge2dualEdge[iEdge];
                        if (iDualEdge != -1 // if it has a dual edge
                         && dualEdge2dualVerts[iDualEdge][0] == -1) // if we didn't already do this dual edge from the opposite
                        {
                            dualEdge2edge[iDualEdge] = iEdge;
                            dualEdge2dualVerts[iDualEdge][0] = edge2dualVert[iEdge];
                            dualEdge2dualVerts[iDualEdge][1] = edge2dualVert[edge.opposite().myIndex()];
                        }

                        int iDualVert = edge2dualVert[iEdge];
                        if (iDualVert != -1 // if this edge is on a triangle
                         && dualVert2verts[iDualVert][0] == -1) // if we didn't already do this dual vert
                        {
                            dualVert2verts[iDualVert][0] = edge.initialVertex().myIndex();
                            dualVert2verts[iDualVert][1] = edge.next().initialVertex().myIndex();
                            dualVert2verts[iDualVert][2] = edge.next().next().initialVertex().myIndex();
                        }
                    }
                    FORI (iDualVert, nDualVerts)
                        FORI (j, 3)
                            assert(dualVert2verts[iDualVert][j] != -1);

                    FORI (iDualEdge, nDualEdges)
                    {
                        assert(dualEdge2edge[iDualEdge] != -1);
                        assert(dualEdge2dualVerts[iDualEdge][0] != -1);
                        assert(dualEdge2dualVerts[iDualEdge][1] != -1);
                    }
                }


                // can optimize positions or lengths.  I think optimizing positions is more robust.
                boolean optimizingBarycentrics = optimizationType == OPTIMIZE_BARYCENTRICS_LEAST_SQUARES
                                              || optimizationType == OPTIMIZE_BARYCENTRICS_MAX_MIN
                                              || optimizationType == OPTIMIZE_BARYCENTRICS_INFINITY_NORM;
                if (optimizingBarycentrics)
                {
                    nDependentVerts = 1; // XXX not right in general, should be number of connected components maybe
                    dependentVertIndices = new int[] {0};
                }

                if (nonEventVerbose >= 1)
                {
                    PRINTVEC(dependentVertIndices);
                }


                int nIndependentVerts = verts.size() - nDependentVerts;

                if (nIndependentVerts > (optimizingBarycentrics ? 2*nDualVerts : nDualEdges))
                {
                    //PRINT((optimizingBarycentrics ? 2*nDualVerts : nDualEdges));
                    System.out.println("Out findOptimalVertexHeights (too many independent verts, it's underconstrained)");
                    return new double[verts.size()]; // zeros
                }

                int vert2independentVert[] = new int[verts.size()];
                int independentVert2verts[] = new int[nIndependentVerts];
                {
                    int iIndependentVert = 0;
                    FORIDOWN (iVert, verts.size())
                    {
                        if (Arrays.indexOf(dependentVertIndices, iVert) == -1)
                        {
                            vert2independentVert[iVert] = iIndependentVert;
                            independentVert2verts[iIndependentVert] = iVert;
                            iIndependentVert++;
                        }
                        else
                            vert2independentVert[iVert] = -1;
                    }
                    assert(iIndependentVert == nIndependentVerts);
                }
                if (nonEventVerbose >= 1)
                {
                    PRINTVEC(vert2independentVert);
                    PRINTVEC(independentVert2verts);
                }


                int nSamples = nIndependentVerts+1;
                double sampleResultVerts[][][] = new double[nSamples][nDualVerts][2]; // SolveForDualPoint actually only needs 2, contrary to all the other comments
                {
                    double sampleHeights[][] = new double[nIndependentVerts+1][nIndependentVerts];
                    VecMath.identitymat(sampleHeights); // the unit basis vectors, and a row of zeros at the end

                    FORI (iSample, nSamples)
                    {
                        //
                        // Input sampleHeights[iSample]
                        // and get out sampleResultVerts[iSample]
                        //
                        FORI (iDualVert, nDualVerts)
                        {
                            int iVert0 = dualVert2verts[iDualVert][0];
                            int iVert1 = dualVert2verts[iDualVert][1];
                            int iVert2 = dualVert2verts[iDualVert][2];
                            int iIndependentVert0 = vert2independentVert[iVert0];
                            int iIndependentVert1 = vert2independentVert[iVert1];
                            int iIndependentVert2 = vert2independentVert[iVert2];
                            double h0 = (iIndependentVert0 == -1 ? 0. : sampleHeights[iSample][iIndependentVert0]);
                            double h1 = (iIndependentVert1 == -1 ? 0. : sampleHeights[iSample][iIndependentVert1]);
                            double h2 = (iIndependentVert2 == -1 ? 0. : sampleHeights[iSample][iIndependentVert2]);
                            Vertex v0 = (Vertex)verts.get(iVert0);
                            Vertex v1 = (Vertex)verts.get(iVert1);
                            Vertex v2 = (Vertex)verts.get(iVert2);
                            SolveForDualPoint(v0.x,v0.y,h0,
                                              v1.x,v1.y,h1,
                                              v2.x,v2.y,h2,
                                              sampleResultVerts[iSample][iDualVert]); // dimension 2-- last coord is simply ignored
                        }
                    }
                    //PRINTMAT(sampleHeights);
                }

                double solvedHeights[];

                if (optimizingBarycentrics)
                {
                    // We want to maximize the minimum barycentric occurring
                    // anywhere in the result.
                    double sampleBarycentrics[][][] = new double[nSamples][nDualVerts][3];
                    FORI (iSample, nSamples)
                    {
                        FORI (iDualVert, nDualVerts)
                        {
                            int tri[] = dualVert2verts[iDualVert];
                            double wholeArea = twiceTriangleArea(((Vertex)verts.get(tri[0])).x, ((Vertex)verts.get(tri[0])).y,
                                                                 ((Vertex)verts.get(tri[1])).x, ((Vertex)verts.get(tri[1])).y,
                                                                 ((Vertex)verts.get(tri[2])).x, ((Vertex)verts.get(tri[2])).y);
                            double dualVert[] = sampleResultVerts[iSample][iDualVert];
                            FORI (iVertOnTri, 3)
                            {
                                sampleBarycentrics[iSample][iDualVert][iVertOnTri] =
                                        twiceTriangleArea(dualVert[0], dualVert[1],
                                                          ((Vertex)verts.get(tri[(iVertOnTri+1)%3])).x,
                                                          ((Vertex)verts.get(tri[(iVertOnTri+1)%3])).y,
                                                          ((Vertex)verts.get(tri[(iVertOnTri+2)%3])).x,
                                                          ((Vertex)verts.get(tri[(iVertOnTri+2)%3])).y)
                                      / wholeArea;
                            }
                        }
                    }
                    double sampleResultVectors[][] = (double[][])Arrays.flatten(sampleBarycentrics, 1, 2);
                    double desiredResultVector[] = VecMath.fillvec(sampleResultVectors[0].length,
                                        optimizationType==OPTIMIZE_BARYCENTRICS_MAX_MIN ? 0. : 1./3.);

                    //
                    // Find C and d
                    // such that x -> C x - d
                    // maps heights to barycentrics.
                    //

                    //
                    // Column i of C is the result from the i'th basis sample,
                    // minus the result from the 0 vector.
                    //
                    double C[][] = new double[sampleResultVectors.length-1][sampleResultVectors[0].length]; // start transposed...
                    FORI (iSample, sampleResultVectors.length-1)
                        VecMath.vmv(C[iSample],
                                    sampleResultVectors[iSample],
                                    sampleResultVectors[sampleResultVectors.length-1]);
                    C = VecMath.transpose(C);

                    //
                    // d is the desired result minus the result from the zero vector.
                    //
                    double d[] = VecMath.vmv(desiredResultVector,
                                             sampleResultVectors[sampleResultVectors.length-1]);

                    // XXX could get clean up the dependent/intependent lookup tables if we want by expressing the independent vertex's constraints here...
                    double A[][] = {}; // no equality constraints
                    double b[] = {}; // no equality constraints

                    LinearProgramming.debugLevel = 0;

                    if (optimizationType == OPTIMIZE_BARYCENTRICS_LEAST_SQUARES)
                    {
                        if (nonEventVerbose >= 1)
                        {
                            System.out.print("    Solving barycentrics least squares from all 1/3's...");
                            System.out.flush();
                        }
                        solvedHeights = VecMath.invmxv(C,d);
                        if (nonEventVerbose >= 1)
                            System.out.println("    done.");
                    }
                    else if (optimizationType == OPTIMIZE_BARYCENTRICS_INFINITY_NORM)
                    {
                        solvedHeights = new double[sampleResultVectors.length-1];
                        if (nonEventVerbose >= 1)
                        {
                            System.out.print("    Solving barycentrics infinity norm from all 1/3's...");
                            System.out.flush();
                        }
                        int result = LinearProgramming.LInfinitySolve(solvedHeights, C,d);
                        if (nonEventVerbose >= 1)
                            System.out.println("    done.");
                        if (result != 0)
                            System.out.println("WARNING: LPSolve returned "+result);
                    }
                    else if (optimizationType == OPTIMIZE_BARYCENTRICS_MAX_MIN)
                    {
                        solvedHeights = new double[sampleResultVectors.length-1];
                        if (nonEventVerbose >= 1)
                        {
                            System.out.print("    Solving barycentrics maximizing minimal element...");
                            System.out.flush();
                        }
                        int result = LinearProgramming.maximizeMinimum(solvedHeights,
                                                                       A, b,
                                                                       C, d);
                        if (nonEventVerbose >= 1)
                            System.out.println("    done.");
                        if (false)
                        {
                            PRINTMAT(A);
                            PRINTVEC(b);
                            PRINTMAT(C);
                            PRINTVEC(d);
                            PRINT(result);
                            PRINTVEC(solvedHeights);
                        }
                        if (result != 0)
                            System.out.println("WARNING: LPSolve returned "+result);
                    }
                    else
                    {
                        assert(false);
                    }
                }
                else // optimize lengths
                {
                    double sampleResultVectors[][];
                    double desiredResultVector[];

                    {
                        double sampleResultLengths[][] = new double[nSamples][nDualEdges];
                        FORI (iSample, nSamples)
                        {
                            //
                            // Calculate sampleResultLengths[iSample]
                            // from sampleResultVerts[iSample]
                            //
                            FORI (iDualEdge, nDualEdges)
                            {
                                sampleResultLengths[iSample][iDualEdge] =
                                    VecMath.dist(2,
                                                 sampleResultVerts[iSample][dualEdge2dualVerts[iDualEdge][0]],
                                                 sampleResultVerts[iSample][dualEdge2dualVerts[iDualEdge][1]]);
                                // Need to figure out the sign.
                                // If dual edge length is positive,
                                // it will point from the original edge's left face
                                // to the original edge's right face.
                                // So the dual edge dir cross the original edge dir
                                // should be > 0.
                                double dualEdgeDir[] = VecMath.vmv(2,
                                                                  sampleResultVerts[iSample][dualEdge2dualVerts[iDualEdge][1]],
                                                                   sampleResultVerts[iSample][dualEdge2dualVerts[iDualEdge][0]]);
                                double originalEdgeDir[] = VecMath.vmv(
                                    new double[] {((Edge)edges.get(dualEdge2edge[iDualEdge])).finalVertex().x,
                                                  ((Edge)edges.get(dualEdge2edge[iDualEdge])).finalVertex().y},
                                    new double[] {((Edge)edges.get(dualEdge2edge[iDualEdge])).initialVertex().x,
                                                  ((Edge)edges.get(dualEdge2edge[iDualEdge])).initialVertex().y}
                                );
                                if (VecMath.vxv2(dualEdgeDir, originalEdgeDir) < 0)
                                {
                                    sampleResultLengths[iSample][iDualEdge] *= -1;
                                }
                            }
                        }
                        sampleResultVectors = sampleResultLengths;
                    }
                    desiredResultVector = VecMath.fillvec(nDualEdges, desiredDualEdgeLength);

                    // the following is general, could optimize something else if desired
                    {

                        //
                        // Row i of A is the result from the i'th basis sample,
                        // minus the result from the 0 vector.
                        //
                        double A[][] = new double[sampleResultVectors.length-1][sampleResultVectors[0].length];
                        FORI (iSample, sampleResultVectors.length-1)
                            VecMath.vmv(A[iSample],
                                        sampleResultVectors[iSample],
                                        sampleResultVectors[sampleResultVectors.length-1]);
                        //
                        // b is the desired result
                        // minus the result from the 0 vector.
                        //
                        double b[] = VecMath.vmv(desiredResultVector,
                                                 sampleResultVectors[sampleResultVectors.length-1]);

                        //PRINTMAT(A);
                        //PRINTVEC(b);

                        double leastSquaresSolution[];
                        if (optimizationType == OPTIMIZE_LENGTHS_LEAST_SQUARES)
                        {
                            if (nonEventVerbose >= 1)
                            {
                                System.out.print("    Solving for lengths least squares from all "+desiredDualEdgeLength+" ...");
                                System.out.flush();
                            }
                            leastSquaresSolution = VecMath.vxinvm(b, A);
                            if (nonEventVerbose >= 1)
                                System.out.println("    done.");
                        }
                        else if (optimizationType == OPTIMIZE_LENGTHS_INFINITY_NORM)
                        {
                            leastSquaresSolution = new double[sampleResultVectors.length-1];
                            if (nonEventVerbose >= 1)
                            {
                                assert(desiredDualEdgeLength == .25);
                                System.out.print("    Solving lengths infinity norm from all .25's...");
                                System.out.flush();
                            }
                            int result = LinearProgramming.LInfinitySolve(leastSquaresSolution, VecMath.transpose(A),b);
                            if (nonEventVerbose >= 1)
                                System.out.println("    done.");
                            if (result != 0)
                                System.out.println("WARNING: LPSolve returned "+result);
                        }
                        else if (optimizationType == OPTIMIZE_LENGTHS_MAX_MIN)
                        {
                            double[] result0 = sampleResultVectors[sampleResultVectors.length-1];

                            leastSquaresSolution = new double[sampleResultVectors.length-1];
                            if (nonEventVerbose >= 1)
                            {
                                System.out.print("    Solving lengths maximizing minimum with sum 1...");
                                System.out.flush();
                            }

                            // Set desired sum to be the sum of the primal edge lengths
                            // (to get something roughly commensurate, that scales with the original)
                            double desiredSum = 0.;
                            FORI (iEdge, edges.size())
                            {
                                Edge edge = (Edge)edges.get(iEdge);
                                if (edge.myIndex() > edge.opposite().myIndex())
                                    continue; // only use canonical one of the two
                                Vertex v0 = edge.initialVertex();
                                Vertex v1 = edge.finalVertex();
                                desiredSum += Math.sqrt(SQR(v1.x-v0.x) + SQR(v1.y-v0.y));
                            }
                            if (nonEventVerbose >= 1)
                                PRINT(desiredSum);

                            if (true)
                            {
                                // Empirically, it's a bit bigger than I want,
                                // especially if there are a lot of infinite edges in the dual
                                // (i.e. much fewer finite edges in the dual than in primal).
                                // So scale down desiredSum by nDualEdges/nEdges.
                                // (nEdges is actually half of edges.size())
                                //PRINT(nDualEdges);
                                //PRINT(edges.size());
                                desiredSum *= ((double)nDualEdges/
                                               (double)(edges.size()/2));
                                // and, final hack... seems to work better scaled by 1/2 anyway
                                desiredSum /= 2.;
                            }




                            // Want solution column vector x
                            // that satisfies [1,1,...,1] (transpose(A) x + result0) = desiredSum
                            //           i.e. [1,1,...,1] (transpose(A) x) + sum(result0) = desiredSum
                            //           i.e. [1,1,...,1] (transpose(A) x) = desiredSum - sum(result0)
                            // and maximizes the minimum element of transpose(A) x + result0.

                            double AA[][] = {VecMath.mxv(A, VecMath.fillvec(nDualEdges, 1.))};
                            double bb[] = {desiredSum - VecMath.sum(result0)};
                            double CC[][] = VecMath.transpose(A);
                            double dd[] = VecMath.sxv(-1.,result0);
                            int result =
                                         leastSquaresSolution.length == 0 ? 0 : // XXX TODO: FIX maximizeMiniumum so it returns 0 instead of -1 in this case!
                                         LinearProgramming.maximizeMinimum(leastSquaresSolution,
                                                                           AA, bb, // AA x = bb
                                                                           CC, dd); // maximize min of CC x - dd, i.e. A^T x + result0
                            if (nonEventVerbose >= 1)
                                System.out.println("    done.");
                            if (result != 0)
                                System.out.println("WARNING: maximizeMinumum returned "+result);

                            if (nonEventVerbose >= 1)
                            {
                                PRINTMAT(AA);
                                PRINTVEC(bb);
                                PRINTVEC(VecMath.vmv(VecMath.mxv(AA, leastSquaresSolution), bb));
                                PRINTVEC(leastSquaresSolution);
                                PRINTVEC(VecMath.vxm(leastSquaresSolution, A));
                                PRINTVEC(VecMath.vpv(VecMath.vxm(leastSquaresSolution,A), result0));
                                PRINT(VecMath.sum(VecMath.vpv(VecMath.vxm(leastSquaresSolution,A), result0)));
                            }

                        }
                        else if (optimizationType == OPTIMIZE_LENGTHS_SUM)
                        {
                            if (nonEventVerbose >= 1)
                            {
                                assert(desiredDualEdgeLength == .25);
                                System.out.print("    Solving lengths minimizing sum with each length >= .25...");
                                System.out.flush();
                            }
                            // XXX not implemented yet
                            assert(false);
                        }
                        else
                            assert(false);

                        //PRINTVEC(leastSquaresSolution);
                        double gotLengths[] = VecMath.vxm(leastSquaresSolution, A);
                        //PRINTVEC(gotLengths);

                        boolean doCheckLeastSquaresSolution = false; // I'm convinced it works
                        if (doCheckLeastSquaresSolution)
                        {
                            System.out.print("    Checking");
                            System.out.flush();

                            int nTests = 100;
                            FORI (iTest, nTests)
                            {
                                System.out.print(".");

                                //
                                // Perturb each element of the solution
                                // by a random amount
                                //
                                double foo[] = VecMath.copyvec(leastSquaresSolution);
                                double dir[] = VecMath.random(leastSquaresSolution.length);
                                VecMath.normalize(dir);
                                double fudges[] = {.01, -.01};
                                FORI (iFudge, fudges.length)
                                {
                                    VecMath.vpsxv(foo, leastSquaresSolution, fudges[iFudge], dir);
                                    double bar[] = VecMath.vxm(foo, A);
                                    //PRINT(VecMath.dist(bar, b));
                                    if (foo.length > 0)
                                        assert(VecMath.dist(gotLengths, b) < VecMath.dist(bar, b));
                                }
                            }
                            System.out.println("    done.");
                        }
                        solvedHeights = leastSquaresSolution;
                    }
                } // optimize lengths

                assert(solvedHeights.length == independentVert2verts.length);
                double optimalVertexHeights[] = new double[verts.size()];
                FORI (iIndex, independentVert2verts.length)
                {
                    optimalVertexHeights[independentVert2verts[iIndex]] = solvedHeights[iIndex];
                }
                FORI (iDependentVert, dependentVertIndices.length)
                    optimalVertexHeights[dependentVertIndices[iDependentVert]] = 0.;


                if (true)
                {
                    // Now we want to adjust the solution
                    // so that the dual verts are shifted in the plane
                    // so that the average of the dual verts
                    // is equal to the average of the original verts.
                    // (This is somewhat arbitrary,
                    // but at least it makes the dual translate with the primal)
                    double[] avgPrimal = new double[2]; // zero initially
                    {
                        FORI (iVert, verts.size())
                        {
                            Vertex vert = (Vertex)verts.get(iVert);
                            avgPrimal[0] += vert.x;
                            avgPrimal[1] += vert.y;
                        }
                        VecMath.vxs(avgPrimal, avgPrimal, 1./verts.size());
                    }
                    double[] avgDual = new double[2]; // zero initially
                    {
                        double scratchDualVert[] = new double[3];
                        FORI (iDualVert, nDualVerts)
                        {
                            int iVert0 = dualVert2verts[iDualVert][0];
                            int iVert1 = dualVert2verts[iDualVert][1];
                            int iVert2 = dualVert2verts[iDualVert][2];
                            Vertex v0 = (Vertex)verts.get(iVert0);
                            Vertex v1 = (Vertex)verts.get(iVert1);
                            Vertex v2 = (Vertex)verts.get(iVert2);
                            double h0 = optimalVertexHeights[iVert0];
                            double h1 = optimalVertexHeights[iVert1];
                            double h2 = optimalVertexHeights[iVert2];
                            SolveForDualPoint(v0.x,v0.y,h0,
                                              v1.x,v1.y,h1,
                                              v2.x,v2.y,h2,
                                              scratchDualVert);
                            VecMath.vpv(2, avgDual, avgDual, scratchDualVert); // only 2 of 3
                        }
                        VecMath.vxs(avgDual, avgDual, 1./nDualVerts);
                    }
                    double[] desiredDelta = VecMath.vmv(avgPrimal, avgDual);
                    //PRINTVEC(avgPrimal);
                    //PRINTVEC(avgDual);
                    //PRINTVEC(desiredDelta);
                    FORI (iVert, optimalVertexHeights.length)
                    {
                        Vertex vert = (Vertex)verts.get(iVert);
                        optimalVertexHeights[iVert] -= vert.x * desiredDelta[0]
                                                     + vert.y * desiredDelta[1];
                    }
                }


                if (nonEventVerbose >= 1)
                    System.out.println("out findOptimalVertexHeights");

                return optimalVertexHeights;
            } // findOptimalVertexHeights

            public void findAndApplyOptimalVertexHeights(int optimizationType)
            {
                double optimalVertexHeights[] = findOptimalVertexHeights(
                                optimizationType);
                FORIDOWN (iVert, verts.size())
                {
                    //PRINTSUB(optimalVertexHeights,iVert);
                    ((Mesh.Vertex)verts.get(iVert)).h = optimalVertexHeights[iVert];
                }
            } // findAndApplyOptimalVertexHeights

            private void flipLeftRight()
            {
                FORIDOWN (iVert, verts.size())
                {
                    Mesh.Vertex vert = (Mesh.Vertex)verts.get(iVert);
                    vert.x *= -1.;
                }
                // XXX rest is dup code
                Mesh.Vertex finalInitials[] = new Mesh.Vertex[edges.size()];
                FORIDOWN(iEdge, edges.size())
                {
                    Mesh.Edge edge = (Mesh.Edge)edges.get(iEdge);
                    finalInitials[iEdge] = edge.finalVertex();
                }
                FORIDOWN(iEdge, edges.size())
                {
                    Mesh.Edge edge = (Mesh.Edge)edges.get(iEdge);
                    edge._initialVertex.arity--;
                    edge._initialVertex = null;
                }
                FORIDOWN(iEdge, edges.size())
                {
                    Mesh.Edge edge = (Mesh.Edge)edges.get(iEdge);
                    Mesh.Edge tempEdge;
                    SWAP(edge._next, edge._prev, tempEdge);
                    assert(edge._initialVertex == null);
                    edge._initialVertex = finalInitials[iEdge];
                    edge._initialVertex.arity++;
                }
                sanityCheck();
            } // flipLeftRight
            private void flipUpDown()
            {
                FORIDOWN (iVert, verts.size())
                {
                    Mesh.Vertex vert = (Mesh.Vertex)verts.get(iVert);
                    vert.y *= -1.;
                }
                // XXX rest is dup code
                Mesh.Vertex finalInitials[] = new Mesh.Vertex[edges.size()];
                FORIDOWN(iEdge, edges.size())
                {
                    Mesh.Edge edge = (Mesh.Edge)edges.get(iEdge);
                    finalInitials[iEdge] = edge.finalVertex();
                }
                FORIDOWN(iEdge, edges.size())
                {
                    Mesh.Edge edge = (Mesh.Edge)edges.get(iEdge);
                    edge._initialVertex.arity--;
                    edge._initialVertex = null;
                }
                FORIDOWN(iEdge, edges.size())
                {
                    Mesh.Edge edge = (Mesh.Edge)edges.get(iEdge);
                    Mesh.Edge tempEdge;
                    SWAP(edge._next, edge._prev, tempEdge);
                    assert(edge._initialVertex == null);
                    edge._initialVertex = finalInitials[iEdge];
                    edge._initialVertex.arity++;
                }
                sanityCheck();
            } // flipUpDown
            private void flipUpperLeftLowerRight()
            {
                FORIDOWN (iVert, verts.size())
                {
                    Mesh.Vertex vert = (Mesh.Vertex)verts.get(iVert);
                    double temp;
                    SWAP(vert.x, vert.y, temp);
                }
                // XXX rest is dup code
                Mesh.Vertex finalInitials[] = new Mesh.Vertex[edges.size()];
                FORIDOWN(iEdge, edges.size())
                {
                    Mesh.Edge edge = (Mesh.Edge)edges.get(iEdge);
                    finalInitials[iEdge] = edge.finalVertex();
                }
                FORIDOWN(iEdge, edges.size())
                {
                    Mesh.Edge edge = (Mesh.Edge)edges.get(iEdge);
                    edge._initialVertex.arity--;
                    edge._initialVertex = null;
                }
                FORIDOWN(iEdge, edges.size())
                {
                    Mesh.Edge edge = (Mesh.Edge)edges.get(iEdge);
                    Mesh.Edge tempEdge;
                    SWAP(edge._next, edge._prev, tempEdge);
                    assert(edge._initialVertex == null);
                    edge._initialVertex = finalInitials[iEdge];
                    edge._initialVertex.arity++;
                }
                sanityCheck();
            } // flipUpperLeftLowerRight
            private void flipLowerLeftUpperRight()
            {
                FORIDOWN (iVert, verts.size())
                {
                    Mesh.Vertex vert = (Mesh.Vertex)verts.get(iVert);
                    double temp;
                    SWAP(vert.x, vert.y, temp);
                    vert.x *= -1.;
                    vert.y *= -1.;
                }
                // XXX rest is dup code
                Mesh.Vertex finalInitials[] = new Mesh.Vertex[edges.size()];
                FORIDOWN(iEdge, edges.size())
                {
                    Mesh.Edge edge = (Mesh.Edge)edges.get(iEdge);
                    finalInitials[iEdge] = edge.finalVertex();
                }
                FORIDOWN(iEdge, edges.size())
                {
                    Mesh.Edge edge = (Mesh.Edge)edges.get(iEdge);
                    edge._initialVertex.arity--;
                    edge._initialVertex = null;
                }
                FORIDOWN(iEdge, edges.size())
                {
                    Mesh.Edge edge = (Mesh.Edge)edges.get(iEdge);
                    Mesh.Edge tempEdge;
                    SWAP(edge._next, edge._prev, tempEdge);
                    assert(edge._initialVertex == null);
                    edge._initialVertex = finalInitials[iEdge];
                    edge._initialVertex.arity++;
                }
                sanityCheck();
            } // flipLowerLeftUpperRight

            private Mesh()
            {
            }

            private Mesh(double vertPositions[][],
                         int faceIndices[][])
            {
                {
                    // Sanity check face indices,
                    // since it's really hard to debug later
                    // if they are insane...
                    java.util.HashSet boundary = new java.util.HashSet();
                    FORI (iFace, faceIndices.length)
                        FORI (iVertThisFace, faceIndices[iFace].length)
                        {
                            int v0 = faceIndices[iFace][iVertThisFace];
                            int v1 = faceIndices[iFace][(iVertThisFace+1)%faceIndices[iFace].length];
                            assert(INRANGE(0 <=, v0, < vertPositions.length));
                            assert(INRANGE(0 <=, v1, < vertPositions.length));
                            String v0_v1 = ""+v0+"_"+v1;
                            String v1_v0 = ""+v1+"_"+v0;
                            if (boundary.contains(v0_v1))
                            {
                                System.out.println("ERROR in Mesh ctor: "+v0_v1+" appears twice");
                                assert(false);
                            }
                            if (!boundary.remove(v1_v0))
                                boundary.add(v0_v1);
                        }
                    if (!boundary.isEmpty())
                    {
                        System.out.println("ERROR in Mesh ctor: unmatched edge(s):");
                        java.util.Iterator iter = boundary.iterator();
                        while (iter.hasNext())
                        {
                            String v0_v1 = (String)iter.next();
                            System.out.println("    "+v0_v1);
                        }
                        assert(false);
                    }
                }

                FORI (i, vertPositions.length)
                {
                    // adds itself to verts...
                    new Vertex(vertPositions[i][0],  // x
                               vertPositions[i][1],  // y
                               vertPositions[i].length == 2 ? 0 : vertPositions[i][2]); // h
                }
                java.util.Hashtable vertIndsToEdge = new java.util.Hashtable();
                FORI (i, faceIndices.length)
                FORI (j, faceIndices[i].length)
                {
                    int v0 = faceIndices[i][j];
                    int v1 = faceIndices[i][(j+1)%faceIndices[i].length];
                    assert(INRANGE(0 <=, v0, < vertPositions.length));
                    assert(INRANGE(0 <=, v1, < vertPositions.length));
                    String v0_v1 = ""+v0+"_"+v1;
                    String v1_v0 = ""+v1+"_"+v0;
                    if (vertIndsToEdge.get(v0_v1) == null)
                    {
                        Edge edge = new Edge(true); // adds itself, and opposite, to verts
                        vertIndsToEdge.put(v0_v1, edge);
                        vertIndsToEdge.put(v1_v0, edge.opposite());
                        edge.setInitialVertex((Vertex)verts.get(v0));
                        edge.opposite().setInitialVertex((Vertex)verts.get(v1));
                    }
                }
                FORI (i, faceIndices.length)
                FORI (j, faceIndices[i].length)
                {
                    int v0 = faceIndices[i][j];
                    int v1 = faceIndices[i][(j+1)%faceIndices[i].length];
                    int v2 = faceIndices[i][(j+2)%faceIndices[i].length];
                    String v0_v1 = ""+v0+"_"+v1;
                    String v1_v2 = ""+v1+"_"+v2;
                    Edge e01 = (Edge)vertIndsToEdge.get(v0_v1);
                    Edge e12 = (Edge)vertIndsToEdge.get(v1_v2);
                    e01.setNext(e12, true);
                }
                sanityCheck();
            } // Mesh from vertex positions and face indices

            private Mesh(Mesh original)
            {
                int nVerts = original.verts.size();
                FORI (iVert, nVerts)
                {
                    Vertex originalVert = (Vertex)original.getVert(iVert);
                    Vertex newVert = new Vertex(originalVert.x,
                                                originalVert.y,
                                                originalVert.h); // adds itself to verts
                    newVert.weight = originalVert.weight;
                    if (originalVert.momentAndArea != null)
                        newVert.momentAndArea = VecMath.copyvec(originalVert.momentAndArea);
                }
                int nEdges = original.edges.size();
                FORI (iEdge, nEdges)
                    new Edge(false); // adds itself to edges
                assert(verts.size() == nVerts);
                assert(edges.size() == nEdges);

                FORI (iEdge, nEdges)
                {
                    Edge edge = (Edge)edges.get(iEdge);
                    Edge originalEdge = (Edge)original.getEdge(iEdge);
                    assert(edge._initialVertex == null);
                    edge._initialVertex = (Vertex)verts.get(originalEdge._initialVertex._myIndex);
                    edge._initialVertex.arity++;
                    edge._opposite = (Edge)edges.get(originalEdge._opposite._myIndex);
                    edge._prev = (Edge)edges.get(originalEdge._prev._myIndex);
                    edge._next = (Edge)edges.get(originalEdge._next._myIndex);
                }
            } // Mesh copy constructor

            public ArrayList/*<Vertex>*/ verts = new ArrayList();
            public ArrayList/*<Edge>*/ edges = new ArrayList();

            // Convenience functions to get a particular vertex or edge without casting,
            // since this is done a kajillion times
            public final Vertex getVert(int iVert) { return (Vertex)verts.get(iVert); }
            public final Edge   getEdge(int iEdge) { return (Edge)edges.get(iEdge); }


            // Accessors for construction of inner class objects
            // XXX not sure this is the right way to do it
            Edge newEdge(boolean andBack)
            {
                return new Edge(andBack);
            }
            Vertex newVertex(double x, double y, double h)
            {
                return new Vertex(x, y, h);
            }


        } // class Mesh

        //
        // Assumes mesh is topologically a polyhedron,
        // The dual vertex is well defined iff the corresponding primal face
        // is a non-degenerate triangle.
        // Otherwise the primal face will be triangulated arbitrarily
        // and the dual vertex will be set to the weighted average
        // of the vertices computed from each triangle.
        // Indexing of dual edges is same as indexing of original edges.
        // The dual edge points from right to left,
        // with respect to the forward direction of the primal edge.
        //
        public static Mesh makeDualMesh(Mesh primal,
                                        boolean includeNonArity3,
                                        boolean includeInsideOut)
        {
            Mesh dual = new Mesh();
            int nEdges = primal.edges.size();
            FORI (iEdge, nEdges)
                dual.newEdge(false); // adds itself to dual.edges
            assert(dual.edges.size() == nEdges);
            FORI (iEdge, nEdges)
            {
                Mesh.Edge dualEdge = dual.getEdge(iEdge);
                Mesh.Edge primalEdge = primal.getEdge(iEdge);
                dualEdge._opposite = dual.getEdge(primalEdge._opposite._myIndex);
                if (false)
                {
                    // CCW faces in primal
                    // produce CCW faces in dual.
                    // If we do this, then applying makeDualMesh twice
                    // will reverse all the edges,
                    // I think.
                    // (assumimg doShowInsideOutDualVerts is true)
                    dualEdge._next = dual.getEdge(primalEdge._prev._opposite._myIndex);
                    dualEdge._prev = dual.getEdge(primalEdge._opposite._next._myIndex);
                }
                else
                {
                    // CCW faces in primal
                    // produce CW faces in dual.
                    // If we do this, then makeDualMesh(makeDualMesh(mesh))
                    // should return something identical to the original,
                    // I think.
                    // (assumimg doShowInsideOutDualVerts is true)
                    // XXX Odd, this seems to behave better all around (I expected rays to go in wrong direction,
                    // but it works better than the other way... should think about why
                    dualEdge._next = dual.getEdge(primalEdge._next._opposite._myIndex);
                    dualEdge._prev = dual.getEdge(primalEdge._opposite._prev._myIndex);
                }
            }

            //
            // Find all the dual vertices.
            // These correspond to primal faces.
            // Include inside-out ones for starters,
            // to avoid lots of redundant calculation.  We'll remove them afterwards.
            //
            FORI (iEdge, nEdges)
            {
                Mesh.Edge dualEdge0 = dual.getEdge(iEdge);
                if (dualEdge0._opposite._initialVertex != null)
                    continue; // did this one already

                Mesh.Edge primalEdge0 = primal.getEdge(iEdge);

                //
                // Triangulate,
                // using primalEdge0's initial vertex as the hub.
                // The final dual vertex will be the triangle-area-weighted average
                // of the circumcenters of the triangles.
                // (the answer is the same regardless of triangulation...
                // at least for the x,y part.  not sure what this does to the h part.)
                //
                double totalMomentAndArea[] = new double[4]; // zero initially

                double triMomentAndArea[] = new double[4]; // scratch for loop
                Mesh.Vertex v0 = primalEdge0._initialVertex;
                int dualVertArity = 2; // and counting
                for (Mesh.Edge primalEdge = primalEdge0.next();
                     primalEdge.finalVertex() != v0;
                     primalEdge = primalEdge.next())
                {
                    Mesh.Vertex v1 = primalEdge.initialVertex();
                    Mesh.Vertex v2 = primalEdge.finalVertex();

                    SolveForDualMomentAndArea(v0.x, v0.y, v0.h,
                                              v1.x, v1.y, v1.h,
                                              v2.x, v2.y, v2.h,
                                              triMomentAndArea);
                    accumulateMomentAndArea(totalMomentAndArea, triMomentAndArea);

                    dualVertArity++;
                }

                double twiceTotalArea = totalMomentAndArea[3];

                double totalCenter[] = new double[3]; // zero arbitrarily XXX should set it to center of edge? not sure
                if (twiceTotalArea != 0.)
                {
                    totalCenter[0] = totalMomentAndArea[0] / twiceTotalArea;
                    totalCenter[1] = totalMomentAndArea[1] / twiceTotalArea;
                    totalCenter[2] = totalMomentAndArea[2] / SQR(twiceTotalArea);
                }

                if (false)
                {
                    // See what happens if I solve for dual point with more than 3 verts...
                    // XXX experiment with this more, maybe make user control for includeNonArity3 and non-arity-3 strategy
                    double coords[][] = new double[dualVertArity][3];
                    Mesh.Edge primalEdge = primalEdge0;
                    FORI (i, dualVertArity)
                    {
                        Mesh.Vertex v = primalEdge.initialVertex();
                        coords[i][0] = v.x;
                        coords[i][1] = v.y;
                        coords[i][2] = v.h - .5 * (SQR(v.x)+SQR(v.y));
                        primalEdge = primalEdge.next();
                    }
                    SolveForDualPointActual(coords, totalCenter);
                    totalCenter[2] += .5 * (SQR(totalCenter[0]) + SQR(totalCenter[1]));
                }

                Mesh.Vertex dualVert = dual.newVertex(totalCenter[0],
                                                      totalCenter[1],
                                                      totalCenter[2]);
                dualVert.weight = .5 * twiceTotalArea;
                dualVert.momentAndArea = totalMomentAndArea;

                // Set dualVert to be the *final* vertex (i.e. initial vertex of opposite)
                // of each dual edge ending at it.
                for (Mesh.Edge dualEdge = dualEdge0;
                     dualEdge._opposite._initialVertex == null;
                     dualEdge = dualEdge._next._opposite)
                {
                    assert(dualEdge._opposite._initialVertex == null);
                    dualEdge._opposite._initialVertex = dualVert;
                    dualEdge._opposite._initialVertex.arity++;
                }
            }

            // Delete all verts that don't satisfy the criteria.
            // Any edges beginning or ending at such verts
            // will end up with null as their initial or final vertex instead.
            FORI (iEdge, nEdges)
            {
                Mesh.Edge dualEdge0 = dual.getEdge(iEdge);
                Mesh.Vertex initialDualVert = dualEdge0._initialVertex;
                if (initialDualVert == null)
                    continue; // initial dual vertex is already gone
                if ((!includeNonArity3 && initialDualVert.arity != 3)
                 || (!includeInsideOut && initialDualVert.momentAndArea[3] < 0.))
                {
                    for (Mesh.Edge dualEdge = dualEdge0;
                         dualEdge._initialVertex != null;
                         dualEdge = dualEdge._opposite._next)
                    {
                        assert(dualEdge._initialVertex == initialDualVert);
                        dualEdge._initialVertex = null;
                        --initialDualVert.arity;
                    }
                    assert(initialDualVert.arity == 0);
                    int iDualVert = initialDualVert.myIndex();
                    Mesh.Vertex lastDualVert = (Mesh.Vertex)dual.verts.remove(dual.verts.size()-1);
                    if (lastDualVert != initialDualVert)
                    {
                        lastDualVert._myIndex = iDualVert;
                        dual.verts.set(iDualVert, lastDualVert);
                    }
                }
            }
            
            //
            // Give each dual edge a direction.
            //
            FORI (iEdge, nEdges)
            {
                Mesh.Edge dualEdge = dual.getEdge(iEdge);
                if (dualEdge.direction != null)
                    continue; // did this one already

                if (dualEdge._initialVertex != null)
                {
                    if (dualEdge.finalVertex() != null)
                    {
                        // it's a usual edge... get the direction by subtracting vertices
                        // XXX but this is not robust? but it may be better in some senses, especially if we're doing non-triangles too
                        dualEdge.direction = VecMath.normalize(VecMath.vmv(
                            new double[]{dualEdge.finalVertex().x,
                                         dualEdge.finalVertex().y},
                            new double[]{dualEdge._initialVertex.x,
                                         dualEdge._initialVertex.y}));
                    }
                    else
                    {
                        // It's a ray.  Compute the direction
                        // as the perpendicular to the corresponding primal edge.
                        Mesh.Edge primalEdge = primal.getEdge(iEdge);
                        double v0[] = {primalEdge._initialVertex.x,
                                       primalEdge._initialVertex.y};
                        double v1[] = {primalEdge.finalVertex().x,
                                       primalEdge.finalVertex().y};
                        dualEdge.direction = VecMath.normalize(VecMath.xv2(VecMath.vmv(v1, v0)));
                    }

                    assert(dualEdge._opposite.direction == null);
                    dualEdge._opposite.direction = VecMath.sxv(-1., dualEdge.direction);
                }
            }

            return dual;
        } // makeDualMesh()


        public static class Net
        {
            // note that our mesh,dualMesh is the reverse of the applet's
            // (since we want a net of the dual mesh).
            public Net(Mesh mesh, Mesh dualMesh)
            {
                int nEdges = mesh.edges.size();
                int nVerts = mesh.verts.size();
                int nFaces = dualMesh.verts.size();

                this._mesh = mesh;
                this._dualMesh = dualMesh;
                this._edgeStatuses = Arrays.fill(nEdges, UNDECIDED);
                this._nFolds = 0;
                this._nCuts = 0;
                this._nUndecideds = nEdges;
                this._vertComponents = new SizeTrackingMergeFind(nVerts+1); // last may or may not be used
                this._faceComponents = new SizeTrackingMergeFind(nFaces+1); // last may or may not be used

                this._vertToParentEdgeInd = null; // only makes sense when net is complete
                this._topSortedVertInds = null; // only makes sense when net is complete
            }

            public Net(Mesh mesh, Mesh dualMesh, int cuts[])
            {
                this(mesh, dualMesh);
                assert(cuts.length == mesh.verts.size()
                    || (cuts.length == mesh.verts.size()+1 && cuts[cuts.length-1] == -1));
                FORI (iCut, cuts.length)
                    if (cuts[iCut] != -1) // probably originall came from a net's _vertToParentEdgeInd, which can have a -1
                        cut(cuts[iCut]);

                // TODO: the following won't be necessary when we implement the cut-forces-folds thing
                FORI (iEdge, _edgeStatuses.length)
                    if (_edgeStatuses[iEdge] == UNDECIDED)
                        fold(iEdge);

                chooseDirections(mesh.verts.size());
            }

            // This can be called after all edges
            // have been cut or folded.
            // Sets and populates _vertToParentEdgeInd and _topSortedVertInds.
            // _vertToParentEdgeInd[iVert] will point from iVert towards the root.
            // _topSortedVertInds is in order from root to leafs.
            public void chooseDirections(int root)
            {
                assert(_nUndecideds == 0);

                int nEdges = _mesh.edges.size();
                int nVerts = _mesh.verts.size();
                Mesh.Edge cutsOut[][] = new Mesh.Edge[nVerts+1][]; // cut edges leading out of each vertex
                {
                    int nCutsOut[] = new int[cutsOut.length]; // zeros initially
                    FORI (iEdge, nEdges)
                        if (_edgeStatuses[iEdge] == CUT)
                        {
                            Mesh.Edge edge = _mesh.getEdge(iEdge);
                            Mesh.Vertex v0 = edge.initialVertex();
                            int i0 = (v0!=null ? v0.myIndex() : nVerts);
                            nCutsOut[i0]++;
                        }
                    FORI (iVert, cutsOut.length)
                    {
                        cutsOut[iVert] = new Mesh.Edge[nCutsOut[iVert]];
                        nCutsOut[iVert] = 0; // reset for filling step
                    }
                    FORI (iEdge, nEdges)
                        if (_edgeStatuses[iEdge] == CUT)
                        {
                            Mesh.Edge edge = _mesh.getEdge(iEdge);
                            Mesh.Vertex v0 = edge.initialVertex();
                            int i0 = (v0!=null ? v0.myIndex() : nVerts);
                            cutsOut[i0][nCutsOut[i0]++] = edge;
                        }
                    FORI (iVert, cutsOut.length)
                        assert(nCutsOut[iVert] == cutsOut[iVert].length);
                }

                _topSortedVertInds = new int[nVerts+1];
                _vertToParentEdgeInd = Arrays.fill(nVerts+1, -1);

                boolean isSorted[] = new boolean[nVerts+1]; // all false initially
                int nSorted = 0;
                _topSortedVertInds[nSorted++] = root;
                isSorted[root] = true;
                FORI (iSorted, nSorted) // while nSorted is growing!
                {
                    int iVert = _topSortedVertInds[iSorted];
                    FORI (iCutOut, cutsOut[iVert].length)
                    {
                        Mesh.Edge edge = cutsOut[iVert][iCutOut];
                        Mesh.Vertex finalVertex = edge.finalVertex();
                        int jVert = (finalVertex!=null ? finalVertex.myIndex() : nVerts);
                        if (!isSorted[jVert])
                        {
                            isSorted[jVert] = true;
                            _topSortedVertInds[nSorted++] = jVert;
                            _vertToParentEdgeInd[jVert] = edge.opposite().myIndex();
                        }
                    }
                }
                assert(nSorted == nVerts+1);

            } // chooseDirections

            // utility to get past gaps using dual mesh
            private Mesh.Edge getNextEdge(Mesh.Edge edge)
            {
                //System.out.println("in getNextEdge");
                //PRINT(edge);
                Mesh.Edge nextEdge = edge.next();
                if (nextEdge == null)
                {
                    //PRINT(nextEdge);
                    // blech, final vertex is the infinite one.
                    // use dual mesh to find next.
                    assert(_mesh.getEdge(edge.myIndex()) == edge); // the following assumes edge is in _mesh, not _dualMesh. in practice, we won't get here for _dualMesh since _dualMesh is the original primal and therefore complete
                    nextEdge = _mesh.getEdge(_dualMesh.getEdge(edge.myIndex()).next().myIndex());
                }
                //PRINT(nextEdge);
                //System.out.println("out getNextEdge");
                return nextEdge;
            }
            // next in either cut tree or fold tree.
            // tree need not be complete.
            // if edge is from dual mesh, return something from dual mesh.
            public Mesh.Edge nextInTree(Mesh.Edge edge)
            {
                Mesh originalMesh = (_mesh.getEdge(edge.myIndex()) == edge ? _mesh : _dualMesh);
                assert(originalMesh.getEdge(edge.myIndex()) == edge);

                int iEdge = edge.myIndex();
                Mesh meshToUse = (_edgeStatuses[iEdge]==CUT ? _mesh : _dualMesh);
                edge = meshToUse.getEdge(iEdge); // switch from _mesh to meshToUse

                Mesh.Edge nextEdge = getNextEdge(edge);
                while (_edgeStatuses[nextEdge.myIndex()] != _edgeStatuses[iEdge])
                    nextEdge = getNextEdge(nextEdge.opposite()); // next spoke CW

                // switch back from meshToUse to original mesh
                nextEdge = originalMesh.getEdge(nextEdge.myIndex());

                return nextEdge;
            }

            // If iEdge is a cut, return a list of all the folds
            // that are alternate exits out of the same lagoon (in same direction).
            // If iEdge is a fold, do the dual thing in the dual mesh.
            public Mesh.Edge[] alternatives(int iEdge)
            {
                assert(_nUndecideds == 0);
                Mesh meshToUse = (_edgeStatuses[iEdge]==CUT ? _mesh : _dualMesh);
                int nVerts = meshToUse.verts.size();
                int nEdges = meshToUse.edges.size();

                Mesh.Edge edge = meshToUse.getEdge(iEdge);
                Mesh.Vertex v0 = edge.initialVertex();
                Mesh.Vertex v1 = edge.finalVertex();
                int i0 = (v0!=null ? v0.myIndex() : nVerts);
                int i1 = (v1!=null ? v1.myIndex() : nVerts);

                int oEdge = edge.opposite().myIndex();
                assert(_edgeStatuses[oEdge] == _edgeStatuses[iEdge]);


                // could do it in O(n) instead of O(n alpha(n))... whatever
                MergeFind mergeFind = new MergeFind(nVerts+1);
                FORI (jEdge, nEdges)
                {
                    if (_edgeStatuses[jEdge] == _edgeStatuses[iEdge]
                     && jEdge != iEdge
                     && jEdge != oEdge)
                    {
                        Mesh.Edge edgeJ = meshToUse.getEdge(jEdge);
                        Mesh.Vertex w0 = edgeJ.initialVertex();
                        Mesh.Vertex w1 = edgeJ.finalVertex();
                        int j0 = (w0!=null ? w0.myIndex() : meshToUse.verts.size());
                        int j1 = (w1!=null ? w1.myIndex() : meshToUse.verts.size());
                        mergeFind.merge(j0, j1);
                    }
                }
                Mesh.Edge results[] = new Mesh.Edge[nEdges];
                int nResults = 0;

                Mesh.Edge edgeJ = edge.opposite(); // just before entering lagoon
                while (edgeJ != edge)
                {
                    // check for lagoon exits out of the final vertex of edgeJ
                    Mesh.Edge edgeK = getNextEdge(edgeJ);
                    int kEdge = edgeK.myIndex();
                    while (_edgeStatuses[edgeK.myIndex()] != _edgeStatuses[iEdge])
                    {
                        assert(meshToUse.getEdge(kEdge) == edgeK); // we should be consistently using that mesh
                        Mesh.Vertex w0 = meshToUse.getEdge(kEdge).initialVertex();
                        Mesh.Vertex w1 = meshToUse.getEdge(kEdge).finalVertex();
                        int j0 = (w0!=null ? w0.myIndex() : meshToUse.verts.size());
                        int j1 = (w1!=null ? w1.myIndex() : meshToUse.verts.size());
                        if (mergeFind.find(j0) == mergeFind.find(i0)
                         && mergeFind.find(j1) == mergeFind.find(i1))
                        {
                            // result is NOT necessarily edgeK since meshToUse isn't necessarily _mesh.
                            results[nResults++] = (meshToUse==_mesh ? edgeK
                                                                    : _mesh.getEdge(kEdge));
                        }

                        edgeK = getNextEdge(edgeK.opposite()); // next spoke
                        kEdge = edgeK.myIndex();
                    }

                    // advance edgeJ to next edge in lagoon or to edge (original lagoon exit)
                    assert(edgeK == nextInTree(edgeJ));
                    edgeJ = edgeK;
                }

                results = (Mesh.Edge[])Arrays.subarray(results, 0, nResults);
                return results;
            } // alternatives()

            // Make the cut a fold, and vice-versa.
            // The result must still be a tree.
            // In the worst case this has to be O(n),
            // so we don't think too hard, we just do it in O(n) (actually O(n alpha(n))).
            public void swapCutAndFold(int iCut, int iFold)
            {
                if (_edgeStatuses[iCut] == FOLD)
                {
                    int temp;
                    SWAP(iCut, iFold, temp);
                }
                Mesh.Edge cut = _mesh.getEdge(iCut);
                Mesh.Edge fold = _mesh.getEdge(iFold);
                int oCut = cut.opposite().myIndex();
                int oFold = fold.opposite().myIndex();
                assert(_edgeStatuses[iCut] == CUT);
                assert(_edgeStatuses[oCut] == CUT);
                assert(_edgeStatuses[iFold] == FOLD);
                assert(_edgeStatuses[oFold] == FOLD);

                // must have called chooseDirections already...
                assert(_vertToParentEdgeInd != null);
                assert(_topSortedVertInds != null);

                {
                    // check that the fold connects the same two components
                    // that are disconnected by removing the cut.
                    // Don't think too hard, just do this with a simple merge-find thing
                    // (even though we could do it in O(n)... whatever)

                    int nVerts = _mesh.verts.size();
                    int nEdges = _mesh.edges.size();
                    MergeFind mergeFind = new MergeFind(nVerts+1);
                    FORI (iEdge, nEdges)
                    {
                        if (_edgeStatuses[iEdge] == CUT
                         && iEdge != iCut
                         && iEdge != oCut)
                        {
                            Mesh.Edge edge = _mesh.getEdge(iEdge);
                            Mesh.Vertex v0 = edge.initialVertex();
                            Mesh.Vertex v1 = edge.finalVertex();
                            int i0 = (v0!=null ? v0.myIndex() : nVerts);
                            int i1 = (v1!=null ? v1.myIndex() : nVerts);
                            mergeFind.merge(i0, i1);
                        }
                    }

                    {
                        Mesh.Vertex v0 = cut.initialVertex();
                        Mesh.Vertex v1 = cut.finalVertex();
                        int i0 = (v0!=null ? v0.myIndex() : nVerts);
                        int i1 = (v1!=null ? v1.myIndex() : nVerts);
                        assert(mergeFind.find(i0) != mergeFind.find(i1)); // logically true since we're starting with a tree
                    }
                    {
                        Mesh.Vertex v0 = fold.initialVertex();
                        Mesh.Vertex v1 = fold.finalVertex();
                        int i0 = (v0!=null ? v0.myIndex() : nVerts);
                        int i1 = (v1!=null ? v1.myIndex() : nVerts);
                        assert(mergeFind.find(i0) != mergeFind.find(i1)); // make sure it's a legal alternative
                    }
                }

                _edgeStatuses[iCut] = FOLD;
                _edgeStatuses[oCut] = FOLD;
                _edgeStatuses[iFold] = CUT;
                _edgeStatuses[oFold] = CUT;

                // nCuts,nFolds stay the same
                
                int root = _topSortedVertInds[0];
                chooseDirections(root);
            } // swapCutAndFold

            public boolean cuttable(int iEdge)
            {
                if (_edgeStatuses[iEdge] != UNDECIDED)
                    return false;
                Mesh.Edge edge = _mesh.getEdge(iEdge);
                Mesh.Vertex v0 = edge.initialVertex();
                Mesh.Vertex v1 = edge.finalVertex();
                int i0 = (v0!=null ? v0.myIndex() : _mesh.verts.size());
                int i1 = (v1!=null ? v1.myIndex() : _mesh.verts.size());
                return _vertComponents.find(i0)
                    != _vertComponents.find(i1);
            }
            public boolean foldable(int iEdge)
            {
                if (_edgeStatuses[iEdge] != UNDECIDED)
                    return false;
                Mesh.Edge edge = _dualMesh.getEdge(iEdge);
                Mesh.Vertex f0 = edge.initialVertex();
                Mesh.Vertex f1 = edge.finalVertex();
                int i0 = (f0!=null ? f0.myIndex() : _dualMesh.verts.size());
                int i1 = (f1!=null ? f1.myIndex() : _dualMesh.verts.size());
                return _faceComponents.find(i0)
                    != _faceComponents.find(i1);
            }
            public void cut(int iEdge)
            {
                if (_edgeStatuses[iEdge] == CUT)
                    return;

                assert(cuttable(iEdge)); // redundant with checks below, but exercises it

                Mesh.Edge edge = _mesh.getEdge(iEdge);
                int oEdge = edge.opposite().myIndex();

                assert(_edgeStatuses[iEdge] == UNDECIDED);
                assert(_edgeStatuses[oEdge] == UNDECIDED);
                _edgeStatuses[iEdge] = CUT;
                _edgeStatuses[oEdge] = CUT;
                _nUndecideds -= 2;
                _nCuts += 2;

                Mesh.Vertex v0 = edge.initialVertex();
                Mesh.Vertex v1 = edge.finalVertex();
                int i0 = (v0!=null ? v0.myIndex() : _mesh.verts.size());
                int i1 = (v1!=null ? v1.myIndex() : _mesh.verts.size());
                assert(_vertComponents.find(i0)
                    != _vertComponents.find(i1));
                _vertComponents.merge(i0, i1);

                // TODO:
                // for each undecided edge out of v0 or v1
                //     if it's to same component
                //         fold it
                // eek, need to do this for entire component! argh!
                // or, at least, entire smaller of the two components before the merge.
                // total O(n log n)
            }
            public void fold(int iEdge)
            {
                if (_edgeStatuses[iEdge] == FOLD)
                    return;

                assert(foldable(iEdge)); // redundant with checks below, but exercises it

                Mesh.Edge dualEdge = _dualMesh.getEdge(iEdge);
                int oEdge = dualEdge.opposite().myIndex();

                assert(_edgeStatuses[iEdge] == UNDECIDED);
                _edgeStatuses[iEdge] = FOLD;
                _edgeStatuses[oEdge] = FOLD;
                _nUndecideds -= 2;
                _nFolds += 2;

                Mesh.Vertex f0 = dualEdge.initialVertex();
                Mesh.Vertex f1 = dualEdge.finalVertex();
                int i0 = (f0!=null ? f0.myIndex() : _dualMesh.verts.size());
                int i1 = (f1!=null ? f1.myIndex() : _dualMesh.verts.size());
                assert(_faceComponents.find(i0)
                    != _faceComponents.find(i1));
                _faceComponents.merge(i0, i1);

                // TODO:
                // for each undecided edge on f0 or f1
                //     if it's to same face component
                //         cut it
                // eek, need to do this for entire component! argh!
                // or, at least, entire smaller of the two components before the merge.
                // total O(n log n)
            }



            private Mesh _mesh;
            private Mesh _dualMesh;

            private static final int UNDECIDED = -1;
            private static final int FOLD = 0;
            private static final int CUT = 1;
            private int _nFolds, _nCuts, _nUndecideds;
            private int _edgeStatuses[];
            private SizeTrackingMergeFind _vertComponents;
            private SizeTrackingMergeFind _faceComponents;
            private int _vertToParentEdgeInd[];
            private int _topSortedVertInds[];

        } // class Net

        // MergeFind that keeps track of component sizes
        public static class SizeTrackingMergeFind extends MergeFind
        {
            private int sizes[];
            public SizeTrackingMergeFind(int n)
            {
                super(n);
                sizes = new int[n];
            }
            // override's base class's
            public void merge(int i, int j)
            {
                i = find(i);
                j = find(j);
                if (i != j)
                {
                    int combinedSize = sizes[i] + sizes[j];
                    sizes[i] = 0;
                    sizes[j] = 0;
                    super.merge(i, j);
                    sizes[find(i)] = combinedSize;
                }
            }
            public int size(int i)
            {
                return sizes[find(i)];
            }
        } // class SizeTrackingMergeFind





        private static double[][] generateBlueNoiseOnUnitSquare(double stubbornness,
                                                                double overlappingDiskRadiusX,
                                                                double overlappingDiskRadiusY) // radius of disks that half-overlap.  this is twice the radius of disks that don't overlap.
        {
            System.out.println("    in generateBlueNoiseOnUnitSquare");
            long t0millis = System.currentTimeMillis();
            // adding margin of 2*overlappingDiskRadius and then throwing it away afterwards
            // should be enough to avoid any boundary artifacts.
            // XXX add another 2 so we don't need to check... ?
            double minX = -2*overlappingDiskRadiusX;
            double maxX = 1+2*overlappingDiskRadiusX;
            double minY = -2*overlappingDiskRadiusY;
            double maxY = 1+2*overlappingDiskRadiusY;

            // we work with cells of size 1, in which overlappingDiskRadius is .5 (nonoverlapping disk radius is 1)
            int nWorkCellsX = (int)Math.ceil((maxX-minX)/overlappingDiskRadiusX);
            int nWorkCellsY = (int)Math.ceil((maxY-minY)/overlappingDiskRadiusY);
            PRINT(nWorkCellsX);
            PRINT(nWorkCellsY);
            double cells[][][][] = new double[nWorkCellsY][nWorkCellsX][6][2];
            int cellSizes[][] = new int[nWorkCellsY][nWorkCellsX]; // zeros initially
            int nSuccesses = 0;
            int nTries;
            for (nTries = 0;
                 nTries==0
              || nTries < nSuccesses * stubbornness;  // first one is guaranteed to be a success
                 ++nTries)
            {
                double x = Math.random() * nWorkCellsX;
                double y = Math.random() * nWorkCellsY;
                int iX1 = (int)(x+.5);
                int iX0 = iX1-1;
                int iY1 = (int)(y+.5);
                int iY0 = iY1-1;
                iX0 = CLAMP(iX0, 0, nWorkCellsX-1);
                iX1 = CLAMP(iX1, 0, nWorkCellsX-1);
                iY0 = CLAMP(iY0, 0, nWorkCellsY-1);
                iY1 = CLAMP(iY1, 0, nWorkCellsY-1);
                boolean bad = false;
                for (int iY = iY0; iY <= iY1 && !bad; ++iY)
                {
                    for (int iX = iX0; iX <= iX1 && !bad; ++iX)
                    {
                        double cell[][] = cells[iY][iX];
                        double cellSize = cellSizes[iY][iX];
                        for (int i = 0; i < cellSize; ++i)
                        {
                            double q[] = cell[i];
                            // if distance from q to new point < .5
                            if (SQR(x-q[0])+SQR(y-q[1]) < .25)
                            {
                                bad = true;
                                break;
                            }
                        }
                    }
                }
                if (!bad)
                {
                    int iX = (int)x;
                    int iY = (int)y;
                    iX = CLAMP(iX, 0, nWorkCellsX-1);
                    iY = CLAMP(iY, 0, nWorkCellsY-1);
                    double entry[] = cells[iY][iX][cellSizes[iY][iX]++];
                    entry[0] = x;
                    entry[1] = y;
                    nSuccesses++;
                }
            }

            PRINT(nTries);
            PRINT(nSuccesses);

            double answer[][] = new double[nSuccesses][];
            int iInCells = 0;
            int iAnswer = 0;
            int margin = 1; // should be 1, can set to 0 to see the margin too
            FORI (iX, nWorkCellsX-2*margin)
            FORI (iY, nWorkCellsY-2*margin)
            {
                double cell[][] = cells[iY+margin][iX+margin];
                double cellSize = cellSizes[iY+margin][iX+margin];
                for (int i = 0; i < cellSize; ++i)
                {
                    double scratch[] = cell[i]; 
                    answer[iAnswer] = scratch;
                    scratch[0] = LERP(minX, maxX, scratch[0]/nWorkCellsX);
                    scratch[1] = LERP(minY, maxY, scratch[1]/nWorkCellsY);
                    if (INRANGE(0 <=, scratch[0], <= 1)
                     && INRANGE(0 <=, scratch[1], <= 1))
                        iAnswer++;
                    iInCells++;
                }
            }
            if (margin == 0)
                assert(iInCells == answer.length);
            answer = (double[][])Arrays.subarray(answer, 0, iAnswer);
            long t1millis = System.currentTimeMillis();
            double seconds = (t1millis-t0millis) * 1e-3;
            System.out.println("    out generateBlueNoiseOnUnitSquare ("+seconds+" seconds)");
            return answer;
        } // generateBlueNoiseOnUnitSquare

        // See paper "Generating Random Spanning Trees
        // More Quickly than the Cover Time" by David Bruce Wilson.
        // But, can't I do it in O(n) time,
        // by simply growing the tree and picking a random new edge out of it on every step?
        // (answer: no, the next edge out of the spanning tree can't be picked uniformly)
        private static void analyzeRandomSpanningTrees(Mesh mesh)
        {
            System.out.println("    in analyzeRandomSpanningTrees");
            int nEdges = mesh.edges.size();
            PRINT(nEdges);
            if (nEdges > 24)
            {
                System.out.println("too many edges, bailing");
                return;
            }

            // convert to simpler data structure...

            int nVerts = mesh.verts.size();
            int e2v[][] = new int[nEdges][2]; // edge to verts
            int e2opposite[] = new int[nEdges];
            int e2next[] = new int[nEdges];

            boolean infiniteVertexUsed = false; // until proven otherwise
            FORI (iEdge, nEdges)
            {
                Mesh.Edge edge = mesh.getEdge(iEdge);
                Mesh.Vertex v0 = edge.initialVertex();
                Mesh.Vertex v1 = edge.finalVertex();
                int i0 = v0==null ? nVerts : v0.myIndex();
                int i1 = v1==null ? nVerts : v1.myIndex();
                e2v[iEdge][0] = i0;
                e2v[iEdge][1] = i1;
                if (v0 == null || v1 == null)
                    infiniteVertexUsed = true;
                e2opposite[iEdge] = edge.opposite().myIndex();
                Mesh.Edge next = edge.next();
                if (next == null)
                {
                    // final vertex is the infinite one; to find next, need to walk backwards around the face
                    next = edge;
                    while (next.prev() != null)
                        next = next.prev();
                }
                e2next[iEdge] = next.myIndex();
            }
            PRINTARRAY(e2v);
            PRINTARRAY(e2opposite);
            PRINTARRAY(e2next);
            PRINT(nVerts);
            PRINT(infiniteVertexUsed);
            if (infiniteVertexUsed)
                nVerts++;
            PRINT(nVerts);

            int v2e[][] = new int[nVerts][];
            {
                int arities[] = new int[nVerts]; // zeros initially
                FORI (iEdge, nEdges)
                    arities[e2v[iEdge][0]]++;
                FORI (iVert, nVerts)
                {
                    v2e[iVert] = new int[arities[iVert]];
                    arities[iVert] = 0;
                }
                FORI (iEdge, nEdges)
                {
                    int iVert = e2v[iEdge][0];
                    if (arities[iVert] == 0)
                    {
                        v2e[iVert][0] = iEdge; // arbitrary edge out of the vertex
                        arities[iVert] = 1;
                    }
                }
                FORI (iVert, nVerts)
                {
                    if (arities[iVert] == 1)
                    {
                        while (arities[iVert] < v2e[iVert].length)
                        {
                            v2e[iVert][arities[iVert]] = e2next[e2opposite[v2e[iVert][arities[iVert]-1]]]; // next one CW around the vertex
                            arities[iVert]++;
                        }
                        assert(e2next[e2opposite[v2e[iVert][arities[iVert]-1]]] == v2e[iVert][0]);
                    }
                    assert(arities[iVert] == v2e[iVert].length);
                    FORI (iEdgeOut, v2e[iVert].length)
                        assert(e2v[v2e[iVert][iEdgeOut]][0] == iVert);
                }
            }
            PRINTARRAY(v2e);

            java.util.Random generator = new java.util.Random();

            int counts[] = new int[1<<nEdges];

            int nTries = 1000*1000;
            FORI (iTry, nTries)
            {
                // Make a random spanning tree, and increment its count.

                int whichTree;

                if (false)
                {
                    // wilson's algorithm with r=0
                    boolean inTree[] = new boolean[nVerts]; // false initially
                    int next[] = new int[nVerts]; // vertex to next *edge*, not vertex
                    int r = 0; // arbitrarily
                    next[r] = -1;
                    inTree[r] = true;
                    FORI (i, nVerts)
                    {
                        int u = i;
                        while (!inTree[u])
                        {
                            next[u] = v2e[u][generator.nextInt(v2e[u].length)];
                            u = e2v[next[u]][1];
                        }
                        u = i;
                        while (!inTree[u])
                        {
                            inTree[u] = true;
                            u = e2v[next[u]][1];
                        }
                    }
                    whichTree = 0;
                    FORI (iVert, nVerts)
                    {
                        int iEdge = next[iVert];
                        if (iEdge != -1)
                        {
                            whichTree |= (1 << iEdge);
                            whichTree |= (1 << e2opposite[iEdge]);
                        }
                    }
                }
                else if (false)
                {
                    // random walk from 0,
                    // keeping *last* edge to each new vertex.
                    // This apparently isn't uniform!
                    boolean inTree[] = new boolean[nVerts]; // false initially
                    int prev[] = VecMath.fillvec(nVerts, -1); // vertex to prev *edge*, not vertex
                    int r = 0; // arbitrarily

                    inTree[r] = true;
                    int nVertsInTree = 1;
                    int u = r;
                    while (nVertsInTree < nVerts)
                    {
                        int iEdge = v2e[u][generator.nextInt(v2e[u].length)];
                        u = e2v[iEdge][1];
                        prev[u] = iEdge; // clobber old value if any, so we retain last edge to u
                        if (!inTree[u])
                        {
                            inTree[u] = true;
                            nVertsInTree++;
                        }
                    }

                    whichTree = 0;
                    FORI (iVert, nVerts)
                    {
                        int iEdge = prev[iVert];
                        if (iEdge != -1)
                        {
                            whichTree |= (1 << iEdge);
                            whichTree |= (1 << e2opposite[iEdge]);
                        }
                    }
                }
                else if (false)
                {
                    // random walk from 0,
                    // keeping *first* edge to each new vertex.
                    // This seems to be uniform.
                    boolean inTree[] = new boolean[nVerts]; // false initially
                    int prev[] = VecMath.fillvec(nVerts, -1); // vertex to prev *edge*, not vertex
                    int r = 0; // arbitrarily

                    inTree[r] = true;
                    int nVertsInTree = 1;
                    int u = r;
                    while (nVertsInTree < nVerts)
                    {
                        int iEdge = v2e[u][generator.nextInt(v2e[u].length)];
                        u = e2v[iEdge][1];
                        if (!inTree[u])
                        {
                            prev[u] = iEdge; // only record first edge to u
                            inTree[u] = true;
                            nVertsInTree++;
                        }
                    }

                    whichTree = 0;
                    FORI (iVert, nVerts)
                    {
                        int iEdge = prev[iVert];
                        if (iEdge != -1)
                        {
                            whichTree |= (1 << iEdge);
                            whichTree |= (1 << e2opposite[iEdge]);
                        }
                    }
                }
                else if (true)
                {
                    // my method--
                    // start at vertex 0 and grow the tree randomly.
                    // Oh damn, it's not uniform after all-- try it on a triangle:
                    // the probabilities are 1/4,1/4,1/2.
                    // Can it be fixed?
                    boolean inTree[] = new boolean[nVerts]; // false initially
                    int prev[] = VecMath.fillvec(nVerts, -1);

                    int nPotentialNextEdges = 0;
                    int potentialNextEdges[] = new int[nEdges];
                    int e2indexInPotentialNextEdges[] = VecMath.fillvec(nEdges, -1);

                    int u = 0;
                    inTree[u] = true;
                    FORI (iEdgeOut, v2e[u].length)
                    {
                        int iEdge = v2e[u][iEdgeOut];
                        if (!inTree[e2v[iEdge][1]])
                        {
                            e2indexInPotentialNextEdges[iEdge] = nPotentialNextEdges;
                            potentialNextEdges[nPotentialNextEdges] = iEdge;
                            nPotentialNextEdges++;
                        }
                    }
                    while (nPotentialNextEdges > 0)
                    {
                        int iPotentialNextEdge = generator.nextInt(nPotentialNextEdges);
                        int iEdge = potentialNextEdges[iPotentialNextEdge];
                        u = e2v[iEdge][1];
                        assert(!inTree[u]);
                        inTree[u] = true;
                        prev[u] = iEdge;

                        // For each edge out of u:
                        // if it's back to the tree (which includes iEdge itself),
                        // remove that edge from the boundary.
                        // otherwise, add that edge to the boundary.
                        FORI (iEdgeOut, v2e[u].length)
                        {
                            int jEdge = v2e[u][iEdgeOut];
                            boolean isBackToTree = inTree[e2v[jEdge][1]];
                            assert(isBackToTree == (e2indexInPotentialNextEdges[e2opposite[jEdge]] != -1));
                            if (isBackToTree)
                            {
                                // remove (opposite of) jEdge from boundary.
                                int index = e2indexInPotentialNextEdges[e2opposite[jEdge]];
                                assert(index != -1);
                                e2indexInPotentialNextEdges[e2opposite[jEdge]] = -1;
                                if (index != nPotentialNextEdges-1)
                                {
                                    // move the last one into the gap
                                    int kEdge = potentialNextEdges[nPotentialNextEdges-1];
                                    potentialNextEdges[index] = kEdge;
                                    e2indexInPotentialNextEdges[kEdge] = index;
                                }
                                --nPotentialNextEdges;
                            }
                            else
                            {
                                // add edge to boundary
                                e2indexInPotentialNextEdges[jEdge] = nPotentialNextEdges;
                                potentialNextEdges[nPotentialNextEdges] = jEdge;
                                nPotentialNextEdges++;
                            }
                        }
                    }
                    FORI (iVert, nVerts)
                        assert(inTree[iVert]);

                    whichTree = 0;
                    FORI (iVert, nVerts)
                    {
                        int iEdge = prev[iVert];
                        if (iEdge != -1)
                        {
                            whichTree |= (1 << iEdge);
                            whichTree |= (1 << e2opposite[iEdge]);
                        }
                    }
                }

                //PRINT(whichTree);

                counts[whichTree]++;

            }
            //PRINTARRAY(counts);

            SortStuff.sort(counts);
            int nZeros = 0;
            while (nZeros < counts.length && counts[nZeros] == 0)
                nZeros++;
            counts = (int[])Arrays.subarray(counts, nZeros, counts.length-nZeros);
            PRINTARRAY(counts);

            System.out.println("    out analyzeRandomSpanningTrees");
        } // analyzeRandomSpanningTrees


        // Holds the information needed to undo and redo a mesh editing operation.
        // This implementation is very simple and inefficient;
        // it just stores a complete copy of the mesh before and after
        // the editing operation.
        private static class UndoItem
        {
            public static class State
            {
                public Mesh mesh;
                public boolean doContinuouslyDelaunayize;
                public boolean doOptimize;
                public int optimizationTypeIndex;
                public int selectedTris[][];
                public int selectedDualVertIndices[];
                public int netCuts[];
                public State(Mesh mesh, boolean doContinuouslyDelaunayize, boolean doOptimize, int optimizationTypeIndex, int selectedTris[][], int selectedDualVertIndices[], Net net)
                {
                    this.mesh = new Mesh(mesh);
                    this.doContinuouslyDelaunayize = doContinuouslyDelaunayize;
                    this.doOptimize = doOptimize;
                    this.optimizationTypeIndex = optimizationTypeIndex;
                    this.selectedTris = (int[][])Arrays.copy(selectedTris, 2);
                    this.selectedDualVertIndices = VecMath.copyvec(selectedDualVertIndices);
                    this.netCuts = (net==null ? null : VecMath.copyvec(net._vertToParentEdgeInd));
                }
            }
            public State before;
            public State after;
            public UndoItem(State before, State after)
            {
                this.before = before;
                this.after = after;
            }
        } // class UndoItem


        /*
            Note, the h given here are the "actual" positions v.h - .5 * (x^2 + y^2).
            where v.h is the offset stored in the vertex.

            Given:
                x0,y0,h0
                x1,y1,h1
                x2,y2,h2
            representing an infinitesimal triangle
            whose vertices are infinitesimally-squared away from the unit sphere
            at the tangent plane z=1:
                x0 eps, y0 eps, 1 + h0 eps^2
                x1 eps, y1 eps, 1 + h1 eps^2
                x2 eps, y2 eps, 1 + h2 eps^2
            we want to find x,y,h
            representing the point:
                x eps, y eps, 1 + h eps^2
            that is the intersection point of the 3 planes
            whose closest-points-to-origin are the reciprocals of the original 3 points.
            That is,
                [x0 eps, y0 eps, 1 + h0 eps^2] [x eps      ]   [1]
                [x1 eps, y1 eps, 1 + h1 eps^2] [y eps      ] = [1]
                [x2 eps, y2 eps, 1 + h2 eps^2] [1 + h eps^2]   [1]
            i.e.
                [ x x0 eps^2 + y y0 eps^2 + 1 + (h+h0)eps^2 + h h0 eps^4]   [1]
                [ x x1 eps^2 + y y1 eps^2 + 1 + (h+h1)eps^2 + h h1 eps^4] = [1]
                [ x x2 eps^2 + y y2 eps^2 + 1 + (h+h2)eps^2 + h h2 eps^4]   [1]
            the eps^4 terms are insignificant, so drop them:
                [ x x0 eps^2 + y y0 eps^2 + 1 + (h+h0)eps^2]   [1]
                [ x x1 eps^2 + y y1 eps^2 + 1 + (h+h1)eps^2] = [1]
                [ x x2 eps^2 + y y2 eps^2 + 1 + (h+h2)eps^2]   [1]
            i.e.
                [ x x0 eps^2 + y y0 eps^2 + (h+h0)eps^2]   [0]
                [ x x1 eps^2 + y y1 eps^2 + (h+h1)eps^2] = [0]
                [ x x2 eps^2 + y y2 eps^2 + (h+h2)eps^2]   [0]
            Divide both sides by eps^2:
                [ x x0 + y y0 + (h+h0)]   [0]
                [ x x1 + y y1 + (h+h1)] = [0]
                [ x x2 + y y2 + (h+h2)]   [0]
            i.e.
                [ x x0 + y y0 + h]   [-h0]
                [ x x1 + y y1 + h] = [-h1]
                [ x x2 + y y2 + h]   [-h2]
            i.e.
                [ x0 y0 1] [x]   [-h0]
                [ x1 y1 1] [y] = [-h1]
                [ x2 y2 1] [h]   [-h2]
            Easy!
        */
        private static void SolveForDualPointActual(double x0, double y0, double h0,
                                              double x1, double y1, double h1,
                                              double x2, double y2, double h2,
                                              double result[])
        {
            double M[][] = {
                {x0,y0,1},
                {x1,y1,1},
                {x2,y2,1},
            };
            double b[] = {
                -h0,
                -h1,
                -h2,
            };

            if (result.length == 3)
                VecMath.invmxv(result,M,b);
            else // result.length == 2, just copy the first two
                VecMath.copyvec(result, VecMath.invmxv(M,b));
        } // SolveForDualPointActual

        private static void SolveForDualPoint(double x0, double y0, double h0,
                                              double x1, double y1, double h1,
                                              double x2, double y2, double h2,
                                              double result[])
        {
            SolveForDualPointActual(x0, y0, h0 - .5 * (SQR(x0) + SQR(y0)),
                                    x1, y1, h1 - .5 * (SQR(x1) + SQR(y1)),
                                    x2, y2, h2 - .5 * (SQR(x2) + SQR(y2)),
                                    result);
            if (result.length == 3)
            {
                result[2] += .5 * (SQR(result[0]) + SQR(result[1]));

                if (false)
                {
                    System.out.println("checking SolveForDualMomentAndArea");
                    double dualMomentAndArea[] = new double[4];
                    SolveForDualMomentAndArea(x0,y0,h0,
                                              x1,y1,h1,
                                              x2,y2,h2,
                                              dualMomentAndArea);
                    double A = dualMomentAndArea[3];
                    PRINT(A);
                    double shouldBeResult[] = {
                        dualMomentAndArea[0] / A,
                        dualMomentAndArea[1] / A,
                        dualMomentAndArea[2] / (A*A),
                    };
                    PRINTVEC(result);
                    PRINTVEC(shouldBeResult);
                    assert(VecMath.equals(shouldBeResult, result, 1e-6));
                    System.out.println("done checking SolveForDualMomentAndArea");
                }
            }
        } // SolveForDualPoint


        // Optimized robust version of SolveForDualPoint.
        // Moments can be used in robust center-of-mass calculations
        // even if individual weights are tiny (or zero).
        // Works in local virtual coord space of x0,y0,h0.
        private static void SolveForDualMomentAndArea(double x0, double y0, double h0,
                                                      double x1, double y1, double h1,
                                                      double x2, double y2, double h2,
                                                      double result[]) // x*A, y*A, A, or
                                                                       // x*A, y*A, h*A^2, A
        {
            // convert from global virtual coord space to local virtual coord space...
            double X1 = x1 - x0;
            double Y1 = y1 - y0;
            double H1 = h1 - h0;
            double X2 = x2 - x0;
            double Y2 = y2 - y0;
            double H2 = h2 - h0;

            // convert from virtual to actual...
            H1 -= .5 * (SQR(X1) + SQR(Y1));
            H2 -= .5 * (SQR(X2) + SQR(Y2));

            // We're solving:
            //    0  0  1     X =   0
            //    X1 Y1 1  *  Y    -H1
            //    X2 Y2 1     H    -H2
            // I.e. H = 0 and:
            //    X1 Y1  *  X  =  -H1
            //    X2 Y2     Y  =  -H2
            //
            //    X  =  Y2 -Y1  *  -H1
            //    Y    -X2  X1     -H2
            //         ---------------
            //          X1*Y2 - X2*Y1

            double A = X1*Y2 - X2*Y1;
            double XA = -Y2*H1 + Y1*H2;
            double YA =  X2*H1 - X1*H2;

            // to convert from local virtual coord space to global virtual coord space:
            //         x = x0 + X
            //           = x0 + XA/A
            //   so  x*A = (x0 + XA/A)*A
            //           = x0*A + XA
            // etc.

            result[0] = XA + x0*A;
            result[1] = YA + y0*A;

            if (result.length == 3)
                result[2] = A;
            else
            {
                // convert from actual (H=0) to virtual...
                double HAA = .5 * (SQR(XA) + SQR(YA));
                result[2] = HAA - h0*(A*A);  // - instead of +, because raising features in the primal corresponds to lowering them in the dual (I think that's why)
                result[3] = A;
            }
        } // SolveForDualMomentAndArea



        // Experimenting with when it's more than a triangle... invmxv will do a least-squares solve,
        // which will be what we want in the case the input is coplanar
        private static void SolveForDualPointActual(double coords[][/*3*/],
                                              double result[])
        {
            double M[][] = new double[coords.length][3];
            double b[] = new double[coords.length];
            FORI (i, coords.length)
            {
                M[i][0] = coords[i][0];
                M[i][1] = coords[i][1];
                M[i][2] = 1.;
                b[i] = -coords[i][2];
            }
            if (result.length == 3)
                VecMath.invmxv(result,M,b);
            else // result.length == 2, just copy the first two
                VecMath.copyvec(result, VecMath.invmxv(M,b));
        } // SolveForDualPointActual, more than 3 inputs

        // Calculate the angle C, opposite side c,
        // given side lengths a, b, c,
        // using c^2 = a^2 + b^2 - 2*a*b*cos(C)
        private static double triangleAngle(double a, double b, double c)
        {
            return Math.acos((a*a + b*b - c*c) / (2*a*b));
        }

        // Find vertex v2 that completes the triangle with given edge lengths,
        // such that v0,v1,v2 are CCW.
        private static double[] completeTriangle(double v0[],
                                                 double v1[],
                                                 double dist12,
                                                 double dist20)
        {
            // Make sure has only 2 entries
            v0 = new double[]{v0[0],v0[1]};
            v1 = new double[]{v1[0],v1[1]};
            double ang0 = triangleAngle(VecMath.dist(v0,v1), dist20, dist12);
            double dir01[] = VecMath.normalize(VecMath.vmv(v1,v0));
            double v2[] = VecMath.sxvpsxvpsxv(
                1.,                    v0,
                dist20*Math.cos(ang0), dir01,
                dist20*Math.sin(ang0), VecMath.xv2(dir01));
            return v2;
        } // completeTriangle

        private static double twiceTriangleArea(double x0, double y0,
                                                double x1, double y1,
                                                double x2, double y2)
        {
            return (x1-x0)*(y2-y0) - (x2-x0)*(y1-y0);
        }
        private static double twiceTriangleArea(double v0[],
                                           double v1[],
                                           double v2[])
        {
            return twiceTriangleArea(v0[0], v0[1],
                                     v1[0], v1[1],
                                     v2[0], v2[1]);
        }

        // eps is in linear units
        private static boolean edgesCrossOrCloseToIt(double a0x, double a0y,
                                                     double a1x, double a1y,
                                                     double b0x, double b0y,
                                                     double b1x, double b1y,
                                                     double eps)
        {
            return twiceTriangleArea(a0x,a0y,
                                     a1x,a1y,
                                     b1x,b1y)
                 * twiceTriangleArea(a1x,a1y,
                                     a0x,a0y,
                                     b0x,b0y) >= -eps*eps*eps*eps
                && twiceTriangleArea(b0x,b0y,
                                     b1x,b1y,
                                     a0x,a0y)
                 * twiceTriangleArea(b1x,b1y,
                                     b0x,b0y,
                                     a1x,a1y) >= -eps*eps*eps*eps;
        } // edgesCrossOrCloseToIt

        private static double distSqrdFromPointToSeg(double x, double y,
                                                     double x0, double y0,
                                                     double x1, double y1)
        {
            double v[] = {x-x0,y-y0};
            double v1[] = {x1-x0,y1-y0};
            if (VecMath.normsqrd(v1) == 0.)
                return VecMath.normsqrd(v);
            double t = VecMath.dot(v,v1)
                     / VecMath.dot(v1,v1);
            t = CLAMP(t, 0., 1.);
            double vprojectedOntoV1[] = VecMath.sxv(t, v1);
            return VecMath.distsqrd(v, vprojectedOntoV1);
        }
        private static double distSqrdFromPointToRay(double x, double y,
                                                     double x0, double y0,
                                                     double xDir, double yDir) // need not be unit length
        {
            double v[] = {x-x0,y-y0};
            double v1[] = {xDir, yDir};
            if (VecMath.normsqrd(v1) == 0.)
                return VecMath.normsqrd(v);
            double t = VecMath.dot(v,v1)
                     / VecMath.dot(v1,v1);
            t = MAX(t, 0.);
            double vprojectedOntoV1[] = VecMath.sxv(t, v1);
            return VecMath.distsqrd(v, vprojectedOntoV1);
        }

        private static void accumulateMomentAndArea(double accumulator[/*3 or 4*/],
                                                    double increment[/*3 or 4*/])
        {
            accumulator[0] += increment[0]; // x/A
            accumulator[1] += increment[1]; // y/A
            if (accumulator.length == 4
             && increment.length == 4)
                accumulator[2] += increment[2]; // h/A^2
            accumulator[accumulator.length-1] += increment[increment.length-1]; // A
        }

        public void drawBitmapCentered(java.awt.Graphics g,
                                       java.awt.Dimension size,
                                       String[] rows)
        {
            int x0 = (size.width - rows[0].length())/2;
            int y0 = (size.height - rows.length)/2;
            FORI (iRow, rows.length)
            {
                String row = rows[iRow];
                int nCols = row.length();
                FORI (iCol, nCols)
                {
                    char c = row.charAt(iCol);
                    if (c != ' ')
                        g.fillRect(x0+iCol, y0+iRow, 1, 1);
                }
            }
        } // drawBitmapCentered


    //
    // App-specific variables...
    //
        private UndoTreeSquirrel undoTreeSquirrel = new UndoTreeSquirrel();
        private Mesh mesh = new Mesh();
        private Net theNet = null; // computed on demand
        private Mesh _dualMesh = null; // computed on demand
        private Mesh _meshOfDualMesh = null; // possibly ill-advised attempt to automatically invalidate dualMesh when mesh gets replaced in various ways
        public Mesh getDualMesh()
        {
            if (_dualMesh == null
             || _meshOfDualMesh != mesh)
            {
                _dualMesh = makeDualMesh(mesh,
                                         false,  // includeNonArity3
                                         false); // includeInsideOut
                _meshOfDualMesh = mesh;
                theNet = null;
            }
            return _dualMesh;
        }
        public void dirtyDualMesh()
        {
            _dualMesh = null;
            _meshOfDualMesh = null; // no sense keeping a ref to it
            theNet = null;
        }
        private int beingDraggedVertIndex = -1;
        private int beingDraggedNetEdgeIndex = -1;
        private boolean rubberBandingNewEdge = false;
        private int[][] selectedTris = {};
        private int[] selectedDualVertIndices = {};
        private Mesh meshOfSelectedTris = mesh; // possibly ill-advised attempt to invalidate selectedTris and selectedDualVertIndices automatically so people can just reset mesh without having to remember

        // XXX is there an easier way to associate that stuff with a certain object? maybe be able to just pass this object to addListener, and make it automatically remove the listener when I go away?
        private Listenable.Listener doContinuouslyDelaunayizeListener = null;
        private Listenable.Listener doOptimizeListener = null;
        private Listenable.Listener optimizationTypeIndexListener = null;
        private Listenable.Listener showMagListener = null;
        private Listenable.Listener showNetListener = null;
        private Listenable.Listener netMethodListener = null;

        private Listenable.Boolean doContinuouslyDelaunayize = new Listenable.Boolean(false);
        private Listenable.Boolean doOptimize = new Listenable.Boolean(false);
            private static final int OPTIMIZE_BARYCENTRICS_LEAST_SQUARES = 0;
            private static final int OPTIMIZE_BARYCENTRICS_INFINITY_NORM = 1;
            private static final int OPTIMIZE_BARYCENTRICS_MAX_MIN = 2;
            private static final int OPTIMIZE_LENGTHS_LEAST_SQUARES = 3;
            private static final int OPTIMIZE_LENGTHS_INFINITY_NORM = 4;
            private static final int OPTIMIZE_LENGTHS_MAX_MIN = 5;
            private static final int OPTIMIZE_LENGTHS_SUM = 6;
            private static final String optimizationTypeNames[] = {
                "BARYCENTRICS_LEAST_SQUARES from all 1/3's",
                "BARYCENTRICS_INFINITY_NORM from all 1/3's",
                "BARYCENTRICS_MAX_MIN",
                "LENGTHS_LEAST_SQUARES from all .25's",
                "LENGTHS_INFINITY_NORM from all .25's",
                "LENGTHS_MAX_MIN with fixed sum",
                //"LENGTHS_SUM with every edge length >= .25",
            };
            private static final int availableOptimizationTypes[] = {
                OPTIMIZE_BARYCENTRICS_LEAST_SQUARES,
                OPTIMIZE_BARYCENTRICS_INFINITY_NORM,
                OPTIMIZE_BARYCENTRICS_MAX_MIN,
                OPTIMIZE_LENGTHS_LEAST_SQUARES,
                OPTIMIZE_LENGTHS_INFINITY_NORM,
                OPTIMIZE_LENGTHS_MAX_MIN,
                //OPTIMIZE_LENGTHS_SUM,
            };
        private Listenable.Int optimizationTypeIndex = new Listenable.Int(0, availableOptimizationTypes.length-1, OPTIMIZE_LENGTHS_MAX_MIN); // min, max, default
        int optimizationType = availableOptimizationTypes[optimizationTypeIndex.get()];


            private static final int NETMETHOD_UPWARD = 0;
            private static final int NETMETHOD_OUTWARD = 1;
            private static final int NETMETHOD_RANDOM = 2;
            private static final String netMethodNames[] = {
                "Upward",
                "Outward",
                "Random",
            };
        private Listenable.Int netMethod = new Listenable.Int(0, netMethodNames.length-1, NETMETHOD_OUTWARD);

        private java.awt.Canvas theCanvas = null;

        // hack
        private int netless8OptimizationIndex = -1;
        private double netless8OptimizationPath[][][] = null;
        private double netless8OptimizationPathGoodnesses[] = null;

        private boolean showLabels = false;
        private boolean doArrowsTowardsSharpestDihedrals = false;
        private boolean doArrowsTowardsShortestEdges = false;
        private boolean doShowInsideOutDualVerts = false; // might also be nice to have option for implicit primal vertex in middle of outer face, so that dual will be single-face-bounded... and maybe ctrl-up,ctrl-down will adjust the height of that face

        private boolean doShowPositiveOrthantnessVisualization = false; // XXX total hack-- it's cool but put it somewhere else!!
        private int showTriangles = 2; // 0: nothing, 1: verts, 2: and tris
        private Listenable.Boolean showNet = new Listenable.Boolean(false);
        private boolean showNetFlow = true;
        private int netFlowIndex = 0;
        private int highlightedDualEdgeIndex = -1;
        private boolean showOrigin = false;
        private boolean showGrid = true;
        private boolean snapToGrid = false;
        private double gridSnapQuantum = 1./64; // no way to change, currently

    //
    // Applet-generic member variables...
    //
        private GraphicsAntiAliasingSetter graphicsAntiAliasingSetter;
        private int eventVerbose = 0; // can set with eventVerbose=1 on command line
        private static int nonEventVerbose = 0; // so static classes can refer to it
        private boolean doAntiAliasing = false;
        private boolean implementAntiAliasingInHardware = true; // XXX should have a better name for this-- really mean let java runtime do it
        private boolean doDoubleBuffer = true;
        private java.awt.Image backBufferImage = null;
        private MyGraphics mostRecentGraphics = null;
        private double globalMagFactor = 1.; // no way to set, currently... phase out?
        private Listenable.Boolean showMag = new Listenable.Boolean(false);
        private int magFactor = 9;
        private int magWidth = 25;


        private double prevP[] = null;

    //
    // Track mouse state...
    // (I think java newer versions of java (XXX starting when?)
    // let you query from the events themselves,
    // but e.g. in 1.1 there is no way to tell whether button1
    // is down during a drag without keeping state
    //
        private boolean button1IsDown = false;
        private boolean button2IsDown = false;
        private boolean button3IsDown = false;
        private UndoItem.State stateWhenPressed = null;


    //
    // Main...
    //
    public static void main(final String args[])
    {
        System.out.println("in main");

        final java.awt.Frame frame = new java.awt.Frame("Shephards Play Applet") {
            public boolean handleEvent(java.awt.Event event)
            {
                switch(event.id)
                {
                    case java.awt.Event.WINDOW_DESTROY:
                        System.out.println("bye!");
                        // Empirically, either of the following
                        // cause the app to exit-- do both to be safe!
                        // (XXX I've heard rumors that just doing dispose()
                        //  messes up the debugger)
                        // (XXX but doing exit is evil)
                        dispose(); // hide() doesn't delete the windows
                        System.exit(0);
                        return true;
                }
                return super.handleEvent(event);
            }
        };

        // ARGH! The above no longer works in java 1.5!
        // have to use a listener I guess...
        frame.addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent we) {
                System.out.println("ciao!");
                frame.dispose(); // hide() doesn't delete the windows
                System.exit(0);
            }
        });

        final ShephardsPlayApplet applet = new ShephardsPlayApplet();

        // XXX the following seems to be necessary, or getParameter() will crash, at least in 1.4.  Want to send params from command line anyway.
        applet.setStub(new java.applet.AppletStub() {
             public void appletResize(int width, int height)
                 { /* should resize frame, but a ShephardsPlayApplet never asks to be resized */ }
             public java.applet.AppletContext getAppletContext() { return null;}
             public java.net.URL getCodeBase() { return null; }
             public java.net.URL getDocumentBase() { return null; }
             public String getParameter(String name)
             {
                 // case insensitive... and unfortunately there's no
                 // startsWithIgnoreCase
                 String prefix = name.toLowerCase() + "=";
                 int i;
                 FOR (i, args.length)
                     if (args[i].toLowerCase().startsWith(prefix))
                         return args[i].substring(prefix.length());
                 return null;
             }
             public boolean isActive() { return true; }
        });

        frame.add(applet);

        applet.init();
        applet.start();

        frame.move(200, 20);
        frame.resize(200,200);
        frame.resize(1001, 701);
        frame.show();

        //Misc.printPlatonicSolidVertexCurvatures();

        System.out.println("out main");
    } // main
} // class ShephardsPlayApplet
