/*
Trying to make a little applet
that will let me play with triangulations with heights,
and produce the dual diagrams with heights.

For starters, always triangulates entire convex hull.
User should be able to:
    left click - add a vertex
                   - if inside a triangle, trisects the triangle
                   - if outside the convex hull, connects up
                     to all visible other vertices
    right click - delete a vertex that's on the convex hull
                  or that's only connected to three neighbors
    middle drag - move a vertex
    's' - swap a diagonal

TO DO:
    - fix optimization problem
    - figure out simpler math behind the mapping from vert heights to edge lengths
    - animation of optimization
    - animation of swap
    - animation of delete vertex (maybe-- might have to triangulate the face to get this to work, which wouldn't be a bad thing)
    - delaunayize?
    - help
    - don't draw crap when resizing (and fix whatever other applet I got this from too)
    - figure out why stack traces show .java on top even after renumbering
    - allow panning
    - 'c' should clear maybe
    - gui
    - write a generic applet to reduce pain each time
    - other mesh editing operations (split face by edge, split edge by vertex, join adjacent vertices, separate a vertex into two (but how to assign the neighbors?))
    - undo?
    - BUG: figure out how to make it not repaint continuously when resizing (my other appets too)
    - BUG: make a quad and then swap, it says there are 0 dual edges??
    - BUG: when only part of window gets exposed, only the exposed part gets painted?  hmm, not sure I have control over this
    - look at this, maybe clues about positive octant penalty functions...
        http://www.cs.indiana.edu/~yingfeng/ABSURDIST/javadoc/penalty/PenaltyMinimizer.html
      something about "translating into a positive orthant problem" and "optimizing over the positive orthant"
      intersection of a linear subspace witht the positive orthant
      http://projecteuclid.org/Dienst/UI/1.0/Summarize/euclid.mmj/1028988894
      The knee-jerk mapping:
      http://www.math.dartmouth.edu/~doyle/docs/jerk/jerk.pdf
*/

#include "macros.h"

// So can compile in pre-1.4,
// we use these instead of java.awt.event.MouseEvent.BUTTON1 etc.
#define java_awt_event_MouseEvent_BUTTON1 1
#define java_awt_event_MouseEvent_BUTTON2 2
#define java_awt_event_MouseEvent_BUTTON3 3


import com.donhatchsw.util.Arrays;
import com.donhatchsw.util.VecMath;

public class ShephardsPlayApplet
    extends java.applet.Applet
    implements java.awt.event.MouseListener,
               java.awt.event.MouseMotionListener,
               java.awt.event.KeyListener
{
    //
    // Utilities for applet stuff...
    //
        private String getParameterString(String paramName,
                                       String defaultValue)
        {
            String paramValueString = getParameter(paramName);
            if (paramValueString != null)
                return paramValueString;
            else
                return defaultValue;
        }
        private int getParameterInt(String paramName,
                                    int defaultValue)
        {
            String paramValueString = getParameter(paramName);
            if (paramValueString != null)
            {
                try
                {
                    return Integer.decode(paramValueString).intValue();
                }
                catch (NumberFormatException e)
                {
                    return 0;
                }
            }
            else
                return defaultValue;
        }
        private double getParameterDouble(String paramName,
                                          double defaultValue)
        {
            String paramValueString = getParameter(paramName);
            if (paramValueString != null)
            {
                try
                {
                    return Double.parseDouble(paramValueString);
                }
                catch (NumberFormatException e)
                {
                    return 0;
                }
            }
            else
                return defaultValue;
        }
        private boolean getParameterBoolean(String paramName,
                                            boolean defaultValue)
        {
            String paramValueString = getParameter(paramName);
            if (paramValueString != null)
            {
                // Too simplistic, only honors case-sensitive "true"
                //return Boolean.valueOf(paramValueString).booleanValue();

                try
                {
                    int n = Integer.decode(paramValueString).intValue();
                    return n != 0;
                }
                catch (NumberFormatException e)
                {
                    if (paramValueString.equalsIgnoreCase("true")
                     || paramValueString.equalsIgnoreCase("yes")
                     || paramValueString.equalsIgnoreCase("t")
                     || paramValueString.equalsIgnoreCase("y"))
                        return true;
                    return false;
                }
            }
            else
                return defaultValue;
        }

    //
    // Implementing Applet methods...
    //
        ShephardsPlayApplet()
        {
            setLayout(new java.awt.GridBagLayout());
        } // ShephardsPlayApplet ctor

        public void init()
        {
            eventVerbose = getParameterInt("EventVerbose", eventVerbose);
            if (eventVerbose >= 1) System.out.println("in init");

            // Specify an "event listener" object
            // to respond to events.
            // (>= Java 1.1 event model).
            this.addMouseListener(this);
            this.addMouseMotionListener(this);
            this.addKeyListener(this);

            graphicsAntiAliasingSetter = new GraphicsAntiAliasingSetter();

            if (eventVerbose >= 1) System.out.println("out init");
        } // init

        public void start()
        {
            if (eventVerbose >= 1) System.out.println("in start");
            if (eventVerbose >= 1) System.out.println("out start");
        }
        public void stop()
        {
            if (eventVerbose >= 1) System.out.println("in stop");
            if (eventVerbose >= 1) System.out.println("out stop");
        }
        public void destroy()
        {
            if (eventVerbose >= 1) System.out.println("in destroy");
            if (eventVerbose >= 1) System.out.println("out destroy");
        }

        //
        // Button behavor changed incompatibly between Java 1.1 and 1.4
        // (not sure exactly what version it changed in though).
        // (I think it was 1.4 since that's when getButton() was added
        // to MouseEvent).
        //
        private static int getButton(java.awt.event.MouseEvent e)
        {
            // gag me! we can't even query the java spec version number
            // since System.getProperty() throws a security exception
            // in netscape!
            // so use empirical evidence...
            int mods = e.getModifiers();
#if 0 // can't seem to get this to work under IE at all, so don't try for now, it will just be wrong under 1.4
            boolean is_1_4_or_greater = ((mods & ~0x1fff) != 0);
            if (is_1_4_or_greater)
            {
                try
                {
                    return e.getButton();
                }
                catch (NoSuchMethodError err)
                {
                    // this only happens in IE, not netscape. fall through...
                }
            }
#endif

            if ((mods & java.awt.event.InputEvent.ALT_MASK) != 0)
                return java_awt_event_MouseEvent_BUTTON2;
            if ((mods & java.awt.event.InputEvent.META_MASK) != 0)
                return java_awt_event_MouseEvent_BUTTON3;
            return java_awt_event_MouseEvent_BUTTON1;
        } // getButton

        //
        // MouseListener and MouseMotionListener methods...
        // 
        public void mousePressed(java.awt.event.MouseEvent e)
        {
            if (eventVerbose >= 1) System.out.println("in mousePressed: "+e);
            if (eventVerbose >= 1)
            {
                if (getButton(e) == java_awt_event_MouseEvent_BUTTON1)
                    System.out.println("    (left mouse)");
                if (getButton(e) == java_awt_event_MouseEvent_BUTTON2)
                    System.out.println("    (middle mouse)");
                if (getButton(e) == java_awt_event_MouseEvent_BUTTON3)
                    System.out.println("    (right mouse)");
            }

            double thisP[] = new double[2];
            mostRecentGraphics.pick(e.getX(), e.getY(), thisP);

            int whichButton = getButton(e);
            if (whichButton == java_awt_event_MouseEvent_BUTTON1)
            {
                button1IsDown = true;

                //
                // Add a vertex
                //
                System.out.println("    Adding a vertex at "+thisP[0]+" "+thisP[1]+" "+0+"");
                mesh.addIsolatedVertex(thisP[0], thisP[1], 0);

                //
                // If it's the second vertex, add an edge
                //
                Mesh.Vertex verts[] = mesh.verts; // after we added one
                if (verts.length == 2)
                {
                    System.out.println("Adding an edge between first two verts");
                    mesh.addEdgeBetweenTwoIsolatedVertices(verts[0], verts[1]);
                }

                //
                // If it's the third or more vertex,
                // find out which face we are on
                // (all triangles CCW), and kis that face.
                // if we are not inside any face by that criterion,
                // then assume we are inside the outer face
                // and connect the new vertex to every vertex
                // that's visible from it.
                //
                if (verts.length >= 3)
                {
                    boolean kissed = false;
                    double twiceMostNegativeFaceArea = Double.POSITIVE_INFINITY;
                    Mesh.Edge edgeOnMostNegativeFace = null;
                    // XXX traverses each face of size n n times!  need to keep track of what we've done already
                    FORI (iEdge, mesh.edges.length)
                    {
                        boolean thisFaceIsGoodSoFar = true;
                        Mesh.Edge edgeI = mesh.edges[iEdge];
                        double twiceThisFaceArea = 0.;
                        for (Mesh.Edge edge = edgeI;;)
                        {
                            double twiceThisTriArea = twiceTriArea(
                                                    thisP[0],thisP[1],
                                                    edge.initialVertex().x,
                                                    edge.initialVertex().y,
                                                    edge.finalVertex().x,
                                                    edge.finalVertex().y);
                            if (twiceThisTriArea < 0)
                            {
                                thisFaceIsGoodSoFar = false; // it's bad!
                            }
                            twiceThisFaceArea += twiceThisTriArea;

                            if ((edge = edge.nextEdgeOnLeftFace()) == edgeI)
                                break;
                        }
                        if (thisFaceIsGoodSoFar)
                        {
                            // I'm inside this face;
                            // kis it and done
                            mesh.kisIsolatedVertex(verts[verts.length-1],
                                                   edgeI);
                            kissed = true;
                            break;
                        }
                        if (twiceThisFaceArea < twiceMostNegativeFaceArea)
                        {
                            twiceMostNegativeFaceArea = twiceThisFaceArea;
                            edgeOnMostNegativeFace = mesh.edges[iEdge];
                        }
                    }
                    if (!kissed)
                    {
                        System.out.println("In the outer face");
                        //
                        // It wasn't inside any face.
                        // Assume it's in the outer face.
                        // In this case,
                        // make a kiss to the outer face
                        // and then delete all newly added edges
                        // that cross the boundary of the outer face.
                        //
                        Mesh.Edge oldOuterFaceBoundary[];
                        {
                            {
                                int iOldBoundaryEdge = 0;
                                for (Mesh.Edge edge = edgeOnMostNegativeFace;;)
                                {
                                    iOldBoundaryEdge++;
                                    if ((edge = edge.nextEdgeOnLeftFace()) == edgeOnMostNegativeFace)
                                        break;
                                }
                                oldOuterFaceBoundary = new Mesh.Edge[iOldBoundaryEdge];
                            }
                            {
                                int iOldBoundaryEdge = 0;
                                for (Mesh.Edge edge = edgeOnMostNegativeFace;;)
                                {
                                    oldOuterFaceBoundary[iOldBoundaryEdge++] = edge;
                                    if ((edge = edge.nextEdgeOnLeftFace()) == edgeOnMostNegativeFace)
                                        break;
                                }
                                assert(iOldBoundaryEdge == oldOuterFaceBoundary.length);
                            }
                        }

                        int oldNumEdges = mesh.edges.length;
                        mesh.kisIsolatedVertex(verts[verts.length-1],
                                               edgeOnMostNegativeFace);
                        for (int iEdge = oldNumEdges;
                             iEdge < mesh.edges.length;
                             iEdge += 2)
                        {
                            for (int iOldBoundaryEdge = 0;
                                 iOldBoundaryEdge < oldOuterFaceBoundary.length;
                                 ++iOldBoundaryEdge)
                            {
                                Mesh.Edge oldEdge = oldOuterFaceBoundary[iOldBoundaryEdge];
                                Mesh.Edge newEdge = mesh.edges[iEdge];

                                if (newEdge.initialVertex() == oldEdge.initialVertex()
                                 || newEdge.initialVertex() == oldEdge.finalVertex()
                                 || newEdge.finalVertex() == oldEdge.initialVertex()
                                 || newEdge.finalVertex() == oldEdge.finalVertex())
                                    continue;
                                //System.out.println("    Seeing whether new edge v"+newEdge.initialVertex().myIndex()+" -> v"+newEdge.finalVertex().myIndex()+" crosses old boundary edges v"+oldEdge.initialVertex().myIndex()+" -> v"+oldEdge.finalVertex().myIndex()+"");
                                if (edgesCrossOrCloseToIt(
                                                oldEdge.initialVertex().x,
                                                oldEdge.initialVertex().y,
                                                oldEdge.finalVertex().x,
                                                oldEdge.finalVertex().y,
                                                newEdge.initialVertex().x,
                                                newEdge.initialVertex().y,
                                                newEdge.finalVertex().x,
                                                newEdge.finalVertex().y,
                                                1e-6))
                                {
                                    //System.out.println("        It does.");
                                    mesh.deleteEdge(newEdge);
                                    iEdge -= 2; // so we don't skip the one that gets moved into the deleted spot
                                    break;
                                }
                                else
                                {
                                    //System.out.println("        It doesn't.");
                                }
                            }
                        }
                    }
                } // if verts.length >= 3

                mesh.sanityCheck();

                selectedVertIndex = verts.length-1;
            }
            else if (whichButton == java_awt_event_MouseEvent_BUTTON2)
            {
                button2IsDown = true;

                //
                // Select closest vertex
                //
                selectedVertIndex = mesh.indexOfClosestVert(thisP[0],thisP[1]);

                System.out.println("Selected vertex "+selectedVertIndex+"");
            }
            else if (whichButton == java_awt_event_MouseEvent_BUTTON3)
            {
                button3IsDown = true;

                //
                // Delete closest vertex
                //
                selectedVertIndex = mesh.indexOfClosestVert(thisP[0],thisP[1]);
                if (selectedVertIndex != -1)
                    mesh.deleteVertex(mesh.verts[selectedVertIndex]);
                selectedVertIndex = -1;

                mesh.sanityCheck();

            } // right mouse

            prevP = thisP;

            repaint();

            if (eventVerbose >= 1) System.out.println("out mousePressed: "+e);
        } // mousePressed
        public void mouseReleased(java.awt.event.MouseEvent e)
        {
            if (eventVerbose >= 1) System.out.println("in mouseReleased: "+e);

            int whichButton = getButton(e);
            if (whichButton == java_awt_event_MouseEvent_BUTTON1)
            {
                button1IsDown = false;
            }
            else if (whichButton == java_awt_event_MouseEvent_BUTTON2)
            {
                button2IsDown = false;
            }
            else if (whichButton == java_awt_event_MouseEvent_BUTTON3)
            {
                button3IsDown = false;
            }

            repaint();

            if (eventVerbose >= 1) System.out.println("out mouseReleased: "+e);
        }
        public void mouseEntered(java.awt.event.MouseEvent e)
        {
            if (eventVerbose >= 1) System.out.println("in mouseEntered: "+e);
            if (eventVerbose >= 1) System.out.println("out mouseEntered: "+e);
        }
        public void mouseExited(java.awt.event.MouseEvent e)
        {
            if (eventVerbose >= 1) System.out.println("in mouseExited: "+e);
            if (eventVerbose >= 1) System.out.println("out mouseExited: "+e);
        }
        public void mouseClicked(java.awt.event.MouseEvent e)
        {
            if (eventVerbose >= 1) System.out.println("in mouseClicked: "+e);
            if (eventVerbose >= 1) System.out.println("out mouseClicked: "+e);
        }
        public void mouseDragged(java.awt.event.MouseEvent e)
        {
            if (eventVerbose >= 2) System.out.println("  in mouseDragged: "+e);

            double thisP[] = new double[2];
            mostRecentGraphics.pick(e.getX(), e.getY(), thisP);

            if (button1IsDown || button2IsDown)
            {
                if (selectedVertIndex != -1)
                {
                    mesh.verts[selectedVertIndex].x += thisP[0]-prevP[0];
                    mesh.verts[selectedVertIndex].y += thisP[1]-prevP[1];
                    // XXX what do do with h???
                }
            }

            if (button3IsDown) // right mouse
            {
            }

            repaint();

            prevP = thisP;

            if (eventVerbose >= 2) System.out.println("  out mouseDragged: "+e);
        }
        public void mouseMoved(java.awt.event.MouseEvent e)
        {
            if (eventVerbose >= 3) System.out.println("    in mouseMoved: "+e);

            if (mostRecentGraphics != null)
            {
                double thisP[] = new double[2];
                mostRecentGraphics.pick(e.getX(), e.getY(), thisP);
                prevP = thisP;
            }

            if (eventVerbose >= 3) System.out.println("    out mouseMoved: "+e);
        }

        //
        // KeyListener methods...
        //
        public void keyPressed(java.awt.event.KeyEvent e)
        {
            if (eventVerbose >= 1) System.out.println("in keyPressed: "+e);
            double incr = .005;
            switch(e.getKeyCode())
            {
                case java.awt.event.KeyEvent.VK_UP:
                {
                    System.out.print("Up");
                    System.out.flush();
                    int iVert = mesh.indexOfClosestVert(prevP[0], prevP[1]);
                    mesh.verts[iVert].h += incr;
                    repaint();
                    break;
                }
                case java.awt.event.KeyEvent.VK_DOWN:
                {
                    System.out.print("Down");
                    System.out.flush();
                    int iVert = mesh.indexOfClosestVert(prevP[0], prevP[1]);
                    mesh.verts[iVert].h -= incr;
                    repaint();
                    break;
                }
                default:
                    break;
            }
            if (eventVerbose >= 1) System.out.println("out keyPressed: "+e);
        }
        public void keyReleased(java.awt.event.KeyEvent e)
        {
            if (eventVerbose >= 1) System.out.println("in keyReleased: "+e);
            if (eventVerbose >= 1) System.out.println("out keyReleased: "+e);
        }
        public void keyTyped(java.awt.event.KeyEvent e)
        {
            if (eventVerbose >= 1) System.out.println("in keyTyped: "+e);
            switch (e.getKeyChar())
            {
                case 'V': // cycle verbosity-- upper-case to minimize possibility of hitting it by accident thus causing subsequent perfomance degradation with no visible reason if Java Console is not visible
                    System.out.print("eventVerbose "+eventVerbose);
                    eventVerbose = (eventVerbose+1) % 4;
                    System.out.println(" -> "+eventVerbose);
                    break;

                case ' ': // just repaint (i.e. mark dirty)
                    repaint();
                    break;
                case 'A': // toggle doAntiAliasing
                    doAntiAliasing ^= true;
                    System.out.println("doAntiAliasing -> "+doAntiAliasing+" (if this platform supports it)");
                    repaint();
                    break;

                case 't': // increase lineThicknessInPixels
                    System.out.print("lineThicknessInPixels "+lineThicknessInPixels);
                    lineThicknessInPixels += 1.;
                    System.out.println(" -> "+lineThicknessInPixels);
                    repaint();
                    break;
                case 'T': // decrease lineThicknessInPixels
                    System.out.print("lineThicknessInPixels "+lineThicknessInPixels);
                    lineThicknessInPixels -= 1.;
                    System.out.println(" -> "+lineThicknessInPixels);
                    repaint();
                    break;

                case 'B': // toggle doDoubleBuffer
                    doDoubleBuffer ^= true;
                    System.out.println("doDoubleBuffer -> "+doDoubleBuffer);
                    repaint();
                    break;

                case 'i': case '+': case '=': // zoom in
                    FORI (iVert, mesh.verts.length)
                    {
                        double scale = Math.sqrt(2.);
                        mesh.verts[iVert].x *= scale;
                        mesh.verts[iVert].y *= scale;
                        mesh.verts[iVert].h *= scale*scale;
                    }
                    repaint();
                    break;
                case 'o': case '-':           // zoom out
                    FORI (iVert, mesh.verts.length)
                    {
                        double scale = Math.sqrt(.5);
                        mesh.verts[iVert].x *= scale;
                        mesh.verts[iVert].y *= scale;
                        mesh.verts[iVert].h *= scale*scale;
                    }
                    repaint();
                    break;

                case 's': // swap diagonal
                {
                    int closestEdgeIndex = mesh.indexOfClosestEdge(prevP[0],prevP[1]);
                    if (closestEdgeIndex != -1)
                    {
                        System.out.println("Swapping diagonal edge e"+closestEdgeIndex);
                        mesh.swapDiagonal(mesh.edges[closestEdgeIndex]);
                        mesh.sanityCheck();
                    }
                    repaint();
                    break;
                }
                case 'd':
                {
                    int closestEdgeIndex = mesh.indexOfClosestEdge(prevP[0],prevP[1]);
                    if (closestEdgeIndex != -1)
                    {
                        System.out.println("Deleting edge e"+closestEdgeIndex);
                        mesh.deleteEdge(mesh.edges[closestEdgeIndex]);
                        mesh.sanityCheck();
                    }
                    repaint();
                    break;
                }
                case 'S': // re-sphereize
                    FORI (iVert, mesh.verts.length)
                        mesh.verts[iVert].h = 0.;
                    repaint();
                    break;

                case 'l': // toggle doLabels
                    doLabels ^= true;
                    System.out.println("doLabels -> "+doLabels);
                    repaint();
                    break;

                case 'O': // toggle doOptimize
                    doOptimize ^= true;
                    System.out.println("doOptimize -> "+doOptimize);
                    repaint();
                    break;



#define CTRL(lowerCaseLetter) ((lowerCaseLetter)-'a' + 1)

                default:
                    System.out.println("Unknown key '"+e.getKeyChar()+"'("+(int)e.getKeyChar()+") typed");
                    break;
            }
            if (eventVerbose >= 1) System.out.println("out keyTyped: "+e);
        } // keyTyped

        //
        // Make it so we get keyboard focus on startup,
        // without having to click first.  Thanks, Melinda!
        // The state of things seems to be:
        //      - Buttons and TextFields are apparently "focus traversable"
        //        by default.  Canvases and Applets aren't,
        //        implying (not obvious) that you need to click to type
        //        when the app starts,
        //        which is almost never the desired behavior.
        //        You can change this by overriding isFocusTraversable(),
        //        which we do below.
        //      - Other approaches using requestFocus():
        //        A Canvas calling requestFocus() doesn't seem to do
        //        anything.  An Applet calling requestFocus() doesn't
        //        do anything during init(), but I think it works
        //        if you put it in the mouseEntered handler or something,
        //        though this can lead to various unpredictabilities.
        // In this applet we are drawing directly on the Applet (not a Canvas),
        // so presumably the requestFocus() approach would work,
        // but the isFocusTraversable() fix is better in any case.
        //
        public boolean isFocusTraversable()
        {
            return true;
        }

        // override to not clear...
        public void update(java.awt.Graphics g)
        {
            paint(g);
        }


        // PAINT
	public void paint(java.awt.Graphics frontBufferGraphics)
	{
	    if (eventVerbose >= 1) System.out.println("in paint");

            makeSureBackBufferIsRight();
            java.awt.Graphics g;
            if (doDoubleBuffer)
                g = backBufferImage.getGraphics();
            else
                g = frontBufferGraphics;


            java.awt.Dimension size = getSize();
            double minSize = MIN(size.width, size.height);
            MyGraphics mg = new MyGraphics(g, size,
                                    -size.width/minSize,size.width/minSize,
                                    -size.height/minSize,size.height/minSize);
            mostRecentGraphics = mg;

            if (implementAntiAliasingInHardware)
            {
                graphicsAntiAliasingSetter.setAntiAliasing(g,
                                                           doAntiAliasing,
                                                           //1
                                                           eventVerbose
                                                           );
            }


            //
            // Clear to black...
            //
            mg.setColor(java.awt.Color.black);
            mg.fillWindow();



            //
            // Draw the mesh...
            //
            {
                mg.setColor(java.awt.Color.white);

                Mesh.Vertex verts[] = mesh.verts;
                FORI (iVert, verts.length)
                {
                    mg.drawPoint(verts[iVert].x,
                                 verts[iVert].y, 3);
                }

                Mesh.Edge edges[] = mesh.edges;
                FORI (iEdge, edges.length/2)
                {
                    Mesh.Vertex v0 = edges[iEdge*2].initialVertex();
                    Mesh.Vertex v1 = edges[iEdge*2].finalVertex();
                    mg.drawLine(v0.x,v0.y,v1.x,v1.y,doAntiAliasing);
                }
            }

            //
            // Try optimizing the heights...
            //
            if (doOptimize)
            {
                double optimalVertexHeights[] = mesh.findOptimalVertexHeights();
                FORI (iVert, mesh.verts.length)
                {
                    PRINT(iVert);
                    PRINT(optimalVertexHeights[iVert]);
                    mesh.verts[iVert].h = optimalVertexHeights[iVert];
                }
            }

            //
            // Draw the dual diagram...
            //
            {
                //
                // Draw and store the dual verts...
                //
                mg.setColor(java.awt.Color.red);
                double dualVerts[][] = new double[mesh.edges.length][];
                FORI (iEdge, mesh.edges.length)
                {
                    if (dualVerts[iEdge] != null)
                        continue; // already did this triangle

                    Mesh.Edge e0 = mesh.edges[iEdge];
                    Mesh.Edge e1 = e0.nextEdgeOnLeftFace();
                    Mesh.Edge e2 = e1.nextEdgeOnLeftFace();
                    if (e2.nextEdgeOnLeftFace() != e0)
                        continue; // not a triangle

                    Mesh.Vertex v0 = e0.initialVertex();
                    Mesh.Vertex v1 = e1.initialVertex();
                    Mesh.Vertex v2 = e2.initialVertex();

                    if (twiceTriArea(v0.x,v0.y,
                                     v1.x,v1.y,
                                     v2.x,v2.y) < 0)
                        continue; // the triangle is inside out; it's the boundary

                    double dualVert[] = new double[3];
                    SolveForDualPoint(v0.x, v0.y, v0.h - .5 * (SQR(v0.x)+SQR(v0.y)),
                                      v1.x, v1.y, v1.h - .5 * (SQR(v1.x)+SQR(v1.y)),
                                      v2.x, v2.y, v2.h - .5 * (SQR(v2.x)+SQR(v2.y)),
                                      dualVert);
                    //System.out.println("    drawing dual vert at "+Arrays.toStringCompact(dualVert));
                    mg.drawPoint(dualVert[0],
                                 dualVert[1], 5);
                    int ind0 = iEdge;
                    int ind1 = e1.myIndex();
                    int ind2 = e2.myIndex();
                    assert(dualVerts[ind0] == null);
                    assert(dualVerts[ind1] == null);
                    assert(dualVerts[ind2] == null);
                    dualVerts[ind0] = dualVert;
                    dualVerts[ind1] = dualVert;
                    dualVerts[ind2] = dualVert;
                }

                //
                // Now try connecting the dual verts
                //
                FORI (iEdge, mesh.edges.length)
                {
                    if (dualVerts[iEdge] == null)
                        continue; // not a triangle
                    int jEdge = mesh.edges[iEdge].opposite().myIndex(); // XXX slow and lame-- should really store myIndex inside the edge, okay to update it whenever we rearrange the edge array
                    if (dualVerts[jEdge] != null)
                    {
                        mg.drawLine(dualVerts[iEdge][0],dualVerts[iEdge][1],
                                    dualVerts[jEdge][0],dualVerts[jEdge][1],
                                    doAntiAliasing);
                    }
                    else
                    {
                        double v0[] = {mesh.edges[iEdge].initialVertex().x,
                                       mesh.edges[iEdge].initialVertex().y};
                        double v1[] = {mesh.edges[iEdge].finalVertex().x,
                                       mesh.edges[iEdge].finalVertex().y};
                        double toEdgeVec[] = VecMath.xv2(
                                                 VecMath.vmv(v0, v1));
                        VecMath.normalize(toEdgeVec, toEdgeVec);
                        double rayLength = 1.;
                        double destPoint[] = {dualVerts[iEdge][0]+rayLength*toEdgeVec[0],
                                              dualVerts[iEdge][1]+rayLength*toEdgeVec[1]};
                        mg.drawLine(dualVerts[iEdge][0],dualVerts[iEdge][1],
                                    destPoint[0],destPoint[1],
                                    doAntiAliasing);
                                                             
                    }
                }
            }

            //
            // Draw the labels last...
            //
            if (doLabels)
            {
                mg.setColor(java.awt.Color.white);

                boolean trySmartVertexAngles = true;

                double smartVertexAngles[] = null;
                if (trySmartVertexAngles)
                {
                    int nVerts = mesh.verts.length;
                    int nEdges = mesh.edges.length;
                    smartVertexAngles = new double[nVerts]; // initialized to 0

                    FORI (iEdge0, nEdges)
                    {
                        Mesh.Edge edge0 = mesh.edges[iEdge0];
                        Mesh.Vertex vert = edge0.initialVertex();
                        if (smartVertexAngles[vert.myIndex()] != 0.)
                            continue; // already saw this one for sure

                        double biggestGap = -1.;
                        double angOfBiggestGap = 0.;
                        // walk CCW around vertex
                        Mesh.Edge thisEdge = edge0;
                        Mesh.Edge nextEdge;
                        do {
                            assert(thisEdge.initialVertex() == vert);
                            nextEdge = thisEdge.prevEdgeOnLeftFace().opposite();
                            double nextAng = Math.atan2(nextEdge.finalVertex().y-nextEdge.initialVertex().y,
                                                        nextEdge.finalVertex().x-nextEdge.initialVertex().x);
                            double thisAng = Math.atan2(thisEdge.finalVertex().y-thisEdge.initialVertex().y,
                                                        thisEdge.finalVertex().x-thisEdge.initialVertex().x);
                            double thisGap = nextAng - thisAng;
                            if (thisGap < 0)
                                thisGap += 2*Math.PI;
                            if (thisGap > biggestGap)
                            {
                                biggestGap = thisGap;
                                angOfBiggestGap = thisAng+thisGap/2;
                            }
                        } while ((thisEdge = nextEdge) != edge0);
                        smartVertexAngles[vert.myIndex()] = angOfBiggestGap;
                    }
                }



                Mesh.Vertex verts[] = mesh.verts;
                FORI (iVert, verts.length)
                {
                    double x = verts[iVert].x;
                    double y = verts[iVert].y;
                    double ang;
                    if (trySmartVertexAngles)
                    {
                        ang = smartVertexAngles[iVert];
                    }
                    else
                    {
                        ang = Math.random() * 2*Math.PI;
                    }
                    double offr = 5/mg.getScaleX(); // pixels
                    double offx = offr*Math.cos(ang);
                    double offy = offr*Math.sin(ang);
                    double offmax = MAX(ABS(offx),ABS(offy));

                    mg.drawString("v"+iVert,
                                  x+offx,
                                  y+offy,
                                  -offx/offmax, offy/offmax);
                }

                Mesh.Edge edges[] = mesh.edges;
                FORI (iEdge, edges.length)
                {
                    Mesh.Vertex v0 = edges[iEdge].initialVertex();
                    Mesh.Vertex v1 = edges[iEdge].finalVertex();
                    double x = (v0.x+v1.x)/2;
                    double y = (v0.y+v1.y)/2;
                    double ang = Math.PI/2 + Math.atan2(v1.y-v0.y, v1.x-v0.x);
                    double offr = 2/mg.getScaleX(); // pixels
                    double offx = offr*Math.cos(ang);
                    double offy = offr*Math.sin(ang);
                    double offmax = MAX(ABS(offx),ABS(offy));
                    mg.drawString("e"+iEdge,
                                  x+offx,
                                  y+offy,
                                  -offx/offmax, offy/offmax);
                }
            }

            if (doShowPositiveOrthantnessVisualization)
            {
                int nPoints = 5000;
                int nLabels = 100;
                double M[][] = new double[3][3];
                {
                    // XXX should add a function to VecMath for random orthonormal matrix?
                    FORI (i, 2)
                    FORI (j, 3)
                        M[i][j] = 2*Math.random() - 1.;
                    VecMath.normalize(M[0], M[0]);
                    VecMath.vpsxv(M[1],
                                  M[1],
                                  -VecMath.dot(M[0], M[1]),
                                  M[0]);
                    VecMath.normalize(M[1], M[1]);
                    VecMath.vxv3(M[2], M[0], M[1]);
                }

                double v[] = new double[3];
                double Mv[] = new double[3];
                FORI (iPoint, nLabels+nPoints)
                {
                    VecMath.random(v);

                    if (iPoint == 0 || iPoint == nLabels+nPoints-1)
                        VecMath.fillvec(v, 1.);
                    else if (iPoint == 1 || iPoint == nLabels+nPoints-2)
                        VecMath.fillvec(v, -1);


                    VecMath.normalize(v, v);
                    VecMath.mxv(Mv, M, v);
                    if (Mv[2] < 0.)
                    {
                        VecMath.sxv(v, -1., v);
                        VecMath.sxv(Mv, -1., Mv);
                    }
                    double goodness = VecMath.positiveOrthantness(v, true);
                    //double incrDegrees = 10.;
                    double incrDegrees = 5.;
                    double dN = goodness * 180 / Math.PI / incrDegrees;
                    int iN = (int)Math.round(dN);
                    if (iPoint <= 1
                     || iPoint >= nLabels+nPoints-2
                     || ABS(iN-dN) < .01)
                    {
                        if (iN == 0)
                            mg.setColor(java.awt.Color.red);
                        else if (iN % 2 == 0)
                            mg.setColor(java.awt.Color.green);
                        else
                            mg.setColor(java.awt.Color.blue);

                        if (iPoint == 0
                         || iPoint == nLabels+nPoints-1)
                            mg.drawString(""+(dN*incrDegrees),
                                          Mv[0],Mv[1], -1., 1.);
                        else if (iPoint < nLabels)
                            mg.drawString(""+(int)Math.round(dN*incrDegrees),
                                          Mv[0],Mv[1], -1., 1.);
                        else
                            mg.drawPoint(Mv[0],Mv[1], 1);
                    }
                    else
                        iPoint--; // cancel loop iteration
                }
            }


            if (g != frontBufferGraphics)
            {
                frontBufferGraphics.drawImage(backBufferImage, 0, 0, this);
            }

	    if (eventVerbose >= 1) System.out.println("out paint");
	} // paint

        private void makeSureBackBufferIsRight()
        {
            if (doDoubleBuffer)
            {
                java.awt.Dimension size = getSize();
                if (backBufferImage == null
                 || backBufferImage.getWidth(this) != size.width
                 || backBufferImage.getHeight(this) != size.height)
                {
                    if (eventVerbose >= 1)
                    {
                        System.out.println("Creating back buffer " + size.width + "x" + size.height);
                    }
                    backBufferImage = createImage(size.width, size.height);
                }
            }
            else
                backBufferImage = null;
        } // makeSureBackBufferIsRight


    //
    // Definition of stuff for this particular app...
    //
        public class Mesh // non-static, for nonEventVerbose
        {
            public String toString()
            {
                StringBuffer sb = new StringBuffer();
                sb.append(""+verts.length+" verts:\n");
                FORI (iVert, verts.length)
                    sb.append("    "+verts[iVert].x+" "+verts[iVert].y+" "+verts[iVert].h+"\n");
                sb.append(""+edges.length+" edges:\n");
                FORI (iEdge, edges.length)
                    sb.append("    v"+edges[iEdge].initialVertex().myIndex()+" -> v"+edges[iEdge].finalVertex().myIndex()+"\n");
                return sb.toString();
            }

            public class Vertex
            {
                public double x, y, h;
                private int _myIndex = -1;
                public Vertex(double x, double y, double h)
                {
                    this.x = x;
                    this.y = y;
                    this.h = h;
                    verts = (Vertex[])com.donhatchsw.util.Arrays.append(verts, this);
                    fixVertIndices(verts.length-1);
                }

                public int myIndex()
                {
                    //return Arrays.indexOfUsingEqualsSymbol(verts, this);
                    return _myIndex;
                }
            } // public class Vertex
            public class Edge
            {
                private Vertex _initialVertex;
                private Edge _opposite;
                private Edge _nextEdgeOnLeftFace;
                private Edge _prevEdgeOnLeftFace;
                private int _myIndex = -1;

                public Edge(boolean andBack)
                {
                    this._myIndex = -1; // will get fixed
                    edges = (Edge[])Arrays.append(edges, this);
                    fixEdgeIndices(edges.length-1);
                    if (andBack)
                    {
                        Edge opposite = new Edge(false);
                        setOpposite(opposite, true);
                    }
                }

                //
                // Accessor methods...
                //
                public Vertex initialVertex()
                {
                    return _initialVertex;
                }
                public Edge opposite()
                {
                    return _opposite;
                }
                public Edge nextEdgeOnLeftFace()
                {
                    return _nextEdgeOnLeftFace;
                }
                public Edge prevEdgeOnLeftFace()
                {
                    return _prevEdgeOnLeftFace;
                }

                public void setInitialVertex(Vertex v)
                {
                    _initialVertex = v;
                }

                public void setOpposite(Edge opposite, boolean andBack)
                {
                    _opposite = opposite;
                    if (andBack)
                        _opposite.setOpposite(this, false);
                }
                public void setNextEdgeOnLeftFace(Edge next, boolean andBack)
                {
                    _nextEdgeOnLeftFace = next;
                    if (andBack)
                        next.setPrevEdgeOnLeftFace(this, false);
                }
                public void setPrevEdgeOnLeftFace(Edge prev, boolean andBack)
                {
                    _prevEdgeOnLeftFace = prev;
                    if (andBack)
                        prev.setNextEdgeOnLeftFace(this, false);
                }

                //
                // Helper methods...
                // From the caller's point of view,
                // these are just like the accessor methods
                //
                public Vertex finalVertex()
                {
                    return _opposite._initialVertex;
                }
                public Edge nextEdgeOnRightFace()
                {
                    return _opposite.prevEdgeOnLeftFace()._opposite;
                }
                public Edge prevEdgeOnRightFace()
                {
                    return _opposite.nextEdgeOnLeftFace()._opposite;
                }


                public int myIndex()
                {
                    //return Arrays.indexOfUsingEqualsSymbol(edges, this);
                    return _myIndex;
                }
            } // public class Edge

            // Called whenever verts array changes
            private void fixVertIndices(int i0)
            {
                for (int iVert = i0; iVert < verts.length; ++iVert)
                    verts[iVert]._myIndex = iVert;
            }
            // Called whenever edges array changes
            private void fixEdgeIndices(int i0)
            {
                for (int iEdge = i0; iEdge < edges.length; ++iEdge)
                    edges[iEdge]._myIndex = iEdge;
            }

            public void sanityCheck()
            {
                boolean sawVertAsInitial[] = new boolean[verts.length]; // all false
                boolean sawEdgeAsOpposite[] = new boolean[edges.length]; // all false
                boolean sawEdgeAsNext[] = new boolean[edges.length]; // all false
                boolean sawEdgeAsPrev[] = new boolean[edges.length]; // all false
                FORI (iEdge, edges.length)
                {
                    Edge e = edges[iEdge];
                    assert(e.myIndex() == iEdge);
                    assert(e.initialVertex() != null);
                    assert(e.opposite() != null);
                    assert(e.opposite() != e);
                    assert(e.initialVertex() != null);
                    assert(e.nextEdgeOnLeftFace() != null);
                    assert(e.prevEdgeOnLeftFace() != null);
                    assert(e.opposite().opposite() == e);
                    assert(e.nextEdgeOnLeftFace().prevEdgeOnLeftFace() == e);
                    assert(e.prevEdgeOnLeftFace().nextEdgeOnLeftFace() == e);

                    // XXX use hash table if going to do this on big things
                    int initialVertIndex = Arrays.indexOfUsingEqualsSymbol(verts, e.initialVertex());
                    int oppositeIndex = Arrays.indexOfUsingEqualsSymbol(edges, e.opposite());
                    int nextIndex = Arrays.indexOfUsingEqualsSymbol(edges, e.nextEdgeOnLeftFace());
                    int prevIndex = Arrays.indexOfUsingEqualsSymbol(edges, e.prevEdgeOnLeftFace());
                    assert(initialVertIndex != -1);
                    assert(oppositeIndex != -1);
                    assert(nextIndex != -1);
                    assert(prevIndex != -1);

                    // Okay for a vert to be initial more than once...
                    sawVertAsInitial[initialVertIndex] = true;

                    // But not the others...
                    assert(!sawEdgeAsOpposite[oppositeIndex]);
                    sawEdgeAsOpposite[oppositeIndex] = true;
                    assert(!sawEdgeAsNext[nextIndex]);
                    sawEdgeAsNext[nextIndex] = true;
                    assert(!sawEdgeAsPrev[prevIndex]);
                    sawEdgeAsPrev[prevIndex] = true;
                }

                FORI (iVert, verts.length)
                {
                    assert(verts[iVert].myIndex() == iVert);
                    if (false) // can have isolated verts
                        assert(sawVertAsInitial[iVert]);
                }
                FORI (iEdge, edges.length)
                {
                    assert(sawEdgeAsOpposite[iEdge]);
                    assert(sawEdgeAsNext[iEdge]);
                    assert(sawEdgeAsPrev[iEdge]);
                }
            } // sanityCheck




            /*                    ^
                 insertThisEdge   | beforeThisEdge
                <-----------------*
                                 /|\
                                / | \
            */
            public void insertEdgeBefore(Edge insertThisEdge, Edge beforeThisEdge)
            {
                if (nonEventVerbose >= 1)
                    System.out.println("        In insertEdgeBefore(insertThisEdge="+insertThisEdge.myIndex()+", beforeThisEdge="+beforeThisEdge.myIndex()+"");
                beforeThisEdge.prevEdgeOnLeftFace().setNextEdgeOnLeftFace(insertThisEdge, true);
                insertThisEdge.opposite().setNextEdgeOnLeftFace(beforeThisEdge, true);
                insertThisEdge.setInitialVertex(beforeThisEdge.initialVertex());
                if (nonEventVerbose >= 1)
                    System.out.println("        Out insertEdgeBefore(insertThisEdge="+insertThisEdge.myIndex()+", beforeThisEdge="+beforeThisEdge.myIndex()+"");
            }
            public void addWhisker(Edge beforeThisEdge,
                                   Vertex v) // to this vertex
            {
                Edge e = new Edge(true);
                e.opposite().setInitialVertex(v);
                e.setNextEdgeOnLeftFace(e.opposite(), true);
                insertEdgeBefore(e, beforeThisEdge);
            }
            public void addDiagonal(Edge beforeThisEdge, Edge beforeThatEdge)
            {
                if (nonEventVerbose >= 1)
                    System.out.println("    In addDiagonal(beforeThisEdge="+beforeThisEdge.myIndex()+", beforeThatEdge="+beforeThatEdge.myIndex()+"");
                Edge e = new Edge(true);
                insertEdgeBefore(e, beforeThisEdge);
                insertEdgeBefore(e.opposite(), beforeThatEdge);
                if (nonEventVerbose >= 1)
                    System.out.println("    Out addDiagonal(beforeThisEdge="+beforeThisEdge.myIndex()+", beforeThatEdge="+beforeThatEdge.myIndex()+"");
            }
            public void swapDiagonal(Edge e)
            {
                if (e.nextEdgeOnLeftFace().nextEdgeOnLeftFace().nextEdgeOnLeftFace() != e
                 || e.opposite().nextEdgeOnLeftFace().nextEdgeOnLeftFace().nextEdgeOnLeftFace() != e.opposite())
                {
                    System.out.println("    Can't swap diagonal, it's not on a quad");
                    return;
                }

                Edge beforeThisEdge = e.prevEdgeOnLeftFace();
                Edge beforeThatEdge = e.opposite().prevEdgeOnLeftFace();

                //
                // Another subtle thing to check...
                // Make sure the other diagonal doesn't
                // already exist.
                //
                {
                    Vertex v0 = beforeThisEdge.initialVertex();
                    Vertex v1 = beforeThatEdge.initialVertex();
                    // XXX could do this faster by walking around the vert,
                    // XXX but whatever
                    FORI (iEdge, edges.length)
                    {
                        if (edges[iEdge].initialVertex() == v0
                         && edges[iEdge].finalVertex() == v1)
                        {
                            System.out.println("    Can't swap diagonal, the other diagonal already exists");
                            return;
                        }
                    }
                }

                deleteEdge(e);
                addDiagonal(beforeThisEdge, beforeThatEdge);
            }
            public void addEdgeBetweenTwoIsolatedVertices(Vertex v0, Vertex v1)
            {
                Edge e = new Edge(true);
                e.setInitialVertex(v0);
                e.opposite().setInitialVertex(v1);
                e.setNextEdgeOnLeftFace(e.opposite(), true);
                e.setPrevEdgeOnLeftFace(e.opposite(), true);
            }
            public void addIsolatedVertex(double x, double y, double h)
            {
                new Vertex(x,y,h); // adds itself to verts
            }
            // This is the "kis" operation, the dual of truncating a vertex.
            public void kisIsolatedVertex(Vertex v, Edge someEdgeOnFace)
            {
                if (nonEventVerbose >= 1)
                    System.out.println("In kis(v="+v.myIndex()+", someEdgeOnFac="+someEdgeOnFace.myIndex()+"");
                //
                // Start by attaching a single whisker to the new vertex...
                //
                if (nonEventVerbose >= 1)
                    System.out.println("    adding a whisker from edge "+someEdgeOnFace.myIndex()+" to vert "+v.myIndex());
                addWhisker(someEdgeOnFace, v);
                if (nonEventVerbose >= 1)
                {
                    System.out.println("    did that at least.");
                    PRINT(this);
                }

                //
                // Now fill in with triangles,
                // connecting everything to the new vertex v.
                //
                while (someEdgeOnFace.nextEdgeOnLeftFace()
                                     .nextEdgeOnLeftFace()
                                     .nextEdgeOnLeftFace() != someEdgeOnFace)
                {
                    if (nonEventVerbose >= 1)
                        System.out.println("    adding diagonal from start of edge "+someEdgeOnFace.prevEdgeOnLeftFace().myIndex()+" to start of edge "+someEdgeOnFace.prevEdgeOnLeftFace().prevEdgeOnLeftFace().prevEdgeOnLeftFace().myIndex()+"");
                    addDiagonal(someEdgeOnFace.prevEdgeOnLeftFace(),
                                someEdgeOnFace.prevEdgeOnLeftFace()
                                              .prevEdgeOnLeftFace()
                                              .prevEdgeOnLeftFace());
                    if (nonEventVerbose >= 1)
                    {
                        System.out.println("    did that diagonal.");
                        PRINT(this);
                    }
                }
                if (nonEventVerbose >= 1)
                    System.out.println("Out kis(v="+v.myIndex()+", someEdgeOnFac="+someEdgeOnFace.myIndex()+"");
            }
            public void deleteEdge(Edge e)
            {
                e.prevEdgeOnLeftFace().setNextEdgeOnLeftFace(e.opposite().nextEdgeOnLeftFace(), true);
                e.opposite().prevEdgeOnLeftFace().setNextEdgeOnLeftFace(e.nextEdgeOnLeftFace(), true);
                /*
                assert(e.nextEdgeOnLeftFace() == e.opposite());
                assert(e.prevEdgeOnLeftFace() == e.opposite());
                */
                int i = e.myIndex();
                edges = (Edge[])Arrays.concat(Arrays.subarray(edges,0,i), Arrays.subarray(edges,i+1,edges.length-i-1)); // XXX should be Arrays.remove when it exists
                fixEdgeIndices(i);

                int j = e.opposite().myIndex();
                edges = (Edge[])Arrays.concat(Arrays.subarray(edges,0,j), Arrays.subarray(edges,j+1,edges.length-j-1)); // XXX should be Arrays.remove when it exists
                fixEdgeIndices(j);
            }
            public void deleteVertex(Vertex v)
            {
                FORI (iEdge, edges.length)
                {
                    if (edges[iEdge].initialVertex() == v
                     || edges[iEdge].finalVertex() == v)
                    {
                        deleteEdge(edges[iEdge]);
                        iEdge--; // so when we incrememnt we get back to here
                    }
                }
                int iVert = v.myIndex();
                verts = (Vertex[])Arrays.concat(Arrays.subarray(verts,0,iVert), Arrays.subarray(verts,iVert+1,verts.length-iVert-1));
                fixVertIndices(iVert);
            }

            public int indexOfClosestVert(double x, double y)
            {
                double closestDistSqrd = Double.POSITIVE_INFINITY;
                int closestVertIndex = -1;
                FORI (iVert, verts.length)
                {
                    double thisDistSqrd = SQR(verts[iVert].x-x)
                                        + SQR(verts[iVert].y-y);
                    if (thisDistSqrd < closestDistSqrd)
                    {
                        closestDistSqrd = thisDistSqrd;
                        closestVertIndex = iVert;
                    }
                }
                return closestVertIndex; // -1 if none
            } // indexOfClosestVert

            public int indexOfClosestEdge(double x, double y)
            {
                double closestDistSqrd = Double.POSITIVE_INFINITY;
                int closestEdgeIndex = -1;
                FORI (iEdge, edges.length)
                {
                    double thisDistSqrd = distSqrdFromPointToSeg(x,y,
                                             edges[iEdge].initialVertex().x,
                                             edges[iEdge].initialVertex().y,
                                             edges[iEdge].finalVertex().x,
                                             edges[iEdge].finalVertex().y);
                    if (thisDistSqrd < closestDistSqrd)
                    {
                        closestDistSqrd = thisDistSqrd;
                        closestEdgeIndex = iEdge;
                    }
                }
                return closestEdgeIndex; // -1 if none
            } // indexOfClosestEdge

            public double[] findOptimalVertexHeights()
            {
                if (verts.length < 3)
                    return new double[verts.length]; // zeros

                System.out.println("In findOptimalVertexHeights");

                int i0 = 0, i1 = 1, i2 = 2;
                // Prefer the triangle that contains the origin...
                {
                    FORI (iEdge, edges.length)
                    {
                        Edge edge = edges[iEdge];
                        if (edge.nextEdgeOnLeftFace().nextEdgeOnLeftFace().nextEdgeOnLeftFace() != edge)
                            continue;
                        Vertex v0 = edge.initialVertex();
                        Vertex v1 = edge.nextEdgeOnLeftFace().initialVertex();
                        Vertex v2 = edge.nextEdgeOnLeftFace().nextEdgeOnLeftFace().initialVertex();
                        if (twiceTriArea(0,0,
                                         v0.x,v0.y,
                                         v1.x,v1.y) >= 0
                         && twiceTriArea(0,0,
                                         v1.x,v1.y,
                                         v2.x,v2.y) >= 0
                         && twiceTriArea(0,0,
                                         v2.x,v2.y,
                                         v0.x,v0.y) >= 0)
                        {
                            i0 = v0.myIndex();
                            i1 = v1.myIndex();
                            i2 = v2.myIndex();
                            break; // origin is inside this tri CCW
                        }
                    }
                }

                // Figure out the desired dualEdgeLength...
                // XXX just hard code for now
                double desiredDualEdgeLength = .1;

                int edge2dualVert[] = VecMath.fillvec(edges.length, -1);
                int edge2dualEdge[] = VecMath.fillvec(edges.length, -1);

                int nDualVerts, nDualEdges;
                {
                    nDualVerts = 0;
                    nDualEdges = 0;
                    FORI (iEdge, edges.length)
                    {
                        if (edge2dualVert[iEdge] != -1)
                            continue; // already saw some other edge on this tri
                        Edge edge = edges[iEdge];
                        Edge edge1 = edge.nextEdgeOnLeftFace();
                        Edge edge2 = edge1.nextEdgeOnLeftFace();
                        boolean thisIsATri = (edge2.nextEdgeOnLeftFace() == edge);
                        if (thisIsATri)
                        {
                            edge2dualVert[iEdge] = nDualVerts;
                            edge2dualVert[edge1.myIndex()] = nDualVerts;
                            edge2dualVert[edge2.myIndex()] = nDualVerts;
                            nDualVerts++;

                            if (edge2dualVert[edge.opposite().myIndex()] != -1
                             && edge.opposite().nextEdgeOnLeftFace().nextEdgeOnLeftFace().nextEdgeOnLeftFace() == edge.opposite())
                            {
                                // Opposite edge is also on a tri
                                // that we haven't counted yet
                                edge2dualEdge[iEdge] = nDualEdges;
                                nDualEdges++;
                            }
                        }
                    }
                }
                PRINT(nDualVerts);
                PRINT(nDualEdges);

                int dualVert2verts[][] = VecMath.fillmat(nDualVerts, 3, -1);
                int dualEdge2edge[] = VecMath.fillvec(nDualEdges, -1); // XXX not used?
                int dualEdge2dualVerts[][] = VecMath.fillmat(nDualEdges, 2, -1);
                {
                    FORI (iEdge, edges.length)
                    {
                        int iDualEdge = edge2dualEdge[iEdge];
                        if (iDualEdge != -1 // if it has a dual edge
                         && dualEdge2dualVerts[iDualEdge][0] == -1) // if we didn't already do this dual edge from the opposite
                        {
                            dualEdge2edge[iDualEdge] = iEdge;
                            dualEdge2dualVerts[iDualEdge][0] = edge2dualVert[iEdge];
                            dualEdge2dualVerts[iDualEdge][1] = edge2dualVert[edges[iEdge].opposite().myIndex()];
                        }

                        int iDualVert = edge2dualVert[iEdge];
                        if (iDualVert != -1 // if this edge is on a triangle
                         && dualVert2verts[iDualVert][0] == -1) // if we didn't already do this dual vert
                        {
                            dualVert2verts[iDualVert][0] = mesh.edges[iEdge].initialVertex().myIndex();
                            dualVert2verts[iDualVert][1] = mesh.edges[iEdge].nextEdgeOnLeftFace().initialVertex().myIndex();
                            dualVert2verts[iDualVert][2] = mesh.edges[iEdge].nextEdgeOnLeftFace().nextEdgeOnLeftFace().initialVertex().myIndex();
                        }
                    }
                    FORI (iDualVert, nDualVerts)
                        FORI (j, 3)
                            assert(dualVert2verts[iDualVert][j] != -1);

                    FORI (iDualEdge, nDualEdges)
                    {
                        assert(dualEdge2edge[iDualEdge] != -1);
                        assert(dualEdge2dualVerts[iDualEdge][0] != -1);
                        assert(dualEdge2dualVerts[iDualEdge][1] != -1);
                    }
                }



                PRINT(i0);
                PRINT(i1);
                PRINT(i2);
                PRINT(verts.length);
                int nIndependentVerts = verts.length - 3; // XXX not right in general
                if (nIndependentVerts > nDualEdges)
                {
                    PRINT(nIndependentVerts);
                    PRINT(nDualEdges);
                    System.out.println("Out findOptimalVertexHeights (too many independent verts, it's underconstrained)");
                    return new double[verts.length]; // zeros
                }

                int vert2independentVert[] = new int[verts.length];
                int independentVert2verts[] = new int[nIndependentVerts];
                {
                    int iIndependentVert = 0;
                    FORI (iVert, verts.length)
                    {
                        if (iVert != i0 && iVert != i1 && iVert != i2)
                        {
                            vert2independentVert[iVert] = iIndependentVert;
                            independentVert2verts[iIndependentVert] = iVert;
                            iIndependentVert++;
                        }
                        else
                            vert2independentVert[iVert] = -1;
                    }
                    assert(iIndependentVert == nIndependentVerts);
                }
                PRINT(nIndependentVerts);
                PRINT(nDualEdges);


                double sampleResultLengths[][] = new double[nIndependentVerts+1][nDualEdges];
                {
                    double sampleHeights[][] = new double[nIndependentVerts+1][nIndependentVerts];
                    VecMath.identitymat(sampleHeights); // the unit basis vectors, and a row of zeros at the end

                    double dualVertsScratch[][] = new double[nDualVerts][2];

                    FORI (iSample, sampleHeights.length)
                    {
                        //
                        // Input sampleHeights[iSample]
                        // and get out sampleResultLengths[iSample]
                        //
                        FORI (iDualVert, nDualVerts)
                        {
                            int iVert0 = dualVert2verts[iDualVert][0];
                            int iVert1 = dualVert2verts[iDualVert][1];
                            int iVert2 = dualVert2verts[iDualVert][2];
                            int iIndependentVert0 = vert2independentVert[iVert0];
                            int iIndependentVert1 = vert2independentVert[iVert1];
                            int iIndependentVert2 = vert2independentVert[iVert2];
                            double h0 = (iIndependentVert0 == -1 ? 0. : sampleHeights[iSample][iIndependentVert0]);
                            double h1 = (iIndependentVert1 == -1 ? 0. : sampleHeights[iSample][iIndependentVert1]);
                            double h2 = (iIndependentVert2 == -1 ? 0. : sampleHeights[iSample][iIndependentVert2]);
                            Vertex v0 = verts[iVert0];
                            Vertex v1 = verts[iVert1];
                            Vertex v2 = verts[iVert2];
                            PRINT(h0);
                            PRINT(h1);
                            PRINT(h2);
                            SolveForDualPoint(v0.x,v0.y,h0,
                                              v1.x,v1.y,h1,
                                              v2.x,v2.y,h2,
                                              dualVertsScratch[iDualVert]);
                        }
                        FORI (iDualEdge, nDualEdges)
                        {
                            sampleResultLengths[iSample][iDualEdge] =
                                VecMath.dist(dualVertsScratch[dualEdge2dualVerts[iDualEdge][0]],
                                             dualVertsScratch[dualEdge2dualVerts[iDualEdge][1]]);
                        }
                    }
                    PRINTMAT(sampleHeights);
                    PRINTMAT(sampleResultLengths);
                }

                //
                // Row i of A is the result from the i'th basis sample,
                // minus the result from the 0 vector.
                //
                double A[][] = new double[nIndependentVerts][nDualEdges];
                FORI (i, nIndependentVerts)
                    VecMath.vmv(A[i],
                                sampleResultLengths[i],
                                sampleResultLengths[nIndependentVerts]);
                //
                // b is the desired result
                // minus the result from the 0 vector.
                //
                double b[] = VecMath.fillvec(nDualEdges, desiredDualEdgeLength);
                VecMath.vmv(b, b, sampleResultLengths[nIndependentVerts]);

                PRINTMAT(A);
                PRINTVEC(b);

                //
                // Solve the linear least squares system...
                //
                System.out.print("    Solving... ");
                System.out.flush();
                double leastSquaresSolution[] = VecMath.vxinvm(b, A);
                System.out.println("    done.");


                assert(leastSquaresSolution.length == independentVert2verts.length);
                double optimalVertexHeights[] = new double[verts.length];
                FORI (iIndex, independentVert2verts.length)
                {
                    optimalVertexHeights[independentVert2verts[iIndex]] = leastSquaresSolution[iIndex];
                }
                optimalVertexHeights[i0] = 0.;
                optimalVertexHeights[i1] = 0.;
                optimalVertexHeights[i2] = 0.;

                System.out.println("Out findOptimalVertexHeights");

                return optimalVertexHeights;
            } // findOptimalVertexHeights


            // XXX should really make these vectors or something,
            // XXX so that all operations will be constant time.
            public Vertex verts[] = {};
            public Edge edges[] = {};
        } // class Mesh


        /*
            Given:
                x0,y0,h0
                x1,y1,h1
                x2,y2,h2
            representing an infinitesimal triangle
            whose vertices are infinitesimally-squared away from the unit sphere:
                x0 eps, y0 eps, 1 + h0 eps^2
                x1 eps, y1 eps, 1 + h1 eps^2
                x2 eps, y2 eps, 1 + h2 eps^2
            we want to find x,y,h
            representing the point:
                x eps, y eps, h eps^2
            that is the intersection point of the 3 planes
            whose closest-points-to-origin are the original 3 points.
            If we write this out, it's equivalent to solving:
                [x0 y0 1] [x]   [x0^2 + y0^2 + h0]
                [x1 y1 1] [y] = [x1^2 + y1^2 + h1]
                [x2 y2 1] [h]   [x0^2 + y2^2 + h2]
        */
        static void SolveForDualPoint(double x0, double y0, double h0,
                                      double x1, double y1, double h1,
                                      double x2, double y2, double h2,
                                      double result[])
        {
            double M[][] = {
                {x0,y0,1},
                {x1,y1,1},
                {x2,y2,1},
            };
            double b[] = {
                x0*x0 + y0*y0 + h0,
                x1*x1 + y1*y1 + h1,
                x2*x2 + y2*y2 + h2,
            };
            if (result.length == 3)
                VecMath.invmxv(result,M,b);
            else // result.length == 2, just copy the first two
                VecMath.copyvec(result, VecMath.invmxv(M,b));

        } // SolveForDualPoint

        static double twiceTriArea(double x0, double y0,
                                   double x1, double y1,
                                   double x2, double y2)
        {
            return (x1-x0)*(y2-y0) - (x2-x0)*(y1-y0);
        }

        // eps is in linear units
        static boolean edgesCrossOrCloseToIt(double a0x, double a0y,
                                             double a1x, double a1y,
                                             double b0x, double b0y,
                                             double b1x, double b1y,
                                             double eps)
        {
            return twiceTriArea(a0x,a0y,
                                a1x,a1y,
                                b1x,b1y)
                 * twiceTriArea(a1x,a1y,
                                a0x,a0y,
                                b0x,b0y) >= -eps*eps*eps*eps
                && twiceTriArea(b0x,b0y,
                                b1x,b1y,
                                a0x,a0y)
                 * twiceTriArea(b1x,b1y,
                                b0x,b0y,
                                a1x,a1y) >= -eps*eps*eps*eps;
        } // edgesCrossOrCloseToIt

        static double distSqrdFromPointToSeg(double x, double y,
                                             double x0, double y0,
                                             double x1, double y1)
        {
            double v[] = {x-x0,y-y0};
            double v1[] = {x1-x0,y1-y0};
            if (VecMath.normsqrd(v1) == 0.)
                return VecMath.normsqrd(v);
            double t = VecMath.dot(v,v1)
                     / VecMath.dot(v1,v1);
            t = CLAMP(t, 0., 1.);
            double vprojectedOntoV1[] = VecMath.sxv(t, v1);
            return VecMath.distsqrd(v, vprojectedOntoV1);
        }


    //
    // App-specific variables...
    //
        Mesh mesh = new Mesh();
        int selectedVertIndex = -1;
        boolean doOptimize = false;
        boolean doLabels = false;

        boolean doShowPositiveOrthantnessVisualization = false; // XXX total hack-- it's cool but put it somewhere else!!

    //
    // Applet-generic member variables...
    //
        GraphicsAntiAliasingSetter graphicsAntiAliasingSetter;
        int eventVerbose = 0; // can set with eventVerbose=1 on command line
        int nonEventVerbose = 0;
        boolean doAntiAliasing = false;
        boolean implementAntiAliasingInHardware = true; // XXX should have a better name for this-- really mean let java runtime do it
        double lineThicknessInPixels = 1.;
        boolean doDoubleBuffer = true;
        java.awt.Image backBufferImage = null;
        MyGraphics mostRecentGraphics = null;

        double prevP[] = null;

    //
    // Track mouse state...
    // (I think java newer versions of java (XXX starting when?)
    // let you query from the events themselves,
    // but e.g. in 1.1 there is no way to tell whether button1
    // is down during a drag without keeping state
    //
        boolean button1IsDown = false;
        boolean button2IsDown = false;
        boolean button3IsDown = false;


    //
    // Main...
    //
    public static void main(final String args[])
    {
        System.out.println("in main");

        final java.awt.Frame frame = new java.awt.Frame("Shephards Play Applet") {
            public boolean handleEvent(java.awt.Event event)
            {
                switch(event.id)
                {
                    case java.awt.Event.WINDOW_DESTROY:
                        System.out.println("bye!");
                        // Empirically, either of the following
                        // cause the app to exit-- do both to be safe!
                        // (XXX I've heard rumors that just doing dispose()
                        //  messes up the debugger)
                        // (XXX but doing exit is evil)
                        dispose(); // hide() doesn't delete the windows
                        System.exit(0);
                        return true;
                }
                return super.handleEvent(event);
            }
        };

        // ARGH! The above no longer works in java 1.5!
        // have to use a listener I guess...
        frame.addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent we) {
                System.out.println("ciao!");
                frame.dispose(); // hide() doesn't delete the windows
                System.exit(0);
            }
        });

        final ShephardsPlayApplet applet = new ShephardsPlayApplet();

        // XXX the following seems to be necessary, or getParameter() will crash, at least in 1.4.  Want to send params from command line anyway.
        applet.setStub(new java.applet.AppletStub() {
             public void appletResize(int width, int height)
                 { /* should resize frame, but a ShephardsPlayApplet never asks to be resized */ }
             public java.applet.AppletContext getAppletContext() { return null;}             public java.net.URL getCodeBase() { return null; }
             public java.net.URL getDocumentBase() { return null; }
             public String getParameter(String name)
             {
                 // case insensitive... and unfortunately there's no
                 // startsWithIgnoreCase
                 String prefix = name.toLowerCase() + "=";
                 int i;
                 FOR (i, args.length)
                     if (args[i].toLowerCase().startsWith(prefix))
                         return args[i].substring(prefix.length());
                 return null;
             }
             public boolean isActive() { return true; }
        });

        frame.add(applet);

        applet.init();
        applet.start();

        frame.move(400, 20);
        frame.resize(512, 512);
        frame.show();

        System.out.println("out main");
    } // main
} // class ShephardsPlayApplet
