/*
Trying to make a little applet
that will let me play with triangulations with heights,
and produce the dual diagrams with heights.

For starters, always triangulates entire convex hull.
User should be able to:
    left click - add a vertex
                   - if inside a triangle, trisects the triangle
                   - if outside the convex hull, connects up
                     to all visible other vertices
    right click - delete a vertex that's on the convex hull
                  or that's only connected to three neighbors
    middle drag - move a vertex
    's' - swap a diagonal

BUG:
    - 'n' for net, Optimize LENGTHS_INFINITY_NORM, Hexes Spiral -> infinite loop  (no it's not, it just takes a long time)
    - the cyan edges sometimes go from the lagoon to itself-- need to get rid of those
    - maximizeMinimum failing when optimizing the initial picture, whatever that is (it's not any more, hmm, maybe just forget this)
    - makeDualMesh seems to be computing each triangle center 3 times,
      and each quad center 4 times, etc.

TO DO:

    - only draw dual edges once (so it won't fight with anti-aliasing)
    - get a nice color scheme
    - show perpendicular of edges, somehow, so can see when off balance

    - think about which optimization types to retain if any
        - maybe optimization should always be max min length, but choice should be how to match scale and translate afterwards.
          Translate:
              - match overall cg of verts to cg of tris
              - match overall cg of verts to circumcenter of tris (can be tricky if degenerate)
          Scale:
              - match variance in some sense?
              - match total length?
              - match bbox?

    - improve kaleidescope:
        - detect and use center
        - detect and use complete symmetry group
        - key to increase or decrease period (requires vertex in center?)
        - snap closest image to exact image? hmm, not sure
        - mode to place new verts in kaleidescope? (draw dots at images of cursor?)

    - +/- should maybe look at undo and redo stack, and use it if possible, to save memory

    - ability to snap to integer grid?

    - show perpendicular of edges, somehow, so can see when off balance
    - mode to highlight all good ways out of given lagoon

    - simple translation from simple lists and back... creating that sample scene was a nightmare!
    - fix optimization problem
    - figure out simpler math behind the mapping from vert heights to edge lengths
    - animation of optimization
    - animation of swap
    - animation of delete vertex (maybe-- might have to triangulate the face to get this to work, which wouldn't be a bad thing)
    - key to delaunayize?
    - don't draw crap when resizing (and fix whatever other applet I got this from too)
    - figure out why stack traces show .java on top even after renumbering
    - write a generic applet to reduce pain each time
    - other mesh editing operations (split face by edge, split edge by vertex, join adjacent vertices, separate a vertex into two (but how to assign the neighbors?))  (idea: same interface as split face by edge... but only works if on two different faces... maybe connec dual verts?)
    - make selected dual verts not so fragile (maybe store the triangles, rather than dual verts indices? not sure)
        - at least, if all selected, make those same selected again?
        - also, during swap, if both relevant ones selected, make them both selected again
    - BUG: figure out how to make it not repaint continuously when resizing (my other appets too)
    - BUG: when only part of window gets exposed, only the exposed part gets painted?  hmm, not sure I have control over this
    - BUG: can't reconnect an isolated vertex to the rest
    - look at this, maybe clues about positive octant penalty functions...
        http://www.cs.indiana.edu/~yingfeng/ABSURDIST/javadoc/penalty/PenaltyMinimizer.html
      something about "translating into a positive orthant problem" and "optimizing over the positive orthant"
      intersection of a linear subspace witht the positive orthant
      http://projecteuclid.org/Dienst/UI/1.0/Summarize/euclid.mmj/1028988894
      The knee-jerk mapping:
      http://www.math.dartmouth.edu/~doyle/docs/jerk/jerk.pdf
*/

#include "macros.h"

// So can compile in pre-1.4,
// we use these instead of java.awt.event.MouseEvent.BUTTON1 etc.
#define java_awt_event_MouseEvent_BUTTON1 1
#define java_awt_event_MouseEvent_BUTTON2 2
#define java_awt_event_MouseEvent_BUTTON3 3


import com.donhatchsw.util.Arrays;
import com.donhatchsw.util.MyMath;
import com.donhatchsw.util.VecMath;
import com.donhatchsw.util.SortStuff;
import com.donhatchsw.util.ConvexHull;
import com.donhatchsw.util.LinearProgramming;
import com.donhatchsw.util.UndoTreeSquirrel;
import com.donhatchsw.util.TriangulationOptimizer;
import com.donhatchsw.util.Minimizer;
import com.donhatchsw.util.Listenable;
import com.donhatchsw.compat.ArrayList;
import com.donhatchsw.compat.IntArrayList;
import com.donhatchsw.awt.Row;
import com.donhatchsw.awt.Col;
import com.donhatchsw.awt.TablePanel;
import com.donhatchsw.awt.RowLayout;
import com.donhatchsw.awt.ColLayout;
import com.donhatchsw.awt.TableLayout;

public class ShephardsPlayApplet
    extends java.applet.Applet
{
    //
    // Utilities for applet stuff...
    //
        private String getParameterString(String paramName,
                                       String defaultValue)
        {
            String paramValueString = getParameter(paramName);
            if (paramValueString != null)
                return paramValueString;
            else
                return defaultValue;
        }
        private int getParameterInt(String paramName,
                                    int defaultValue)
        {
            String paramValueString = getParameter(paramName);
            if (paramValueString != null)
            {
                try
                {
                    return Integer.decode(paramValueString).intValue();
                }
                catch (NumberFormatException e)
                {
                    return 0;
                }
            }
            else
                return defaultValue;
        }
        private double getParameterDouble(String paramName,
                                          double defaultValue)
        {
            String paramValueString = getParameter(paramName);
            if (paramValueString != null)
            {
                try
                {
                    return Double.parseDouble(paramValueString);
                }
                catch (NumberFormatException e)
                {
                    return 0;
                }
            }
            else
                return defaultValue;
        }
        private boolean getParameterBoolean(String paramName,
                                            boolean defaultValue)
        {
            String paramValueString = getParameter(paramName);
            if (paramValueString != null)
            {
                // Too simplistic, only honors case-sensitive "true"
                //return Boolean.valueOf(paramValueString).booleanValue();

                try
                {
                    int n = Integer.decode(paramValueString).intValue();
                    return n != 0;
                }
                catch (NumberFormatException e)
                {
                    if (paramValueString.equalsIgnoreCase("true")
                     || paramValueString.equalsIgnoreCase("yes")
                     || paramValueString.equalsIgnoreCase("t")
                     || paramValueString.equalsIgnoreCase("y"))
                        return true;
                    return false;
                }
            }
            else
                return defaultValue;
        }

    //
    // Implementing Applet methods...
    //
        public ShephardsPlayApplet()
        {
            // used as "fill" argument to add()
            final java.awt.GridBagConstraints stretchx = new java.awt.GridBagConstraints(){{fill=HORIZONTAL;weightx=1.;}};
            final java.awt.GridBagConstraints stretchy = new java.awt.GridBagConstraints(){{fill=VERTICAL;weighty=1.;}};
            final java.awt.GridBagConstraints stretchxy = new java.awt.GridBagConstraints(){{fill=BOTH;weightx=weighty=1.;}};

            setLayout(new ColLayout());

            add(theCanvas = new TheCanvas() {
                },
                stretchxy
            );

            add(new Row() {{ // first row of buttons

                add(new java.awt.Button("Clear") {
                    public boolean isFocusTraversable() { return false; } // so doesn't steal from canvas
                {
                    addActionListener(new java.awt.event.ActionListener() {
                        public void actionPerformed(java.awt.event.ActionEvent e)
                        {
                            UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);

                            mesh = new Mesh();
                            if (doContinuouslyDelaunayize.get()) delaunayize();

                            UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);
                            undoTreeSquirrel.Do(new UndoItem(before, after));

                            theCanvas.repaint();
                        }
                    });
                }});

                add(new java.awt.Label("    "), stretchx);

                add(new java.awt.Button("Hexes Spiral") {
                    public boolean isFocusTraversable() { return false; } // so doesn't steal from canvas
                {
                    addActionListener(new java.awt.event.ActionListener() {
                        public void actionPerformed(java.awt.event.ActionEvent e)
                        {
                            UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);

                            doCannedThingHexesSpiral();

                            UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);
                            undoTreeSquirrel.Do(new UndoItem(before, after));

                            theCanvas.repaint();
                        }
                    });
                }});

                add(new java.awt.Button("Hexes Spiral Alt") {
                    public boolean isFocusTraversable() { return false; } // so doesn't steal from canvas
                {
                    addActionListener(new java.awt.event.ActionListener() {
                        public void actionPerformed(java.awt.event.ActionEvent e)
                        {
                            UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);

                            doCannedThingHexesSpiralOther();

                            UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);
                            undoTreeSquirrel.Do(new UndoItem(before, after));

                            theCanvas.repaint();
                        }
                    });
                }});

                add(new java.awt.Button("netless8 symmetric") {
                    public boolean isFocusTraversable() { return false; } // so doesn't steal from canvas
                {
                    addActionListener(new java.awt.event.ActionListener() {
                        public void actionPerformed(java.awt.event.ActionEvent e)
                        {
                            UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);

                            doCannedThingNetless8Symmetric();

                            UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);
                            undoTreeSquirrel.Do(new UndoItem(before, after));

                            theCanvas.repaint();
                        }
                    });
                }});

                add(new java.awt.Button("netless8") {
                    public boolean isFocusTraversable() { return false; } // so doesn't steal from canvas
                {
                    addActionListener(new java.awt.event.ActionListener() {
                        public void actionPerformed(java.awt.event.ActionEvent e)
                        {
                            UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);

                            doCannedThingNetless8();

                            UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);
                            undoTreeSquirrel.Do(new UndoItem(before, after));

                            theCanvas.repaint();
                        }
                    });
                }});

                add(new java.awt.Button("netless9") {
                    public boolean isFocusTraversable() { return false; } // so doesn't steal from canvas
                {
                    addActionListener(new java.awt.event.ActionListener() {
                        public void actionPerformed(java.awt.event.ActionEvent e)
                        {
                            UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);

                            doCannedThingNetless9();

                            UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);
                            undoTreeSquirrel.Do(new UndoItem(before, after));

                            theCanvas.repaint();
                        }
                    });
                }});

                add(new java.awt.Button("Crack Killer") {
                    public boolean isFocusTraversable() { return false; } // so doesn't steal from canvas
                {
                    addActionListener(new java.awt.event.ActionListener() {
                        public void actionPerformed(java.awt.event.ActionEvent e)
                        {
                            UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);

                            doCannedThingCrackKiller();

                            UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);
                            undoTreeSquirrel.Do(new UndoItem(before, after));

                            theCanvas.repaint();
                        }
                    });
                }});

                add(new java.awt.Button("Sweep Killer") {
                    public boolean isFocusTraversable() { return false; } // so doesn't steal from canvas
                {
                    addActionListener(new java.awt.event.ActionListener() {
                        public void actionPerformed(java.awt.event.ActionEvent e)
                        {
                            UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);

                            doCannedThingSweepKiller0();

                            UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);
                            undoTreeSquirrel.Do(new UndoItem(before, after));

                            theCanvas.repaint();
                        }
                    });
                }});
                add(new java.awt.Button("Sweep Killer 1") {
                    public boolean isFocusTraversable() { return false; } // so doesn't steal from canvas
                {
                    addActionListener(new java.awt.event.ActionListener() {
                        public void actionPerformed(java.awt.event.ActionEvent e)
                        {
                            UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);

                            doCannedThingSweepKiller1();

                            UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);
                            undoTreeSquirrel.Do(new UndoItem(before, after));

                            theCanvas.repaint();
                        }
                    });
                }});
                add(new java.awt.Button("Sweep Killer 2") {
                    public boolean isFocusTraversable() { return false; } // so doesn't steal from canvas
                {
                    addActionListener(new java.awt.event.ActionListener() {
                        public void actionPerformed(java.awt.event.ActionEvent e)
                        {
                            UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);

                            doCannedThingSweepKiller2();

                            UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);
                            undoTreeSquirrel.Do(new UndoItem(before, after));

                            theCanvas.repaint();
                        }
                    });
                }});

                add(new java.awt.Button("Algorithm5 Killer0") {
                    public boolean isFocusTraversable() { return false; } // so doesn't steal from canvas
                {
                    addActionListener(new java.awt.event.ActionListener() {
                        public void actionPerformed(java.awt.event.ActionEvent e)
                        {
                            UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);

                            doCannedThingAlgorithm5Killer0();

                            UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);
                            undoTreeSquirrel.Do(new UndoItem(before, after));

                            theCanvas.repaint();
                        }
                    });
                }});

                add(new java.awt.Button("Algorithm5 Killer1") {
                    public boolean isFocusTraversable() { return false; } // so doesn't steal from canvas
                {
                    addActionListener(new java.awt.event.ActionListener() {
                        public void actionPerformed(java.awt.event.ActionEvent e)
                        {
                            UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);

                            doCannedThingAlgorithm5Killer1();

                            UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);
                            undoTreeSquirrel.Do(new UndoItem(before, after));

                            theCanvas.repaint();
                        }
                    });
                }});

                add(new java.awt.Button("Lagoon Killer") {
                    public boolean isFocusTraversable() { return false; } // so doesn't steal from canvas
                {
                    addActionListener(new java.awt.event.ActionListener() {
                        public void actionPerformed(java.awt.event.ActionEvent e)
                        {
                            UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);

                            doCannedThingBlindLagoonExitKiller();

                            UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);
                            undoTreeSquirrel.Do(new UndoItem(before, after));

                            theCanvas.repaint();
                        }
                    });
                }});

                add(new java.awt.Button("Far Lagoon Killer") {
                    public boolean isFocusTraversable() { return false; } // so doesn't steal from canvas
                {
                    addActionListener(new java.awt.event.ActionListener() {
                        public void actionPerformed(java.awt.event.ActionEvent e)
                        {
                            UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);

                            doCannedThingFarthestLagoonExitKiller();

                            UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);
                            undoTreeSquirrel.Do(new UndoItem(before, after));

                            theCanvas.repaint();
                        }
                    });
                }});

            }}, stretchx); // first row of buttons

            add(new Row() {{ // second row: col, table, col
                add(new Col() {{
                    add(new Row() {{
                        add(new java.awt.Button("Load DUMP.off") {
                            public boolean isFocusTraversable() { return false; } // so doesn't steal from canvas
                        {
                            addActionListener(new java.awt.event.ActionListener() {
                                public void actionPerformed(java.awt.event.ActionEvent e)
                                {
                                    UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);

                                    load("DUMP.off");

                                    UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);
                                    undoTreeSquirrel.Do(new UndoItem(before, after));

                                    theCanvas.repaint();
                                }
                            });
                        }});

                        add(new java.awt.Button("Save DUMP.off") {
                            public boolean isFocusTraversable() { return false; } // so doesn't steal from canvas
                        {
                            addActionListener(new java.awt.event.ActionListener() {
                                public void actionPerformed(java.awt.event.ActionEvent e)
                                {
                                    save("DUMP.off");
                                }
                            });
                        }});

                        add(new java.awt.Button("Save DUALVERTS.txt") {
                            public boolean isFocusTraversable() { return false; } // so doesn't steal from canvas
                        {
                            addActionListener(new java.awt.event.ActionListener() {
                                public void actionPerformed(java.awt.event.ActionEvent e)
                                {
                                    dualSave("DUALVERTS.txt");
                                }
                            });
                        }});

                        add(new java.awt.Label(""), stretchx);
                    }}, stretchxy);
                    add(new Row() {{
                        add(new java.awt.Checkbox("Optimize", doOptimize.get()) {
                            public boolean isFocusTraversable() { return false; } // so doesn't steal from canvas
                            {
                                addItemListener(new java.awt.event.ItemListener() {
                                    public void itemStateChanged(java.awt.event.ItemEvent e)
                                    {
                                        UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);
                                        doOptimize.set(getState());
                                        System.out.println("doOptimize -> "+doOptimize.get());
                                        if (doContinuouslyDelaunayize.get()) delaunayize();
                                        UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);
                                        undoTreeSquirrel.Do(new UndoItem(before, after));
                                        theCanvas.repaint();
                                    }
                                });
                                doOptimize.addListener(doOptimizeListener = new Listenable.Listener() {
                                    public void valueChanged()
                                    {
                                        setState(doOptimize.get()); // of the checkbox
                                    }
                                });
                            }
                        });
                        add(new java.awt.Choice() {
                            public boolean isFocusTraversable() { return false; } // so doesn't steal from canvas
                            {
                                FORI (i, optimizationTypeNames.length)
                                    insert(optimizationTypeNames[availableOptimizationTypes[i]], i);
                                select(optimizationTypeIndex.get());
                                addItemListener(new java.awt.event.ItemListener() {
                                    public void itemStateChanged(java.awt.event.ItemEvent e)
                                    {
                                        UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);


                                        optimizationTypeIndex.set(getSelectedIndex());
                                        optimizationType = availableOptimizationTypes[optimizationTypeIndex.get()];
                                        System.out.println("optimizationType -> "+optimizationTypeNames[optimizationType]);


                                        if (doContinuouslyDelaunayize.get()) delaunayize();
                                        UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);
                                        undoTreeSquirrel.Do(new UndoItem(before, after));
                                        theCanvas.repaint();
                                    }
                                });
                                optimizationTypeIndex.addListener(optimizationTypeIndexListener = new Listenable.Listener() {
                                    public void valueChanged()
                                    {
                                        select(optimizationTypeIndex.get());
                                    }
                                });
                            }
                        });
                        add(new java.awt.Checkbox("Delaunayize", doContinuouslyDelaunayize.get()) {
                            public boolean isFocusTraversable() { return false; } // so doesn't steal from canvas
                            {
                                addItemListener(new java.awt.event.ItemListener() {
                                    public void itemStateChanged(java.awt.event.ItemEvent e)
                                    {
                                        UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);
                                        doContinuouslyDelaunayize.set(getState());
                                        System.out.println("doContinuouslyDelaunayize -> "+doContinuouslyDelaunayize.get());
                                        if (doContinuouslyDelaunayize.get()) delaunayize();
                                        UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);
                                        undoTreeSquirrel.Do(new UndoItem(before, after));
                                        theCanvas.repaint();
                                    }
                                });
                                doContinuouslyDelaunayize.addListener(doContinuouslyDelaunayizeListener = new Listenable.Listener() {
                                    public void valueChanged()
                                    {
                                        setState(doContinuouslyDelaunayize.get()); // of the checkbox
                                    }
                                });
                            }
                        });
                        add(new java.awt.Label(""), stretchxy);
                    }}, stretchx);
                }}, stretchy);

                add(new TablePanel() {{
                    add(new java.awt.Button("") {
                        public boolean isFocusTraversable() { return false; } // so doesn't steal from canvas
                        public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(15,19); }
                        public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(15,19); }
                        public void paint(java.awt.Graphics g)
                        {
                            g.setColor(java.awt.Color.black);
                            drawBitmapCentered(g, size(),
                                               new String[] {
                                                  "      *      ",
                                                  "     ***     ",
                                                  "    ** **    ",
                                                  "             ",
                                                  "  *       *  ",
                                                  "  **     **  ",
                                                  "   **   **   ",
                                                  "  **     **  ",
                                                  "  *       *  ",
                                                  "             ",
                                                  "    ** **    ",
                                                  "     ***     ",
                                                  "      *      ",
                                               });
                        }
                    {
                        addActionListener(new java.awt.event.ActionListener() {
                            public void actionPerformed(java.awt.event.ActionEvent e)
                            {
                                rescale(Math.sqrt(.5), Math.sqrt(2.));
                            }
                        });
                    }}, stretchxy);
                    add(new java.awt.Button("") {
                        public boolean isFocusTraversable() { return false; } // so doesn't steal from canvas
                        public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(11,19); }
                        public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(11,19); }
                        public void paint(java.awt.Graphics g)
                        {
                            g.setColor(java.awt.Color.black);
                            drawBitmapCentered(g, size(),
                                               new String[] {
                                                  "      *      ",
                                                  "     ***     ",
                                                  "    ** **    ",
                                                  "             ",
                                                  "             ",
                                                  "             ",
                                                  "             ",
                                                  "             ",
                                                  "             ",
                                                  "             ",
                                                  "    ** **    ",
                                                  "     ***     ",
                                                  "      *      ",
                                               });
                        }
                    {
                        addActionListener(new java.awt.event.ActionListener() {
                            public void actionPerformed(java.awt.event.ActionEvent e)
                            {
                                rescale(1., Math.sqrt(2.));
                            }
                        });
                    }}, stretchxy);
                    add(new java.awt.Button("") {
                        public boolean isFocusTraversable() { return false; } // so doesn't steal from canvas
                        public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(19,19); }
                        public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(19,19); }
                        public void paint(java.awt.Graphics g)
                        {
                            g.setColor(java.awt.Color.black);
                            drawBitmapCentered(g, size(),
                                               new String[] {
                                                  "      *      ",
                                                  "     ***     ",
                                                  "    ** **    ",
                                                  "             ",
                                                  "  *       *  ",
                                                  " **       ** ",
                                                  "**         **",
                                                  " **       ** ",
                                                  "  *       *  ",
                                                  "             ",
                                                  "    ** **    ",
                                                  "     ***     ",
                                                  "      *      ",
                                                  "             ",
                                               });
                        }
                    {
                        addActionListener(new java.awt.event.ActionListener() {
                            public void actionPerformed(java.awt.event.ActionEvent e)
                            {
                                rescale(Math.sqrt(2.), Math.sqrt(2.));
                            }
                        });
                    }}, stretchxy);
                    advanceRow();
                    add(new java.awt.Button("") {
                        public boolean isFocusTraversable() { return false; } // so doesn't steal from canvas
                        public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(15,11); }
                        public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(15,11); }
                        public void paint(java.awt.Graphics g)
                        {
                            g.setColor(java.awt.Color.black);
                            drawBitmapCentered(g, size(),
                                               new String[] {
                                                  "             ",
                                                  "             ",
                                                  "             ",
                                                  "             ",
                                                  "  *       *  ",
                                                  "  **     **  ",
                                                  "   **   **   ",
                                                  "  **     **  ",
                                                  "  *       *  ",
                                                  "             ",
                                                  "             ",
                                                  "             ",
                                                  "             ",
                                               });
                        }
                    {
                        addActionListener(new java.awt.event.ActionListener() {
                            public void actionPerformed(java.awt.event.ActionEvent e)
                            {
                                rescale(Math.sqrt(.5), 1.);
                            }
                        });
                    }}, stretchxy);
                    add(new java.awt.Button("f") {
                        public boolean isFocusTraversable() { return false; } // so doesn't steal from canvas
                        public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(17,17); }
                        public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(17,17); }
                    {
                        addActionListener(new java.awt.event.ActionListener() {
                            public void actionPerformed(java.awt.event.ActionEvent e)
                            {
                                frame();
                            }
                        });
                    }}, stretchxy);
                    add(new java.awt.Button("") {
                        public boolean isFocusTraversable() { return false; } // so doesn't steal from canvas
                        public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(19,11); }
                        public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(19,11); }
                        public void paint(java.awt.Graphics g)
                        {
                            g.setColor(java.awt.Color.black);
                            drawBitmapCentered(g, size(),
                                               new String[] {
                                                  "             ",
                                                  "             ",
                                                  "             ",
                                                  "             ",
                                                  "  *       *  ",
                                                  " **       ** ",
                                                  "**         **",
                                                  " **       ** ",
                                                  "  *       *  ",
                                                  "             ",
                                                  "             ",
                                                  "             ",
                                                  "             ",
                                               });
                        }
                    {
                        addActionListener(new java.awt.event.ActionListener() {
                            public void actionPerformed(java.awt.event.ActionEvent e)
                            {
                                rescale(Math.sqrt(2.), 1.);
                            }
                        });
                    }}, stretchxy);
                    advanceRow();
                    add(new java.awt.Button("") {
                        public boolean isFocusTraversable() { return false; } // so doesn't steal from canvas
                        public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(15,15); }
                        public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(15,15); }
                        public void paint(java.awt.Graphics g)
                        {
                            g.setColor(java.awt.Color.black);
                            drawBitmapCentered(g, size(),
                                               new String[] {
                                                  "             ",
                                                  "             ",
                                                  "    ** **    ",
                                                  "     ***     ",
                                                  "  *   *   *  ",
                                                  "  **     **  ",
                                                  "   **   **   ",
                                                  "  **     **  ",
                                                  "  *   *   *  ",
                                                  "     ***     ",
                                                  "    ** **    ",
                                                  "             ",
                                                  "             ",
                                               });
                        }
                    {
                        addActionListener(new java.awt.event.ActionListener() {
                            public void actionPerformed(java.awt.event.ActionEvent e)
                            {
                                rescale(Math.sqrt(.5), Math.sqrt(.5));
                            }
                        });
                    }}, stretchxy);
                    add(new java.awt.Button("") {
                        public boolean isFocusTraversable() { return false; } // so doesn't steal from canvas
                        public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(11,15); }
                        public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(11,15); }
                        public void paint(java.awt.Graphics g)
                        {
                            g.setColor(java.awt.Color.black);
                            drawBitmapCentered(g, size(),
                                               new String[] {
                                                  "             ",
                                                  "             ",
                                                  "    ** **    ",
                                                  "     ***     ",
                                                  "      *      ",
                                                  "             ",
                                                  "             ",
                                                  "             ",
                                                  "      *      ",
                                                  "     ***     ",
                                                  "    ** **    ",
                                                  "             ",
                                                  "             ",
                                               });
                        }
                    {
                        addActionListener(new java.awt.event.ActionListener() {
                            public void actionPerformed(java.awt.event.ActionEvent e)
                            {
                                rescale(1., Math.sqrt(.5));
                            }
                        });
                    }}, stretchxy);
                    add(new java.awt.Button("") {
                        public boolean isFocusTraversable() { return false; } // so doesn't steal from canvas
                        public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(19,15); }
                        public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(19,15); }
                        public void paint(java.awt.Graphics g)
                        {
                            g.setColor(java.awt.Color.black);
                            drawBitmapCentered(g, size(),
                                               new String[] {
                                                  "             ",
                                                  "             ",
                                                  "    ** **    ",
                                                  "     ***     ",
                                                  "  *   *   *  ",
                                                  " **       ** ",
                                                  "**         **",
                                                  " **       ** ",
                                                  "  *   *   *  ",
                                                  "     ***     ",
                                                  "    ** **    ",
                                                  "             ",
                                                  "             ",
                                               });
                        }
                    {
                        addActionListener(new java.awt.event.ActionListener() {
                            public void actionPerformed(java.awt.event.ActionEvent e)
                            {
                                rescale(Math.sqrt(2.), Math.sqrt(.5));
                            }
                        });
                    }}, stretchxy);
                }}); // table

                add(new Col() {{
                    add(new Row() {{
                        add(new java.awt.Label(""), stretchx);

                        add(new java.awt.Button("Help") {
                            public boolean isFocusTraversable() { return false; } // so doesn't steal from canvas
                        {
                            addActionListener(new java.awt.event.ActionListener() {
                                public void actionPerformed(java.awt.event.ActionEvent e)
                                {
                                    help();
                                }
                            });
                        }});
                    }}, stretchxy);
                    add(new Row() {{
                        add(new java.awt.Label(""), stretchx);

                        add(new java.awt.Button("Undo") {
                            public boolean isFocusTraversable() { return false; } // so doesn't steal from canvas
                        {
                            addActionListener(new java.awt.event.ActionListener() {
                                public void actionPerformed(java.awt.event.ActionEvent e)
                                {
                                    UndoItem item = (UndoItem)undoTreeSquirrel.undo();
                                    if (item != null)
                                    {
                                        mesh = new Mesh(item.before.mesh);
                                        doContinuouslyDelaunayize.set(item.before.doContinuouslyDelaunayize);
                                        doOptimize.set(item.before.doOptimize);
                                        optimizationTypeIndex.set(item.before.optimizationTypeIndex);
                                        optimizationType = availableOptimizationTypes[optimizationTypeIndex.get()];
                                        selectedDualVertIndices = VecMath.copyvec(item.before.selectedDualVertIndices);
                                    }
                                    else
                                    {
                                        System.out.println("Nothing to undo!");
                                    }
                                    theCanvas.repaint();
                                }
                            });
                        }});
                        add(new java.awt.Button("Redo") {
                            public boolean isFocusTraversable() { return false; } // so doesn't steal from canvas
                        {
                            addActionListener(new java.awt.event.ActionListener() {
                                public void actionPerformed(java.awt.event.ActionEvent e)
                                {
                                    UndoItem item = (UndoItem)undoTreeSquirrel.redo();
                                    if (item != null)
                                    {
                                        mesh = new Mesh(item.after.mesh);
                                        doContinuouslyDelaunayize.set(item.after.doContinuouslyDelaunayize);
                                        doOptimize.set(item.after.doOptimize);
                                        optimizationTypeIndex.set(item.after.optimizationTypeIndex);
                                        optimizationType = availableOptimizationTypes[optimizationTypeIndex.get()];
                                        selectedDualVertIndices = VecMath.copyvec(item.after.selectedDualVertIndices);
                                    }
                                    else
                                    {
                                        System.out.println("Nothing to redo!");
                                    }
                                    theCanvas.repaint();
                                }
                            });
                        }});
                    }}, stretchx);
                }}, stretchxy);
            }}, stretchx); // second row: col, table, col

            //randomlyColorize(this);
        } // ShephardsPlayApplet ctor

        private static void help()
        {
            System.out.println("===================================================================");
            System.out.println("Mouse:");
            System.out.println("    left click: add a vertex and drag it");
            System.out.println("    middle drag: drag a vertex");
            System.out.println("    right click: delete a vertex");
            System.out.println("    shift-middle drag: pan entire picture");
            System.out.println("    shift-left drag: create new edge between two vertices");
            System.out.println("    ctrl-left and ctrl-middle: add/drag vertex and all reflections of it");
            System.out.println("Keys:");
            System.out.println("    'V' - cycle verbosity (to java console or system output)");
            System.out.println("    ' ' - just repaint");
            System.out.println("    'A' - toggle doAntiAliasing");
            System.out.println("    't' - toggle primary (triangle) mesh");
            System.out.println("    'B' - toggle doDoubleBuffer");
            System.out.println("    'i'/'+'/'=' - zoom in");
            System.out.println("    'o'/'-' - zoom out");
            System.out.println("    'f' - frame picture");
            System.out.println("    '|' - flip left-right");
            System.out.println("    '_' - flip up-down");
            System.out.println("    's' - swap a diagonal");
            System.out.println("    ctrl-'s' - swap a diagonal if the result is more Delaunay");
            System.out.println("    'D' - Delaunay triangulate");
            System.out.println("    'w' - add or remove closest red point from list of points to show curvature center of");
            System.out.println("    'O' - toggle doOptimize");
            System.out.println("    'l' - toggle doLabels");
            System.out.println("    'a' - toggle doArrowsTowardsSharpestDihedrals (green)");
            System.out.println("    alt-'a' - toggle doArrowsTowardsShortestEdges (cyan)");
            System.out.println("    'n' - toggle showNet");
            System.out.println("    'S' - turn off optimize, and re-spherize");
            System.out.println("    'd' - delete closest edge");
            System.out.println("    ctrl-'i' - toggle doShowInsideOutDualVerts");
            System.out.println("    ctrl-'o' - cycle optimizationType");
            System.out.println("    ctrl-'v' - toggle nonEventVerbose");
            System.out.println("    Up arrow: pull face plane of closest vertex out");
            System.out.println("    Down arrow: push face plane of closest vertex in");
            System.out.println("    Left/right arrow: translate fudge");
            System.out.println("    'c' - clear");
            System.out.println("    ctrl-'c' - example in which cutting the sharpest dihedral at each vertex does not lead to a solution");
            System.out.println("    'u' / ctrl-'z' - undo");
            System.out.println("    'r' / 'U' / ctrl-'r' / ctrl-'y' - redo");
            System.out.println("    'h' - help");
            System.out.println("    ctrl-'q' - quit");
            System.out.println("===================================================================");
        } // help

        private static void randomlyColorize(java.awt.Component c)
        {
            c.setBackground(new java.awt.Color((float)Math.random(),
                                               (float)Math.random(),
                                               (float)Math.random()));
            c.setForeground(new java.awt.Color((float)Math.random(),
                                               (float)Math.random(),
                                               (float)Math.random()));
            if (c instanceof java.awt.Container)
            {
                java.awt.Container C = (java.awt.Container)c;
                int n = C.getComponentCount();
                for (int i = 0; i < n; ++i)
                    randomlyColorize(C.getComponent(i));
            }
        } // randomlyColorize

        public void dualSave(String fileName)
        {
            System.out.println("Saving dual verts to "+fileName+"... ");
            System.out.flush();
            try {
                java.io.PrintWriter writer = new java.io.PrintWriter(new java.io.BufferedWriter(new java.io.FileWriter(fileName)));
                // XXX want \r\n no matter which platform I'm on, I think

                int nDualVerts = mostRecentDualMesh.verts.size();
                FORI (iDualVert, nDualVerts)
                {
                    Mesh.Vertex dualVert = (Mesh.Vertex)mostRecentDualMesh.verts.get(iDualVert);
                    if (dualVert.arity == 3
                     && (doShowInsideOutDualVerts
                      || dualVert.weight >= 0))
                        writer.println("        {" + dualVert.x
                                   + ", " + dualVert.y
                                   + ", " + dualVert.h
                                   + "},");
                    else
                        writer.println("null");
                }

                writer.flush();
                writer.close();
            }
            catch (Exception exc)
            {
                System.out.println("save to file "+fileName+" failed:" + exc);
            }
            System.out.println("done.");
        } // save
        public void save(String fileName)
        {
            System.out.println("Saving to "+fileName+"... ");
            System.out.flush();
            try {
                java.io.PrintWriter writer = new java.io.PrintWriter(new java.io.BufferedWriter(new java.io.FileWriter(fileName)));

                // XXX want \n\r no matter which platform I'm on!

                writer.println("OFF");

                // count faces
                int nFaces;
                {
                    boolean didEdge[] = new boolean[mesh.edges.size()]; // all false
                    nFaces = 0; // and counting
                    int nEdges = mesh.edges.size();
                    FORI (iEdge, nEdges)
                    {
                        if (didEdge[iEdge])
                            continue;
                        nFaces++;
                        Mesh.Edge e = (Mesh.Edge)mesh.edges.get(iEdge);
                        while (!didEdge[e.myIndex()])
                        {
                            didEdge[e.myIndex()] = true;
                            e = e.next();
                        }
                    }
                }
                writer.println("" + mesh.verts.size()
                            + " " + nFaces
                            + " " + 0);
                FORI (iVert, mesh.verts.size())
                {
                    Mesh.Vertex vert = (Mesh.Vertex)mesh.verts.get(iVert);
                    writer.println("" + vert.x + " " + vert.y + " " + vert.h);
                }
                {
                    boolean didEdge[] = new boolean[mesh.edges.size()]; // all false
                    int nEdges = mesh.edges.size();
                    IntArrayList vertsThisFace = new IntArrayList();
                    FORI (iEdge, nEdges)
                    {
                        if (didEdge[iEdge])
                            continue;
                        vertsThisFace.clear();
                        Mesh.Edge e = (Mesh.Edge)mesh.edges.get(iEdge);
                        while (!didEdge[e.myIndex()])
                        {
                            didEdge[e.myIndex()] = true;
                            vertsThisFace.add(e.initialVertex().myIndex());
                            e = e.next();
                        }
                        writer.print("" + vertsThisFace.size() + " ");
                        FORI (iVertThisFace, vertsThisFace.size())
                            writer.print(" " + vertsThisFace.get(iVertThisFace));
                        writer.println();
                    }
                }

                writer.flush();
                writer.close();
            }
            catch (Exception exc)
            {
                System.out.println("save to file "+fileName+" failed:" + exc);
            }
            System.out.println("done.");
        } // save
        public void load(String fileName)
        {
            System.out.print("Loading from "+fileName+"... ");
            System.out.flush();
            try {
                java.io.LineNumberReader reader = new java.io.LineNumberReader(new java.io.FileReader(fileName)); // LineNumberReader is already a buffered reader
                String line;
                if ((line = reader.readLine()) == null)
                {
                    reader.close();
                    throw new Exception("premature EOF expecting OFF");
                }
                if (!line.equals("OFF"))
                {
                    reader.close();
                    throw new Exception("expected OFF, got \""+line+"\"");
                }
                if ((line = reader.readLine()) == null)
                {
                    reader.close();
                    throw new Exception("premature EOF expecting number of verts, faces, 0");
                }
                //String[] tokens = line.trim().split("\\s+");
                String[] tokens = com.donhatchsw.compat.regex.split(line.trim(), "\\s+");
                if (tokens.length != 3)
                {
                    reader.close();
                    throw new Exception("expected number of verts, number of faces, 0, got \""+line+"\"");
                }
                int nVerts = Integer.parseInt(tokens[0]);
                int nFaces = Integer.parseInt(tokens[1]);
                int zero = Integer.parseInt(tokens[2]);
                double verts[][] = new double[nVerts][3];
                int faces[][] = new int[nFaces][];

                FORI (iVert, nVerts)
                {
                    if ((line = reader.readLine()) == null)
                    {
                        reader.close();
                        throw new Exception("premature EOF trying to read vertex "+iVert+"/"+nVerts+"");
                    }
                    //tokens = line.trim().split("\\s+");
                    tokens = com.donhatchsw.compat.regex.split(line.trim(), "\\s+");
                    if (tokens.length != 3)
                    {
                        reader.close();
                        throw new Exception("expected 3 floating point numbers, got \""+line+"\"");
                    }
                    FORI (i, 3)
                        verts[iVert][i] = Double.parseDouble(tokens[i]);
                }
                FORI (iFace, nFaces)
                {
                    if ((line = reader.readLine()) == null)
                    {
                        reader.close();
                        throw new Exception("premature EOF trying to read face "+iFace+"/"+nFaces+"");
                    }
                    //tokens = line.trim().split("\\s+");
                    tokens = com.donhatchsw.compat.regex.split(line.trim(), "\\s+");
                    if (tokens.length == 0)
                    {
                        reader.close();
                        throw new Exception("expected a face, got \""+line+"\"");
                    }
                    int faceSize = Integer.parseInt(tokens[0]);
                    if (tokens.length != 1 + faceSize)
                    {
                        reader.close();
                        throw new Exception("expected a face, got \""+line+"\" (wrong number of indices)");
                    }
                    faces[iFace] = new int[faceSize];
                    FORI (i, faceSize)
                        faces[iFace][i] = Integer.parseInt(tokens[i+1]);
                }
                reader.close();

                mesh = new Mesh(verts, faces);

                if (doContinuouslyDelaunayize.get()) delaunayize();
            }
            catch (Exception exc)
            {
                exc.printStackTrace();
                System.out.println("load from file "+fileName+" failed:" + exc);            }
            System.out.println("done.");
        } // load

        public void rescale(double scaleX, double scaleY)
        {
            UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);
            double scale = Math.sqrt(.5);
            FORIDOWN (iVert, mesh.verts.size())
            {
                Mesh.Vertex vert = (Mesh.Vertex)mesh.verts.get(iVert);
                vert.h -= .5 * (SQR(vert.x) + SQR(vert.y)); // convert to "actual"
                vert.x *= scaleX;
                vert.y *= scaleY;
                vert.h *= scaleX * scaleY;
                vert.h += .5 * (SQR(vert.x) + SQR(vert.y)); // convert from "actual"
            }
            // should be no need to re-delaunayize if uniform scale
            if (scaleX != scaleY)
                if (doContinuouslyDelaunayize.get()) delaunayize();
            UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);
            undoTreeSquirrel.Do(new UndoItem(before, after));
            theCanvas.repaint();
        } // rescale

        public void frame()
        {
            UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);

            {
                double minx = Double.POSITIVE_INFINITY;
                double miny = Double.POSITIVE_INFINITY;
                double maxx = Double.NEGATIVE_INFINITY;
                double maxy = Double.NEGATIVE_INFINITY;
                FORIDOWN(iVert, mesh.verts.size())
                {
                    Mesh.Vertex vert = (Mesh.Vertex)mesh.verts.get(iVert);
                    minx = MIN(minx, vert.x);
                    maxx = MAX(maxx, vert.x);
                    miny = MIN(miny, vert.y);
                    maxy = MAX(maxy, vert.y);
                }
                double center[] = {(minx+maxx)*.5, (miny+maxy)*.5};
                double maxsize = MAX(maxx-minx, maxy-miny);
                double scale = 2./maxsize;
                if (maxsize > 0.)
                {
                    FORIDOWN(iVert, mesh.verts.size())
                    {
                        Mesh.Vertex vert = (Mesh.Vertex)mesh.verts.get(iVert);
                        vert.x -= center[0];
                        vert.y -= center[1];

                        vert.x *= scale;
                        vert.y *= scale;
                        vert.h *= scale*scale;
                    }
                }
            }

            // should be no need to re-delaunayize, since uniform scale
            UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);
            undoTreeSquirrel.Do(new UndoItem(before, after));
            theCanvas.repaint();
        } // frame



        public void init()
        {
            eventVerbose = getParameterInt("EventVerbose", eventVerbose);
            if (eventVerbose >= 1) System.out.println("in init");

            // These (and eventVerbose) can be specified on the command line as, e.g. doLabels=true
            doLabels = getParameterBoolean("doLabels", doLabels);
            doContinuouslyDelaunayize.set(getParameterBoolean("doContinuouslyDelaunayize", doContinuouslyDelaunayize.get()));
            doOptimize.set(getParameterBoolean("doOptimize", doOptimize.get()));
            doShowPositiveOrthantnessVisualization = getParameterBoolean("doShowPositiveOrthantnessVisualization", doShowPositiveOrthantnessVisualization);
            // XXX this is kind of messed up, we don't get to know whether the user misspelled something


            graphicsAntiAliasingSetter = new GraphicsAntiAliasingSetter();

            //doCannedThingHexesSpiral();
            //doCannedThingNetless9();
            //doCannedThingEyeball();
            //doCannedThingNetless8();
            //doCannedThingCrackKiller();
            //doCannedThingHexesSpiralOther();
            //doCannedThingNetless8Symmetric();
            //doCannedThingNetless8Optimized();
            //doCannedThingSweepKiller0();
            //doCannedThingSweepKiller1();
            //doCannedThingAlgorithm5Killer0();
            //doCannedThingAlgorithm5Killer1();
            //doCannedThingBlindLagoonExitKiller();
            doCannedThingFarthestLagoonExitKiller();
            //doBlueNoiseThing();
            //load("DUMP.off");

            if (eventVerbose >= 1) System.out.println("out init");
        } // init

        public void start()
        {
            if (eventVerbose >= 1) System.out.println("in start");
            if (eventVerbose >= 1) System.out.println("out start");
        }
        public void stop()
        {
            if (eventVerbose >= 1) System.out.println("in stop");
            if (eventVerbose >= 1) System.out.println("out stop");
        }
        public void destroy()
        {
            if (eventVerbose >= 1) System.out.println("in destroy");
            if (eventVerbose >= 1) System.out.println("out destroy");
        }

        //
        // Button behavor changed incompatibly between Java 1.1 and 1.4
        // (not sure exactly what version it changed in though).
        // (I think it was 1.4 since that's when getButton() was added
        // to MouseEvent).
        //
        private static int getButton(java.awt.event.MouseEvent e)
        {
            // gag me! we can't even query the java spec version number
            // since System.getProperty() throws a security exception
            // in netscape!
            // so use empirical evidence...
            int mods = e.getModifiers();
#if 0 // can't seem to get this to work under IE at all, so don't try for now, it will just be wrong under 1.4
            boolean is_1_4_or_greater = ((mods & ~0x1fff) != 0);
            if (is_1_4_or_greater)
            {
                try
                {
                    return e.getButton();
                }
                catch (NoSuchMethodError err)
                {
                    // this only happens in IE, not netscape. fall through...
                }
            }
#endif

            if ((mods & java.awt.event.InputEvent.ALT_MASK) != 0)
                return java_awt_event_MouseEvent_BUTTON2;
            if ((mods & java.awt.event.InputEvent.META_MASK) != 0)
                return java_awt_event_MouseEvent_BUTTON3;
            return java_awt_event_MouseEvent_BUTTON1;
        } // getButton

        private class TheCanvas
            extends java.awt.Canvas
            implements java.awt.event.MouseListener,
                       java.awt.event.MouseMotionListener,
                       java.awt.event.KeyListener
        {
            TheCanvas()
            {
                // Specify an "event listener" object
                // to respond to events.
                // (>= Java 1.1 event model).
                this.addMouseListener(this);
                this.addMouseMotionListener(this);
                this.addKeyListener(this);
            }

            //
            // MouseListener and MouseMotionListener methods...
            //
            public void mousePressed(java.awt.event.MouseEvent e)
            {
                if (eventVerbose >= 1) System.out.println("in mousePressed: "+e);
                if (eventVerbose >= 1)
                {
                    if (getButton(e) == java_awt_event_MouseEvent_BUTTON1)
                        System.out.println("    (left mouse)");
                    if (getButton(e) == java_awt_event_MouseEvent_BUTTON2)
                        System.out.println("    (middle mouse)");
                    if (getButton(e) == java_awt_event_MouseEvent_BUTTON3)
                        System.out.println("    (right mouse)");
                }

                double thisP[] = new double[2];
                mostRecentGraphics.pick(e.getX(), e.getY(), thisP);

                stateWhenPressed = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);

                int whichButton = getButton(e);

                if (whichButton != java_awt_event_MouseEvent_BUTTON2) // no need to clear selection when just dragging
                {
                    if (selectedDualVertIndices.length > 0
                     && selectedDualVertIndices.length == nDrawnDualVerts)
                        selectAllDualVertsAtNextOpportunity = true;
                    selectedDualVertIndices = new int[] {};
                }

                if (whichButton == java_awt_event_MouseEvent_BUTTON1)
                {
                    button1IsDown = true;

                    if (e.isShiftDown())
                    {
                        //
                        // Add an edge from the closest vertex
                        //
                        System.out.println("    Adding an edge at "+thisP[0]+" "+thisP[1]+" "+0+"");

                        //
                        // If there are no vertices, add one
                        //
                        ArrayList verts = mesh.verts;
                        if (verts.size() == 0)
                        {
                            System.out.println("        (Adding a vertex first)");
                            mesh.addIsolatedVertex(thisP[0], thisP[1], 0);
                        }

                        //
                        // Select closest vertex
                        //
                        beingDraggedVertIndex = mesh.indexOfClosestVert(thisP[0],thisP[1]);
                        rubberBandingNewEdge = true;
                    }
                    else // shift is not down
                    {
                        //
                        // Add a vertex
                        //

                        double vertsToAdd[][] = {
                            thisP,
                        };

                        if (e.isControlDown())
                        {
                            // add a mirror image.
                            // prepend instead of appending, so that the last thing we do
                            // is the one that will be dragged.
                            vertsToAdd = (double[][])Arrays.concat(new double[][]{{-thisP[0], thisP[1]}}, vertsToAdd);
                            // TODO: detect entire symmetry group
                        }

                        FORI (iVertToAdd, vertsToAdd.length)
                        {
                            double vertToAdd[] = vertsToAdd[iVertToAdd];
                            double x = vertToAdd[0];
                            double y = vertToAdd[1];

                            System.out.println("    Adding a vertex at "+x+" "+y+" "+0+"");
                            mesh.addIsolatedVertex(x, y, 0);

                            ArrayList verts = mesh.verts;
                            ArrayList edges = mesh.edges;
                            if (verts.size() >= 2)
                            {
                                //
                                // If are no edges at all, add an edge.
                                // XXX this is kind of lame when there were more than one isolated vertex, should connect to them all
                                //
                                if (edges.size() == 0)
                                {
                                    System.out.println("Adding an edge between two verts");
                                    mesh.addEdgeBetweenTwoIsolatedVertices((Mesh.Vertex)verts.get(verts.size()-2),
                                                                           (Mesh.Vertex)verts.get(verts.size()-1));
                                }
                                else // edges.size() >= 1
                                {
                                    // There was already an edge.
                                    // Find out which face we are on
                                    // (all triangles CCW), and kis that face.
                                    // if we are not inside any face by that criterion,
                                    // then assume we are inside the outer face
                                    // and connect the new vertex to every vertex
                                    // that's visible from it.
                                    //
                                    boolean kissed = false;
                                    double twiceMostNegativeFaceArea = Double.POSITIVE_INFINITY;
                                    Mesh.Edge edgeOnMostNegativeFace = null;
                                    // XXX traverses each face of size n n times!  need to keep track of what we've done already
                                    int nEdges = mesh.edges.size();
                                    FORI (iEdge, nEdges)
                                    {
                                        boolean thisFaceIsGoodSoFar = true;
                                        Mesh.Edge edgeI = (Mesh.Edge)mesh.edges.get(iEdge);
                                        double twiceThisFaceArea = 0.;
                                        for (Mesh.Edge edge = edgeI;;)
                                        {
                                            double twiceThisTriArea = twiceTriangleArea(
                                                                    x, y,
                                                                    edge.initialVertex().x,
                                                                    edge.initialVertex().y,
                                                                    edge.finalVertex().x,
                                                                    edge.finalVertex().y);
                                            if (twiceThisTriArea < 0)
                                            {
                                                thisFaceIsGoodSoFar = false; // it's bad!
                                            }
                                            twiceThisFaceArea += twiceThisTriArea;

                                            if ((edge = edge.next()) == edgeI)
                                                break;
                                        }
                                        if (thisFaceIsGoodSoFar)
                                        {
                                            // I'm inside this face;
                                            // kis it and done
                                            mesh.kisIsolatedVertex((Mesh.Vertex)verts.get(verts.size()-1),
                                                                   edgeI);
                                            kissed = true;
                                            break;
                                        }
                                        if (twiceThisFaceArea < twiceMostNegativeFaceArea)
                                        {
                                            twiceMostNegativeFaceArea = twiceThisFaceArea;
                                            edgeOnMostNegativeFace = edgeI;
                                        }
                                    }
                                    if (!kissed)
                                    {
                                        System.out.println("In the outer face");
                                        //
                                        // It wasn't inside any face.
                                        // Assume it's in the outer face.
                                        // In this case,
                                        // make a kiss to the outer face
                                        // and then delete all newly added edges
                                        // that cross the boundary of the outer face.
                                        //

                                        ArrayList/*<Mesh.Edge>*/ oldOuterFaceBoundary = new ArrayList();
                                        for (Mesh.Edge edge = edgeOnMostNegativeFace;;)
                                        {
                                            oldOuterFaceBoundary.add(edge);
                                            if ((edge = edge.next()) == edgeOnMostNegativeFace)
                                                break;
                                        }
                                        int oldOuterFaceBoundarySize = oldOuterFaceBoundary.size();

                                        int oldNumEdges = mesh.edges.size();
                                        mesh.kisIsolatedVertex((Mesh.Vertex)verts.get(verts.size()-1),
                                                               edgeOnMostNegativeFace);
                                        if (!e.isShiftDown()) // XXX TODO: document that shift-left kisses whole boundary
                                        {
                                            for (int iEdge = oldNumEdges;
                                                 iEdge < mesh.edges.size();
                                                 iEdge += 2) // only do one of an edge and its opposite
                                            {
                                                for (int iOldBoundaryEdge = 0;
                                                     iOldBoundaryEdge < oldOuterFaceBoundarySize;
                                                     ++iOldBoundaryEdge)
                                                {
                                                    Mesh.Edge oldEdge = (Mesh.Edge)oldOuterFaceBoundary.get(iOldBoundaryEdge);
                                                    Mesh.Edge newEdge = (Mesh.Edge)mesh.edges.get(iEdge);

                                                    if (newEdge.initialVertex() == oldEdge.initialVertex()
                                                     || newEdge.initialVertex() == oldEdge.finalVertex()
                                                     || newEdge.finalVertex() == oldEdge.initialVertex()
                                                     || newEdge.finalVertex() == oldEdge.finalVertex())
                                                        continue;
                                                    //System.out.println("    Seeing whether new edge v"+newEdge.initialVertex().myIndex()+" -> v"+newEdge.finalVertex().myIndex()+" crosses old boundary edges v"+oldEdge.initialVertex().myIndex()+" -> v"+oldEdge.finalVertex().myIndex()+"");
                                                    if (edgesCrossOrCloseToIt(
                                                                    oldEdge.initialVertex().x,
                                                                    oldEdge.initialVertex().y,
                                                                    oldEdge.finalVertex().x,
                                                                    oldEdge.finalVertex().y,
                                                                    newEdge.initialVertex().x,
                                                                    newEdge.initialVertex().y,
                                                                    newEdge.finalVertex().x,
                                                                    newEdge.finalVertex().y,
                                                                    1e-6))
                                                    {
                                                        //System.out.println("        It does.");
                                                        mesh.deleteEdge(newEdge);
                                                        iEdge -= 2; // so we don't skip the one that gets moved into the deleted spot
                                                        break;
                                                    }
                                                    else
                                                    {
                                                        //System.out.println("        It doesn't.");
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } // if verts.length >= 3
                            } // if verts.size() >= 2 after adding the new vertex

                            mesh.sanityCheck();

                            beingDraggedVertIndex = verts.size()-1;
                        }
                    }
                }
                else if (whichButton == java_awt_event_MouseEvent_BUTTON2)
                {
                    button2IsDown = true;

                    //
                    // Select closest vertex
                    //
                    beingDraggedVertIndex = mesh.indexOfClosestVert(thisP[0],thisP[1]);

                    System.out.println("Dragging vertex "+beingDraggedVertIndex+"");
                }
                else if (whichButton == java_awt_event_MouseEvent_BUTTON3)
                {
                    button3IsDown = true;

                    //
                    // Delete closest vertex
                    //
                    beingDraggedVertIndex = mesh.indexOfClosestVert(thisP[0],thisP[1]);
                    if (beingDraggedVertIndex != -1)
                        mesh.deleteVertex((Mesh.Vertex)mesh.verts.get(beingDraggedVertIndex));
                    beingDraggedVertIndex = -1;

                    mesh.sanityCheck();

                } // right mouse

                if (doContinuouslyDelaunayize.get()) delaunayize();

                prevP = thisP;

                theCanvas.repaint();

                if (eventVerbose >= 1) System.out.println("out mousePressed: "+e);
            } // mousePressed
            public void mouseReleased(java.awt.event.MouseEvent e)
            {
                if (eventVerbose >= 1) System.out.println("in mouseReleased: "+e);

                double thisP[] = new double[2];
                mostRecentGraphics.pick(e.getX(), e.getY(), thisP);

                int whichButton = getButton(e);
                if (whichButton == java_awt_event_MouseEvent_BUTTON1)
                {
                    if (rubberBandingNewEdge)
                    {
                        if (mesh.verts.size() == 1)
                        {
                            mesh.addIsolatedVertex(thisP[0], thisP[1], 0);
                        }
                        int finalVertIndex = mesh.indexOfClosestVert(thisP[0],thisP[1]);
                        if (beingDraggedVertIndex != -1
                         && finalVertIndex != -1
                         && beingDraggedVertIndex != finalVertIndex)
                        {
                            System.out.println("Trying to add an edge between "+beingDraggedVertIndex+" and "+finalVertIndex);
                            ArrayList verts = mesh.verts;
                            mesh.addEdgeBetweenTwoVertices((Mesh.Vertex)mesh.verts.get(beingDraggedVertIndex),
                                                           (Mesh.Vertex)mesh.verts.get(finalVertIndex));
                            mesh.sanityCheck();
                        }
                    }

                    rubberBandingNewEdge = false;

                    button1IsDown = false;
                }
                else if (whichButton == java_awt_event_MouseEvent_BUTTON2)
                {
                    button2IsDown = false;
                }
                else if (whichButton == java_awt_event_MouseEvent_BUTTON3)
                {
                    button3IsDown = false;
                }

                if (doContinuouslyDelaunayize.get()) delaunayize();

                if (stateWhenPressed != null)
                {
                    UndoItem.State stateWhenReleased = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);
                    undoTreeSquirrel.Do(new UndoItem(stateWhenPressed, stateWhenReleased));
                    stateWhenPressed = null;
                }

                prevP = thisP;

                theCanvas.repaint();

                if (eventVerbose >= 1) System.out.println("out mouseReleased: "+e);
            }
            public void mouseEntered(java.awt.event.MouseEvent e)
            {
                if (eventVerbose >= 1) System.out.println("in mouseEntered: "+e);
                // steal keyboard focus!
                if (eventVerbose >= 1) System.out.println("out mouseEntered: "+e);
            }
            public void mouseExited(java.awt.event.MouseEvent e)
            {
                if (eventVerbose >= 1) System.out.println("in mouseExited: "+e);
                if (eventVerbose >= 1) System.out.println("out mouseExited: "+e);
            }
            public void mouseClicked(java.awt.event.MouseEvent e)
            {
                if (eventVerbose >= 1) System.out.println("in mouseClicked: "+e);
                if (eventVerbose >= 1) System.out.println("out mouseClicked: "+e);
            }
            public void mouseDragged(java.awt.event.MouseEvent e)
            {
                if (eventVerbose >= 2) System.out.println("  in mouseDragged: "+e);

                double thisP[] = new double[2];
                mostRecentGraphics.pick(e.getX(), e.getY(), thisP);

                if (button1IsDown || button2IsDown)
                {
                    if (rubberBandingNewEdge)
                    {
                        // nothing, we'll just draw the rubberband in the new position when we repaint
                    }
                    else
                    {
                        if (e.isShiftDown())
                        {
                            // Drag all the verts
                            FORIDOWN (iVert, mesh.verts.size())
                            {
                                ((Mesh.Vertex)mesh.verts.get(iVert)).x += thisP[0]-prevP[0];
                                ((Mesh.Vertex)mesh.verts.get(iVert)).y += thisP[1]-prevP[1];
                            }
                        }
                        else if (beingDraggedVertIndex != -1)
                        {
                            if (e.isControlDown())
                            {
                                // Drag all 6 points of kaleidoscope

                                // XXX should do it around whatever center we can find
                                // XXX should do it with whatever rotational periodicity we can find

#if 1
                                // rotation by 120 degrees, row-oriented
                                double A[][] = {
                                   { Math.cos(DTOR(120)), Math.sin(DTOR(120))},
                                   {-Math.sin(DTOR(120)), Math.cos(DTOR(120))},
                                };
                                // left-right reflection
                                double B[][] = {
                                    {-1,0},
                                    {0,1},
                                };
                                double AA[][] = VecMath.mxm(A,A);
                                double I[][] = VecMath.mxm(AA,A);
                                double AB[][] = VecMath.mxm(A,B);
                                double AAB[][] = VecMath.mxm(AA,B);
                                double group[][][] = {I,A,AA,B,AB,AAB};
#endif
#if 0
                                // rotation by 180 degrees, row-oriented
                                double A[][] = {
                                   { Math.cos(DTOR(180)), Math.sin(DTOR(180))},
                                   {-Math.sin(DTOR(180)), Math.cos(DTOR(180))},
                                };
                                // left-right reflection
                                double B[][] = {
                                    {-1,0},
                                    {0,1},
                                };
                                double I[][] = VecMath.mxm(A,A);
                                double group[][][] = {I,A};
#endif

                                double v[] = {((Mesh.Vertex)mesh.verts.get(beingDraggedVertIndex)).x,
                                              ((Mesh.Vertex)mesh.verts.get(beingDraggedVertIndex)).y};
                                double dv[] = VecMath.vmv(thisP, prevP);


                                double newVertPositions[][] = new double[mesh.verts.size()][2];
                                FORI (i, newVertPositions.length)
                                {
                                    newVertPositions[i][0] = ((Mesh.Vertex)mesh.verts.get(i)).x;
                                    newVertPositions[i][1] = ((Mesh.Vertex)mesh.verts.get(i)).y;
                                }

                                // Whenever we can find a reflected image vertex in a mirror,
                                // apply the reflected dv to the reflected image vertex.
                                // In particular, if the vertex is its own image,
                                // that means the mirror passes through it;
                                // this will end up constraining it to the mirror
                                // (and moving it twice as far along the mirror as otherwise, which is fine).
                                FORI (iGroup, group.length)
                                {
                                    double image[] = VecMath.vxm(v,group[iGroup]);
                                    int iImage = mesh.indexOfClosestVert(
                                                    image[0], image[1]);

                                    double imageVertPosition[] = {
                                        ((Mesh.Vertex)mesh.verts.get(iImage)).x,
                                        ((Mesh.Vertex)mesh.verts.get(iImage)).y,
                                    };

                                    if (VecMath.equals(image, imageVertPosition, 1e-6))
                                    {
                                        // TODO: snap imageVertPosition to image, to prevent drift away from symmetry?
                                        double imageTweak[] = VecMath.vxm(dv, group[iGroup]);
                                        VecMath.vpv(newVertPositions[iImage],
                                                    newVertPositions[iImage],
                                                    imageTweak);
                                    }
                                }
                                FORI (i, newVertPositions.length)
                                {
                                    ((Mesh.Vertex)mesh.verts.get(i)).x = newVertPositions[i][0];
                                    ((Mesh.Vertex)mesh.verts.get(i)).y = newVertPositions[i][1];
                                }
                            }
                            else
                            {
                                // Drag just the selected vert
                                ((Mesh.Vertex)mesh.verts.get(beingDraggedVertIndex)).x += thisP[0]-prevP[0];
                                ((Mesh.Vertex)mesh.verts.get(beingDraggedVertIndex)).y += thisP[1]-prevP[1];
                            }

                            if (doContinuouslyDelaunayize.get()) delaunayize();
                            if (nonEventVerbose >= 1)
                            {
                                double verts[][] = new double[mesh.verts.size()][];
                                FORIDOWN (iVert, mesh.verts.size())
                                    verts[iVert] = new double[] {((Mesh.Vertex)mesh.verts.get(iVert)).x,
                                                                 ((Mesh.Vertex)mesh.verts.get(iVert)).y,
                                                                 ((Mesh.Vertex)mesh.verts.get(iVert)).h};
                                int edges[][] = new int[mesh.edges.size()][];
                                FORIDOWN (iEdge, mesh.edges.size())
                                    edges[iEdge] = new int[] {((Mesh.Edge)mesh.edges.get(iEdge)).initialVertex().myIndex(),
                                                              ((Mesh.Edge)mesh.edges.get(iEdge)).finalVertex().myIndex()};
                                PRINTARRAY(verts);
                                PRINTARRAY(edges);
                            }
                        }
                    }
                }

                if (button3IsDown) // right mouse
                {
                }

                theCanvas.repaint();

                prevP = thisP;

                if (eventVerbose >= 2) System.out.println("  out mouseDragged: "+e);
            }
            public void mouseMoved(java.awt.event.MouseEvent e)
            {
                if (eventVerbose >= 3) System.out.println("    in mouseMoved: "+e);

                if (mostRecentGraphics != null)
                {
                    double thisP[] = new double[2];
                    mostRecentGraphics.pick(e.getX(), e.getY(), thisP);
                    if (showNet)
                    {
                        int closestDualEdgeIndex = mostRecentDualMesh.indexOfClosestEdge(thisP);
                        if (closestDualEdgeIndex != highlightedDualEdgeIndex)
                        {
                            highlightedDualEdgeIndex = closestDualEdgeIndex;
                            theCanvas.repaint();
                        }
                    }
                    prevP = thisP;
                }

                if (eventVerbose >= 3) System.out.println("    out mouseMoved: "+e);
            }

            //
            // KeyListener methods...
            //
            public void keyPressed(java.awt.event.KeyEvent e)
            {
                if (eventVerbose >= 1) System.out.println("in keyPressed: "+e);
                double incr = .005;
                switch(e.getKeyCode())
                {
                    case java.awt.event.KeyEvent.VK_UP:
                    {
                        UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);
                        if (doOptimize.get())
                        {
                            doOptimize.set(false);
                            System.out.println("doOptimize -> "+doOptimize.get()+" ('O' to turn back on)");
                        }
                        System.out.print("Up");
                        System.out.flush();
                        int iVert = mesh.indexOfClosestVert(prevP[0], prevP[1]);
                        if (e.isShiftDown())
                            ((Mesh.Vertex)mesh.verts.get(iVert)).h -= incr*10;
                        else if (e.isControlDown())
                            ((Mesh.Vertex)mesh.verts.get(iVert)).h -= incr*.1;
                        else
                            ((Mesh.Vertex)mesh.verts.get(iVert)).h -= incr;
                        System.out.println("    verts["+iVert+"].h -> "+((Mesh.Vertex)mesh.verts.get(iVert)).h);
                        if (doContinuouslyDelaunayize.get()) delaunayize();
                        UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);
                        undoTreeSquirrel.Do(new UndoItem(before, after));
                        theCanvas.repaint();
                        break;
                    }
                    case java.awt.event.KeyEvent.VK_DOWN:
                    {
                        UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);
                        if (doOptimize.get())
                        {
                            doOptimize.set(false);
                            System.out.println("doOptimize -> "+doOptimize.get()+" ('O' to turn back on)");
                        }
                        System.out.print("Down");
                        System.out.flush();
                        int iVert = mesh.indexOfClosestVert(prevP[0], prevP[1]);
                        if (e.isShiftDown())
                            ((Mesh.Vertex)mesh.verts.get(iVert)).h += incr*10;
                        else if (e.isControlDown())
                            ((Mesh.Vertex)mesh.verts.get(iVert)).h += incr*.1;
                        else
                            ((Mesh.Vertex)mesh.verts.get(iVert)).h += incr;
                        System.out.println("    verts["+iVert+"].h -> "+((Mesh.Vertex)mesh.verts.get(iVert)).h);
                        if (doContinuouslyDelaunayize.get()) delaunayize();
                        UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);
                        undoTreeSquirrel.Do(new UndoItem(before, after));
                        theCanvas.repaint();
                        break;
                    }

                    default:
                        break;
                }
                if (eventVerbose >= 1) System.out.println("out keyPressed: "+e);
            }
            public void keyReleased(java.awt.event.KeyEvent e)
            {
                if (eventVerbose >= 1) System.out.println("in keyReleased: "+e);
                if (eventVerbose >= 1) System.out.println("out keyReleased: "+e);
            }
            public void keyTyped(java.awt.event.KeyEvent e)
            {
                if (eventVerbose >= 1) System.out.println("in keyTyped: "+e);
                char c = e.getKeyChar();

                // In java 1.6, apparently ctrl-letter
                // started coming out as just the letter
                // (with ke.isControlDown() true).
                // Detect this and change it to the old behavior...
                // XXX need to do something else, or nothing at all here, for old javas (1.1) in which isControlDown doesn't exist... or else just stop trying to support 1.1 at all
                if (c >= 'a' && c <= 'z' && e.isControlDown())
                {
                    c -= ('a'-1);
                }

    #define CTRL(lowerCaseLetter) ((lowerCaseLetter)-'a' + 1)
                switch (c)
                {
                    case 'V': // cycle verbosity-- upper-case to minimize possibility of hitting it by accident thus causing subsequent perfomance degradation with no visible reason if Java Console is not visible
                        System.out.print("eventVerbose "+eventVerbose);
                        eventVerbose = (eventVerbose+1) % 4;
                        System.out.println(" -> "+eventVerbose);
                        break;

                    case ' ': // just repaint (i.e. mark dirty)
                        theCanvas.repaint();
                        break;
                    case 'A': // toggle doAntiAliasing
                        doAntiAliasing ^= true;
                        System.out.println("doAntiAliasing -> "+doAntiAliasing+" (if this platform supports it)");
                        theCanvas.repaint();
                        break;

                    case 't': // toggle showTriangles
                        System.out.print("showTriangles "+showTriangles);
                        showTriangles = MOD(showTriangles-1, 3);
                        System.out.println(" -> "+showTriangles);
                        theCanvas.repaint();
                        break;

                    case 'n': // toggle showNet
                        showNet ^= true;
                        System.out.println("showNet -> "+showNet);
                        theCanvas.repaint();
                        break;

                    case 'B': // toggle doDoubleBuffer
                        doDoubleBuffer ^= true;
                        System.out.println("doDoubleBuffer -> "+doDoubleBuffer);
                        theCanvas.repaint();
                        break;

                    case 'i': case '+': case '=': // zoom in
                    {
                        rescale(Math.sqrt(2.), Math.sqrt(2.));
                        break;
                    }
                    case 'o': case '-':           // zoom out
                    {
                        rescale(Math.sqrt(.5), Math.sqrt(.5));
                        break;
                    }
                    case 'f': // frame
                    {
                        frame();
                        break;
                    }
                    case '|': // left-to-right flip whole diagram
                    {
                        UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);
                        mesh.flipLeftRight();
                        // should be no need to re-delaunayize
                        UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);
                        undoTreeSquirrel.Do(new UndoItem(before, after));
                        theCanvas.repaint();
                        break;
                    }
                    case '_': // up-to-down flip whole diagram
                    {
                        UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);
                        mesh.flipUpDown();
                        // should be no need to re-delaunayize
                        UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);
                        undoTreeSquirrel.Do(new UndoItem(before, after));
                        theCanvas.repaint();
                        break;
                    }

                    case 's': // swap diagonal
                    {
                        UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);
                        //
                        // Really would like everything selected
                        // that was selected before,
                        // except for the two dual verts that changed...
                        // the new two should both be selected
                        // if the original two were selected,
                        // or both unselected otherwise.
                        // But we don't really have any way to get the
                        // correspondence.  In fact we have no clue
                        // what the new verts will look like at all,
                        // til they get drawn.
                        // So for now, just set a flag saying
                        // we want them all selected,
                        // if they were all selected before.
                        //
                        if (selectedDualVertIndices.length == nDrawnDualVerts)
                            selectAllDualVertsAtNextOpportunity = true;
                        selectedDualVertIndices = new int[] {};


                        int closestEdgeIndex = mesh.indexOfClosestEdge(prevP);
                        if (closestEdgeIndex != -1)
                        {
                            System.out.println("Swapping diagonal edge e"+closestEdgeIndex);
                            mesh.swapDiagonal((Mesh.Edge)mesh.edges.get(closestEdgeIndex), /*onlyIfMoreDelaunay=*/false, /*verbose=*/true);
                            mesh.sanityCheck();
                        }
                        if (doContinuouslyDelaunayize.get()) delaunayize();

                        UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);
                        undoTreeSquirrel.Do(new UndoItem(before, after));
                        theCanvas.repaint();
                        break;
                    }

                    case CTRL('s'): // swap diagonal but only if it makes it closer to delaunay
                    {
                        // Swap diagonal but only if it makes it closer to delaunay
                        UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);
                        if (selectedDualVertIndices.length == nDrawnDualVerts)
                            selectAllDualVertsAtNextOpportunity = true;
                        selectedDualVertIndices = new int[] {};
                        int closestEdgeIndex = mesh.indexOfClosestEdge(prevP);
                        if (closestEdgeIndex != -1)
                        {
                            System.out.println("Swapping diagonal edge e"+closestEdgeIndex);
                            mesh.swapDiagonal((Mesh.Edge)mesh.edges.get(closestEdgeIndex), /*onlyIfMoreDelaunay=*/true, /*verbose=*/true);
                            mesh.sanityCheck();
                        }
                        if (doContinuouslyDelaunayize.get()) delaunayize(); // silly, it will just undo the swap in this case
                        UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);
                        undoTreeSquirrel.Do(new UndoItem(before, after));
                        theCanvas.repaint();
                        break;
                    }

                    case 'D': // delaunayize
                    {
                        UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);
                        delaunayize();
                        UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);
                        undoTreeSquirrel.Do(new UndoItem(before, after));
                        theCanvas.repaint();
                        break;
                    }

                    case 'w': // toggle closest dual vertex for weighting (think of better mnemonic)
                    {
                        UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);
                        if (mostRecentDualMesh != null)
                        {
                            double closestDistSqrd = Double.POSITIVE_INFINITY;
                            int closestIndex = -1;
                            int nDualVerts = mostRecentDualMesh.verts.size();
                            PRINT(nDualVerts);
                            FORI (iDualVert, nDualVerts) // beginnng to end, so we choose first of equal
                            {
                                Mesh.Vertex dualVert = (Mesh.Vertex)mostRecentDualMesh.verts.get(iDualVert);
                                if (dualVert.arity != 3)
                                    continue; // not a triangle
                                if (!doShowInsideOutDualVerts)
                                {
                                    if (dualVert.weight < 0)
                                        continue; // the triangle is inside out; it's the boundary
                                }
                                double thisDistSqrd = VecMath.distsqrd(prevP, new double[]{dualVert.x,dualVert.y});
                                if (thisDistSqrd < closestDistSqrd)
                                {
                                    closestDistSqrd = thisDistSqrd;
                                    closestIndex = iDualVert;
                                }
                            }
                            int indInd = Arrays.indexOf(selectedDualVertIndices, closestIndex);
                            double closestDualVertWeight = ((Mesh.Vertex)mostRecentDualMesh.verts.get(closestIndex)).weight;
                            double totalWeightBefore = 0.; FORIDOWN(iSelected, selectedDualVertIndices.length) totalWeightBefore += ((Mesh.Vertex)mostRecentDualMesh.verts.get(selectedDualVertIndices[iSelected])).weight;

                            if (indInd != -1)
                            {
                                System.out.println("    deselecting dual vert "+closestIndex);
                                selectedDualVertIndices = (int[])Arrays.delete(selectedDualVertIndices, indInd);
                            }
                            else
                            {
                                System.out.println("    selecting dual vert "+closestIndex);
                                selectedDualVertIndices = (int[])Arrays.append(selectedDualVertIndices, closestIndex);
                            }
                            double totalWeightAfter = 0.; FORIDOWN(iSelected, selectedDualVertIndices.length) totalWeightAfter += ((Mesh.Vertex)mostRecentDualMesh.verts.get(selectedDualVertIndices[iSelected])).weight;
                            System.out.println("    Total selected weight: "+totalWeightBefore+" "+(indInd!=-1?'-':'+')+" "+closestDualVertWeight+" = "+totalWeightAfter+"");
                        }
                        UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);
                        undoTreeSquirrel.Do(new UndoItem(before, after));
                        theCanvas.repaint();
                        break;
                    }
                    case 'd': // delete closest edge
                    {
                        UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);
                        int closestEdgeIndex = mesh.indexOfClosestEdge(prevP);
                        if (closestEdgeIndex != -1)
                        {
                            System.out.println("Deleting edge e"+closestEdgeIndex);
                            mesh.deleteEdge((Mesh.Edge)mesh.edges.get(closestEdgeIndex));
                            mesh.sanityCheck();
                        }
                        doContinuouslyDelaunayize.set(false);
                        UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);
                        undoTreeSquirrel.Do(new UndoItem(before, after));
                        theCanvas.repaint();
                        break;
                    }
                    case 'S': // turn off optimize, and re-sphereize
                    {
                        UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);
                        if (doOptimize.get())
                        {
                            doOptimize.set(false);
                            System.out.println("doOptimize -> "+doOptimize.get()+" ('O' to turn back on)");
                        }
                        FORIDOWN (iVert, mesh.verts.size())
                            ((Mesh.Vertex)mesh.verts.get(iVert)).h = 0.;
                        if (doContinuouslyDelaunayize.get()) delaunayize();
                        UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);
                        undoTreeSquirrel.Do(new UndoItem(before, after));
                        theCanvas.repaint();
                        break;
                    }

                    case 'l': // toggle doLabels
                        doLabels ^= true;
                        System.out.println("doLabels -> "+doLabels);
                        theCanvas.repaint();
                        break;

                    case 'O': // toggle doOptimize
                    {
                        UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);
                        doOptimize.set(!doOptimize.get());
                        System.out.println("doOptimize -> "+doOptimize.get());
                        if (doContinuouslyDelaunayize.get()) delaunayize();
                        UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);
                        undoTreeSquirrel.Do(new UndoItem(before, after));
                        theCanvas.repaint();
                        break;
                    }

                    case 'a': // toggle doArrowsTowardsSharpestDihedrals or doArrowsTowardsShortestEdges
                    {
                        if (e.isAltDown())
                        {
                            doArrowsTowardsShortestEdges ^= true;
                            System.out.println("doArrowsTowardsShortestEdges -> "+doArrowsTowardsShortestEdges);
                        }
                        else
                        {
                            doArrowsTowardsSharpestDihedrals ^= true;
                            System.out.println("doArrowsTowardsSharpestDihedrals -> "+doArrowsTowardsSharpestDihedrals);
                        }
                        theCanvas.repaint();
                        break;
                    }

                    case CTRL('d'): // swap primal and dual
                    {
                        UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);

                        boolean heightsWereAllZero = true;
                        FORI (iVert, mesh.verts.size())
                            if (((Mesh.Vertex)mesh.verts.get(iVert)).h != 0.)
                            {
                                heightsWereAllZero = false;
                                break;
                            }

                        mesh = makeDualMesh(mesh,
                                            true,  // includeNonArity3 (so we get full mesh)
                                            true); // includeInsideOut

                        // this seems to make it a bit better, though I don't really understand.
                        if (heightsWereAllZero)
                        {
                            FORI (iVert, mesh.verts.size())
                                ((Mesh.Vertex)mesh.verts.get(iVert)).h = 0.;
                        }

                        selectedDualVertIndices = new int[] {};
                        if (doContinuouslyDelaunayize.get()) delaunayize();
                        UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);
                        undoTreeSquirrel.Do(new UndoItem(before, after));
                        theCanvas.repaint();
                        break;
                    }

                    case 'u': case CTRL('z'): // undo
                    {
                        UndoItem item = (UndoItem)undoTreeSquirrel.undo();
                        if (item != null)
                        {
                            mesh = new Mesh(item.before.mesh);
                            doContinuouslyDelaunayize.set(item.before.doContinuouslyDelaunayize);
                            doOptimize.set(item.before.doOptimize);
                            optimizationTypeIndex.set(item.before.optimizationTypeIndex);
                            optimizationType = availableOptimizationTypes[optimizationTypeIndex.get()];
                            selectedDualVertIndices = VecMath.copyvec(item.before.selectedDualVertIndices);
                        }
                        else
                        {
                            System.out.println("Nothing to undo!");
                        }
                        theCanvas.repaint();
                        break;
                    }
                    case 'r': case 'U': case CTRL('r'): case CTRL('y'): // redo
                    {
                        UndoItem item = (UndoItem)undoTreeSquirrel.redo();
                        if (item != null)
                        {
                            mesh = new Mesh(item.after.mesh);
                            doContinuouslyDelaunayize.set(item.after.doContinuouslyDelaunayize);
                            doOptimize.set(item.after.doOptimize);
                            optimizationTypeIndex.set(item.after.optimizationTypeIndex);
                            optimizationType = availableOptimizationTypes[optimizationTypeIndex.get()];
                            selectedDualVertIndices = VecMath.copyvec(item.after.selectedDualVertIndices);
                        }
                        else
                        {
                            System.out.println("Nothing to redo!");
                        }
                        theCanvas.repaint();
                        break;
                    }
                    case 'c': // clear
                    {
                        UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);
                        mesh = new Mesh();
                        if (doContinuouslyDelaunayize.get()) delaunayize();
                        UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);
                        undoTreeSquirrel.Do(new UndoItem(before, after));
                        theCanvas.repaint();
                        break;
                    }
                    case CTRL('q'): // quit
                    {
                        System.out.println("Aww.");
                        System.exit(1);
                    }

                    case 'h': // help
                        help();
                        break;

                    case CTRL('i'): // toggle doShowInsideOutDualVerts
                        doShowInsideOutDualVerts ^= true;
                        System.out.println("doShowInsideOutDualVerts -> "+doShowInsideOutDualVerts);
                        theCanvas.repaint();
                        break;

                    case CTRL('o'): // cycle optimizationType
                        optimizationTypeIndex.set((optimizationTypeIndex.get()+1)%availableOptimizationTypes.length);
                        optimizationType = availableOptimizationTypes[optimizationTypeIndex.get()];
                        System.out.println("optimizationType -> "+optimizationTypeNames[optimizationType]);
                        theCanvas.repaint();
                        break;

                    case CTRL('v'): // toggle nonEventVerbose
                        nonEventVerbose = (nonEventVerbose+1)%2;
                        System.out.println("nonEventVerbose -> "+nonEventVerbose);
                        theCanvas.repaint();
                        break;

                    case '7':
                    {
                        int oldIndex = netless8OptimizationIndex;
                        netless8OptimizationIndex = MOD(netless8OptimizationIndex-1, netless8OptimizationPath.length);
                        System.out.println("netless8OptimizationIndex "+oldIndex+" -> "+netless8OptimizationIndex+"");

                        if (mesh.verts.size() == 6)
                        {
                            double verts[][] = netless8OptimizationPath[netless8OptimizationIndex];
                            FORI (iVert, 6)
                            {
                                ((Mesh.Vertex)mesh.verts.get(iVert)).x = verts[iVert][0];
                                ((Mesh.Vertex)mesh.verts.get(iVert)).y = verts[iVert][1];
                                ((Mesh.Vertex)mesh.verts.get(iVert)).h = verts[iVert][2];
                            }
                        }

                        theCanvas.repaint();
                        break;
                    }
                    case '8':
                    {
                        int oldIndex = netless8OptimizationIndex;
                        netless8OptimizationIndex = (netless8OptimizationIndex+1) % netless8OptimizationPath.length;
                        System.out.println("netless8OptimizationIndex "+oldIndex+" -> "+netless8OptimizationIndex+"");

                        if (mesh.verts.size() == 6)
                        {
                            double verts[][] = netless8OptimizationPath[netless8OptimizationIndex];
                            FORI (iVert, 6)
                            {
                                ((Mesh.Vertex)mesh.verts.get(iVert)).x = verts[iVert][0];
                                ((Mesh.Vertex)mesh.verts.get(iVert)).y = verts[iVert][1];
                                ((Mesh.Vertex)mesh.verts.get(iVert)).h = verts[iVert][2];
                            }
                        }

                        theCanvas.repaint();
                        break;
                    }

                    case CTRL('b'): // blue noise pattern
                    {
                        UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);

                        doBlueNoiseThing();

                        if (doContinuouslyDelaunayize.get()) delaunayize();
                        UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);
                        undoTreeSquirrel.Do(new UndoItem(before, after));
                        theCanvas.repaint();
                        break;
                    }

                    case CTRL('c'): // very special case canned... netless9 example
                    {
                        UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);

                        if (e.isAltDown())
                            doCannedThingHexesSpiral();
                        else
                            doCannedThingNetless9();

                        if (doContinuouslyDelaunayize.get()) delaunayize();
                        UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);
                        undoTreeSquirrel.Do(new UndoItem(before, after));
                        theCanvas.repaint();
                        break;
                    }
                    case CTRL('e'): // very special case canned eyeball example
                    {
                        UndoItem.State before = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);
                        doCannedThingEyeball();
                        if (doContinuouslyDelaunayize.get()) delaunayize();
                        UndoItem.State after = new UndoItem.State(mesh, doContinuouslyDelaunayize.get(), doOptimize.get(), optimizationTypeIndex.get(), selectedDualVertIndices);
                        undoTreeSquirrel.Do(new UndoItem(before, after));
                        theCanvas.repaint();
                        break;
                    }

                    default:
                        System.out.println("Unknown key '"+c+"'("+(int)e.getKeyChar()+") typed");
                        break;
                }
                if (eventVerbose >= 1) System.out.println("out keyTyped: "+e);
            } // keyTyped






            //
            // Make it so we get keyboard focus on startup,
            // without having to click first.  Thanks, Melinda!
            // The state of things seems to be:
            //      - Buttons and TextFields are apparently "focus traversable"
            //        by default.  Canvases and Applets aren't,
            //        implying (not obvious) that you need to click to type
            //        when the app starts,
            //        which is almost never the desired behavior.
            //        You can change this by overriding isFocusTraversable(),
            //        which we do below.
            //      - Other approaches using requestFocus():
            //        A Canvas calling requestFocus() doesn't seem to do
            //        anything.  An Applet calling requestFocus() doesn't
            //        do anything during init(), but I think it works
            //        if you put it in the mouseEntered handler or something,
            //        though this can lead to various unpredictabilities.
            //
            public boolean isFocusTraversable()
            {
                return true;
            }

            // override to not clear...
            public void update(java.awt.Graphics g)
            {
                paint(g);
            }

                // recursive work function
                // should be static but "inner classes cannot have static declarations", wtf???
                private void _accumulateWeightAndCenter(int iDualVert,
                                                        double weightStrictlyBelowEachDualVertex[],
                                                        double centerStrictlyBelowEachDualVertex[][],
                                                        Mesh.Edge dualVertIndexToFirstChildEdge[],
                                                        Mesh.Edge edgeIndexToNextSiblingEdge[])
                {
                    if (centerStrictlyBelowEachDualVertex[iDualVert] != null)
                        return; // already did this one
                    double weightStrictlyBelow = 0.;
                    double centerStrictlyBelow[] = {0., 0.};
                    for (Mesh.Edge childEdge = dualVertIndexToFirstChildEdge[iDualVert];
                         childEdge != null;
                         childEdge = edgeIndexToNextSiblingEdge[childEdge.myIndex()])
                    {
                         Mesh.Vertex childVert = childEdge.finalVertex();
                         double childVertCoords[] = {childVert.x, childVert.y};
                         int childVertexIndex = childEdge.finalVertex().myIndex();
                         _accumulateWeightAndCenter(childVertexIndex,
                                                    weightStrictlyBelowEachDualVertex,
                                                    centerStrictlyBelowEachDualVertex,
                                                    dualVertIndexToFirstChildEdge,
                                                    edgeIndexToNextSiblingEdge);

                         System.out.println("    accumulating weight "+childVert.weight+" into vert "+iDualVert+"");
                         weightStrictlyBelow += childVert.weight;
                         VecMath.lerp(centerStrictlyBelow,
                                      centerStrictlyBelow,
                                      childVertCoords,
                                      childVert.weight/weightStrictlyBelow);

                         weightStrictlyBelow += weightStrictlyBelowEachDualVertex[childVertexIndex];
                         VecMath.lerp(centerStrictlyBelow,
                                      centerStrictlyBelow,
                                      centerStrictlyBelowEachDualVertex[childVertexIndex],
                                      weightStrictlyBelowEachDualVertex[childVertexIndex]/weightStrictlyBelow);
                    }
                    weightStrictlyBelowEachDualVertex[iDualVert] = weightStrictlyBelow;
                    centerStrictlyBelowEachDualVertex[iDualVert] = centerStrictlyBelow;
                } // _accumulateWeightAndCenter


                // common code used twice
                private void drawLabels(MyGraphics mg,
                                        Mesh mesh,
                                        boolean isDualMesh)
                {
                    boolean trySmartVertexAngles = true;

                    double smartVertexAngles[] = null;
                    if (trySmartVertexAngles)
                    {
                        int nVerts = mesh.verts.size();
                        int nEdges = mesh.edges.size();
                        smartVertexAngles = new double[nVerts]; // initialized to 0

                        FORI (iEdge0, nEdges)
                        {
                            Mesh.Edge edge0 = (Mesh.Edge)mesh.edges.get(iEdge0);
                            Mesh.Vertex vert = edge0.initialVertex();
                            if (vert == null)
                                continue;
                            if (smartVertexAngles[vert.myIndex()] != 0.)
                                continue; // already saw this one for sure

                            double biggestGap = -1.;
                            double angOfBiggestGap = 0.;
                            // walk CCW around vertex
                            Mesh.Edge thisEdge = edge0;
                            Mesh.Edge nextEdge;
                            do {
                                assert(thisEdge.initialVertex() == vert);
                                nextEdge = thisEdge.prev().opposite();
                                double nextAng =
                                    nextEdge.direction != null
                                  ? Math.atan2(nextEdge.direction[1],
                                               nextEdge.direction[0])
                                  : Math.atan2(nextEdge.finalVertex().y-nextEdge.initialVertex().y,
                                               nextEdge.finalVertex().x-nextEdge.initialVertex().x);
                                double thisAng =
                                    thisEdge.direction != null
                                  ? Math.atan2(thisEdge.direction[1],
                                               thisEdge.direction[0])
                                  : Math.atan2(thisEdge.finalVertex().y-thisEdge.initialVertex().y,
                                               thisEdge.finalVertex().x-thisEdge.initialVertex().x);
                                double thisGap = nextAng - thisAng;
                                if (isDualMesh)
                                    thisGap = -thisGap;
                                if (thisGap < 0)
                                    thisGap += 2*Math.PI;
                                if (thisGap > biggestGap)
                                {
                                    biggestGap = thisGap;
                                    if (isDualMesh)
                                        angOfBiggestGap = thisAng - thisGap/2;
                                    else
                                        angOfBiggestGap = thisAng + thisGap/2;
                                }
                            } while ((thisEdge = nextEdge) != edge0);
                            smartVertexAngles[vert.myIndex()] = angOfBiggestGap;
                        }
                    }



                    if (true)
                    {
                        ArrayList verts = mesh.verts;
                        FORIDOWN (iVert, verts.size())
                        {
                            Mesh.Vertex vert = (Mesh.Vertex)verts.get(iVert);
                            double x = vert.x;
                            double y = vert.y;
                            double ang;
                            if (trySmartVertexAngles)
                            {
                                ang = smartVertexAngles[iVert];
                            }
                            else
                            {
                                ang = Math.random() * 2*Math.PI;
                            }
                            double offr = 5/mg.getScaleX(); // pixels
                            double offx = offr*Math.cos(ang);
                            double offy = offr*Math.sin(ang);
                            double offmax = MAX(ABS(offx),ABS(offy));

                            mg.drawString("v"+iVert,
                                          x+offx,
                                          y+offy,
                                          -offx/offmax, offy/offmax);
                        }
                    }

                    if (false) // edges are too busy, maybe should be separate option
                    {
                        ArrayList edges = mesh.edges;
                        FORIDOWN (iEdge, edges.size())
                        {
                            Mesh.Edge edge = (Mesh.Edge)edges.get(iEdge);
                            Mesh.Vertex v0 = edge.initialVertex();
                            Mesh.Vertex v1 = edge.finalVertex();
                            double x = (v0.x+v1.x)/2;
                            double y = (v0.y+v1.y)/2;
                            double ang = Math.PI/2 + Math.atan2(v1.y-v0.y, v1.x-v0.x);
                            double offr = 2/mg.getScaleX(); // pixels
                            double offx = offr*Math.cos(ang);
                            double offy = offr*Math.sin(ang);
                            double offmax = MAX(ABS(offx),ABS(offy));
                            mg.drawString("e"+iEdge,
                                          x+offx,
                                          y+offy,
                                          -offx/offmax, offy/offmax);
                        }
                    }
                } // drawLabels

            // PAINT/DISPLAY/DRAW
            public void paint(java.awt.Graphics frontBufferGraphics)
            {
                if (eventVerbose >= 1) System.out.println("in paint");

                makeSureBackBufferIsRight();
                java.awt.Graphics g;
                if (doDoubleBuffer)
                    g = backBufferImage.getGraphics();
                else
                    g = frontBufferGraphics;


                java.awt.Dimension size = getSize();
                double minSize = MIN(size.width, size.height);
                MyGraphics mg = new MyGraphics(g, size,
                                        -size.width/minSize,size.width/minSize,
                                        -size.height/minSize,size.height/minSize);
                mostRecentGraphics = mg;

                if (implementAntiAliasingInHardware)
                {
                    graphicsAntiAliasingSetter.setAntiAliasing(g,
                                                               doAntiAliasing,
                                                               //1
                                                               eventVerbose
                                                               );
                }


                //
                // Clear to black...
                //
                mg.setColor(java.awt.Color.black);
                mg.fillWindow();



                //
                // Draw the mesh in white...
                //
                if (showTriangles >= 1)
                {
                    mg.setColor(java.awt.Color.white);

                    ArrayList verts = mesh.verts;
                    FORIDOWN (iVert, verts.size())
                    {
                        Mesh.Vertex vert = (Mesh.Vertex)verts.get(iVert);
                        mg.drawPoint(vert.x,
                                     vert.y, 3);
                    }

                    if (showTriangles >= 2)
                    {

                        ArrayList edges = mesh.edges;
                        FORIDOWN (iEdge, edges.size()/2)
                        {
                            Mesh.Edge edge = (Mesh.Edge)edges.get(iEdge*2);
                            Mesh.Vertex v0 = edge.initialVertex();
                            Mesh.Vertex v1 = edge.finalVertex();
                            mg.drawLine(v0.x,v0.y,v1.x,v1.y,doAntiAliasing);
                        }
                    }
                }

                //
                // Try optimizing the heights...
                // XXX paint is a funky place for this
                //
                if (doOptimize.get())
                    mesh.findAndApplyOptimalVertexHeights(optimizationType);

                boolean doMakeVert0CoplanarWith145 = false;
                if (doMakeVert0CoplanarWith145)
                {
                    // XXX total hack
                    Mesh.Vertex v0 = (Mesh.Vertex)mesh.verts.get(0);
                    Mesh.Vertex v1 = (Mesh.Vertex)mesh.verts.get(1);
                    Mesh.Vertex v4 = (Mesh.Vertex)mesh.verts.get(4);
                    Mesh.Vertex v5 = (Mesh.Vertex)mesh.verts.get(5);
                    double A[] = {v1.x, v1.y, v1.h - .5 * (SQR(v1.x) + SQR(v1.y))};
                    double B[] = {v4.x, v4.y, v4.h - .5 * (SQR(v4.x) + SQR(v4.y))};
                    double C[] = {v5.x, v5.y, v5.h - .5 * (SQR(v5.x) + SQR(v5.y))};
                    double N[] = VecMath.vxv3(VecMath.vmv(B,A),
                                              VecMath.vmv(C,A));
                    double desiredDot = VecMath.dot(N,A);
                    double D[] = {v0.x, v0.y, v0.h};
                    // Find D[2] such that N dot D == desiredDot
                    // I.e. N[0]*D[0] + N[1]*D[1] + N[2]*D[2] == desiredDot
                    D[2] = (desiredDot - (N[0]*D[0] + N[1]*D[1])) / N[2];

                    v0.h = D[2];
                    v0.h += .5 * (SQR(v0.x) + SQR(v0.y));
                }

                //
                // Draw the dual diagram in color...
                //
                if (true)
                {
                    java.awt.Color lightBlue = new java.awt.Color(128,128,255);
                    /*
                    java.awt.Color dualVertSelectionColor = java.awt.Color.green;
                    java.awt.Color dualColor = java.awt.Color.red;
                    java.awt.Color dualColorBothSelected = lightBlue;
                    java.awt.Color dualColorOneSelectedBad = java.awt.Color.magenta;
                    java.awt.Color dualColorOneSelectedGood = java.awt.Color.green;
                    */
                    java.awt.Color dualVertSelectionColor = java.awt.Color.yellow;
                    java.awt.Color dualColor = lightBlue;
                    java.awt.Color dualColorBothSelected = java.awt.Color.yellow;
                    java.awt.Color dualColorOneSelectedBad = java.awt.Color.red;
                    java.awt.Color dualColorOneSelectedGood = java.awt.Color.green;

                    //
                    // Compute and store the dual mesh...
                    // XXX weird place to do it, in draw
                    //
                    if (showNet)
                        mg.setColor(dualVertSelectionColor);
                    else
                        mg.setColor(dualColor);
                    Mesh dualMesh = makeDualMesh(mesh,
                                                 false, // includeNonArity3,
                                                 doShowInsideOutDualVerts);
                    mostRecentDualMesh = dualMesh;

                    FORIDOWN(iDualVert, dualMesh.verts.size())
                    {
                        Mesh.Vertex dualVert = (Mesh.Vertex)dualMesh.verts.get(iDualVert);
                        if (!doShowInsideOutDualVerts)
                        {
                            if (dualVert.weight < 0)
                                continue; // the triangle is inside out; it's the boundary
                        }

                        //System.out.println("    drawing dual vert at "+Arrays.toStringCompact(dualVert));
                        mg.drawPoint(dualVert.x,
                                     dualVert.y, 5);

                        nDrawnDualVerts++;
                        if (selectAllDualVertsAtNextOpportunity)
                            selectedDualVertIndices = (int[])Arrays.append(selectedDualVertIndices, iDualVert);
                    }
                    selectAllDualVertsAtNextOpportunity = false;


                    //
                    // If showing net, compute a net.
                    // For now, sweep upwards,
                    // color good edges green and off-balance ones red.
                    //
                    boolean dualEdgeIsCut[] = null;
                    boolean dualEdgeIsOffBalanceCut[] = null;
                    // Hack for now... just one
                    Mesh.Edge theBadLagoonExitToDraw = null;
                    ArrayList offBalanceEdgeToGoodLagoonExits[] = new ArrayList[dualMesh.edges.size()]; // all nulls initially
                    if (showNet)
                    {
                        dualEdgeIsCut = new boolean[mesh.edges.size()]; // all false initially
                        dualEdgeIsOffBalanceCut = new boolean[mesh.edges.size()]; // all false initially
                        Mesh.Edge dualVertIndexToParentEdge[] = new Mesh.Edge[dualMesh.verts.size()]; // all null initially
                        FORIDOWN (iEdge, mesh.edges.size())
                        {
                            Mesh.Vertex triCenterDualVert = ((Mesh.Edge)dualMesh.edges.get(iEdge)).finalVertex();
                            if (triCenterDualVert == null)
                                continue; // primal face was not a triangle, or inside out
                            if (dualVertIndexToParentEdge[triCenterDualVert.myIndex()] != null)
                                continue; // definitely already did this vertex  XXX but root vertex stays null so it will be done 3 times :-(

                            Mesh.Edge e0 = (Mesh.Edge)mesh.edges.get(iEdge);
                            Mesh.Edge e1 = e0.next();
                            Mesh.Edge e2 = e1.next();
                            assert(e2.next() == e0);

                            double threeDirections[][] = {
                                ((Mesh.Edge)dualMesh.edges.get(e0.myIndex())).opposite().direction,
                                ((Mesh.Edge)dualMesh.edges.get(e1.myIndex())).opposite().direction,
                                ((Mesh.Edge)dualMesh.edges.get(e2.myIndex())).opposite().direction,
                            };

                            int bestSide = MAXI3(threeDirections[0][1],
                                                 threeDirections[1][1],
                                                 threeDirections[2][1]);
                            if (true)
                            {
                                // Hack to simulate symbolic perterbation
                                // by an infinitesimal rotation counterclockwise
                                if (EQ(threeDirections[bestSide][1], threeDirections[(bestSide+1)%3][1], 1e-6)
                                 && LT(threeDirections[bestSide][0], threeDirections[(bestSide+1)%3][0], 1e-6))
                                {
                                    bestSide = (bestSide+1)%3;
                                    if (EQ(threeDirections[bestSide][1], threeDirections[(bestSide+1)%3][1], 1e-6)
                                     && LT(threeDirections[bestSide][0], threeDirections[(bestSide+1)%3][0], 1e-6))
                                        bestSide = (bestSide+1)%3;
                                }
                                else
                                {
                                    if (EQ(threeDirections[bestSide][1], threeDirections[(bestSide+2)%3][1], 1e-6)
                                     && LT(threeDirections[bestSide][0], threeDirections[(bestSide+2)%3][0], 1e-6))
                                        bestSide = (bestSide+2)%3;
                                }
                            }
                            if (true)
                            {
                                // Hack to ensure that a negative-weight (assume that means boundary)
                                // vertex never has a positive-weight vertex as parent
                                Mesh.Edge threeEdges[] = {
                                    ((Mesh.Edge)dualMesh.edges.get(e0.myIndex())).opposite(),
                                    ((Mesh.Edge)dualMesh.edges.get(e1.myIndex())).opposite(),
                                    ((Mesh.Edge)dualMesh.edges.get(e2.myIndex())).opposite(),
                                };
                                if (triCenterDualVert.weight < 0.
                                 && threeEdges[bestSide].finalVertex() != null
                                 && threeEdges[bestSide].finalVertex().weight >= 0.)
                                {
                                    int origBestSide = bestSide;
                                    bestSide = (threeDirections[(bestSide+1)%3][1] >= threeDirections[(bestSide+2)%3][1] ? (bestSide+1)%3 : (bestSide+2)%3);
                                    if (triCenterDualVert.weight < 0.
                                     && threeEdges[bestSide].finalVertex() != null
                                     && threeEdges[bestSide].finalVertex().weight >= 0.)
                                    {
                                        bestSide = 3 - bestSide - origBestSide;
                                    }
                                }
                            }

                            if (false) // set this to true to debug
                            {
                                double whereToDrawMark[] = {
                                    triCenterDualVert.x + .05 * threeDirections[bestSide][0],
                                    triCenterDualVert.y + .05 * threeDirections[bestSide][1],
                                };
                                mg.drawPoint(whereToDrawMark[0],
                                             whereToDrawMark[1], 5);
                            }


                            Mesh.Edge e = bestSide==0 ? e0 : bestSide==1 ? e1 : e2;
                            // remember each edge gets drawn in an arbitrary one of the two directions,
                            // so we have to set the flag on both of them
                            dualEdgeIsCut[e.myIndex()] = true;
                            dualEdgeIsCut[e.opposite().myIndex()] = true;

                            // Set parent... but only if the edge
                            // is really upwards.
                            // to avoid a cycle in the graph
                            {
                                Mesh.Edge maybeParentEdge = ((Mesh.Edge)dualMesh.edges.get(e.myIndex())).opposite();
                                if (GT(maybeParentEdge.direction[1], 0, 1e-6)
                                 || (EQ(maybeParentEdge.direction[1], 0, 1e-6)
                                  && maybeParentEdge.direction[0] > 0.))
                                    dualVertIndexToParentEdge[triCenterDualVert.myIndex()] = maybeParentEdge;
                            }
                        }

                        //
                        // Now figure out which ones are off balance.
                        //
                        // accumulate weights...
                        int nDualVerts = dualMesh.verts.size();
                        int nDualEdges = dualMesh.edges.size();
                        double weightStrictlyBelowEachDualVertex[] = new double[nDualVerts]; // initially 0's
                        double centerStrictlyBelowEachDualVertex[][] = new double[nDualVerts][]; // initially nulls
                        if (true)
                        {
                            // Simple way, O(n^2)
                            FORI (iDualVert, nDualVerts)
                                centerStrictlyBelowEachDualVertex[iDualVert] = new double[2];
                            FORI (iDualVert, nDualVerts)
                            {
                                // Add its weight and center to every vertex strictly above it
                                Mesh.Vertex dualVert = (Mesh.Vertex)dualMesh.verts.get(iDualVert);
                                double dualVertCoords[] = {dualVert.x, dualVert.y};
                                Mesh.Edge dualEdge = dualVertIndexToParentEdge[iDualVert];

                                while (dualEdge != null
                                    && dualEdge.finalVertex() != null)
                                {
                                    int jDualVert = dualEdge.finalVertex().myIndex();
                                    //System.out.println("    adding weight of "+iDualVert+" to "+jDualVert+"");
                                    weightStrictlyBelowEachDualVertex[jDualVert] += dualVert.weight;
                                    VecMath.lerp(centerStrictlyBelowEachDualVertex[jDualVert],
                                                 centerStrictlyBelowEachDualVertex[jDualVert],
                                                 dualVertCoords,
                                                 dualVert.weight/weightStrictlyBelowEachDualVertex[jDualVert]);
                                    dualEdge = dualVertIndexToParentEdge[jDualVert];
                                }
                            }
                        }
                        else
                        {
                            // Smarter way, O(n)
                            Mesh.Edge dualVertIndexToFirstChildEdge[] = new Mesh.Edge[nDualVerts]; // nulls initially
                            Mesh.Edge edgeIndexToNextSiblingEdge[] = new Mesh.Edge[nDualEdges]; // nulls initially
                            FORI (iDualVert, nDualVerts)
                            {
                                Mesh.Edge upwardDualEdge = dualVertIndexToParentEdge[iDualVert];
                                if (upwardDualEdge == null)
                                    continue; // this dual vert is the root
                                assert(upwardDualEdge.initialVertex().myIndex() == iDualVert);
                                Mesh.Edge downwardDualEdge = upwardDualEdge.opposite();
                                Mesh.Vertex parentDualVertex = downwardDualEdge.initialVertex();
                                edgeIndexToNextSiblingEdge[downwardDualEdge.myIndex()] = dualVertIndexToFirstChildEdge[parentDualVertex.myIndex()];
                                dualVertIndexToFirstChildEdge[parentDualVertex.myIndex()] = downwardDualEdge;
                            }
                            FORI (iDualVert, nDualVerts)
                                _accumulateWeightAndCenter(iDualVert,
                                                           weightStrictlyBelowEachDualVertex,
                                                           centerStrictlyBelowEachDualVertex,
                                                           dualVertIndexToFirstChildEdge,
                                                           edgeIndexToNextSiblingEdge);
                        }

                        FORI (iDualVert, nDualVerts)
                        {
                            if (weightStrictlyBelowEachDualVertex[iDualVert] != 0.)
                            {
                                Mesh.Edge dualEdge = dualVertIndexToParentEdge[iDualVert];
                                if (dualEdge == null)
                                    continue; // this is the root / highest node
                                Mesh.Vertex dualVert = dualEdge.initialVertex();
                                assert(dualVert.myIndex() == iDualVert);
                                if (dualVert.weight < 0.)
                                    continue; // nodes on the boundary are automatically okay
                                if (VecMath.dot(dualEdge.direction,
                                                VecMath.vmv(centerStrictlyBelowEachDualVertex[iDualVert],
                                                            new double[]{dualVert.x,
                                                                         dualVert.y})) > 0.)
                                {
                                    dualEdgeIsOffBalanceCut[dualEdge.myIndex()] = true;
                                    dualEdgeIsOffBalanceCut[dualEdge.opposite().myIndex()] = true;
                                    //System.out.println("    edge at dual vert "+iDualVert+" is off balance!");
                                }
                                else
                                {
                                    //System.out.println("    edge at dual vert "+iDualVert+" is balanced");
                                }
                            }
                        }

                        if (true)
                        {
                            //
                            // Start to try to make a data structure
                            // for net surgery.
                            //
                            Mesh.Edge nextDualEdgeInCutTree[] = new Mesh.Edge[nDualEdges];

                            FORI (iDualEdge, nDualEdges)
                            {
                                Mesh.Edge dualEdge = (Mesh.Edge)dualMesh.edges.get(iDualEdge);
                                // Is this dual edge a cut?
                                // well, could look it up in the dualEdgeIsCut
                                // array, but we don't need that
                                Mesh.Vertex initialVertex = dualEdge.initialVertex();
                                Mesh.Vertex finalVertex = dualEdge.finalVertex();
                                boolean isCut = (initialVertex != null
                                              && dualVertIndexToParentEdge[initialVertex.myIndex()] == dualEdge)
                                             || (finalVertex != null
                                              && dualVertIndexToParentEdge[finalVertex.myIndex()] == dualEdge.opposite());
                                if (!isCut)
                                    continue;

                                for (Mesh.Edge next = dualEdge.next();
                                     ;
                                     next = next.opposite().next())
                                {
                                    Mesh.Vertex nextInitialVertex = next.initialVertex();
                                    Mesh.Vertex nextFinalVertex = next.finalVertex();
                                    boolean nextIsCut = (nextInitialVertex != null
                                                      && dualVertIndexToParentEdge[nextInitialVertex.myIndex()] == next)
                                                     || (nextFinalVertex != null
                                                      && dualVertIndexToParentEdge[nextFinalVertex.myIndex()] == next.opposite());
                                    if (nextIsCut)
                                    {
                                        nextDualEdgeInCutTree[iDualEdge] = next;
                                        break;
                                    }
                                    assert(next.opposite() != dualEdge); // that would be endless loop... must have found a next by now, since an edge should be a cut iff its opposite is a cut
                                }
                            }

                            FORI (iDualEdge, nDualEdges)
                            {
                                assert((nextDualEdgeInCutTree[iDualEdge] != null)
                                    == dualEdgeIsCut[iDualEdge]);
                            }

                            if (false)
                            {
                                // Print it out
                                System.out.println("Walking around net tree:");
                                boolean seen[] = new boolean[nDualEdges]; // false initially
                                FORI (iPass, 2)
                                {
                                    FORI (iDualEdge, nDualEdges)
                                    {
                                        if (nextDualEdgeInCutTree[iDualEdge] == null)
                                            continue; // not a cut
                                        if (seen[iDualEdge])
                                            continue;
                                        assert(iPass == 0); // should have got everything in pass 0
                                        Mesh.Edge dualEdge = (Mesh.Edge)dualMesh.edges.get(iDualEdge);
                                        if (dualEdge.initialVertex() != null
                                         && dualVertIndexToParentEdge[dualEdge.initialVertex().myIndex()] != null)
                                            continue; // start connected components with roots (including or non-vertices) only XXX would be good to start with the extremal child, but that's hard to figure out
                                        System.out.print("    ");
                                        while (true)
                                        {
                                            System.out.print("(");
                                            if (dualEdge.initialVertex() != null)
                                                System.out.print(""+dualEdge.initialVertex().myIndex());
                                            else
                                                System.out.print("null");
                                            System.out.print("->");
                                            if (dualEdge.finalVertex() != null)
                                                System.out.print(""+dualEdge.finalVertex().myIndex());
                                            else
                                                System.out.print("null");
                                            System.out.print(")");
                                            seen[dualEdge.myIndex()] = true;
                                            dualEdge = nextDualEdgeInCutTree[dualEdge.myIndex()];
                                            if (dualEdge.myIndex() == iDualEdge)
                                                break;
                                        }
                                        System.out.println();
                                    }
                                }
                            }

                            // ARGH! this doesn't work for good lagoon exits, which is what I wrote it for, since those are not a partition!  (cyan edge can be exit for more than one lagoon)... TODO: remove it if it's not good for anything
                            class EdgesPartition
                            {
                                private Mesh.Edge firsts[];
                                private Mesh.Edge nexts[];
                                public EdgesPartition(int n,
                                                      Mesh mesh)
                                {
                                    firsts = new Mesh.Edge[n];
                                    nexts = new Mesh.Edge[mesh.edges.size()];
                                }
                                public Mesh.Edge first(int i)
                                {
                                    return firsts[i];
                                }
                                public Mesh.Edge next(Mesh.Edge e)
                                {
                                    return nexts[e.myIndex()];
                                }
                                public void add(int i, Mesh.Edge e)
                                {
                                    assert(nexts[e.myIndex()] == null);
                                    nexts[e.myIndex()] = firsts[i];
                                    firsts[i] = e;
                                }
                            }; // EdgesPartition


                            // Try to do some surgery.
                            //System.out.println("Trying surgery...");
                            FORI (iDualEdge, nDualEdges)
                            {
                                Mesh.Edge dualEdge = (Mesh.Edge)dualMesh.edges.get(iDualEdge);
                                Mesh.Vertex initialVertex = dualEdge.initialVertex();
                                if (dualEdgeIsOffBalanceCut[iDualEdge]
                                 && initialVertex != null
                                 && dualVertIndexToParentEdge[initialVertex.myIndex()] == dualEdge)
                                {
                                    //System.out.println("    Looking for alternatives to bad exit "+dualEdge+"");
                                    // It's an upward off-balance cut.
                                    // Starting with its opposite, walk around the lagoon
                                    // until we find a good exit.
                                    // In fact, record them all.
                                    offBalanceEdgeToGoodLagoonExits[dualEdge.myIndex()] = new ArrayList();

                                    double lagoonCenter[] =
                                        VecMath.lerp(centerStrictlyBelowEachDualVertex[initialVertex.myIndex()],
                                                     new double[]{initialVertex.x, initialVertex.y},
                                                     initialVertex.weight/(initialVertex.weight+weightStrictlyBelowEachDualVertex[initialVertex.myIndex()]));
                                    // begin with dualEdge.opposite() even though it's not really in the lagoon, so that we'll see the first exit from the same vertex if there is one
                                    for (Mesh.Edge lagoonEdge = dualEdge.opposite();
                                         lagoonEdge != dualEdge;
                                         lagoonEdge = nextDualEdgeInCutTree[lagoonEdge.myIndex()])
                                    {
                                        for (Mesh.Edge lagoonExitEdge = lagoonEdge.next();
                                             lagoonExitEdge != nextDualEdgeInCutTree[lagoonEdge.myIndex()];
                                             lagoonExitEdge = lagoonExitEdge.opposite().next())
                                        {
                                            // found a lagoon exit... see if it's a good one.
                                            Mesh.Vertex lagoonExitVertex = lagoonExitEdge.initialVertex();
                                            boolean isGood = VecMath.dot(lagoonExitEdge.direction,
                                                                         VecMath.vmv(lagoonCenter,
                                                                                     new double[]{lagoonExitVertex.x,
                                                                                                  lagoonExitVertex.y})) <= 0;
                                            if (isGood)
                                            {
                                                // At this point we're not sure if it's an exit.
                                                // Scan upwards to see if we find dualEdge.
                                                // if we do, then we're in the same lagoon.
                                                // (note, it would be more efficient asymptotically
                                                // to just turn on a bit for every node in the lagoon,
                                                // but this is simple for now, and probably not a bottleneck)
                                                boolean isExit = true; // until proven otherwise
                                                if (lagoonExitEdge.finalVertex() != null)
                                                {
                                                    //System.out.println("        is "+initialVertex.myIndex()+" downstream from "+lagoonExitEdge.finalVertex().myIndex()+"?");
                                                    for (int jVertex = lagoonExitEdge.finalVertex().myIndex();
                                                         dualVertIndexToParentEdge[jVertex] != null && dualVertIndexToParentEdge[jVertex].finalVertex() != null;
                                                         jVertex = dualVertIndexToParentEdge[jVertex].finalVertex().myIndex())
                                                        if (jVertex == initialVertex.myIndex()) // the original bad lagoon exit vertex
                                                        {
                                                            isExit = false;
                                                            //System.out.println("            oops! found vertex "+initialVertex.myIndex()+" scanning upwards from "+lagoonExitVertex.myIndex()+"");
                                                            break;
                                                        }
                                                }
                                                if (isExit)
                                                {
                                                    offBalanceEdgeToGoodLagoonExits[iDualEdge].add(lagoonExitEdge);
                                                    // could break here since we found one, if that's the way we were doing things
                                                }
                                            }
                                        }
                                    }
                                    if (false)
                                    {
                                        System.out.print("        bad cut "+dualEdge+" could be replaced by: ");
                                        FORI (iGoodExit, offBalanceEdgeToGoodLagoonExits[iDualEdge].size())
                                        {
                                            Mesh.Edge goodExit = (Mesh.Edge)offBalanceEdgeToGoodLagoonExits[iDualEdge].get(iGoodExit);
                                            System.out.print(" " + goodExit);
                                        }
                                        System.out.println();
                                    }

                                    if (dualEdge.myIndex() == highlightedDualEdgeIndex
                                     || dualEdge.opposite().myIndex() == highlightedDualEdgeIndex)
                                        theBadLagoonExitToDraw = dualEdge;
                                    if (offBalanceEdgeToGoodLagoonExits[iDualEdge].size() < 2)
                                    {
                                        System.out.println("        HEY!!! bad cut "+dualEdge+" has only "+offBalanceEdgeToGoodLagoonExits[iDualEdge].size()+" good lagoon exits! That's impossible!");
                                        //assert(false);
                                    }
                                }
                            }
                        }
                    }

                    //PRINT(theBadLagoonExitToDraw);

                    //
                    // Now try connecting the dual verts
                    // 
                    //java.awt.Color darkBlue = new java.awt.Color(0,0,127);
                    //java.awt.Color darkBlue = new java.awt.Color(0,0,192);
                    java.awt.Color darkBlue = new java.awt.Color(0.f,0.f,3/4.f);
                    //java.awt.Color darkBlue = new java.awt.Color(0.f,0.f,7/8.f);
                    //java.awt.Color darkBlue = new java.awt.Color(0.f,0.f,1.f);
                    //
                    FORIDOWN (iEdge, mesh.edges.size())
                    {
                        Mesh.Edge dualEdge = (Mesh.Edge)dualMesh.edges.get(iEdge);
                        Mesh.Vertex leftDualVert = dualEdge.finalVertex();
                        if (leftDualVert == null)
                            continue; // primal face was not a triangle, or inside out
                        Mesh.Edge edge = (Mesh.Edge)mesh.edges.get(iEdge);
                        int jEdge = edge.opposite().myIndex();

                        if (dualEdgeIsCut != null)
                        {
                            if (dualEdge == theBadLagoonExitToDraw
                             || dualEdge.opposite() == theBadLagoonExitToDraw)
                            {
                                mg.setColor(java.awt.Color.magenta); // red turning blue
                            }
                            else if (theBadLagoonExitToDraw != null
                                  && (offBalanceEdgeToGoodLagoonExits[theBadLagoonExitToDraw.myIndex()].indexOf(dualEdge) != -1
                                   || offBalanceEdgeToGoodLagoonExits[theBadLagoonExitToDraw.myIndex()].indexOf(dualEdge.opposite()) != -1))
                            {
                                mg.setColor(java.awt.Color.cyan); // blue turning green
                            }
                            else if (dualEdgeIsOffBalanceCut[iEdge])
                            {
                                mg.setColor(java.awt.Color.red);
                            }
                            else if (dualEdgeIsCut[iEdge])
                            {
                                mg.setColor(java.awt.Color.green);
                            }
                            else
                            {
                                //mg.setColor(java.awt.Color.blue);
                                mg.setColor(darkBlue);
                            }
                        }

                        Mesh.Vertex rightDualVert = dualEdge.initialVertex();

                        if (rightDualVert != null)
                        {
                            if (leftDualVert.myIndex() < rightDualVert.myIndex()) // don't bother drawing it in both directions
                                mg.drawLine(leftDualVert.x, leftDualVert.y,
                                            rightDualVert.x, rightDualVert.y,
                                            doAntiAliasing);
                        }
                        else
                        {
                            // Draw a ray out to infinity
                            double v0[] = {edge.initialVertex().x,
                                           edge.initialVertex().y};
                            double v1[] = {edge.finalVertex().x,
                                           edge.finalVertex().y};
                            double toEdgeVec[] = VecMath.xv2(
                                                     VecMath.vmv(v0, v1));
                            VecMath.normalize(toEdgeVec, toEdgeVec);
                            double rayLength = 1.; // for edges to infinity
                            double destPoint[] = {leftDualVert.x + rayLength*toEdgeVec[0],
                                                  leftDualVert.y + rayLength*toEdgeVec[1]};
                            mg.drawLine(leftDualVert.x, leftDualVert.y,
                                        destPoint[0],destPoint[1],
                                        doAntiAliasing);
                                                               
                        }
                    }

                    //
                    // And, as polish for voronoi diagrams,
                    // draw perpendicular lines
                    // at each isolated edge or whisker.
                    // XXX should do this along hairs... or maybe every edge that is not on a triangle on either side? nah
                    //
                    if (showNet)
                        mg.setColor(dualVertSelectionColor);
                    else
                        mg.setColor(dualColor);
                    FORIDOWN (iEdge, mesh.edges.size())
                    {
                        Mesh.Edge edge = (Mesh.Edge)mesh.edges.get(iEdge);
                        if (edge.next() == edge.opposite()) // check in only one of the two directions XXX am I doing this?  might have broken it
                        //if (leftDualVerts[iEdge] == null && leftDualVerts[edge.opposite().myIndex()] == null && iEdge < edge.opposite().myIndex())
                        {
                            double v0[] = {edge.initialVertex().x,
                                           edge.initialVertex().y};
                            double v1[] = {edge.finalVertex().x,
                                           edge.finalVertex().y};
                            double toEdgeVec[] = VecMath.xv2(
                                                     VecMath.vmv(v0, v1));
                            VecMath.normalize(toEdgeVec, toEdgeVec);
                            double midPoint[] = VecMath.lerp(v0, v1, .5);
                            double lineLength = 1.;
                            double fromPoint[] = VecMath.vpsxv(midPoint, -lineLength*.5, toEdgeVec);
                            double toPoint[] = VecMath.vpsxv(midPoint, lineLength*.5, toEdgeVec);
                            mg.drawLine(fromPoint[0],fromPoint[1],
                                        toPoint[0], toPoint[1],
                                        doAntiAliasing);
                        }
                    }



                    //
                    // Now try marking the sharpest dihedral dual edge
                    // out of each dual vertex.
                    // I.e. the dual edge opposite the largest dual angle.
                    // I.e. the dual edge corresponding to the longest of the three primal
                    // triangle sides.
                    // We draw it 3 times, to make sure we get the same logic from each direction. If there are ties, it will get drawn in each place I think.
                    //
                    if (doArrowsTowardsSharpestDihedrals)
                    {
                        if (showNet)
                            mg.setColor(dualColor);
                        else
                            mg.setColor(dualVertSelectionColor);
                        FORIDOWN (iEdge, mesh.edges.size())
                        {
                            Mesh.Vertex triCenterDualVert = ((Mesh.Edge)dualMesh.edges.get(iEdge)).finalVertex();
                            if (triCenterDualVert == null)
                                continue; // primary face was not a triangle, or inside out

                            Mesh.Edge e0 = (Mesh.Edge)mesh.edges.get(iEdge);
                            Mesh.Edge e1 = e0.next();
                            Mesh.Edge e2 = e1.next();
                            assert(e2.next() == e0);
                            Mesh.Vertex triVerts[] = {e0.initialVertex(),
                                                      e1.initialVertex(),
                                                      e2.initialVertex()};
                            double sideLengths[] = new double[3];
                            FORI (i, 3)
                                sideLengths[i] = Math.sqrt(SQR(triVerts[i].x-triVerts[(i+1)%3].x)
                                                         + SQR(triVerts[i].y-triVerts[(i+1)%3].y));
                            int bestSide = MAXI3(sideLengths[0], sideLengths[1], sideLengths[2]);

                            double v0[] = {triVerts[bestSide].x, triVerts[bestSide].y};
                            double v1[] = {triVerts[(bestSide+1)%3].x, triVerts[(bestSide+1)%3].y};
                            double toEdgeVec[] = VecMath.xv2(
                                                     VecMath.vmv(v0, v1));
                            VecMath.normalize(toEdgeVec, toEdgeVec);
                            // XXX be smarter!  maybe 1/3 of the way along the edge, or somethin
                            double whereToDrawMark[] = {
                                triCenterDualVert.x + .02 * toEdgeVec[0],
                                triCenterDualVert.y + .02 * toEdgeVec[1],
                            };
                            //VecMath.vpsxv(whereToDrawMark, whereToDrawMark, .004, VecMath.random(2));
                            mg.drawPoint(whereToDrawMark[0],
                                         whereToDrawMark[1], 5);
                        }
                    }
                    if (doArrowsTowardsShortestEdges)
                    {
                        // XXX we do this in 3 ways, possibly getting different answer each time, in case of a tie... should fix that
                        mg.setColor(java.awt.Color.cyan);
                        FORIDOWN (iEdge, mesh.edges.size())
                        {
                            Mesh.Vertex triCenterDualVert = ((Mesh.Edge)dualMesh.edges.get(iEdge)).finalVertex();
                            if (triCenterDualVert == null)
                                continue; // primary face was not a triangle, or inside out

                            Mesh.Edge e0 = (Mesh.Edge)mesh.edges.get(iEdge);
                            Mesh.Edge e1 = e0.next();
                            Mesh.Edge e2 = e1.next();
                            assert(e2.next() == e0);
                            Mesh.Vertex triVerts[] = {e0.initialVertex(),
                                                      e1.initialVertex(),
                                                      e2.initialVertex()};
                            double triCenterDualVertCoords[] = {triCenterDualVert.x, triCenterDualVert.y};
                            Mesh.Vertex neighborDualVerts[] = {
                                ((Mesh.Edge)dualMesh.edges.get(e0.myIndex())).initialVertex(),
                                ((Mesh.Edge)dualMesh.edges.get(e1.myIndex())).initialVertex(),
                                ((Mesh.Edge)dualMesh.edges.get(e2.myIndex())).initialVertex(),
                            };

                            double dualSideLengths[] = new double[3];
                            FORI (i, 3)
                            {
                                if (neighborDualVerts[i] == null)
                                    dualSideLengths[i] = Double.POSITIVE_INFINITY;
                                else
                                    dualSideLengths[i] = VecMath.dist(triCenterDualVertCoords,
                                                                      new double[]{neighborDualVerts[i].x,
                                                                                   neighborDualVerts[i].y});
                            }
                            int bestSide = MINI3(dualSideLengths[0], dualSideLengths[1], dualSideLengths[2]);
                            double v0[] = {triVerts[bestSide].x, triVerts[bestSide].y};
                            double v1[] = {triVerts[(bestSide+1)%3].x, triVerts[(bestSide+1)%3].y};
                            double toEdgeVec[] = VecMath.xv2(
                                                     VecMath.vmv(v0, v1));
                            VecMath.normalize(toEdgeVec, toEdgeVec);
                            // XXX be smarter!  maybe 1/3 of the way along the edge, or somethin
                            double whereToDrawMark[] = {
                                triCenterDualVert.x + .02 * toEdgeVec[0],
                                triCenterDualVert.y + .02 * toEdgeVec[1],
                            };
                            //VecMath.vpsxv(whereToDrawMark, whereToDrawMark, .005, VecMath.random(2));
                            mg.drawPoint(whereToDrawMark[0],
                                         whereToDrawMark[1], 5);

                        }
                    }

                    if (true)
                    {
                        //
                        // Draw center of curvature
                        // of selected dual vertices
                        //

                        // First check for validity (they are fragile)
                        FORI (i, selectedDualVertIndices.length)
                        {
                            int ind = selectedDualVertIndices[i];
                            if (ind >= dualMesh.verts.size()
                             || dualMesh.verts.get(ind) == null)
                            {
                                selectedDualVertIndices = new int[] {};
                                System.out.println("BAM!");
                                break;
                            }
                        }

                        if (selectedDualVertIndices.length >= 1)
                        {
                            if (showNet)
                                mg.setColor(dualColor);
                            else
                                mg.setColor(dualVertSelectionColor);
                            double areaSum = 0.;
                            double moment[] = {0.,0.};
                            double dualVertCoords[] = new double[2]; // scratch for loop
                            FORI (i, selectedDualVertIndices.length)
                            {
                                int ind = selectedDualVertIndices[i];
                                Mesh.Vertex dualVert = (Mesh.Vertex)dualMesh.verts.get(ind);
                                mg.drawPoint(dualVert.x,
                                             dualVert.y, 5);
                                dualVertCoords[0] = dualVert.x;
                                dualVertCoords[1] = dualVert.y;
                                VecMath.vpsxv(moment,
                                              moment,
                                              dualVert.weight, dualVertCoords);
                                areaSum += dualVert.weight;
                            }
                            double avg[] = VecMath.sxv(1./areaSum, moment);
                            mg.drawPoint(avg[0],
                                         avg[1], 7);
                            PRINTVEC(avg);

                            if (!showNet)
                            {
                                //
                                // Highlight the "good" ways out of the lagoon.
                                // This is a bit silly since we are recalculating and redrawing
                                // lines we already drew...
                                //

                                // first identify the edges out of the lagoon...
                                boolean isSelectedDualVert[] = new boolean[dualMesh.verts.size()]; // all false initially
                                FORI (i, selectedDualVertIndices.length)
                                    isSelectedDualVert[selectedDualVertIndices[i]] = true;
                                FORI (iDualEdge, dualMesh.edges.size())
                                {
                                    Mesh.Edge dualEdge = (Mesh.Edge)dualMesh.edges.get(iDualEdge);
                                    Mesh.Vertex initialVertex = dualEdge.initialVertex();
                                    if (initialVertex == null)
                                        continue; // no initial vertex
                                    int iDualVert = initialVertex.myIndex();
                                    if (!isSelectedDualVert[iDualVert])
                                        continue; // doesn't originate in the lagoon
                                    Mesh.Vertex finalVertex = dualEdge.finalVertex();
                                    if (finalVertex != null
                                     && isSelectedDualVert[finalVertex.myIndex()])
                                    {
                                        // both ends are in the lagoon.
                                        int jDualVert = finalVertex.myIndex();
                                        if (iDualVert > jDualVert)
                                            continue; // only need to do it in canonical dir
                                        mg.setColor(dualColorBothSelected); // both selected
                                    }
                                    else
                                    {
                                        // starts in the lagoon, ends outside it.
                                        // is it a good exit?
                                        double initialVertexCoords[] = {initialVertex.x, initialVertex.y};
                                        double goodness = VecMath.dot(dualEdge.direction,
                                                                      VecMath.vmv(2, initialVertexCoords, avg));
                                        if (GEQ(goodness, 0., SQR(1e-6)))
                                            mg.setColor(dualColorOneSelectedGood);
                                        else
                                            mg.setColor(dualColorOneSelectedBad);
                                    }
                                    if (finalVertex != null)
                                    {
                                        mg.drawLine(initialVertex.x, initialVertex.y,
                                                    finalVertex.x, finalVertex.y,
                                                    doAntiAliasing);
                                    }
                                    else
                                    {
                                        // Draw a ray out to infinity
                                        double rayLength = 1.; // for edges to infinity
                                        mg.drawLine(initialVertex.x, initialVertex.y,
                                                    initialVertex.x + rayLength * dualEdge.direction[0],
                                                    initialVertex.y + rayLength * dualEdge.direction[1],
                                                    doAntiAliasing);
                                    }
                                }
                            } // if (true)
                        } // if (selectedDualVertIndices.length >= 1)
                    } // if (true)
                } // if (true)

                //
                // Draw the labels last...
                //
                if (doLabels)
                {
                    if (showTriangles >= 1)
                    {
                        mg.setColor(java.awt.Color.white);
                        drawLabels(mg, mesh, false); // primal
                    }
                    mg.setColor(java.awt.Color.red);
                    drawLabels(mg, mostRecentDualMesh, true); // dual

                    // draw a subtle dot at the origin
                    mg.setColor(java.awt.Color.white);
                    mg.drawPoint(0., 0., 1);
                } // if (doLabels)

                //
                // Draw the rubber band last last
                //
                if (rubberBandingNewEdge)
                {
                    mg.setColor(java.awt.Color.white);
                    Mesh.Vertex v0 = (Mesh.Vertex)mesh.verts.get(beingDraggedVertIndex);
                    mg.drawLine(v0.x, v0.y,
                                prevP[0], prevP[1], doAntiAliasing);
                } // if (rubberBandingNewEdge)

                if (doShowPositiveOrthantnessVisualization)
                {
                    int nPoints = 5000;
                    int nLabels = 100;
                    double M[][] = new double[3][3];
                    {
                        // XXX should add a function to VecMath for random orthonormal matrix?
                        FORI (i, 2)
                        FORI (j, 3)
                            M[i][j] = 2*Math.random() - 1.;
                        VecMath.normalize(M[0], M[0]);
                        VecMath.vpsxv(M[1],
                                      M[1],
                                      -VecMath.dot(M[0], M[1]),
                                      M[0]);
                        VecMath.normalize(M[1], M[1]);
                        VecMath.vxv3(M[2], M[0], M[1]);
                    }

                    double v[] = new double[3];
                    double Mv[] = new double[3];
                    FORI (iPoint, nLabels+nPoints)
                    {
                        VecMath.random(v);

                        if (iPoint == 0 || iPoint == nLabels+nPoints-1)
                            VecMath.fillvec(v, 1.);
                        else if (iPoint == 1 || iPoint == nLabels+nPoints-2)
                            VecMath.fillvec(v, -1);


                        VecMath.normalize(v, v);
                        VecMath.mxv(Mv, M, v);
                        if (Mv[2] < 0.)
                        {
                            VecMath.sxv(v, -1., v);
                            VecMath.sxv(Mv, -1., Mv);
                        }
                        double goodness = VecMath.positiveOrthantness(v, true); // true means use "synopsis"
                        //double incrDegrees = 10.;
                        double incrDegrees = 5.;
                        double dN = goodness * 180 / Math.PI / incrDegrees;
                        int iN = (int)Math.round(dN);
                        if (iPoint <= 1
                         || iPoint >= nLabels+nPoints-2
                         || ABS(iN-dN) < .01)
                        {
                            if (iN == 0)
                                mg.setColor(java.awt.Color.red);
                            else if (iN % 2 == 0)
                                mg.setColor(java.awt.Color.green);
                            else
                                mg.setColor(java.awt.Color.blue);

                            if (iPoint == 0
                             || iPoint == nLabels+nPoints-1)
                                mg.drawString(""+(dN*incrDegrees),
                                              Mv[0],Mv[1], -1., 1.);
                            else if (iPoint < nLabels)
                                mg.drawString(""+(int)Math.round(dN*incrDegrees),
                                              Mv[0],Mv[1], -1., 1.);
                            else
                                mg.drawPoint(Mv[0],Mv[1], 1);
                        }
                        else
                            iPoint--; // cancel loop iteration
                    }
                }


                if (g != frontBufferGraphics)
                {
                    frontBufferGraphics.drawImage(backBufferImage, 0, 0, this);
                }

                if (false) // hack-- uncomment this to mess around with crackkiller
                {
                    if (((Mesh.Vertex)mesh.verts.get(1)).x
                      < ((Mesh.Vertex)mesh.verts.get(0)).x)
                        exploreCrackHead(mesh, 1, 0);
                    else
                        exploreCrackHead(mesh, 0, 1);
                }

                if (eventVerbose >= 1) System.out.println("out paint");
            } // paint

            private void makeSureBackBufferIsRight()
            {
                if (doDoubleBuffer)
                {
                    java.awt.Dimension size = getSize();
                    if (backBufferImage == null
                     || backBufferImage.getWidth(this) != size.width
                     || backBufferImage.getHeight(this) != size.height)
                    {
                        if (eventVerbose >= 1)
                        {
                            System.out.println("Creating back buffer " + size.width + "x" + size.height);
                        }
                        backBufferImage = createImage(size.width, size.height);
                    }
                }
                else
                    backBufferImage = null;
            } // makeSureBackBufferIsRight
        } // class TheCanvas

            private void delaunayize()
            {
                // Not exactly sure what I'm doing, but the following is safer than doing nothing, in the case that all dual verts are selected (e.g. if we're here because of an up or down arrow key, with doContinuouslyDelaunayize on)
                if (selectedDualVertIndices.length > 0
                 && mostRecentDualMesh != null
                 && selectedDualVertIndices.length == mostRecentDualMesh.verts.size())
                {
                    selectAllDualVertsAtNextOpportunity = true;
                    selectedDualVertIndices = new int[] {};
                }

                //
                // Discard the mesh edges and replace it with
                // the Delaunay triangulation of the vertex set,
                // using 3d convex hull.
                // Project to a paraboloid tweaked by heights,
                // which is the right thing to do.
                //
                int nVerts = mesh.verts.size();
                double verts[][] = new double[nVerts][/*3*/];
                FORI (iVert, nVerts)
                {
                    Mesh.Vertex v = (Mesh.Vertex)mesh.verts.get(iVert);
                    verts[iVert] = new double[]{v.x, v.y, v.h};
                }

                double vertsForHull[][] = new double[nVerts][3];
                FORI (iVert, nVerts)
                {
                    vertsForHull[iVert][0] = verts[iVert][0];
                    vertsForHull[iVert][1] = verts[iVert][1];
                    vertsForHull[iVert][2] = verts[iVert][2] - .5 * (SQR(verts[iVert][0]) + SQR(verts[iVert][1]));
                }
                //PRINTARRAY(verts);
                //PRINTARRAY(vertsForHull);
                // normalize to range -1..1 in all three dimensions
                double bbox[][] = VecMath.bbox(vertsForHull);
                if (bbox != null)
                {
                    FORI (iDim, 3)
                    {
                        double bboxCenter = .5*(bbox[1][iDim]+bbox[0][iDim]);
                        double bboxRadius = .5*(bbox[1][iDim]-bbox[0][iDim]);
                        if (bboxRadius == 0.)
                            bboxRadius = 1.;
                        FORI (iVert, nVerts)
                            vertsForHull[iVert][iDim] = (vertsForHull[iVert][iDim] - bboxCenter) / bboxRadius;
                    }
                }
                //System.out.println("    computing convex hull");
                int hull[][] = ConvexHull.convexHull(vertsForHull, 1e-12);

                // correct it, if 2 verts
                if (nVerts == 2)
                    hull = new int[][]{{0,1},{0,1}};

                mesh = new Mesh(verts, hull);

                //
                // Now get rid of each edge
                // that separates two negative-area faces.
                // Analyze all the edges first before deleting any,
                // so that we are only looking at triangle areas.
                //
                {
                    ArrayList edgesToDelete = new ArrayList();
                    int nEdges = mesh.edges.size();
                    for (int iEdge = 0; iEdge < nEdges; iEdge += 2) // only one of an edge and its opposite
                    {
                        Mesh.Edge edge = (Mesh.Edge)mesh.edges.get(iEdge);
                        if (mesh.twiceFaceArea(edge) < 0
                         && mesh.twiceFaceArea(edge.opposite()) < 0)
                            edgesToDelete.add(edge);
                    }
                    int nEdgesToDelete = edgesToDelete.size();
                    //System.out.println("    removing "+nEdgesToDelete+" backside edges");
                    FORI (iEdgeToDelete, nEdgesToDelete)
                    {
                        Mesh.Edge edge = (Mesh.Edge)edgesToDelete.get(iEdgeToDelete);
                        mesh.deleteEdge(edge);
                    }
                }

                // XXX should get rid of unreferenced vertices? NO! But should get rid of dups maybe
            } // delaunayize

            private void doCannedThingAlgorithm5Killer0()
            {
                if (true)
                {
                    double verts[][] = {
                        {0,0},     // 0
                        //{0,14,-1.5},    // 1
                        {0,10.5,-.8},    // 1
                        {7,7},     // 2
                        {-7,7},    // 3
                        {31,-5,10},   // 4
                        {-31,-5,10},  // 5
                        {28,-14},  // 6
                        {-28,-14}, // 7
                        {52,-26},  // 8
                        {-52,-26}, // 9
                    };
                    // XXX lame, we are scaling heights wrong... picked heights empirically for this wrongness
                    VecMath.mxs(verts, verts,
                                .02);
                    int faces[][] = {
                        {0,2,1},
                        {0,6,2},
                        {2,6,4},
                        {4,6,8},
                        {0,1,3},
                        {0,3,7},
                        {3,5,7},
                        {5,9,7},
                        {0,7,9,5,3,1,2,4,8,6},
                    };
                    mesh = new Mesh(verts, faces);
                }



                if (true)
                {
                    double scale = .05;

                    //double topTilt = DTOR(2.);
                    //double topTilt = DTOR(45.);
                    //double topTilt = Math.atan2(1,2);
                    //double topTilt = Math.atan2(1,2)/2;
                    double topTilt = Math.atan2(1,4);
                    double q = 250;
                    double qq = 300;
                    double verts[][] = {
                        {0,0},     // 0
                        {0,7+7*Math.tan(topTilt)}, // 1
                        {7,7},     // 2
                        {-7,7},    // 3
                        {14,0},  // 4
                        {-14,0}, // 5
                        {15,3},   // 6
                        {-15,3},  // 7
                        {14.5+q*Math.cos(DTOR(30.)), 1.5-q*Math.sin(DTOR(30.))},  // 8
                        {-14.5-q*Math.cos(DTOR(30.)), 1.5-q*Math.sin(DTOR(30.))},  // 9
#define DO_OUTER
#ifdef DO_OUTER
                        {14.5+qq*Math.cos(DTOR(30.)), 1.5-qq*Math.sin(DTOR(30.))},  // 10
                        {-14.5-qq*Math.cos(DTOR(30.)), 1.5-qq*Math.sin(DTOR(30.))},  // 11
                        {0,50}, // 12     (will be adjusted)
#endif // DO_OUTER
                    };
#ifdef DO_OUTER
                    verts[12][1] = verts[10][1] + Math.sqrt(3.)*verts[10][0];
#endif // DO_OUTER
                    int faces[][] = {
                        {1,0,2},
                        {0,1,3},
                        {2,0,4},
                        {0,3,5},
                        {2,4,6},
                        {5,3,7},
                        {6,4,8},
                        {5,7,9},

#ifndef DO_OUTER // if NOT doing outer
                        {0,5,9,7,3,1,2,6,8,4},
#endif // DO_OUTER

#ifdef DO_OUTER
                        {6,8,10},
                        {9,7,11},
                        {10,0,11},
                        {10,8,4},
                        {10,4,0},
                        {11,5,9},
                        {11,0,5},

                        //{10,11,5,3,1,2,4},
                        {12,11,7},
                        {12,7,3},
                        {12,3,1},
                        {12,1,2},
                        {12,2,6},
                        {12,6,10},
                        {12,10,11},
#endif // DO_OUTER
                    };
                    // corresponding to the triangular faces... (some of them)
                    double desiredDualVerts[][] = {
                        {1,3},
                        {-1,3},
                        {3,1},
                        {-3,1},
                        {9,7},
                        {-9,7},

                        //{12,6},
                        //{-12,6},

                        //{15,5},
                        //{-15,5},

                        {18,4},
                        {-18,4},

#ifdef DO_OUTER
                        {12+.5*Math.cos(RTOD(60.))/Math.sin(RTOD(60.)), 6.5}, // this one is only approximate, and will be adjusted below
                        {-12-.5*Math.cos(RTOD(60.))/Math.sin(RTOD(60.)), 6.5}, // this one is only approximate, and will be adjusted below
#endif // DO_OUTER
                    };
#ifdef DO_OUTER
                    PRINTVEC(desiredDualVerts[desiredDualVerts.length-2]);
                    PRINTVEC(desiredDualVerts[desiredDualVerts.length-1]);
                    double height = (desiredDualVerts[desiredDualVerts.length-5][1]
                                   - desiredDualVerts[desiredDualVerts.length-3][1])/2.;
                    double length = height / Math.sin(RTOD(60.));
                    desiredDualVerts[desiredDualVerts.length-1][1] =
                    desiredDualVerts[desiredDualVerts.length-2][1] =
                        desiredDualVerts[desiredDualVerts.length-3][1] + height;
                    desiredDualVerts[desiredDualVerts.length-1][0] =
                    -(desiredDualVerts[desiredDualVerts.length-2][0] =
                         desiredDualVerts[desiredDualVerts.length-4][0] + length * Math.cos(RTOD(60.)));
                    PRINTVEC(desiredDualVerts[desiredDualVerts.length-2]);
                    PRINTVEC(desiredDualVerts[desiredDualVerts.length-1]);

                    boolean doBackface = true;
                    if (doBackface)
                    {
                        verts = (double[][])Arrays.append(verts,
                                                          VecMath.bary(verts[verts.length-3],
                                                                       verts[verts.length-2], 1/3.,
                                                                       verts[verts.length-1], 1/3.));
                        verts[verts.length-1] = (double[])Arrays.append(verts[verts.length-1], -6./(scale*scale)); // shameless hardcoding
                        // Replace the last face with 3 faces
                        faces[faces.length-1] = new int[]{10,11,13};
                        faces = (int[][])Arrays.append(faces, new int[]{11,12,13});
                        faces = (int[][])Arrays.append(faces, new int[]{12,10,13});
                    }
#endif // DO_OUTER
                    // make room for heights in the array
                    FORI (iVert, verts.length)
                        if (verts[iVert].length == 2)
                            verts[iVert] = (double[])Arrays.append(verts[iVert], 0.);
                    // adjust heights to make the dual verts right
                    FORI (iVert, desiredDualVerts.length+2)
                    {
                        if (iVert == 0)
                            verts[iVert][2] = 0.;
                        else if (iVert == 1)
                        {
                            // Get the y coord of desiredDualVerts[0] right
                            double sampleResultVerts[][] = new double[2][3];
                            int iDualVert = 0;
                            double v0[] = verts[faces[iDualVert][0]];
                            double v1[] = verts[faces[iDualVert][1]];
                            double v2[] = verts[faces[iDualVert][2]];
                            FORI (iSample, 2)
                            {
                                verts[iVert][2] = (double)iSample; // 0. or 1.
                                SolveForDualPoint(v0[0],v0[1],v0[2],
                                                  v1[0],v1[1],v1[2],
                                                  v2[0],v2[1],v2[2],
                                                  sampleResultVerts[iSample]);
                            }
                            double toDesired[] = VecMath.vmv(2, desiredDualVerts[iDualVert], sampleResultVerts[0]);
                            double toSample1[] = VecMath.vmv(2, sampleResultVerts[1], sampleResultVerts[0]);
                            double t = toDesired[1] / toSample1[1];
                            verts[iVert][2] = t;

                            // check...
                            double finalResultVert[] = new double[3];
                            SolveForDualPoint(v0[0],v0[1],v0[2],
                                              v1[0],v1[1],v1[2],
                                              v2[0],v2[1],v2[2],
                                              finalResultVert);
                            //PRINTVEC(desiredDualVerts[iDualVert]);
                            //PRINTVEC(finalResultVert);
                            assert(Math.abs(desiredDualVerts[iDualVert][1]-finalResultVert[1]) <= 1e-6);
                        }
                        else
                        {
                            assert(faces[iVert-2][2] == iVert);
                            double sampleResultVerts[][] = new double[2][3];
                            int iDualVert = iVert-2;
                            double v0[] = verts[faces[iDualVert][0]];
                            double v1[] = verts[faces[iDualVert][1]];
                            double v2[] = verts[faces[iDualVert][2]];
                            FORI (iSample, 2)
                            {
                                verts[iVert][2] = (double)iSample; // 0. or 1.
                                SolveForDualPoint(v0[0],v0[1],v0[2],
                                                  v1[0],v1[1],v1[2],
                                                  v2[0],v2[1],v2[2],
                                                  sampleResultVerts[iSample]);
                            }
                            double toDesired[] = VecMath.vmv(2, desiredDualVerts[iDualVert], sampleResultVerts[0]);
                            double toSample1[] = VecMath.vmv(2, sampleResultVerts[1], sampleResultVerts[0]);
                            double t = VecMath.dot(2, toDesired,toSample1) / VecMath.dot(2, toSample1,toSample1);
                            verts[iVert][2] = t;

                            // check...
                            double finalResultVert[] = new double[3];
                            SolveForDualPoint(v0[0],v0[1],v0[2],
                                              v1[0],v1[1],v1[2],
                                              v2[0],v2[1],v2[2],
                                              finalResultVert);
                            PRINTVEC(desiredDualVerts[iDualVert]);
                            PRINTVEC(finalResultVert);
                            //assert(VecMath.dist(desiredDualVerts[iDualVert], finalResultVert) <= 1e-6);
                        }
                    }
#ifdef DO_OUTER
                    // apex height is same as other outer heights
                    PRINT(verts[10][2]);
                    PRINT(verts[11][2]);
                    assert(Math.abs(verts[11][2]-verts[10][2]) <= 1e-6);
                    verts[12][2] = verts[11][2];
#endif
                    FORI (iVert, verts.length)
                    {
                        verts[iVert][0] *= scale;
                        verts[iVert][1] *= scale;
                        if (verts[iVert].length > 2)
                            verts[iVert][2] *= scale*scale;
                    }
                    mesh = new Mesh(verts, faces);
                }
            } // doCannedThingAlgorithm5Killer

            private void doCannedThingAlgorithm5Killer1()
            {
                if (true)
                {
                    double scale = 1/60000.;

                    double q = 30; // for working
                    //double q = 100; // the real thing
                    //double q = 60; // try not so extreme
                    double qq = 90;
                    //double qq = 300; // the real thing
                    //double qq = 180; // try not so extreme
                    double fudgeUp = 0; // fraction of big triangle height to move big triangle up
                    double verts[][] = {
                        {0,0},      // 0
                        {0,7},      // 1
                        {14,28},    // 2
                        {-14,28},   // 3

                        VecMath.lerp(new double[]{7,14},new double[]{392,-98},.8), // 4
                        VecMath.lerp(new double[]{-7,14},new double[]{-392,-98},.8), // 5



                        {392,-98},  // 6
                        {-392,-98}, // 7

                        {398,-68},  // 8
                        {-398,-68}, // 9

                        {q*395, -83},  // 10
                        {-q*395, -83}, // 11
                        {q*395, -83 + .25*q*395}, // 12
                        {-q*395, -83 + .25*q*395}, // 13

                        {q*395 + qq*395, -83 - qq*395}, // 14
                        {-q*395 - qq*395, -83 - qq*395}, // 15

                        {0, 1000}, // 16 -- will be adjusted
                    };
                    verts[16][1] = verts[14][1] + Math.sqrt(3.)*verts[14][0];
                    verts[14][1] += fudgeUp * verts[14][0];
                    verts[15][1] += fudgeUp * verts[14][0];
                    verts[16][1] += fudgeUp * verts[14][0];

                    int faces[][] = {
                        {1,0,2},
                        {0,1,3},
                        {1,2,3},

                        //{2,0,6},
                        {2,0,4},
                        {4,0,6},
                        {2,4,6},

                        {0,3,7},
                        //{0,3,5},
                        //{0,5,7},
                        //{5,3,7},

                        {2,6,8},
                        {7,3,9},
                        {8,6,10},
                        {7,9,11},

                        {8,10,12},
                        {11,9,13},

                        {6,0,14},
                        {0,7,15},


                        {2,12,16}, // moved up from below so can match with a desiredDualVert




                        {10,6,14},
                        {7,11,15},

                        {12,10,14},
                        {11,13,15},

                        {0,15,14},

                        {15,13,16},

                        {13,9,3},
                        {13,3,16},

                        {3,2,16},


                        {2,8,12},
                        //{2,12,16}, // moving this up

                        {12,14,16},
                        {14,15,16},
                    };
                    // corresponding to the triangular faces... (some of them)
                    double desiredDualVerts[][] = {
                        {3,0},
                        {-3,0},
                        {0,2},

                        //{5,-1},
                        {5,-1},
                        {4.75,-2},
                        {5.25,-.25},

                        {-5,-1},
                        //{-5,-1},
                        //{-4.75,-2},
                        //{-5.25,-.25},

                        {14,26},
                        {-14,26},
                        {19,25},
                        {-19,25},

                        {19,25.5},
                        {-19,25.5},

                        {4,-4},
                        {-4,-4},

                        //{14,46}, // approx
                        //{15,42}, // approx
                        {16,38}, // approx
                    };
                    VecMath.mxs(desiredDualVerts, desiredDualVerts,
                                80.);

                    boolean doBackface = true;
                    if (doBackface)
                    {
                        verts = (double[][])Arrays.append(verts,
                                                          VecMath.bary(verts[verts.length-3],
                                                                       verts[verts.length-2], 1/3.,
                                                                       verts[verts.length-1], 1/3.));
                        verts[verts.length-1] = (double[])Arrays.append(verts[verts.length-1], -.4/(scale*scale)); // shameless hardcoding
                        // Replace the last face with 3 faces
                        int oldLastFace[] = faces[faces.length-1];
                        faces[faces.length-1] = new int[]{oldLastFace[0],oldLastFace[1],verts.length-1};
                        faces = (int[][])Arrays.append(faces, new int[]{oldLastFace[1],oldLastFace[2],verts.length-1});
                        faces = (int[][])Arrays.append(faces, new int[]{oldLastFace[2],oldLastFace[0],verts.length-1});
                    }

                    // make room for heights in the array
                    FORI (iVert, verts.length)
                        if (verts[iVert].length == 2)
                            verts[iVert] = (double[])Arrays.append(verts[iVert], 0.);
                    // adjust heights to make the dual verts right
                    verts[0][2] = 0.;
                    {
                        int iVert = 1;
                        int iDualVert = 0;
                        // Get the y coord of desiredDualVerts[0] right
                        double sampleResultVerts[][] = new double[2][3];
                        double v0[] = verts[faces[iDualVert][0]];
                        double v1[] = verts[faces[iDualVert][1]];
                        double v2[] = verts[faces[iDualVert][2]];
                        FORI (iSample, 2)
                        {
                            verts[iVert][2] = (double)iSample; // 0. or 1.
                            SolveForDualPoint(v0[0],v0[1],v0[2],
                                              v1[0],v1[1],v1[2],
                                              v2[0],v2[1],v2[2],
                                              sampleResultVerts[iSample]);
                        }
                        double toDesired[] = VecMath.vmv(2, desiredDualVerts[iDualVert], sampleResultVerts[0]);
                        double toSample1[] = VecMath.vmv(2, sampleResultVerts[1], sampleResultVerts[0]);
                        double t = toDesired[1] / toSample1[1];
                        verts[iVert][2] = t;

                        // check...
                        double finalResultVert[] = new double[3];
                        SolveForDualPoint(v0[0],v0[1],v0[2],
                                          v1[0],v1[1],v1[2],
                                          v2[0],v2[1],v2[2],
                                          finalResultVert);
                        //PRINTVEC(desiredDualVerts[iDualVert]);
                        //PRINTVEC(finalResultVert);
                        assert(Math.abs(desiredDualVerts[iDualVert][1]-finalResultVert[1]) <= 1e-6);
                    }

                    FORI (iDualVert, desiredDualVerts.length)
                    {
                        int iVert = faces[iDualVert][2];
                        double sampleResultVerts[][] = new double[2][3];
                        double v0[] = verts[faces[iDualVert][0]];
                        double v1[] = verts[faces[iDualVert][1]];
                        double v2[] = verts[faces[iDualVert][2]];
                        FORI (iSample, 2)
                        {
                            verts[iVert][2] = (double)iSample; // 0. or 1.
                            SolveForDualPoint(v0[0],v0[1],v0[2],
                                              v1[0],v1[1],v1[2],
                                              v2[0],v2[1],v2[2],
                                              sampleResultVerts[iSample]);
                        }
                        double toDesired[] = VecMath.vmv(2, desiredDualVerts[iDualVert], sampleResultVerts[0]);
                        double toSample1[] = VecMath.vmv(2, sampleResultVerts[1], sampleResultVerts[0]);
                        double t = VecMath.dot(2, toDesired,toSample1) / VecMath.dot(2, toSample1,toSample1);
                        verts[iVert][2] = t;

                        // check...
                        double finalResultVert[] = new double[3];
                        SolveForDualPoint(v0[0],v0[1],v0[2],
                                          v1[0],v1[1],v1[2],
                                          v2[0],v2[1],v2[2],
                                          finalResultVert);
                        PRINTVEC(desiredDualVerts[iDualVert]);
                        PRINTVEC(finalResultVert);
                        //assert(VecMath.dist(desiredDualVerts[iDualVert], finalResultVert) <= 1e-6);
                    }

                    FORI (iVert, verts.length)
                    {
                        verts[iVert][0] *= scale;
                        verts[iVert][1] *= scale;
                        if (verts[iVert].length > 2)
                            verts[iVert][2] *= scale*scale;
                    }
                    mesh = new Mesh(verts, faces);
                }
            } // doCannedThingAlgorithm5Killer

            private void doBlueNoiseThing()
            {
                double stubbornness = 100;
                double overlappingDiskRadiusX = .1;
                double overlappingDiskRadiusY = .1;
                double verts[][] = generateBlueNoiseOnUnitSquare(stubbornness,
                                                                 overlappingDiskRadiusX,
                                                                 overlappingDiskRadiusY);
                VecMath.mmv(verts, verts, new double[]{.5,.5});
                FORI (iVert, verts.length)
                    verts[iVert] = (double[])Arrays.append(verts[iVert], 0.); // make room for heights
                mesh = new Mesh(verts, new int[][]{});
            } // doBlueNoiseThing

            //
            // Blind lagoon exiting goes into an endless loop:
            //     A is the upper-left horizontal edge
            //     B is the horizontal edge below A
            //     C is the middle edge
            // Bad exit A -> good exit B
            // Bad exit C -> good exit A
            // Bad exit B -> good exit C
            // and we're back to the beginning.
            //
            private void doCannedThingBlindLagoonExitKiller()
            {
                double verts[][] = {
                   { 0.15,  0.5, -0.155},
                   {-0.15,  0.2,  0.0},
                   {-0.15,  0.8,  0.0},
                   { 0.15, -0.2,  0.0},
                   {-0.15, -0.1,  0.0},
                   {-0.15, -0.5,  0.0},
                };
                int faces[][] = {
                    {0,1,3},
                    {1,0,2},
                    {3,1,4},
                    {0,3,5,4,1,2},
                    {3,4,5},
                };
                mesh = new Mesh(verts, faces);
            } // doCannedThingBlindLagoonExitKiller

            //
            // Farthest-from-center lagoon exiting goes into an endless loop:
            //     A is the upper-left almost-horizontal edge
            //     B is the lower-right edge
            //     C is the edge halfway between them
            // Only bad exit A -> farthest good exit B
            // Only bad exit C -> farthest good exit A  XXX ARGH! there's two choices at A! OH that edge was supposed to be acute!  okay dammit, need an optimizer
            // Only bad exit B -> farthest good exit C
            // and we're back to the beginning.
            //
            private void doCannedThingFarthestLagoonExitKiller()
            {
                double verts[][] = {
                    {0.254632748975815, 0.6613110539845769, 0.0},
                    {0.001985463846777679, 0.40848329048843174, 0.0050},
                    {-0.0016100400996860165, 0.8262841442469365, -0.0705},
                    {0.15968401023145556, 0.09537275064267343, -0.0050},
                    {0.053309106411296145, 0.1762210796915167, -0.01},
                    {-0.4317114578915699, -0.6837916370249981, -0.5450000000000002},
                };
                int faces[][] = {
                    {1, 3, 0},
                    {3, 1, 4},
                    {0, 3, 5, 4, 1, 2},
                    {1, 0, 2},
                    {3, 4, 5},
                };
                mesh = new Mesh(verts, faces);
            } // doCannedThingFarthestLagoonExitKiller



            private void doCannedThingNetless8()
            {
                double Eps = .04;
                double slope = 1./16; // started with 1./100, 1/10 works but starts pushing outer point far away
                //     3   2
                //       1
                //      5 4
                //       0
                double verts[][] = {
                    {0*Eps, -7*Eps, 0},  // the "lowest" face, bottom point of dual
                    {0*Eps, 7*Eps, 1.64*Eps*Eps}, // empirical
                    {2*Eps, 9*Eps, 0},
                    {-2*Eps, 9*Eps, 0},
                    {7*slope*Eps, 0,  -23*Eps*Eps},
                    {-7*slope*Eps, 0, -23*Eps*Eps},
                };

                int faces[][] = {
                    {5,4,1},
                    {0,4,5},
                    {4,2,1},
                    {5,1,3},
                    {5,3,0},
                    {2,4,0},
                    {1,2,3},
                    {0,3,2},
                };

                mesh = new Mesh(verts, faces);
            } // doCannedThingNetless8

            // Counterexample to entire class of sweep algorithms
            // that cut each vertex to a higher vertex.
            // It contains two netless8's.
            private void doCannedThingSweepKiller0()
            {
                // cheap way of getting verts of netless8
                doCannedThingNetless8();
                double netless8Verts[][] = new double[mesh.verts.size()][3];
                FORI (i, netless8Verts.length)
                {
                    Mesh.Vertex vertex = (Mesh.Vertex)mesh.verts.get(i);
                    netless8Verts[i][0] = vertex.x;
                    netless8Verts[i][1] = vertex.y;
                    netless8Verts[i][2] = vertex.h;
                }

                double separation = 2;
                double verts[][] = new double[2*netless8Verts.length][3];
                FORI (i, netless8Verts.length)
                {
                    VecMath.copyvec(verts[i], netless8Verts[i]);
                    verts[i][0] -= separation/2;
                    VecMath.copyvec(verts[netless8Verts.length+i], netless8Verts[i]);
                    verts[netless8Verts.length+i][0] += separation/2;
                }

                double netless8TriHeight = verts[2][1] - verts[0][1];
                double y = verts[0][1] - netless8TriHeight;
                double Eps = .04; // same as netless8
                double h = -110*Eps*Eps; // not strictly necessary, but makes it easier to think about

                verts = (double[][])Arrays.append(verts, new double[]{verts[3][0],
                                                  y,
                                                  h});
                verts = (double[][])Arrays.append(verts, new double[]{verts[2][0],
                                                  y,
                                                  h});
                verts = (double[][])Arrays.append(verts, new double[]{verts[9][0],
                                                  y,
                                                  h});
                verts = (double[][])Arrays.append(verts, new double[]{verts[8][0],
                                                  y,
                                                  h});
                y -= (verts[2][0]-verts[3][0])*3/4;
                verts = (double[][])Arrays.append(verts, new double[]{0,
                                                  y,
                                                  0});
                verts = (double[][])Arrays.append(verts, new double[]{verts[1][0],
                                                  y,
                                                  h});
                verts = (double[][])Arrays.append(verts, new double[]{verts[7][0],
                                                  y,
                                                  h});
                y += (verts[2][0]-verts[3][0])*3/4;
                y -= netless8TriHeight;
                verts = (double[][])Arrays.append(verts, new double[]{verts[3][0]-2*(verts[2][0]-verts[3][0]),
                                                                      y,
                                                                      0});
                verts = (double[][])Arrays.append(verts, new double[]{-verts[verts.length-1][0],
                                                                      y,
                                                                      0});


                int faces[][] = new int[0][0];
                mesh = new Mesh(verts, faces);

                // temporarily fudge to prevent degenerate edges on boundary
                ((Mesh.Vertex)mesh.verts.get(3)).y -= 1/1024.;
                ((Mesh.Vertex)mesh.verts.get(8)).y -= 1/1024.;
                delaunayize();
                ((Mesh.Vertex)mesh.verts.get(3)).y += 1/1024.;
                ((Mesh.Vertex)mesh.verts.get(8)).y += 1/1024.;

            } // doCannedThingSweepKiller0

            // Counterexample to entire class of sweep algorithms
            // that cut each vertex to a higher vertex.
            // Slightly simpler than SweepKiller0.
            private void doCannedThingSweepKiller1()
            {
                double verts[][] = {
                    {0,0,0},
                    {9,-9,0},
                    {6,-3,0},
                    {7,24,0},
                    {-7,24,0},
                    {-6,-3,0},
                    {-9,-9,0},

                    {7,-6,0},
                    {3,-2,0},

                    {-3,-2,0},
                    {-7,-6,0},
                };
                int faces[][] = {
                    //{0,1,2},
                    {0,1,8},
                    {1,7,8},
                    {1,2,7},
                    {2,0,8},
                    {2,8,7},

                    //{6,0,5},
                    {0,5,9},
                    {0,9,6},
                    {5,10,9},
                    {5,6,10},
                    {9,10,6},

                    {1,3,2},
                    {2,3,0},
                    {0,3,4},
                    {0,4,5},
                    {4,6,5},
                    {0,6,1},
                    {1,6,4,3},
                };
                // argh, requires panning the whole picture around randomly a bit in order for it to come out symmetric...
                VecMath.mpv(verts, verts, new double[]{.1,.1,0});
                mesh = new Mesh(verts, faces);
                mesh.findAndApplyOptimalVertexHeights(OPTIMIZE_LENGTHS_INFINITY_NORM);
                // XXX argh, still requires use to set OPTIMIZE_LENGTHS_INFINITY_NORM and turn on and off Optimize, otherwise the dual picture is tiny... why??

            } // doCannedThingSweepKiller1

            // Counterexample to entire class of sweep algorithms
            // that cut each vertex to a higher vertex.
            // Slightly simpler than SweepKiller1.
            private void doCannedThingSweepKiller2()
            {
                double verts[][] = {
                    {0,0,0},
                    {9,-9,0},
                    {6,-3,0},
                    {7,24,0},
                    {-7,24,0},
                    {-6,-3,0},
                    {-9,-9,0},
                    {3,-2,0},
                    {-3,-2,0},
                };

                int faces[][] = {
                    {0,1,7},
                    {1,2,7},
                    {2,0,7},

                    {0,5,8},
                    {0,8,6},
                    {5,6,8},

                    {1,3,2},
                    {2,3,0},
                    {0,3,4},
                    {0,4,5},
                    {4,6,5},
                    {0,6,1},
                    {1,6,4,3},
                };
                // argh, requires panning the whole picture around randomly a bit in order for it to come out symmetric...
                VecMath.mpv(verts, verts, new double[]{.1,.1,0});
                mesh = new Mesh(verts, faces);
                mesh.findAndApplyOptimalVertexHeights(OPTIMIZE_LENGTHS_INFINITY_NORM);
                // XXX argh, still requires use to set OPTIMIZE_LENGTHS_INFINITY_NORM and turn on and off Optimize, otherwise the dual picture is tiny... why??

            } // doCannedThingSweepKiller2


            private static class Netless8OptimizationStuff
            {
                // Returns the optimization path, better and better verts
                public static double[][][] optimizeVerts(
                    double initialGuessVerts[][])
                {
                    System.out.println("    in optimizeVerts");

                    double initialGuessParams[] = vertsToParams(initialGuessVerts);
                    PRINTARRAY(initialGuessVerts);
                    PRINTVEC(initialGuessVerts[4]);
                    PRINTARRAY(initialGuessParams);
                    PRINTARRAY(paramsToVerts(initialGuessParams));
                    PRINTARRAY(VecMath.mmm(paramsToVerts(initialGuessParams),initialGuessVerts));

                    final String paramNames[] = {
                        "y1",
                        "h1",
                        "x2",
                        "y2",
                        "x4",
                        "y4",
                    };

                    final double saveBestParams[] = new double[5];
                    final double saveBestValue[] = {Double.POSITIVE_INFINITY};
                    final ArrayList optimizationPathList = new ArrayList();

                    Minimizer.VectorFunction fun = new Minimizer.VectorFunction() {
                        // VectorFunction interface
                        public double apply(double params[])
                        {
                            double verts[][] = paramsToVerts(params);
                            double leftDualVerts[][] = vertsToDualVertsInNetless8(verts);
                            double dualEdgeLengths[] = vertsAndDualVertsToDualEdgeLengths(verts, leftDualVerts);

                            double dualEdgeLengthExponent = 2.;
                            double triAreaExponent = 1.;
                            double angleExponent = 2.;


                            double answer = 0.;
                            FORI (iDualEdge, dualEdgeLengths.length)
                            {
                                if (dualEdgeLengths[iDualEdge] <= 0.)
                                    return Double.POSITIVE_INFINITY;
                                answer += 1./Math.pow(dualEdgeLengths[iDualEdge], dualEdgeLengthExponent);
                            }

                            FORI (iTri, tris.length)
                            {
                                double area = twiceTriangleArea(
                                              verts[tris[iTri][0]],
                                              verts[tris[iTri][1]],
                                              verts[tris[iTri][2]]);
                                if (area <= 0.)
                                    return Double.POSITIVE_INFINITY;
                                answer += 1./Math.pow(area, triAreaExponent);
                            }

                            // Also add in a penalty for being too close
                            // to violating the alpha-beta thing
                            if (true)
                            {
                                int dualVertsBeingAveraged[] = {0, 2, 3};
                                double totalArea = 0.;
                                double center[] = {0.,0.};
                                FORI (i, 3)
                                {
                                    double area = twiceTriangleArea(
                                        verts[tris[dualVertsBeingAveraged[i]][0]],
                                        verts[tris[dualVertsBeingAveraged[i]][1]],
                                        verts[tris[dualVertsBeingAveraged[i]][2]]);
                                    PRINT(dualVertsBeingAveraged[i]);
                                    PRINT(area);
                                    if (area <= 0.)
                                        return Double.POSITIVE_INFINITY;
                                    totalArea += area;
                                    VecMath.vpsxv(center,
                                                  center, area, leftDualVerts[dualVertsBeingAveraged[i]]);
                                }
                                VecMath.vxs(center, center, 1./totalArea);

                                double height = VecMath.dot(
                                    2,
                                    VecMath.normalize(VecMath.vmv(leftDualVerts[4],
                                                                  leftDualVerts[1])),
                                    VecMath.vmv(center, leftDualVerts[1]));
                                if (height <= 0.)
                                    return Double.POSITIVE_INFINITY;
                                answer += 1./Math.pow(height, angleExponent);
                            }

                            if (answer < saveBestValue[0])
                            {
                                saveBestValue[0] = answer;
                                optimizationPathList.add(paramsToVerts(params));
                            }
                            return answer;
                        }
                    }; // fun

                    double initialDelta = .0001;
                    //int maxCalls = 10*1000;
                    int maxCalls = 1*1000;
                    //int maxCalls = 500;
                    //int maxCalls = 100;
                    //int maxCalls = 53;
                    PRINT(fun.apply(initialGuessParams));
                    double answerParams[] = Minimizer.minimize(fun,
                                                               initialGuessParams,
                                                               initialDelta,
                                                               maxCalls,
                                                               paramNames);
                    // we don't really use that
                    double optimizationPath[][][] = new double[optimizationPathList.size()][][];
                    optimizationPathList.toArray(optimizationPath);
                    System.out.println("    out optimizeVerts");
                    return optimizationPath;
                } // optimizeVerts

                private static double[] vertsToParams(double verts[][])
                {
                    double params[] = new double[6];
                    params[0] = verts[1][1];
                    params[1] = verts[1][2];
                    params[2] = verts[2][0];
                    params[3] = verts[2][1];
                    params[4] = verts[4][0];
                    params[5] = verts[4][1];
                    return params;
                } // vertsToParams

                private static double[][] paramsToVerts(double params[])
                {
                    //System.out.println("            in paramsToVerts");
                    //PRINTVEC(params);
                    double eps = 1e-6;
                    double verts[][] = new double[6][3];

                    //     3   2
                    //       1
                    //      5 4
                    //       0
                    verts[0][0] = 0;
                    verts[0][1] = 0;
                    verts[0][2] = 0;

                    verts[1][0] = 0;
                    verts[1][1] = params[0];
                    verts[1][2] = params[1];

                    verts[2][0] = params[2];
                    verts[2][1] = params[3];
                    verts[2][2] = 0;

                    verts[3][0] = -verts[2][0];
                    verts[3][1] = verts[2][1];
                    verts[3][2] = 0;

                    verts[4][0] = params[4];
                    verts[4][1] = params[5];
                    // verts[4][2] filled in below

                    verts[5][0] = -verts[4][0];
                    verts[5][1] = verts[4][1];
                    // verts[5][2] = verts[4][2] whenever we set it

                    verts[5][2] = verts[4][2] = 0;
                    double xradius0 = vertsToDualVertsInNetless8(verts)[0][0];
                    verts[5][2] = verts[4][2] = 1;
                    double xradius1 = vertsToDualVertsInNetless8(verts)[0][0];
                    verts[5][2] = verts[4][2] = (1.-xradius0)/(xradius1-xradius0);
                    assert(Math.abs(vertsToDualVertsInNetless8(verts)[0][0]-1.) < eps);

                    //System.out.println("            out paramsToVerts");
                    return verts;
                } // paramsToVerts

                private static int tris[][] = {
                    {0,2,4}, // 0: right
                    {4,2,1}, // 1: the vertex with the angle we care about
                    {5,4,1}, // 2: top of seg we care about
                    {0,4,5}, // 3: bottom of seg we care about
                    {1,2,3}, // 4: top
                    {0,5,3}, // 5: left
                    {5,1,3}, // 6: top left
                };
                private static double[][] vertsToDualVertsInNetless8(double verts[][])
                {
                    // Could optimize the hell out of this,
                    // by caching the linear transform
                    double leftDualVerts[][] = new double[tris.length][3];
                    FORI (iDualVert, leftDualVerts.length)
                    {
                        int tri[] = tris[iDualVert];
                        double x0 = verts[tri[0]][0];
                        double y0 = verts[tri[0]][1];
                        double h0 = verts[tri[0]][2];
                        double x1 = verts[tri[1]][0];
                        double y1 = verts[tri[1]][1];
                        double h1 = verts[tri[1]][2];
                        double x2 = verts[tri[2]][0];
                        double y2 = verts[tri[2]][1];
                        double h2 = verts[tri[2]][2];
                        SolveForDualPoint(x0,y0,h0,
                                          x1,y1,h1,
                                          x2,y2,h2,
                                          leftDualVerts[iDualVert]);
                    }
                    return leftDualVerts;
                } // vertsToDualVertsInNetless8


                private static int edge2verts[/*9*/][/*2*/] = null; // from, to
                private static int edge2tris[/*9*/][/*2*/] = null; // left, right

                private static double[] vertsAndDualVertsToDualEdgeLengths(double verts[][], double leftDualVerts[][])
                {
                    if (edge2verts == null)
                    {
                        edge2verts = new int[9][2]; // from, to
                        edge2tris = new int[9][2]; // left, right
                        {
                            int nEdges = 0;
                            FORI (iTri, tris.length)
                                FORI (jTri, iTri)
                                {
                                    // If they have two things in common...
                                    FORI (ii, 3)
                                        FORI (jj, 3)
                                            if (tris[iTri][ii] == tris[jTri][jj]
                                             && tris[iTri][(ii+1)%3] == tris[jTri][MOD(jj-1,3)])
                                            {
                                                edge2verts[nEdges][0] = tris[iTri][ii]; // from
                                                edge2verts[nEdges][1] = tris[iTri][(ii+1)%3]; // to
                                                edge2tris[nEdges][0] = iTri; // left
                                                edge2tris[nEdges][1] = jTri; // right
                                                nEdges++;
                                            }
                                }
                            PRINT(nEdges);
                            assert(nEdges == edge2verts.length);
                            assert(nEdges == edge2tris.length);
                            PRINTARRAY(edge2verts);
                            PRINTARRAY(edge2tris);
                        }
                    }

                    double dualEdgeLengths[] = new double[9];
                    FORI (iEdge, 9)
                    {
                        double fromVert[] = verts[edge2verts[iEdge][0]];
                        double toVert[] = verts[edge2verts[iEdge][1]];
                        double leftDualVert[] = leftDualVerts[edge2tris[iEdge][0]];
                        double rightDualVert[] = leftDualVerts[edge2tris[iEdge][1]];
                        assert(fromVert != toVert);
                        assert(leftDualVert != rightDualVert);
                        dualEdgeLengths[iEdge] = VecMath.dist(2,
                                                              leftDualVert,
                                                              rightDualVert);
                        // Test whether it's negative.
                        if (VecMath.vxv2(VecMath.vmv(rightDualVert,leftDualVert),
                                         VecMath.vmv(toVert,fromVert)) < 0.)
                            dualEdgeLengths[iEdge] *= -1;
                    }
                    return dualEdgeLengths;
                } // vertsToDualEdgeLengths

            } // class Netless8OptimizationStuff

            private void doCannedThingNetless8Optimized()
            {
                doCannedThingNetless8();

                double initialGuessVerts[][] = new double[6][3];
                {
                    double x0 = ((Mesh.Vertex)mesh.verts.get(0)).x;
                    double y0 = ((Mesh.Vertex)mesh.verts.get(0)).y;
                    double h0 = ((Mesh.Vertex)mesh.verts.get(0)).h;
                    FORI (iVert, initialGuessVerts.length)
                    {
                        initialGuessVerts[iVert][0] = ((Mesh.Vertex)mesh.verts.get(iVert)).x - x0;
                        initialGuessVerts[iVert][1] = ((Mesh.Vertex)mesh.verts.get(iVert)).y - y0;
                        initialGuessVerts[iVert][2] = ((Mesh.Vertex)mesh.verts.get(iVert)).h - h0;
                    }
                }
                PRINT("before scaling");
                PRINTARRAY(initialGuessVerts);
                PRINTVEC(initialGuessVerts[4]);

                {
                    // scale so initial guess has radius 1
                    double xradius = Netless8OptimizationStuff.vertsToDualVertsInNetless8(initialGuessVerts)[0][0];
                    double scale = 1./xradius;
                    FORI (iVert, initialGuessVerts.length)
                    {
                        initialGuessVerts[iVert][0] *= scale;
                        initialGuessVerts[iVert][1] *= scale;
                        initialGuessVerts[iVert][2] *= (scale*scale);
                    }
                    assert(Math.abs(Netless8OptimizationStuff.vertsToDualVertsInNetless8(initialGuessVerts)[0][0] - 1.) < 1e-9);
                }
                PRINT("after scaling");
                PRINTARRAY(initialGuessVerts);
                PRINTVEC(initialGuessVerts[4]);

                PRINTVEC(Netless8OptimizationStuff.vertsToDualVertsInNetless8(initialGuessVerts));

                double initialGuessDualVerts[][] = Netless8OptimizationStuff.vertsToDualVertsInNetless8(initialGuessVerts);


                double optimizationPathVerts[][][] = Netless8OptimizationStuff.optimizeVerts(
                    initialGuessVerts);
                double verts[][] = optimizationPathVerts[optimizationPathVerts.length-1];
                FORI (iVert, 6)
                {
                    ((Mesh.Vertex)mesh.verts.get(iVert)).x = verts[iVert][0];
                    ((Mesh.Vertex)mesh.verts.get(iVert)).y = verts[iVert][1];
                    ((Mesh.Vertex)mesh.verts.get(iVert)).h = verts[iVert][2];
                }

                netless8OptimizationPath = optimizationPathVerts;
                netless8OptimizationIndex = optimizationPathVerts.length-1;
                PRINT(optimizationPathVerts.length);
            } // doCannedThingNetless8Optimized

            private static double[][] generateVertices(double vertGenerators[][],
                                                       double xforms[][][])
            {
                double eps = 1e-9;
                double verts[][] = vertGenerators; // make this an arraylist if we ever do a lot
                FORI (iVert, verts.length) // while verts is growing
                {
                    FORI (ixform, xforms.length)
                    {
                        double vert[] = VecMath.vxm(verts[iVert],
                                                    xforms[ixform]);
                        int jVert;
                        FOR (jVert, verts.length)
                            if (VecMath.equals(vert, verts[jVert], eps))
                                break;
                        if (jVert == verts.length)
                            verts = (double[][])Arrays.append(verts, vert);
                    }
                }
                return verts;
            } // generateVertices

            private void doCannedThingNetless8Symmetric()
            {
                double vertsGenerators[][] = new double[][] {
                    {0,-1},
                    //{0,1/5.}, // looks nice but doesn't work well
                    {0,3/8.},
                };
                double xforms[][][] = {
                    // left-right reflection
                    {
                        {-1,0},
                        {0,1},
                    },
                    // rotation by 120 degrees, row-oriented
                    {
                       { Math.cos(DTOR(120)), Math.sin(DTOR(120))},
                       {-Math.sin(DTOR(120)), Math.cos(DTOR(120))},
                    },
                };
                double verts[][] = generateVertices(vertsGenerators,
                                                    xforms);

                if (true)
                {
                    // hack to make the order the same as for netless8
                    double temp[] = verts[3];
                    verts[3] = verts[4];
                    verts[4] = verts[5];
                    verts[5] = temp;
                }

                if (false)
                {
                    // Hack to see what happens... maybe have key for this
                    FORI (iVert, verts.length)
                        verts[iVert][1] *= .1;
                }

                int faces[][] = {};
                mesh = new Mesh(verts, faces);
                delaunayize();
            } // doCannedThingNetless8Symmetric

            // Make the mesh into netless9
            private void doCannedThingNetless9()
            {
                if (true)
                {
                    // s = how much bigger each edge is from the previous
                    double s = 1.05;
                    //double s = 1.001;
                    double sliceAngle;
                    {
                        // In the initial 6 slice pie,
                        // the southwest triangle has sides a=1, b=s^5, c=s^6.
                        // what are its angles?
                        // http://www.teacherschoice.com.au/Maths_Library/Trigonometry/solve_trig_SSS.htm
                        double a = 1;
                        double b = s*s*s*s*s;
                        double c = s*s*s*s*s*s;
                        double C = triangleAngle(a, b, c);
                        // All right, the southwest angle at the center
                        // is C, a bit more than pi/3.
                        // Distribute the rest of the spokes evenly.
                        sliceAngle = (2*Math.PI-C) / 5;
                    }
                    PRINT(RTOD(sliceAngle));
                    int nVerts = 19;
                    //int nVerts = 40;
                    //int nVerts = 1000;
                    double verts[][] = new double[nVerts][3];
                    int nNeighbors[] = new int[nVerts]; // zeros
                    ArrayList/*<int[]>*/ facesList = new ArrayList();

                    // Seed with verts 0 and 1, and an edge between them.
                    verts[0][0] = 0;
                    verts[0][1] = 0;
                    verts[0][2] = 0;
                    // Had the seed on the -y axis, changing it to +x axis for the hell of it
                    verts[1][0] = 1;
                    verts[1][1] = 0;
                    verts[1][2] = 0;
                    nNeighbors[0] = 1;
                    nNeighbors[1] = 1;

                    PRINT(VecMath.dist(verts[1], verts[6]));
                    PRINT(Math.pow(s, 6));

                    int oldestPerimeterEdge[] = {0,1};

                    for (int i = 2; i < nVerts; ++i)
                    {
                        //PRINT(i);
                        int arity = nNeighbors[oldestPerimeterEdge[0]];
                        assert(arity < 6);
                        double angFrac = 1./(6-arity);
                        //PRINT(1./angFrac);
                        double largestEdge = VecMath.dist(verts[i-1], verts[oldestPerimeterEdge[0]]);
                        //PRINT(largestEdge);
                        //PRINT(Math.pow(s, facesList.size()));

                        double c = VecMath.dist(verts[oldestPerimeterEdge[0]],
                                                verts[oldestPerimeterEdge[1]]);
                        double a = largestEdge * Math.pow(s, 1./angFrac);
                        double b = a*s;
                        //PRINT(a);
                        //PRINT(b);
                        double target[] = completeTriangle(verts[oldestPerimeterEdge[1]],
                                                           verts[oldestPerimeterEdge[0]],
                                                           a, b);
                        double ang0 = Math.atan2(verts[i-1][1]-verts[oldestPerimeterEdge[0]][1],
                                                 verts[i-1][0]-verts[oldestPerimeterEdge[0]][0]);
                        double ang1 = Math.atan2(target[1]-verts[oldestPerimeterEdge[0]][1],
                                                 target[0]-verts[oldestPerimeterEdge[0]][0]);
                        //PRINT(RTOD(ang0));
                        //PRINT(RTOD(ang1));
                        //PRINT(angFrac);
                        while (ang1 < ang0) ang1 += 2*Math.PI;
                        double ang = LERP(ang0, ang1, angFrac);
                        double length = largestEdge * s;
                        verts[i][0] = verts[oldestPerimeterEdge[0]][0] + length*Math.cos(ang);
                        verts[i][1] = verts[oldestPerimeterEdge[0]][1] + length*Math.sin(ang);
                        facesList.add(new int[]{oldestPerimeterEdge[0], i-1, i});
                        nNeighbors[oldestPerimeterEdge[0]]++;
                        nNeighbors[i-1]++;
                        nNeighbors[i] = 2;
                        if (nNeighbors[oldestPerimeterEdge[0]] == 6)
                        {
                            //System.out.println("COMPLETING at "+i);
                            facesList.add(new int[]{oldestPerimeterEdge[1], oldestPerimeterEdge[0], i});
                            nNeighbors[oldestPerimeterEdge[1]]++;
                            nNeighbors[i]++;
                            oldestPerimeterEdge[0]++;
                            oldestPerimeterEdge[1]++;
                        }
                    }

                    {
                        int nPerimeterVerts = 0;
                        FORI (i, nVerts)
                            if (nNeighbors[i] < 6)
                                nPerimeterVerts++;
                        int perimeterVerts[] = new int[nPerimeterVerts];
                        nPerimeterVerts = 0;
                        FORI (i, nVerts)
                            if (nNeighbors[i] < 6)
                                perimeterVerts[perimeterVerts.length-1-nPerimeterVerts++] = i;
                        facesList.add(perimeterVerts);
                        PRINT(nPerimeterVerts);
                    }


                    int faces[][] = new int[facesList.size()][];
                    facesList.toArray(faces);
                    mesh = new Mesh(verts, faces);
                    //PRINTARRAY(nNeighbors);
                    //PRINTARRAY(verts);
                    //PRINTARRAY(faces);
                }
                FORIDOWN (iVert, mesh.verts.size())
                {
                    double scale = .2;
                    Mesh.Vertex vert = (Mesh.Vertex)mesh.verts.get(iVert);
                    vert.x *= scale;
                    vert.y *= scale;
                    vert.h *= scale*scale;
                }
            } // doCannedThingNetless9

            // Argh, short-lived brilliant idea
            // that's going nowhere, since a zig-zag
            // through the cornea is always possible.
            private void doCannedThingEyeball()
            {
                int n = 72;
                int nRows = 15;
                double r0 = .25;
                double aspect = 2;

                // empirically, fudges to make it kind of right for n=72, r0=.25, aspect=2
                double incr = .005;
                incr *= .25; // XXX argh! up and down arrows depend on current view scale! squared!

                double rowHeightFudges[] = {
                    -0*incr,
                               // +3
                     3*incr,          // -1
                               // +2         // -1
                     5*incr,          // -2
                               // +0         // -1
                     5*incr,          // -3
                               // -3         // -2
                     2*incr,          // -5
                               // -8         // -2.5
                    -6*incr,         // -7.5
                               // -15.5      // -4
                    -21.5*incr,       // -11.5
                               // -27        // -5.5
                    -48.5*incr,       // -17
                               // -44        // -8
                    -92.5*incr,       // -25
                               // -69        // -11
                    -161.5*incr,      // -36
                               // -105       // -16
                    -266.5*incr,      // -52
                               // -157       // -22
                    -423.5*incr,      // -74
                               // -231       // -31
                    -654.5*incr,      // -105
                               // -336       // -43
                    -990.5*incr,      // -148
                               // -484
                    -1474.5*incr,
                };  

                ArrayList vertsList = new ArrayList();
                ArrayList facesList = new ArrayList();

                vertsList.add(new double[]{0,0,0});
                FORI (iRow, nRows)
                {
                    double multiplier = 1 + aspect*2*Math.PI/n; // magic
                    double r = r0 * Math.pow(multiplier, iRow);
                    FORI (i, n)
                    {
                        double theta = 2*Math.PI*(i+iRow*.5)/n;
                        vertsList.add(new double[]{r*Math.cos(theta),
                                                   r*Math.sin(theta),
                                                   rowHeightFudges[iRow],
                                                   });
                        if (iRow == 0)
                            facesList.add(new int[]{1 + iRow*n + i,
                                                    1 + iRow*n + (i+1)%n,
                                                    0});
                        else
                        {
                            facesList.add(new int[]{1 + iRow*n + i,
                                                    1 + iRow*n + (i+1)%n,
                                                    1 + (iRow-1)*n + (i+1)%n});
                            facesList.add(new int[]{1 + iRow*n + i,
                                                    1 + (iRow-1)*n + (i+1)%n,
                                                    1 + (iRow-1)*n + i});
                        }
                        /*
                        else
                        {
                            facesList.add(new int[]{1 + iRow*n + i,
                                                    1 + (iRow-1)*n + (i+1)%n,
                                                    1 + (iRow-2)*n + (i+1)%n});
                            facesList.add(new int[]{1 + iRow*n + i,
                                                    1 + (iRow-2)*n + (i+1)%n,
                                                    1 + (iRow-1)*n + i});
                        }
                        if (iRow == nRows-1)
                            facesList.add(new int[]{1 + iRow*n + i,
                                                    1 + iRow*n + (i+1)%n,
                                                    1 + (iRow-1)*n + (i+1)%n});
                        */
                    }
                }
                int insideOutFace[] = new int[n];
                FORI (i, n)
                    insideOutFace[i] = vertsList.size()-1-i;
                facesList.add(insideOutFace);


                double verts[][] = new double[vertsList.size()][];
                vertsList.toArray(verts);
                int faces[][] = new int[facesList.size()][];
                facesList.toArray(faces);
                mesh = new Mesh(verts, faces);
            } // doCannedThingEyeball

            private static double[] triangleApex(double v0[], double ang0,
                                                 double v1[], double ang1)
            {
                double e01ang = Math.atan2(v1[1]-v0[1], v1[0]-v0[0]);
                double e02ang = e01ang + ang0;
                double e21ang = e01ang - ang1;
                double normal02[] = new double[]{Math.cos(e02ang+Math.PI/2),
                                                 Math.sin(e02ang+Math.PI/2)};
                double normal21[] = new double[]{Math.cos(e21ang+Math.PI/2),
                                                 Math.sin(e21ang+Math.PI/2)};
                // Find v2 satisfying:
                //    v2 dot normal02 == v0 dot normal02
                //    v2 dot normal21 == v1 dot normal21
                double A[][] = {normal02,
                                normal21};
                double b[] = {VecMath.dot(v0, normal02),
                              VecMath.dot(v1, normal21)};
                // Solve A v2 == b
                return VecMath.invmxv(A, b);
            } // triangleApex

            private void doCannedThingCrackKiller()
            {
                // any of the following sets of choices work

                int nSpokes = 9;
                double angle0 = DTOR(180.);
                double angleIncr = DTOR(-(360/(nSpokes-1) - .01));
                double length0 = .1;
                double lengthMultiplier = 2; // would be nice to be more scientific

                /*
                int nSpokes = 7;
                double angle0 = DTOR(180.);
                double angleIncr = DTOR(-(360/(nSpokes-1) - .01));
                double length0 = .1;
                double lengthMultiplier = 3; // would be nice to be more scientific
                */

                /*
                int nSpokes = 6;
                double angle0 = DTOR(180.);
                double angleIncr = DTOR(-(360/(nSpokes-1) - .001)); // argh, needs finer and finer apparently... although .01 works if we manually adjust the height of one of the faces
                double length0 = .1;
                double lengthMultiplier = 5; // would be nice to be more scientific
                */


                double verts[][] = new double[nSpokes+1][];

                verts[0] = new double[]{0,0};
                FORI (i, nSpokes)
                {
                    double length = length0 * Math.pow(lengthMultiplier, i);
                    double ang = angle0 + i*angleIncr;
                    verts[i+1] = new double[]{length*Math.cos(ang),
                                              length*Math.sin(ang)};
                }
                int faces[][] = new int[nSpokes+1][];
                FORI (i, nSpokes)
                {
                    faces[i] = new int[] {
                        1+i,
                        0,
                        1+(i+1)%nSpokes,
                    };
                }
                faces[nSpokes] = new int[nSpokes];
                FORI (i, nSpokes)
                    faces[nSpokes][i] = 1+i;

                PRINTARRAY(faces);

                mesh = new Mesh(verts, faces);

                // optimize
                mesh.findAndApplyOptimalVertexHeights(OPTIMIZE_LENGTHS_LEAST_SQUARES);

                exploreCrackHead(mesh, 1, 0);
            } // doCannedThingCrackKiller

                // little private utility
                private static double getTriCenterAndArea(Mesh.Edge edge,
                                                          double triCenter[])
                {
                    assert(edge.next().next().next() == edge);
                    Mesh.Vertex v0 = edge.initialVertex();
                    Mesh.Vertex v1 = edge.finalVertex();
                    Mesh.Vertex v2 = edge.next().finalVertex();
                    double twiceTriArea = twiceTriangleArea(v0.x,v0.y,
                                                            v1.x,v1.y,
                                                            v2.x,v2.y);
                    assert(twiceTriArea > 0);
                    SolveForDualPoint(v0.x, v0.y, v0.h,
                                      v1.x, v1.y, v1.h,
                                      v2.x, v2.y, v2.h,
                                      triCenter);
                    return .5*twiceTriArea;
                } // getTriCenterAndArea

            // Test whether the crack killer is really a crack killer
            private static boolean exploreCrackHead(Mesh mesh,
                                                    int i0, int i1) // from and to of tri edge that goes from left to right of first crack edge
            {
                System.out.println("    Exploring crack head, starting with left->right "+i0+"->"+i1+"");
                // Find the initial edge
                Mesh.Edge firstTriEdge = null;
                FORI (iEdge, mesh.edges.size())
                {
                    Mesh.Edge edge = (Mesh.Edge)mesh.edges.get(iEdge);
                    if (edge.initialVertex().myIndex() == i0
                     && edge.finalVertex().myIndex() == i1)
                    {
                        assert(firstTriEdge == null);
                        firstTriEdge = edge;
                    }
                }
                assert(firstTriEdge != null);

                double totalCenter[] = {0.,0.};
                double totalArea = 0.;
                Mesh.Edge thisTriEdge = firstTriEdge;

                java.util.Hashtable seenVerts = new java.util.Hashtable();
                {
                    int inds[] = {thisTriEdge.initialVertex().myIndex(),
                                  thisTriEdge.finalVertex().myIndex(),
                                  thisTriEdge.opposite().next().finalVertex().myIndex()};
                    SortStuff.sort(inds);
                    int item = (inds[0]*mesh.verts.size()+inds[1])*mesh.verts.size()+inds[2];
                    seenVerts.put(new Integer(item), "");
                }

                while (true)
                {
                    double prevTriCenter[] = new double[3]; // SolveForDualPoint needs 3
                    double prevTriArea = getTriCenterAndArea(thisTriEdge.opposite(),
                                                             prevTriCenter);
                    // Update totalCenter and totalArea
                    VecMath.lerp(2, totalCenter,
                                 totalCenter, prevTriCenter,
                                 prevTriArea / (totalArea + prevTriArea));
                    totalArea += prevTriArea;

                    //PRINT(totalArea);
                    //PRINTVEC(totalCenter);

                    // gag, duplicate work, whatever
                    double nextTriCenter[] = new double[3]; // SolveForDualPoint needs 3
                    getTriCenterAndArea(thisTriEdge,
                                        nextTriCenter);
                    //PRINTVEC(nextTriCenter);

                    // totalCenter and totalArea are now the total
                    // for all crack vertices BEFORE this tri edge.

                    Mesh.Vertex v0 = thisTriEdge.initialVertex();
                    Mesh.Vertex v1 = thisTriEdge.finalVertex();
                    Mesh.Vertex v2 = thisTriEdge.next().finalVertex();

                    {
                        int inds[] = {v0.myIndex(), v1.myIndex(), v2.myIndex()};
                        SortStuff.sort(inds);
                        int item = (inds[0]*mesh.verts.size()+inds[1])*mesh.verts.size()+inds[2];
                        if (seenVerts.put(new Integer(item), "") != null)
                            System.out.println("        HEY! saw this dual vertex "+v0.myIndex()+","+v1.myIndex()+","+v2.myIndex()+" before!");
                    }


                    System.out.println("    at tri edge "+v0.myIndex()+"->"+v1.myIndex()+"");
                    System.out.println("        left next tri edge: "+v0.myIndex()+"->"+v2.myIndex()+"");
                    System.out.println("        right next tri edge: "+v2.myIndex()+"->"+v1.myIndex()+"");
                    assert(thisTriEdge.next().next().next() == thisTriEdge);
                    double leftNextTriEdgeNormal[] = VecMath.normalize(VecMath.xv2(new double[]{v2.x-v0.x, v2.y-v0.y}));
                    double rightNextTriEdgeNormal[] = VecMath.normalize(VecMath.xv2(new double[]{v1.x-v2.x, v1.y-v2.y}));
                    //PRINTVEC(leftNextTriEdgeNormal);
                    //PRINTVEC(rightNextTriEdgeNormal);
                    double leftHeight = VecMath.dot(VecMath.vmv(totalCenter, nextTriCenter), leftNextTriEdgeNormal);
                    double rightHeight = VecMath.dot(VecMath.vmv(totalCenter, nextTriCenter), rightNextTriEdgeNormal);
                    //PRINT(leftHeight);
                    //PRINT(rightHeight);
                    assert(leftHeight != 0.);
                    assert(rightHeight != 0.);
                    assert(leftHeight < 0 || rightHeight < 0);
                    if (leftHeight < 0 && rightHeight > 0)
                    {
                        System.out.println("        left is good, right is bad, choosing left");
                        thisTriEdge = thisTriEdge.next().next().opposite();
                        assert(thisTriEdge.initialVertex() == v0);
                        assert(thisTriEdge.finalVertex() == v2);
                    }
                    else if (rightHeight < 0 && leftHeight > 0)
                    {
                        System.out.println("        right is good, left is bad, choosing right");
                        thisTriEdge = thisTriEdge.next().opposite();
                        assert(thisTriEdge.initialVertex() == v2);
                        assert(thisTriEdge.finalVertex() == v1);
                    }
                    else
                    {
                        System.out.println("    NO CLEAR CHOICE");
                        return false; // failure
                    }
                }

            } // exploreCrackHead

            // Generalization of netless9.
            // counterexample to "there is an unfolding
            // that uses the sharpest edge at each vertex"
            private void doCannedThingHexesSpiral()
            {
                if (true)
                {
                    // s = how much bigger each edge is from the previous
                    //double s = 1.05;
                    //double s = 1.01;
                    double s = 1.005;
                    //double s = 1.001;
                    //double s = 1.;
                    double sliceAngle;
                    {
                        // In the initial 6 slice pie,
                        // the southwest triangle has sides a=1, b=s^5, c=s^6.
                        // what are its angles?
                        // http://www.teacherschoice.com.au/Maths_Library/Trigonometry/solve_trig_SSS.htm
                        double a = 1;
                        double b = s*s*s*s*s;
                        double c = s*s*s*s*s*s;
                        double C = triangleAngle(a, b, c);
                        // All right, the southwest angle at the center
                        // is C, a bit more than pi/3.
                        // Distribute the rest of the spokes evenly.
                        sliceAngle = (2*Math.PI-C) / 5;
                    }
                    PRINT(RTOD(sliceAngle));
                    //int nVerts = 19;
                    //int nVerts = 18;
                    //int nVerts = 100;
                    int nVerts = 300;
                    //int nVerts = 500;
                    //int nVerts = 1000;
                    double verts[][] = new double[nVerts][3];
                    int nNeighbors[] = new int[nVerts]; // zeros
                    ArrayList/*<int[]>*/ facesList = new ArrayList();

                    // Seed with verts 0 and 1, and an edge between them.
                    verts[0][0] = 0;
                    verts[0][1] = 0;
                    verts[0][2] = 0;
                    // Had the seed on the -y axis, changing it to +x axis for the hell of it
                    verts[1][0] = 1;
                    verts[1][1] = 0;
                    verts[1][2] = 0;
                    nNeighbors[0] = 1;
                    nNeighbors[1] = 1;

                    PRINT(VecMath.dist(verts[1], verts[6]));
                    PRINT(Math.pow(s, 6));

                    int oldestPerimeterEdge[] = {0,1};

                    for (int i = 2; i < nVerts; ++i)
                    {
                        //PRINT(i);
                        int arity = nNeighbors[oldestPerimeterEdge[0]];
                        assert(arity < 6);
                        double angFrac = 1./(6-arity);
                        //PRINT(1./angFrac);
                        double largestEdge = VecMath.dist(verts[i-1], verts[oldestPerimeterEdge[0]]);
                        //PRINT(largestEdge);
                        //PRINT(Math.pow(s, facesList.size()));

                        double c = VecMath.dist(verts[oldestPerimeterEdge[0]],
                                                verts[oldestPerimeterEdge[1]]);
                        double a = largestEdge * Math.pow(s, 1./angFrac);
                        double b = a*s;
                        //PRINT(a);
                        //PRINT(b);
                        double target[] = completeTriangle(verts[oldestPerimeterEdge[1]],
                                                           verts[oldestPerimeterEdge[0]],
                                                           a, b);
                        double ang0 = Math.atan2(verts[i-1][1]-verts[oldestPerimeterEdge[0]][1],
                                                 verts[i-1][0]-verts[oldestPerimeterEdge[0]][0]);
                        double ang1 = Math.atan2(target[1]-verts[oldestPerimeterEdge[0]][1],
                                                 target[0]-verts[oldestPerimeterEdge[0]][0]);
                        //PRINT(RTOD(ang0));
                        //PRINT(RTOD(ang1));
                        //PRINT(angFrac);
                        while (ang1 < ang0) ang1 += 2*Math.PI;
                        double ang = LERP(ang0, ang1, angFrac);
                        double length = largestEdge * s;
                        verts[i][0] = verts[oldestPerimeterEdge[0]][0] + length*Math.cos(ang);
                        verts[i][1] = verts[oldestPerimeterEdge[0]][1] + length*Math.sin(ang);
                        facesList.add(new int[]{oldestPerimeterEdge[0], i-1, i});
                        nNeighbors[oldestPerimeterEdge[0]]++;
                        nNeighbors[i-1]++;
                        nNeighbors[i] = 2;
                        if (nNeighbors[oldestPerimeterEdge[0]] == 6)
                        {
                            //System.out.println("COMPLETING at "+i);
                            facesList.add(new int[]{oldestPerimeterEdge[1], oldestPerimeterEdge[0], i});
                            nNeighbors[oldestPerimeterEdge[1]]++;
                            nNeighbors[i]++;
                            oldestPerimeterEdge[0]++;
                            oldestPerimeterEdge[1]++;
                        }
                    }

                    {
                        int nPerimeterVerts = 0;
                        FORI (i, nVerts)
                            if (nNeighbors[i] < 6)
                                nPerimeterVerts++;
                        int perimeterVerts[] = new int[nPerimeterVerts];
                        nPerimeterVerts = 0;
                        FORI (i, nVerts)
                            if (nNeighbors[i] < 6)
                                perimeterVerts[perimeterVerts.length-1-nPerimeterVerts++] = i;
                        facesList.add(perimeterVerts);
                        PRINT(nPerimeterVerts);
                    }


                    int faces[][] = new int[facesList.size()][];
                    facesList.toArray(faces);
                    mesh = new Mesh(verts, faces);
                    //PRINTARRAY(nNeighbors);
                    //PRINTARRAY(verts);
                    //PRINTARRAY(faces);
                }
                FORIDOWN (iVert, mesh.verts.size())
                {
                    double scale = .2;
                    Mesh.Vertex vert = (Mesh.Vertex)mesh.verts.get(iVert);
                    vert.x *= scale;
                    vert.y *= scale;
                    vert.h *= scale*scale;
                }
                //double heightIncr = .005*.14;
                double heightIncr = .005*.01;
                FORIDOWN (iVert, mesh.verts.size())
                {
                    ((Mesh.Vertex)mesh.verts.get(iVert)).h -= heightIncr * iVert;
                }
            } // doCannedThingHexesSpiral

            // counterexample to "there is an unfolding
            // that uses the dullest edge on each face", // almost... needs some height adjustments... just hit O to optimize?
            private void doCannedThingHexesSpiralOther()
            {
                int nVerts = 50;
                double r = .7; // XXX actually this would have to gradually increase or decrease each time, to get a consistent direction
                double R = 1.;

                ArrayList vertsList = new ArrayList();
                vertsList.add(new double[]{0,0});
                vertsList.add(new double[]{r,0});
                vertsList.add(completeTriangle((double[])vertsList.get(0),
                                           (double[])vertsList.get(1), r, R));

                ArrayList facesList = new ArrayList();
                facesList.add(new int[]{0,1,2});


                int oldestOnBoundary = 0;
                while (vertsList.size() < nVerts)
                {
                    double newVertex[] = completeTriangle((double[])vertsList.get(oldestOnBoundary),
                                                          (double[])vertsList.get(vertsList.size()-1),
                                                          r, R);
                    if (VecMath.distsqrd((double[])vertsList.get(oldestOnBoundary+1),
                                         newVertex) <= R*R)
                    {
                        facesList.add(new int[]{oldestOnBoundary+1,
                                           oldestOnBoundary,
                                           vertsList.size()-1});
                        oldestOnBoundary++;
                    }
                    else
                    {
                        vertsList.add(newVertex);
                        facesList.add(new int[]{oldestOnBoundary,
                                           vertsList.size()-2,
                                           vertsList.size()-1});
                    }
                }
                // Now add the inside out one
                int insideOutFace[] = new int[vertsList.size() - oldestOnBoundary];
                FORI (i, insideOutFace.length)
                    insideOutFace[i] = vertsList.size()-1-i;
                facesList.add(insideOutFace);

                double verts[][] = new double[vertsList.size()][];
                vertsList.toArray(verts);
                int faces[][] = new int[facesList.size()][];
                facesList.toArray(faces);

                VecMath.mxs(verts, verts,
                            .75/VecMath.norm(verts[verts.length-1]));

                mesh = new Mesh(verts, faces);
                delaunayize(); // so faces were unnecessary, oh well
            } // doCannedThingHexesSpiralOther


    //
    // Definition of stuff for this particular app...
    //
        private static class Mesh
        {
            public String toString()
            {
                StringBuffer sb = new StringBuffer();
                sb.append(""+verts.size()+" verts:\n");
                FORI (iVert, verts.size())
                {
                    Vertex vert = (Vertex)verts.get(iVert);
                    sb.append("    "+vert.x+" "+vert.y+" "+vert.h+"\n");
                }
                sb.append(""+edges.size()+" edges:\n");
                FORI (iEdge, edges.size())
                {
                    Edge edge = (Edge)edges.get(iEdge);
                    sb.append("    v"+edge.initialVertex().myIndex()+" -> v"+edge.finalVertex().myIndex()+"\n");
                }
                return sb.toString();
            }

            public class Vertex
            {
                public double x, y, h; // x, y, "height"
                public double weight = 1.; // optional, if this is a compute dual vertex, this should be the original triangle area
                public int arity = 0; // number of edges having this vertex as initial vertex

                private int _myIndex = -1;
                public Vertex(double x, double y, double h)
                {
                    this.x = x;
                    this.y = y;
                    this.h = h;
                    verts.add(this);
                    fixVertIndices(verts.size()-1);
                }

                // A Vertex can belong to only one Mesh.
                // myIndex() returns the index into the Mesh's edges.
                public int myIndex()
                {
                    //return Arrays.indexOfUsingEqualsSymbol(verts, this);
                    return _myIndex;
                }
            } // public class Vertex
            public class Edge
            {
                private Vertex _initialVertex;
                private Edge _opposite; // opposite edge
                private Edge _next; // next edge CCW around the face to my left
                private Edge _prev; // prev edge (next edge CW) around the face to my left
                private int _myIndex = -1;
                public double direction[] = null; // optional, not kept up to date by mesh editing operations, only really used in dual, which is constructed and not edited

                public Edge(boolean andBack)
                {
                    this._myIndex = -1; // will get fixed
                    edges.add(this);
                    fixEdgeIndices(edges.size()-1);
                    if (andBack)
                    {
                        Edge opposite = new Edge(false);
                        setOpposite(opposite, true);
                    }
                }

                //
                // Accessor methods...
                //
                public Vertex initialVertex()
                {
                    return _initialVertex;
                }
                public Edge opposite()
                {
                    return _opposite;
                }
                // next edge CCW around the face to my left
                public Edge next()
                {
                    return _next;
                }
                // prev edge (next edge CW) around the face to my left
                public Edge prev()
                {
                    return _prev;
                }

                //
                // Helper methods...
                // From the caller's point of view,
                // these are just like the accessor methods
                //
                public Vertex finalVertex()
                {
                    return _opposite._initialVertex;
                }


                // An Edge can belong to only one Mesh.
                // myIndex() returns the index into the Mesh's edges.
                public int myIndex()
                {
                    //return Arrays.indexOfUsingEqualsSymbol(edges, this);
                    return _myIndex;
                }


                public void setInitialVertex(Vertex v)
                {
                    assert(_initialVertex == null);
                    _initialVertex = v;
                    _initialVertex.arity++;
                }

                public void setOpposite(Edge opposite, boolean andBack)
                {
                    _opposite = opposite;
                    if (andBack)
                        _opposite.setOpposite(this, false);
                }
                public void setNext(Edge next, boolean andBack)
                {
                    _next = next;
                    if (andBack)
                        next.setPrev(this, false);
                }
                public void setPrev(Edge prev, boolean andBack)
                {
                    _prev = prev;
                    if (andBack)
                        prev.setNext(this, false);
                }

                public String toString()
                {
                    StringBuffer sb = new StringBuffer();
                    if (initialVertex() != null)
                        sb.append(initialVertex().myIndex());
                    else
                        sb.append("null");
                    sb.append("->");
                    if (finalVertex() != null)
                        sb.append(finalVertex().myIndex());
                    else
                        sb.append("null");
                    return sb.toString();
                }

            } // public class Edge

            // Called whenever verts array changes
            private void fixVertIndices(int i0)
            {
                for (int iVert = i0; iVert < verts.size(); ++iVert)
                    ((Vertex)verts.get(iVert))._myIndex = iVert;
            }
            // Called whenever edges array changes
            private void fixEdgeIndices(int i0)
            {
                for (int iEdge = i0; iEdge < edges.size(); ++iEdge)
                    ((Edge)edges.get(iEdge))._myIndex = iEdge;
            }

            public void sanityCheck()
            {
                int nVerts = this.verts.size();
                int nEdges = this.edges.size();

                Vertex verts[] = new Vertex[nVerts];
                Edge edges[] = new Edge[nEdges];

                FORI (iVert, nVerts)
                {
                    Vertex vert = (Vertex)this.verts.get(iVert);
                    assert(vert.myIndex() == iVert);
                    verts[iVert] = vert;
                }
                FORI (iEdge, nEdges)
                {
                    Edge edge = (Edge)this.edges.get(iEdge);
                    assert(edge.myIndex() == iEdge);
                    edges[iEdge] = edge;
                }

                int nTimesSawVertAsInitial[] = new int[nVerts]; // all zero
                boolean sawEdgeAsOpposite[] = new boolean[nEdges]; // all false
                boolean sawEdgeAsNext[] = new boolean[nEdges]; // all false
                boolean sawEdgeAsPrev[] = new boolean[nEdges]; // all false
                FORI (iEdge, nEdges)
                {
                    Edge e = edges[iEdge];
                    Vertex initialVertex = e.initialVertex();
                    Edge opposite = e.opposite();
                    Edge next = e.next();
                    Edge prev = e.prev();

                    assert(initialVertex != null);
                    assert(opposite != null);
                    assert(next != null);
                    assert(prev != null);

                    int initialVertIndex = initialVertex.myIndex();
                    int oppositeIndex = opposite.myIndex();
                    int nextIndex = next.myIndex();
                    int prevIndex = prev.myIndex();

                    assert(verts[initialVertIndex] == initialVertex);
                    assert(edges[oppositeIndex] == opposite);
                    assert(edges[nextIndex] == next);
                    assert(edges[prevIndex] == prev);

                    assert(initialVertex != e.finalVertex());
                    assert(opposite != e);
                    assert(next != e);
                    assert(prev != e);
                    assert(opposite.opposite() == e);
                    assert(next.prev() == e);
                    assert(prev.next() == e);


                    // Okay for a vert to be initial more than once...
                    nTimesSawVertAsInitial[initialVertIndex]++;

                    // But not the others...
                    assert(!sawEdgeAsOpposite[oppositeIndex]);
                    sawEdgeAsOpposite[oppositeIndex] = true;
                    assert(!sawEdgeAsNext[nextIndex]);
                    sawEdgeAsNext[nextIndex] = true;
                    assert(!sawEdgeAsPrev[prevIndex]);
                    sawEdgeAsPrev[prevIndex] = true;
                }

                FORI (iVert, nVerts)
                {
                    assert(nTimesSawVertAsInitial[iVert] == verts[iVert].arity);
                }
                FORI (iEdge, nEdges)
                {
                    assert(sawEdgeAsOpposite[iEdge]);
                    assert(sawEdgeAsNext[iEdge]);
                    assert(sawEdgeAsPrev[iEdge]);
                }
            } // sanityCheck




            /*                    ^
                 insertThisEdge   | beforeThisEdge
                <-----------------*
                                 /|\
                                / | \
            */
            public void insertEdgeBefore(Edge insertThisEdge, Edge beforeThisEdge)
            {
                if (nonEventVerbose >= 1)
                    System.out.println("        In insertEdgeBefore(insertThisEdge="+insertThisEdge.myIndex()+", beforeThisEdge="+beforeThisEdge.myIndex()+"");
                beforeThisEdge.prev().setNext(insertThisEdge, true);
                insertThisEdge.opposite().setNext(beforeThisEdge, true);
                insertThisEdge.setInitialVertex(beforeThisEdge.initialVertex());
                if (nonEventVerbose >= 1)
                    System.out.println("        Out insertEdgeBefore(insertThisEdge="+insertThisEdge.myIndex()+", beforeThisEdge="+beforeThisEdge.myIndex()+"");
            }
            public void addWhisker(Edge beforeThisEdge,
                                   Vertex v) // to this vertex
            {
                Edge e = new Edge(true);
                e.opposite().setInitialVertex(v);
                e.setNext(e.opposite(), true);
                insertEdgeBefore(e, beforeThisEdge);
            }
            public void addDiagonal(Edge beforeThisEdge, Edge beforeThatEdge)
            {
                if (nonEventVerbose >= 1)
                    System.out.println("    In addDiagonal(beforeThisEdge="+beforeThisEdge.myIndex()+", beforeThatEdge="+beforeThatEdge.myIndex()+"");
                Edge e = new Edge(true);
                insertEdgeBefore(e, beforeThisEdge);
                insertEdgeBefore(e.opposite(), beforeThatEdge);
                if (nonEventVerbose >= 1)
                    System.out.println("    Out addDiagonal(beforeThisEdge="+beforeThisEdge.myIndex()+", beforeThatEdge="+beforeThatEdge.myIndex()+"");
            }
            // returns true iff did something
            public boolean swapDiagonal(Edge e, boolean onlyIfMoreDelaunay, boolean verbose)
            {
                if (e.next().next().next() != e
                 || e.opposite().next().next().next() != e.opposite())
                {
                    if (verbose)
                        System.out.println("    Can't swap diagonal, it's not on a quad");
                    return false;
                }

                Edge beforeThisEdge = e.prev();
                Edge beforeThatEdge = e.opposite().prev();

                //
                // Another subtle thing to check...
                // Make sure the other diagonal doesn't
                // already exist.
                //
                {
                    Vertex v0 = beforeThisEdge.initialVertex();
                    Vertex v1 = beforeThatEdge.initialVertex();
                    // Could do this faster by walking around the vert,
                    // but this is more complete since it checks for some pathological cases
                    FORIDOWN (iEdge, edges.size())
                    {
                        Edge edge = (Edge)edges.get(iEdge);
                        if (edge.initialVertex() == v0
                         && edge.finalVertex() == v1)
                        {
                            if (verbose)
                                System.out.println("    Can't swap diagonal, the other diagonal already exists");
                            return false;
                        }
                    }
                }

                if (onlyIfMoreDelaunay)
                {
                    Vertex a = beforeThisEdge.finalVertex();
                    Vertex b = beforeThatEdge.initialVertex();
                    Vertex c = beforeThatEdge.finalVertex();
                    Vertex d = beforeThisEdge.initialVertex();
                    // comfort of ac relative to bd
                    double comfort = TriangulationOptimizer.calcQuadComfort(new double[]{a.x,a.y},
                                                                            new double[]{b.x,b.y},
                                                                            new double[]{c.x,c.y},
                                                                            new double[]{d.x,d.y},
                                                                            0, 1);
                    // XXX TODO: take height into account!!!!!
                    if (verbose)
                        System.out.println("    comfort = "+comfort);
                    if (comfort >= 0) // should this be fuzzy? I won't worry about it for now
                    {
                        if (verbose)
                            System.out.println("    Swapping diagonal would not improve it");
                        return false;
                    }
                }

                if (true)
                {
                    // This works, but leaves dual verts in a different order
                    deleteEdge(e);
                    addDiagonal(beforeThisEdge, beforeThatEdge);
                }
                else
                {
                    // TODO: why did this work in temp branch but fails here?
                    // OH, it's because the assertion in setInitialVertex is new.
                    // hmm, can try to fix it, or just get rid of this case since it was somewhat ill-advised anyway.

                    // Aww fooey, still in different order :-(
                    beforeThatEdge.setNext(beforeThisEdge.prev(), true);
                    beforeThisEdge.setNext(beforeThatEdge.prev(), true);
                    insertEdgeBefore(e, beforeThisEdge);
                    insertEdgeBefore(e.opposite(), beforeThatEdge);
                    // no need to fix up edge indices
                }
                return true;
            } // swapDiagonal
            public void addEdgeBetweenTwoIsolatedVertices(Vertex v0, Vertex v1)
            {
                Edge e = new Edge(true);
                e.setInitialVertex(v0);
                e.opposite().setInitialVertex(v1);
                e.setNext(e.opposite(), true);
                e.setPrev(e.opposite(), true);
            }
            public void addEdgeBetweenTwoVertices(Vertex v0, Vertex v1)
            {
                assert(v0 != v1);
                if (verts.size() == 2)
                {
                    // XXX this case might not be necessary?
                    addEdgeBetweenTwoIsolatedVertices(v0, v1);
                    return;
                }
                // find the face containing both vertices
                // that has greatest area.
                Edge bestBeforeThisEdge = null;
                Edge bestBeforeThatEdge = null;
                double bestTwiceFaceArea = Double.NEGATIVE_INFINITY;
                int nEdges = edges.size();
                FORI (iEdge, nEdges)
                {
                    Edge e0 = (Edge)edges.get(iEdge);
                    if (e0.initialVertex() == v0)
                    {
                        if (e0.finalVertex() == v1)
                        {
                            return; // the vertices are neighbors... definitely don't do anything in this case
                        }
                        // walk around the face CCW looking for v1
                        for (Edge e = e0; e.finalVertex() != v0; e = e.next())
                        {
                            if (e.finalVertex() == v1)
                            {
                                double twiceFaceArea = twiceFaceArea(e0);
                                if (twiceFaceArea > bestTwiceFaceArea)
                                {
                                    bestBeforeThisEdge = e0;
                                    bestBeforeThatEdge = e.next();
                                    bestTwiceFaceArea = twiceFaceArea;
                                }
                                break;
                            }
                        }
                    }
                }
                if (bestBeforeThisEdge != null)
                {
                    addDiagonal(bestBeforeThisEdge,
                                bestBeforeThatEdge);
                    return;
                }
                // XXX TODO: more cases, if either or both of the vertices are isolated, or otherwise connecting two components
            } // addEdgeBetweenTwoVertices

            public double twiceFaceArea(Edge e0)
            {
                double sum = 0;
                Vertex v0 = e0.initialVertex();
                // All edges e not containing v0...
                for (Edge e = e0.next(); e.finalVertex() != v0; e = e.next())
                {
                    Vertex v1 = e.initialVertex();
                    Vertex v2 = e.finalVertex();
                    sum += twiceTriangleArea(v0.x, v0.y,
                                             v1.x, v1.y,
                                             v2.x, v2.y);
                }
                return sum;
            } // twiceFaceArea

            public void addIsolatedVertex(double x, double y, double h)
            {
                new Vertex(x,y,h); // adds itself to verts
            }
            // This is the "kis" operation, the dual of truncating a vertex.
            public void kisIsolatedVertex(Vertex v, Edge someEdgeOnFace)
            {
                if (nonEventVerbose >= 1)
                    System.out.println("In kis(v="+v.myIndex()+", someEdgeOnFac="+someEdgeOnFace.myIndex()+"");
                //
                // Start by attaching a single whisker to the new vertex...
                //
                if (nonEventVerbose >= 1)
                    System.out.println("    adding a whisker from edge "+someEdgeOnFace.myIndex()+" to vert "+v.myIndex());
                addWhisker(someEdgeOnFace, v);
                if (nonEventVerbose >= 1)
                {
                    System.out.println("    did that at least.");
                    PRINT(this);
                }

                //
                // Now fill in with triangles,
                // connecting everything to the new vertex v.
                //
                while (someEdgeOnFace.next()
                                     .next()
                                     .next() != someEdgeOnFace)
                {
                    if (nonEventVerbose >= 1)
                        System.out.println("    adding diagonal from start of edge "+someEdgeOnFace.prev().myIndex()+" to start of edge "+someEdgeOnFace.prev().prev().prev().myIndex()+"");
                    addDiagonal(someEdgeOnFace.prev(),
                                someEdgeOnFace.prev()
                                              .prev()
                                              .prev());
                    if (nonEventVerbose >= 1)
                    {
                        System.out.println("    did that diagonal.");
                        PRINT(this);
                    }
                }
                if (nonEventVerbose >= 1)
                    System.out.println("Out kis(v="+v.myIndex()+", someEdgeOnFac="+someEdgeOnFace.myIndex()+"");
            }
            public void deleteEdge(Edge e)
            {
                e.prev().setNext(e.opposite().next(), true);
                e.opposite().prev().setNext(e.next(), true);
                /*
                assert(e.next() == e.opposite());
                assert(e.prev() == e.opposite());
                */
                int i = e.myIndex();
                edges.remove(i);
                fixEdgeIndices(i);

                int j = e.opposite().myIndex();
                edges.remove(j);
                fixEdgeIndices(j);

                e._initialVertex.arity--;
                e._initialVertex = null;

                e.opposite()._initialVertex.arity--;
                e.opposite()._initialVertex = null;
            }
            public void deleteVertex(Vertex v)
            {
                FORI (iEdge, edges.size())
                {
                    Edge edge = (Edge)edges.get(iEdge);
                    if (edge.initialVertex() == v
                     || edge.finalVertex() == v)
                    {
                        deleteEdge(edge);
                        iEdge--; // so when we increment we get back to here
                    }
                }
                assert(v.arity == 0);
                int iVert = v.myIndex();
                verts.remove(iVert);
                fixVertIndices(iVert);
                // XXX should we do the fast remove, moving the last one into the slot?  well, is there an advantage to keeping the vertices in order?  Probably.
            }

            public int indexOfClosestVert(double x, double y)
            {
                double closestDistSqrd = Double.POSITIVE_INFINITY;
                int closestVertIndex = -1;
                FORI (iVert, verts.size()) // beginning to end, so we choose first of equal
                {
                    Vertex vert = (Vertex)verts.get(iVert);
                    double thisDistSqrd = SQR(vert.x-x)
                                        + SQR(vert.y-y);
                    if (thisDistSqrd < closestDistSqrd)
                    {
                        closestDistSqrd = thisDistSqrd;
                        closestVertIndex = iVert;
                    }
                }
                return closestVertIndex; // -1 if none
            } // indexOfClosestVert

            public int indexOfClosestEdge(double point[/*2*/])
            {
                double x = point[0], y = point[1];
                double closestDistSqrd = Double.POSITIVE_INFINITY;
                int closestEdgeIndex = -1;
                FORI (iEdge, edges.size()) // beginning to end, so we choose first of equal
                {
                    Edge edge = (Edge)edges.get(iEdge);
                    double thisDistSqrd =
                        edge.initialVertex() == null ? Double.POSITIVE_INFINITY : // no need to deal with edges whose initial vertex is NULL and final vertex isn't, since we'll encounter its opposite anyway
                        edge.finalVertex() == null ? distSqrdFromPointToRay(x,y,
                                                                            edge.initialVertex().x,
                                                                            edge.initialVertex().y,
                                                                            edge.direction[0],
                                                                            edge.direction[1]) :
                        edge.initialVertex().myIndex() > edge.finalVertex().myIndex() ? Double.POSITIVE_INFINITY
                                                    : distSqrdFromPointToSeg(x,y,
                                                                             edge.initialVertex().x,
                                                                             edge.initialVertex().y,
                                                                             edge.finalVertex().x,
                                                                             edge.finalVertex().y);
                    if (thisDistSqrd < closestDistSqrd)
                    {
                        closestDistSqrd = thisDistSqrd;
                        closestEdgeIndex = iEdge;
                    }
                }
                return closestEdgeIndex; // -1 if none
            } // indexOfClosestEdge

            public double[] findOptimalVertexHeights(int optimizationType)
            {
                if (verts.size() < 3)
                    return new double[verts.size()]; // zeros

                if (nonEventVerbose >= 1)
                    System.out.println("in findOptimalVertexHeights");

                int nDependentVerts = 3;
                int dependentVertIndices[] = {0,1,2};
                // Prefer the triangle that contains the origin...
                {
                    FORI (iEdge, edges.size())
                    {
                        Edge edge = (Edge)edges.get(iEdge);
                        if (edge.next().next().next() != edge)
                            continue;
                        Vertex v0 = edge.initialVertex();
                        Vertex v1 = edge.next().initialVertex();
                        Vertex v2 = edge.next().next().initialVertex();
                        if (twiceTriangleArea(0,0,
                                              v0.x,v0.y,
                                              v1.x,v1.y) >= 0
                         && twiceTriangleArea(0,0,
                                              v1.x,v1.y,
                                              v2.x,v2.y) >= 0
                         && twiceTriangleArea(0,0,
                                              v2.x,v2.y,
                                              v0.x,v0.y) >= 0)
                        {
                            dependentVertIndices[0] = v0.myIndex();
                            dependentVertIndices[1] = v1.myIndex();
                            dependentVertIndices[2] = v2.myIndex();
                            break; // origin is inside this tri CCW
                        }
                    }
                }

                // Figure out the desired dualEdgeLength...
                // XXX just hard code for now
                double desiredDualEdgeLength = .25;

                // edge2dualVert[iEdge] will be the dual vert on the left of edges[iEdge]
                int edge2dualVert[] = VecMath.fillvec(edges.size(), -1);
                int nDualVerts;
                {
                    nDualVerts = 0;
                    FORI (iEdge, edges.size())
                    {
                        if (edge2dualVert[iEdge] != -1)
                            continue; // already saw some other edge on this tri
                        Edge e0 = (Edge)edges.get(iEdge);
                        Edge e1 = e0.next();
                        Edge e2 = e1.next();
                        boolean thisIsATri = (e2.next() == e0);
                        if (!thisIsATri)
                            continue;

                        Mesh.Vertex v0 = e0.initialVertex();
                        Mesh.Vertex v1 = e1.initialVertex();
                        Mesh.Vertex v2 = e2.initialVertex();

                        double dualVertArea = twiceTriangleArea(v0.x,v0.y,
                                                                v1.x,v1.y,
                                                                v2.x,v2.y);
                        if (dualVertArea < 0.)
                            continue; // triangle is inside out

                        edge2dualVert[iEdge] = nDualVerts;
                        edge2dualVert[e1.myIndex()] = nDualVerts;
                        edge2dualVert[e2.myIndex()] = nDualVerts;
                        nDualVerts++;
                    }
                }
                if (nonEventVerbose >= 1)
                    PRINT(nDualVerts);

                // there is only one dual edge per pair (edge,edge.opposite()).
                int edge2dualEdge[] = VecMath.fillvec(edges.size(), -1);
                int nDualEdges;
                {
                    nDualEdges = 0;
                    FORI (iEdge, edges.size())
                    {
                        if (edge2dualEdge[iEdge] != -1)
                            continue; // already seen it from the opposite edge

                        Edge edge = (Edge)edges.get(iEdge);
                        if (edge2dualVert[iEdge] != -1
                         && edge2dualVert[edge.opposite().myIndex()] != -1)
                        {
                            // Opposite edge is also on a tri
                            // that we haven't counted yet
                            edge2dualEdge[iEdge] = nDualEdges;
                            edge2dualEdge[edge.opposite().myIndex()] = nDualEdges;
                            nDualEdges++;
                        }
                    }
                }
                if (nonEventVerbose >= 1)
                    PRINT(nDualEdges);

                int dualVert2verts[][] = VecMath.fillmat(nDualVerts, 3, -1);
                int dualEdge2edge[] = VecMath.fillvec(nDualEdges, -1); // XXX not used?
                int dualEdge2dualVerts[][] = VecMath.fillmat(nDualEdges, 2, -1);
                {
                    FORI (iEdge, edges.size())
                    {
                        Edge edge = (Edge)edges.get(iEdge);
                        int iDualEdge = edge2dualEdge[iEdge];
                        if (iDualEdge != -1 // if it has a dual edge
                         && dualEdge2dualVerts[iDualEdge][0] == -1) // if we didn't already do this dual edge from the opposite
                        {
                            dualEdge2edge[iDualEdge] = iEdge;
                            dualEdge2dualVerts[iDualEdge][0] = edge2dualVert[iEdge];
                            dualEdge2dualVerts[iDualEdge][1] = edge2dualVert[edge.opposite().myIndex()];
                        }

                        int iDualVert = edge2dualVert[iEdge];
                        if (iDualVert != -1 // if this edge is on a triangle
                         && dualVert2verts[iDualVert][0] == -1) // if we didn't already do this dual vert
                        {
                            dualVert2verts[iDualVert][0] = edge.initialVertex().myIndex();
                            dualVert2verts[iDualVert][1] = edge.next().initialVertex().myIndex();
                            dualVert2verts[iDualVert][2] = edge.next().next().initialVertex().myIndex();
                        }
                    }
                    FORI (iDualVert, nDualVerts)
                        FORI (j, 3)
                            assert(dualVert2verts[iDualVert][j] != -1);

                    FORI (iDualEdge, nDualEdges)
                    {
                        assert(dualEdge2edge[iDualEdge] != -1);
                        assert(dualEdge2dualVerts[iDualEdge][0] != -1);
                        assert(dualEdge2dualVerts[iDualEdge][1] != -1);
                    }
                }


                // can optimize positions or lengths.  I think optimizing positions is more robust.
                boolean optimizingBarycentrics = optimizationType == OPTIMIZE_BARYCENTRICS_LEAST_SQUARES
                                              || optimizationType == OPTIMIZE_BARYCENTRICS_MAX_MIN
                                              || optimizationType == OPTIMIZE_BARYCENTRICS_INFINITY_NORM;
                if (optimizingBarycentrics)
                {
                    nDependentVerts = 1; // XXX not right in general, should be number of connected components maybe
                    dependentVertIndices = new int[] {0};
                }

                if (nonEventVerbose >= 1)
                {
                    PRINTVEC(dependentVertIndices);
                }


                int nIndependentVerts = verts.size() - nDependentVerts;

                if (nIndependentVerts > (optimizingBarycentrics ? 2*nDualVerts : nDualEdges))
                {
                    //PRINT((optimizingBarycentrics ? 2*nDualVerts : nDualEdges));
                    System.out.println("Out findOptimalVertexHeights (too many independent verts, it's underconstrained)");
                    return new double[verts.size()]; // zeros
                }

                int vert2independentVert[] = new int[verts.size()];
                int independentVert2verts[] = new int[nIndependentVerts];
                {
                    int iIndependentVert = 0;
                    FORIDOWN (iVert, verts.size())
                    {
                        if (Arrays.indexOf(dependentVertIndices, iVert) == -1)
                        {
                            vert2independentVert[iVert] = iIndependentVert;
                            independentVert2verts[iIndependentVert] = iVert;
                            iIndependentVert++;
                        }
                        else
                            vert2independentVert[iVert] = -1;
                    }
                    assert(iIndependentVert == nIndependentVerts);
                }
                if (nonEventVerbose >= 1)
                {
                    PRINTVEC(vert2independentVert);
                    PRINTVEC(independentVert2verts);
                }


                int nSamples = nIndependentVerts+1;
                double sampleResultVerts[][][] = new double[nSamples][nDualVerts][2]; // SolveForDualPoint actually only needs 2, contrary to all the other comments
                {
                    double sampleHeights[][] = new double[nIndependentVerts+1][nIndependentVerts];
                    VecMath.identitymat(sampleHeights); // the unit basis vectors, and a row of zeros at the end

                    FORI (iSample, nSamples)
                    {
                        //
                        // Input sampleHeights[iSample]
                        // and get out sampleResultVerts[iSample]
                        //
                        FORI (iDualVert, nDualVerts)
                        {
                            int iVert0 = dualVert2verts[iDualVert][0];
                            int iVert1 = dualVert2verts[iDualVert][1];
                            int iVert2 = dualVert2verts[iDualVert][2];
                            int iIndependentVert0 = vert2independentVert[iVert0];
                            int iIndependentVert1 = vert2independentVert[iVert1];
                            int iIndependentVert2 = vert2independentVert[iVert2];
                            double h0 = (iIndependentVert0 == -1 ? 0. : sampleHeights[iSample][iIndependentVert0]);
                            double h1 = (iIndependentVert1 == -1 ? 0. : sampleHeights[iSample][iIndependentVert1]);
                            double h2 = (iIndependentVert2 == -1 ? 0. : sampleHeights[iSample][iIndependentVert2]);
                            Vertex v0 = (Vertex)verts.get(iVert0);
                            Vertex v1 = (Vertex)verts.get(iVert1);
                            Vertex v2 = (Vertex)verts.get(iVert2);
                            SolveForDualPoint(v0.x,v0.y,h0,
                                              v1.x,v1.y,h1,
                                              v2.x,v2.y,h2,
                                              sampleResultVerts[iSample][iDualVert]); // dimension 2-- last coord is simply ignored
                        }
                    }
                    //PRINTMAT(sampleHeights);
                }

                double solvedHeights[];

                if (optimizingBarycentrics)
                {
                    // We want to maximize the minimum barycentric occurring
                    // anywhere in the result.
                    double sampleBarycentrics[][][] = new double[nSamples][nDualVerts][3];
                    FORI (iSample, nSamples)
                    {
                        FORI (iDualVert, nDualVerts)
                        {
                            int tri[] = dualVert2verts[iDualVert];
                            double wholeArea = twiceTriangleArea(((Vertex)verts.get(tri[0])).x, ((Vertex)verts.get(tri[0])).y,
                                                                 ((Vertex)verts.get(tri[1])).x, ((Vertex)verts.get(tri[1])).y,
                                                                 ((Vertex)verts.get(tri[2])).x, ((Vertex)verts.get(tri[2])).y);
                            double dualVert[] = sampleResultVerts[iSample][iDualVert];
                            FORI (iVertOnTri, 3)
                            {
                                sampleBarycentrics[iSample][iDualVert][iVertOnTri] =
                                        twiceTriangleArea(dualVert[0], dualVert[1],
                                                          ((Vertex)verts.get(tri[(iVertOnTri+1)%3])).x,
                                                          ((Vertex)verts.get(tri[(iVertOnTri+1)%3])).y,
                                                          ((Vertex)verts.get(tri[(iVertOnTri+2)%3])).x,
                                                          ((Vertex)verts.get(tri[(iVertOnTri+2)%3])).y)
                                      / wholeArea;
                            }
                        }
                    }
                    double sampleResultVectors[][] = (double[][])Arrays.flatten(sampleBarycentrics, 1, 2);
                    double desiredResultVector[] = VecMath.fillvec(sampleResultVectors[0].length,
                                        optimizationType==OPTIMIZE_BARYCENTRICS_MAX_MIN ? 0. : 1./3.);

                    //
                    // Find C and d
                    // such that x -> C x - d
                    // maps heights to barycentrics.
                    //

                    //
                    // Column i of C is the result from the i'th basis sample,
                    // minus the result from the 0 vector.
                    //
                    double C[][] = new double[sampleResultVectors.length-1][sampleResultVectors[0].length]; // start transposed...
                    FORI (iSample, sampleResultVectors.length-1)
                        VecMath.vmv(C[iSample],
                                    sampleResultVectors[iSample],
                                    sampleResultVectors[sampleResultVectors.length-1]);
                    C = VecMath.transpose(C);

                    //
                    // d is the desired result minus the result from the zero vector.
                    //
                    double d[] = VecMath.vmv(desiredResultVector,
                                             sampleResultVectors[sampleResultVectors.length-1]);

                    // XXX could get clean up the dependent/intependent lookup tables if we want by expressing the independent vertex's constraints here...
                    double A[][] = {}; // no equality constraints
                    double b[] = {}; // no equality constraints

                    LinearProgramming.debugLevel = 0;

                    if (optimizationType == OPTIMIZE_BARYCENTRICS_LEAST_SQUARES)
                    {
                        if (nonEventVerbose >= 1)
                        {
                            System.out.print("    Solving barycentrics least squares from all 1/3's...");
                            System.out.flush();
                        }
                        solvedHeights = VecMath.invmxv(C,d);
                        if (nonEventVerbose >= 1)
                            System.out.println("    done.");
                    }
                    else if (optimizationType == OPTIMIZE_BARYCENTRICS_INFINITY_NORM)
                    {
                        solvedHeights = new double[sampleResultVectors.length-1];
                        if (nonEventVerbose >= 1)
                        {
                            System.out.print("    Solving barycentrics infinity norm from all 1/3's...");
                            System.out.flush();
                        }
                        int result = LinearProgramming.LInfinitySolve(solvedHeights, C,d);
                        if (nonEventVerbose >= 1)
                            System.out.println("    done.");
                        if (result != 0)
                            System.out.println("WARNING: LPSolve returned "+result);
                    }
                    else if (optimizationType == OPTIMIZE_BARYCENTRICS_MAX_MIN)
                    {
                        solvedHeights = new double[sampleResultVectors.length-1];
                        if (nonEventVerbose >= 1)
                        {
                            System.out.print("    Solving barycentrics maximizing minimal element...");
                            System.out.flush();
                        }
                        int result = LinearProgramming.maximizeMinimum(solvedHeights,
                                                                       A, b,
                                                                       C, d);
                        if (nonEventVerbose >= 1)
                            System.out.println("    done.");
                        if (false)
                        {
                            PRINTMAT(A);
                            PRINTVEC(b);
                            PRINTMAT(C);
                            PRINTVEC(d);
                            PRINT(result);
                            PRINTVEC(solvedHeights);
                        }
                        if (result != 0)
                            System.out.println("WARNING: LPSolve returned "+result);
                    }
                    else
                    {
                        assert(false);
                    }
                }
                else // optimize lengths
                {
                    double sampleResultVectors[][];
                    double desiredResultVector[];

                    {
                        double sampleResultLengths[][] = new double[nSamples][nDualEdges];
                        FORI (iSample, nSamples)
                        {
                            //
                            // Calculate sampleResultLengths[iSample]
                            // from sampleResultVerts[iSample]
                            //
                            FORI (iDualEdge, nDualEdges)
                            {
                                sampleResultLengths[iSample][iDualEdge] =
                                    VecMath.dist(2,
                                                 sampleResultVerts[iSample][dualEdge2dualVerts[iDualEdge][0]],
                                                 sampleResultVerts[iSample][dualEdge2dualVerts[iDualEdge][1]]);
                                // Need to figure out the sign.
                                // If dual edge length is positive,
                                // it will point from the original edge's left face
                                // to the original edge's right face.
                                // So the dual edge dir cross the original edge dir
                                // should be > 0.
                                double dualEdgeDir[] = VecMath.vmv(2,
                                                                  sampleResultVerts[iSample][dualEdge2dualVerts[iDualEdge][1]],
                                                                   sampleResultVerts[iSample][dualEdge2dualVerts[iDualEdge][0]]);
                                double originalEdgeDir[] = VecMath.vmv(
                                    new double[] {((Edge)edges.get(dualEdge2edge[iDualEdge])).finalVertex().x,
                                                  ((Edge)edges.get(dualEdge2edge[iDualEdge])).finalVertex().y},
                                    new double[] {((Edge)edges.get(dualEdge2edge[iDualEdge])).initialVertex().x,
                                                  ((Edge)edges.get(dualEdge2edge[iDualEdge])).initialVertex().y}
                                );
                                if (VecMath.vxv2(dualEdgeDir, originalEdgeDir) < 0)
                                {
                                    sampleResultLengths[iSample][iDualEdge] *= -1;
                                }
                            }
                        }
                        sampleResultVectors = sampleResultLengths;
                    }
                    desiredResultVector = VecMath.fillvec(nDualEdges, desiredDualEdgeLength);

                    // the following is general, could optimize something else if desired
                    {

                        //
                        // Row i of A is the result from the i'th basis sample,
                        // minus the result from the 0 vector.
                        //
                        double A[][] = new double[sampleResultVectors.length-1][sampleResultVectors[0].length];
                        FORI (iSample, sampleResultVectors.length-1)
                            VecMath.vmv(A[iSample],
                                        sampleResultVectors[iSample],
                                        sampleResultVectors[sampleResultVectors.length-1]);
                        //
                        // b is the desired result
                        // minus the result from the 0 vector.
                        //
                        double b[] = VecMath.vmv(desiredResultVector,
                                                 sampleResultVectors[sampleResultVectors.length-1]);

                        //PRINTMAT(A);
                        //PRINTVEC(b);

                        double leastSquaresSolution[];
                        if (optimizationType == OPTIMIZE_LENGTHS_LEAST_SQUARES)
                        {
                            if (nonEventVerbose >= 1)
                            {
                                System.out.print("    Solving for lengths least squares from all "+desiredDualEdgeLength+" ...");
                                System.out.flush();
                            }
                            leastSquaresSolution = VecMath.vxinvm(b, A);
                            if (nonEventVerbose >= 1)
                                System.out.println("    done.");
                        }
                        else if (optimizationType == OPTIMIZE_LENGTHS_INFINITY_NORM)
                        {
                            leastSquaresSolution = new double[sampleResultVectors.length-1];
                            if (nonEventVerbose >= 1)
                            {
                                assert(desiredDualEdgeLength == .25);
                                System.out.print("    Solving lengths infinity norm from all .25's...");
                                System.out.flush();
                            }
                            int result = LinearProgramming.LInfinitySolve(leastSquaresSolution, VecMath.transpose(A),b);
                            if (nonEventVerbose >= 1)
                                System.out.println("    done.");
                            if (result != 0)
                                System.out.println("WARNING: LPSolve returned "+result);
                        }
                        else if (optimizationType == OPTIMIZE_LENGTHS_MAX_MIN)
                        {
                            double[] result0 = sampleResultVectors[sampleResultVectors.length-1];

                            leastSquaresSolution = new double[sampleResultVectors.length-1];
                            if (nonEventVerbose >= 1)
                            {
                                System.out.print("    Solving lengths maximizing minimum with sum 1...");
                                System.out.flush();
                            }

                            // Set desired sum to be the sum of the primal edge lengths
                            // (to get something roughly commensurate, that scales with the original)
                            double desiredSum = 0.;
                            FORI (iEdge, edges.size())
                            {
                                Edge edge = (Edge)edges.get(iEdge);
                                if (edge.myIndex() > edge.opposite().myIndex())
                                    continue; // only use canonical one of the two
                                Vertex v0 = edge.initialVertex();
                                Vertex v1 = edge.finalVertex();
                                desiredSum += Math.sqrt(SQR(v1.x-v0.x) + SQR(v1.y-v0.y));
                            }
                            if (nonEventVerbose >= 1)
                                PRINT(desiredSum);

                            if (true)
                            {
                                // Empirically, it's a bit bigger than I want,
                                // especially if there are a lot of infinite edges in the dual
                                // (i.e. much fewer finite edges in the dual than in primal).
                                // So scale down desiredSum by nDualEdges/nEdges.
                                // (nEdges is actually half of edges.size())
                                //PRINT(nDualEdges);
                                //PRINT(edges.size());
                                desiredSum *= ((double)nDualEdges/
                                               (double)(edges.size()/2));
                                // and, final hack... seems to work better scaled by 1/2 anyway
                                desiredSum /= 2.;
                            }




                            // Want solution column vector x
                            // that satisfies [1,1,...,1] (transpose(A) x + result0) = desiredSum
                            //           i.e. [1,1,...,1] (transpose(A) x) + sum(result0) = desiredSum
                            //           i.e. [1,1,...,1] (transpose(A) x) = desiredSum - sum(result0)
                            // and maximizes the minimum element of transpose(A) x + result0.

                            double AA[][] = {VecMath.mxv(A, VecMath.fillvec(nDualEdges, 1.))};
                            double bb[] = {desiredSum - VecMath.sum(result0)};
                            double CC[][] = VecMath.transpose(A);
                            double dd[] = VecMath.sxv(-1.,result0);
                            int result =
                                         leastSquaresSolution.length == 0 ? 0 : // XXX TODO: FIX maximizeMiniumum so it returns 0 instead of -1 in this case!
                                         LinearProgramming.maximizeMinimum(leastSquaresSolution,
                                                                           AA, bb, // AA x = bb
                                                                           CC, dd); // maximize min of CC x - dd, i.e. A^T x + result0
                            if (nonEventVerbose >= 1)
                                System.out.println("    done.");
                            if (result != 0)
                                System.out.println("WARNING: maximizeMinumum returned "+result);

                            if (nonEventVerbose >= 1)
                            {
                                PRINTMAT(AA);
                                PRINTVEC(bb);
                                PRINTVEC(VecMath.vmv(VecMath.mxv(AA, leastSquaresSolution), bb));
                                PRINTVEC(leastSquaresSolution);
                                PRINTVEC(VecMath.vxm(leastSquaresSolution, A));
                                PRINTVEC(VecMath.vpv(VecMath.vxm(leastSquaresSolution,A), result0));
                                PRINT(VecMath.sum(VecMath.vpv(VecMath.vxm(leastSquaresSolution,A), result0)));
                            }

                        }
                        else if (optimizationType == OPTIMIZE_LENGTHS_SUM)
                        {
                            if (nonEventVerbose >= 1)
                            {
                                assert(desiredDualEdgeLength == .25);
                                System.out.print("    Solving lengths minimizing sum with each length >= .25...");
                                System.out.flush();
                            }
                            // XXX not implemented yet
                            assert(false);
                        }
                        else
                            assert(false);

                        //PRINTVEC(leastSquaresSolution);
                        double gotLengths[] = VecMath.vxm(leastSquaresSolution, A);
                        //PRINTVEC(gotLengths);

                        boolean doCheckLeastSquaresSolution = false; // I'm convinced it works
                        if (doCheckLeastSquaresSolution)
                        {
                            System.out.print("    Checking");
                            System.out.flush();

                            int nTests = 100;
                            FORI (iTest, nTests)
                            {
                                System.out.print(".");

                                //
                                // Perturb each element of the solution
                                // by a random amount
                                //
                                double foo[] = VecMath.copyvec(leastSquaresSolution);
                                double dir[] = VecMath.random(leastSquaresSolution.length);
                                VecMath.normalize(dir);
                                double fudges[] = {.01, -.01};
                                FORI (iFudge, fudges.length)
                                {
                                    VecMath.vpsxv(foo, leastSquaresSolution, fudges[iFudge], dir);
                                    double bar[] = VecMath.vxm(foo, A);
                                    //PRINT(VecMath.dist(bar, b));
                                    if (foo.length > 0)
                                        assert(VecMath.dist(gotLengths, b) < VecMath.dist(bar, b));
                                }
                            }
                            System.out.println("    done.");
                        }
                        solvedHeights = leastSquaresSolution;
                    }
                } // optimize lengths

                assert(solvedHeights.length == independentVert2verts.length);
                double optimalVertexHeights[] = new double[verts.size()];
                FORI (iIndex, independentVert2verts.length)
                {
                    optimalVertexHeights[independentVert2verts[iIndex]] = solvedHeights[iIndex];
                }
                FORI (iDependentVert, dependentVertIndices.length)
                    optimalVertexHeights[dependentVertIndices[iDependentVert]] = 0.;


                if (true)
                {
                    // Now we want to adjust the solution
                    // so that the dual verts are shifted in the plane
                    // so that the average of the dual verts
                    // is equal to the average of the original verts.
                    // (This is somewhat arbitrary,
                    // but at least it makes the dual translate with the primal)
                    double[] avgPrimal = new double[2]; // zero initially
                    {
                        FORI (iVert, verts.size())
                        {
                            Vertex vert = (Vertex)verts.get(iVert);
                            avgPrimal[0] += vert.x;
                            avgPrimal[1] += vert.y;
                        }
                        VecMath.vxs(avgPrimal, avgPrimal, 1./verts.size());
                    }
                    double[] avgDual = new double[2]; // zero initially
                    {
                        double scratchDualVert[] = new double[3];
                        FORI (iDualVert, nDualVerts)
                        {
                            int iVert0 = dualVert2verts[iDualVert][0];
                            int iVert1 = dualVert2verts[iDualVert][1];
                            int iVert2 = dualVert2verts[iDualVert][2];
                            Vertex v0 = (Vertex)verts.get(iVert0);
                            Vertex v1 = (Vertex)verts.get(iVert1);
                            Vertex v2 = (Vertex)verts.get(iVert2);
                            double h0 = optimalVertexHeights[iVert0];
                            double h1 = optimalVertexHeights[iVert1];
                            double h2 = optimalVertexHeights[iVert2];
                            SolveForDualPoint(v0.x,v0.y,h0,
                                              v1.x,v1.y,h1,
                                              v2.x,v2.y,h2,
                                              scratchDualVert);
                            VecMath.vpv(2, avgDual, avgDual, scratchDualVert); // only 2 of 3
                        }
                        VecMath.vxs(avgDual, avgDual, 1./nDualVerts);
                    }
                    double[] desiredDelta = VecMath.vmv(avgPrimal, avgDual);
                    //PRINTVEC(avgPrimal);
                    //PRINTVEC(avgDual);
                    //PRINTVEC(desiredDelta);
                    FORI (iVert, optimalVertexHeights.length)
                    {
                        Vertex vert = (Vertex)verts.get(iVert);
                        optimalVertexHeights[iVert] -= vert.x * desiredDelta[0]
                                                     + vert.y * desiredDelta[1];
                    }
                }


                if (nonEventVerbose >= 1)
                    System.out.println("out findOptimalVertexHeights");

                return optimalVertexHeights;
            } // findOptimalVertexHeights

            public void findAndApplyOptimalVertexHeights(int optimizationType)
            {
                double optimalVertexHeights[] = findOptimalVertexHeights(
                                optimizationType);
                FORIDOWN (iVert, verts.size())
                {
                    //PRINTSUB(optimalVertexHeights,iVert);
                    ((Mesh.Vertex)verts.get(iVert)).h = optimalVertexHeights[iVert];
                }
            } // findAndApplyOptimalVertexHeights

            private void flipLeftRight()
            {
                FORIDOWN (iVert, verts.size())
                {
                    Mesh.Vertex vert = (Mesh.Vertex)verts.get(iVert);
                    vert.x *= -1.;
                }
                // XXX rest is dup code
                Mesh.Vertex finalInitials[] = new Mesh.Vertex[edges.size()];
                FORIDOWN(iEdge, edges.size())
                {
                    Mesh.Edge edge = (Mesh.Edge)edges.get(iEdge);
                    finalInitials[iEdge] = edge.finalVertex();
                }
                FORIDOWN(iEdge, edges.size())
                {
                    Mesh.Edge edge = (Mesh.Edge)edges.get(iEdge);
                    edge._initialVertex.arity--;
                    edge._initialVertex = null;
                }
                FORIDOWN(iEdge, edges.size())
                {
                    Mesh.Edge edge = (Mesh.Edge)edges.get(iEdge);
                    Mesh.Edge tempEdge;
                    SWAP(edge._next, edge._prev, tempEdge);
                    assert(edge._initialVertex == null);
                    edge._initialVertex = finalInitials[iEdge];
                    edge._initialVertex.arity++;
                }
                sanityCheck();
            } // flipLeftRight
            private void flipUpDown()
            {
                FORIDOWN (iVert, verts.size())
                {
                    Mesh.Vertex vert = (Mesh.Vertex)verts.get(iVert);
                    vert.y *= -1.;
                }
                // XXX rest is dup code
                Mesh.Vertex finalInitials[] = new Mesh.Vertex[edges.size()];
                FORIDOWN(iEdge, edges.size())
                {
                    Mesh.Edge edge = (Mesh.Edge)edges.get(iEdge);
                    finalInitials[iEdge] = edge.finalVertex();
                }
                FORIDOWN(iEdge, edges.size())
                {
                    Mesh.Edge edge = (Mesh.Edge)edges.get(iEdge);
                    edge._initialVertex.arity--;
                    edge._initialVertex = null;
                }
                FORIDOWN(iEdge, edges.size())
                {
                    Mesh.Edge edge = (Mesh.Edge)edges.get(iEdge);
                    Mesh.Edge tempEdge;
                    SWAP(edge._next, edge._prev, tempEdge);
                    assert(edge._initialVertex == null);
                    edge._initialVertex = finalInitials[iEdge];
                    edge._initialVertex.arity++;
                }
                sanityCheck();
            } // flipUpDown

            private Mesh()
            {
            }

            private Mesh(double vertPositions[][],
                         int faceIndices[][])
            {
                {
                    // Sanity check face indices,
                    // since it's really hard to debug later
                    // if they are insane...
                    java.util.HashSet boundary = new java.util.HashSet();
                    FORI (iFace, faceIndices.length)
                        FORI (iVertThisFace, faceIndices[iFace].length)
                        {
                            int v0 = faceIndices[iFace][iVertThisFace];
                            int v1 = faceIndices[iFace][(iVertThisFace+1)%faceIndices[iFace].length];
                            assert(INRANGE(0 <=, v0, < vertPositions.length));
                            assert(INRANGE(0 <=, v1, < vertPositions.length));
                            String v0_v1 = ""+v0+"_"+v1;
                            String v1_v0 = ""+v1+"_"+v0;
                            if (boundary.contains(v0_v1))
                            {
                                System.out.println("ERROR in Mesh ctor: "+v0_v1+" appears twice");
                                assert(false);
                            }
                            if (!boundary.remove(v1_v0))
                                boundary.add(v0_v1);
                        }
                    if (!boundary.isEmpty())
                    {
                        System.out.println("ERROR in Mesh ctor: unmatched edge(s):");
                        java.util.Iterator iter = boundary.iterator();
                        while (iter.hasNext())
                        {
                            String v0_v1 = (String)iter.next();
                            System.out.println("    "+v0_v1);
                        }
                        assert(false);
                    }
                }

                FORI (i, vertPositions.length)
                {
                    // adds itself to verts...
                    new Vertex(vertPositions[i][0],  // x
                               vertPositions[i][1],  // y
                               vertPositions[i].length == 2 ? 0 : vertPositions[i][2]); // h
                }
                java.util.Hashtable vertIndsToEdge = new java.util.Hashtable();
                FORI (i, faceIndices.length)
                FORI (j, faceIndices[i].length)
                {
                    int v0 = faceIndices[i][j];
                    int v1 = faceIndices[i][(j+1)%faceIndices[i].length];
                    assert(INRANGE(0 <=, v0, < vertPositions.length));
                    assert(INRANGE(0 <=, v1, < vertPositions.length));
                    String v0_v1 = ""+v0+"_"+v1;
                    String v1_v0 = ""+v1+"_"+v0;
                    if (vertIndsToEdge.get(v0_v1) == null)
                    {
                        Edge edge = new Edge(true); // adds itself, and opposite, to verts
                        vertIndsToEdge.put(v0_v1, edge);
                        vertIndsToEdge.put(v1_v0, edge.opposite());
                        edge.setInitialVertex((Vertex)verts.get(v0));
                        edge.opposite().setInitialVertex((Vertex)verts.get(v1));
                    }
                }
                FORI (i, faceIndices.length)
                FORI (j, faceIndices[i].length)
                {
                    int v0 = faceIndices[i][j];
                    int v1 = faceIndices[i][(j+1)%faceIndices[i].length];
                    int v2 = faceIndices[i][(j+2)%faceIndices[i].length];
                    String v0_v1 = ""+v0+"_"+v1;
                    String v1_v2 = ""+v1+"_"+v2;
                    Edge e01 = (Edge)vertIndsToEdge.get(v0_v1);
                    Edge e12 = (Edge)vertIndsToEdge.get(v1_v2);
                    e01.setNext(e12, true);
                }
                sanityCheck();
            } // Mesh from vertex positions and face indices

            private Mesh(Mesh original)
            {
                int nVerts = original.verts.size();
                FORI (iVert, nVerts)
                {
                    Vertex originalVert = (Vertex)original.verts.get(iVert);
                    new Vertex(originalVert.x,
                               originalVert.y,
                               originalVert.h); // adds itself to verts
                }
                int nEdges = original.edges.size();
                FORI (iEdge, nEdges)
                    new Edge(false); // adds itself to edges
                assert(verts.size() == nVerts);
                assert(edges.size() == nEdges);

                FORI (iEdge, nEdges)
                {
                    Edge edge = (Edge)edges.get(iEdge);
                    Edge originalEdge = (Edge)original.edges.get(iEdge);
                    assert(edge._initialVertex == null);
                    edge._initialVertex = (Vertex)verts.get(originalEdge._initialVertex._myIndex);
                    edge._initialVertex.arity++;
                    edge._opposite = (Edge)edges.get(originalEdge._opposite._myIndex);
                    edge._prev = (Edge)edges.get(originalEdge._prev._myIndex);
                    edge._next = (Edge)edges.get(originalEdge._next._myIndex);
                }
            } // Mesh copy constructor

            public ArrayList/*<Vertex>*/ verts = new ArrayList();
            public ArrayList/*<Edge>*/ edges = new ArrayList();


            // Accessors for construction of inner class objects
            // XXX not sure this is the right way to do it
            Edge newEdge(boolean andBack)
            {
                return new Edge(andBack);
            }
            Vertex newVertex(double x, double y, double h)
            {
                return new Vertex(x, y, h);
            }


        } // class Mesh

        //
        // Assumes mesh is topologically a polyhedron,
        // The dual vertex is well defined iff the corresponding primal face
        // is a non-degenerate triangle.
        // Otherwise the primal face will be triangulated arbitrarily
        // and the dual vertex will be set to the weighted average
        // of the vertices computed from each triangle.
        // Indexing of dual edges is same as indexing of original edges.
        // The dual edge points from right to left,
        // with respect to the forward direction of the primal edge.
        //
        public Mesh makeDualMesh(Mesh primal,
                                 boolean includeNonArity3,
                                 boolean includeInsideOut)
        {
            Mesh dual = new Mesh();
            int nEdges = primal.edges.size();
            FORI (iEdge, nEdges)
                dual.newEdge(false); // adds itself to dual.edges
            assert(dual.edges.size() == nEdges);
            FORI (iEdge, nEdges)
            {
                Mesh.Edge dualEdge = (Mesh.Edge)dual.edges.get(iEdge);
                Mesh.Edge primalEdge = (Mesh.Edge)primal.edges.get(iEdge);
                dualEdge._opposite = (Mesh.Edge)dual.edges.get(primalEdge._opposite._myIndex);
                if (false)
                {
                    // regions of CCW faces correspond
                    // to CCW faces in dual.
                    // If we do this, then applying makeDualMesh twice
                    // will reverse all the edges,
                    // I think.
                    dualEdge._next = (Mesh.Edge)dual.edges.get(primalEdge._prev._opposite._myIndex);
                    dualEdge._prev = (Mesh.Edge)dual.edges.get(primalEdge._opposite._next._myIndex);
                }
                else
                {
                    // regions of CCW faces in primal
                    // correspond to CW faces in dual.
                    // If we do this, then makeDualMesh(makeDualMesh(mesh))
                    // should return something identical to the original,
                    // I think.
                    // XXX Odd, this seems to behave better all around (I expected rays to go in wrong direction,
                    // but it works better than the other way... should think about why
                    dualEdge._next = (Mesh.Edge)dual.edges.get(primalEdge._next._opposite._myIndex);
                    dualEdge._prev = (Mesh.Edge)dual.edges.get(primalEdge._opposite._prev._myIndex);
                }
            }

            //
            // Find all the dual vertices.
            // These correspond to primal faces.
            //
            FORI (iEdge, nEdges)
            {
                Mesh.Edge dualEdge0 = (Mesh.Edge)dual.edges.get(iEdge);
                if (dualEdge0._opposite._initialVertex != null)
                    continue; // did this one already

                Mesh.Edge primalEdge0 = (Mesh.Edge)primal.edges.get(iEdge);

                //
                // Triangulate,
                // using primalEdge0's initial vertex as the hub.
                // The final dual vertex will be the triangle-area-weighted average
                // of the circumcenters of the triangles.
                // (the answer is the same regardless of triangulation...
                // at least for the x,y part.  not sure what this does to the h part.)
                //
                double twiceTotalArea = 0.;
                double totalCenter[] = new double[3]; // zero initially   XXX should set it to center of edge?  not sure

                double triCenter[] = new double[3]; // scratch for loop
                Mesh.Vertex v0 = primalEdge0._initialVertex;
                int dualVertArity = 2; // and counting
                for (Mesh.Edge primalEdge = primalEdge0.next();
                     primalEdge.finalVertex() != v0;
                     primalEdge = primalEdge.next())
                {
                    Mesh.Vertex v1 = primalEdge.initialVertex();
                    Mesh.Vertex v2 = primalEdge.finalVertex();
                    SolveForDualPoint(v0.x, v0.y, v0.h,
                                      v1.x, v1.y, v1.h,
                                      v2.x, v2.y, v2.h,
                                      triCenter);

                    double twiceTriArea = twiceTriangleArea(v0.x,v0.y,
                                                            v1.x,v1.y,
                                                            v2.x,v2.y);
                    twiceTotalArea += twiceTriArea;
                    if (twiceTotalArea != 0.)
                        VecMath.lerp(totalCenter,
                                     totalCenter, triCenter, twiceTriArea/twiceTotalArea);
                    else
                        VecMath.zerovec(totalCenter); // arbitrary
                    dualVertArity++;
                }

                if ((includeNonArity3
                  || dualVertArity == 3)
                 && (includeInsideOut
                  || twiceTotalArea >= 0.))
                {
                    if (true)
                    {
                        // See what happens if I solve for dual point with more than 3 verts...
                        // XXX experiment with this more, maybe make user control for includeNonArity3 and non-arity-3 strategy
                        double coords[][] = new double[dualVertArity][3];
                        Mesh.Edge primalEdge = primalEdge0;
                        FORI (i, dualVertArity)
                        {
                            Mesh.Vertex v = primalEdge.initialVertex();
                            coords[i][0] = v.x;
                            coords[i][1] = v.y;
                            coords[i][2] = v.h - .5 * (SQR(v.x)+SQR(v.y));
                            primalEdge = primalEdge.next();
                        }
                        SolveForDualPointActual(coords, totalCenter);
                        totalCenter[2] += .5 * (SQR(totalCenter[0]) + SQR(totalCenter[1]));
                    }

                    Mesh.Vertex dualVert = dual.newVertex(totalCenter[0],
                                                          totalCenter[1],
                                                          totalCenter[2]);
                    dualVert.weight = .5 * twiceTotalArea;

                    // Set dualVert to be the *final* vertex (i.e. initial vertex of opposite)
                    // of each dual edge ending at it.
                    for (Mesh.Edge dualEdge = dualEdge0;
                         dualEdge._opposite._initialVertex == null;
                         dualEdge = dualEdge._next._opposite)
                    {
                        assert(dualEdge._opposite._initialVertex == null);
                        dualEdge._opposite._initialVertex = dualVert;
                        dualEdge._opposite._initialVertex.arity++;
                    }
                }
            }
            
            //
            // Give each dual edge a direction.
            //
            FORI (iEdge, nEdges)
            {
                Mesh.Edge dualEdge = (Mesh.Edge)dual.edges.get(iEdge);
                if (dualEdge.direction != null)
                    continue; // did this one already

                if (dualEdge._initialVertex != null)
                {
                    if (dualEdge.finalVertex() != null)
                    {
                        // it's a usual edge... get the direction by subtracting vertices
                        // XXX but this is not robust? but it may be better in some senses, especially if we're doing non-triangles too
                        dualEdge.direction = VecMath.normalize(VecMath.vmv(
                            new double[]{dualEdge.finalVertex().x,
                                         dualEdge.finalVertex().y},
                            new double[]{dualEdge._initialVertex.x,
                                         dualEdge._initialVertex.y}));
                    }
                    else
                    {
                        // It's a ray.  Compute the direction
                        // as the perpendicular to the corresponding primal edge.
                        Mesh.Edge primalEdge = (Mesh.Edge)primal.edges.get(iEdge);
                        double v0[] = {primalEdge._initialVertex.x,
                                       primalEdge._initialVertex.y};
                        double v1[] = {primalEdge.finalVertex().x,
                                       primalEdge.finalVertex().y};
                        dualEdge.direction = VecMath.normalize(VecMath.xv2(VecMath.vmv(v1, v0)));
                    }

                    assert(dualEdge._opposite.direction == null);
                    dualEdge._opposite.direction = VecMath.sxv(-1., dualEdge.direction);
                }
            }

            if (true)
            {
                // Experiment with predicting dual edge lengths.
                // See if I can reduce it to a simple formula in terms of the original verts.
                FORI (iEdge, nEdges)
                {
                    Mesh.Edge dualEdge = (Mesh.Edge)dual.edges.get(iEdge);
                    Mesh.Vertex v0 = dualEdge.initialVertex();
                    Mesh.Vertex v1 = dualEdge.finalVertex();
                    if (v0 != null
                     && v1 != null)
                    {
                        double actualDualEdgeLength = MyMath.hypot(v1.x-v0.x, v1.y-v0.y);
                        PRINT(iEdge);
                        PRINT(actualDualEdgeLength);

                       /*

                       D* 
                        |\
                        | \
                        |  \
                        |   \
                        |  ^ \
                       A*--|--*C
                         \ |  |
                          \   |
                           \  |
                            \ |
                             \|
                              *B
                        */


                        // primal edge dir is dual edge dir rotated 90 degrees clockwise
                        Mesh.Edge primalEdge = (Mesh.Edge)primal.edges.get(iEdge);
                        if (primalEdge.next().next().next() != primalEdge)
                            continue; // not a triangle
                        if (primalEdge.opposite().next().next().next() != primalEdge.opposite())
                            continue; // neighbor not a triangle
                        Mesh.Vertex Avert = primalEdge.initialVertex();
                        Mesh.Vertex Cvert = primalEdge.finalVertex();
                        Mesh.Vertex Dvert = primalEdge.next().finalVertex();
                        Mesh.Vertex Bvert = primalEdge.opposite().next().finalVertex();



                        double Avirtual[] = {Avert.x, Avert.y, Avert.h};
                        double Bvirtual[] = {Bvert.x, Bvert.y, Bvert.h};
                        double Cvirtual[] = {Cvert.x, Cvert.y, Cvert.h};
                        double Dvirtual[] = {Dvert.x, Dvert.y, Dvert.h};
                        double ABvirtual[] = VecMath.vmv(Bvirtual, Avirtual);
                        double ACvirtual[] = VecMath.vmv(Cvirtual, Avirtual);
                        double ADvirtual[] = VecMath.vmv(Dvirtual, Avirtual);

                        if (true)
                        {
                            // XXX TODO: neither of these ways works yet, don't know why. surely we can translate so A is at the origin somehow?  it's true the error is only in the height, but... ?  hmm, maybe SolveForDualPointActually gets the height wrong? hmm.

                            double ABactual[] = {ABvirtual[0], ABvirtual[1], ABvirtual[2] - .5 * (SQR(ABvirtual[0])+SQR(ABvirtual[1]))};
                            double ACactual[] = {ACvirtual[0], ACvirtual[1], ACvirtual[2] - .5 * (SQR(ACvirtual[0])+SQR(ACvirtual[1]))};
                            double ADactual[] = {ADvirtual[0], ADvirtual[1], ADvirtual[2] - .5 * (SQR(ADvirtual[0])+SQR(ADvirtual[1]))};
                            double Av0[] = new double[3];
                            double Av1[] = new double[3];
                            if (true)
                            {
                                double M0[][] = {
                                    {0,0,1},
                                    {ABactual[0],ABactual[1],1},
                                    {ACactual[0],ACactual[1],1},
                                };
                                double invM0[][] = VecMath.invertmat(M0);
                                // actually only need first two rows...
                                invM0 = new double[][] {invM0[0], invM0[1]};

                                double b0[] = {0, -ABactual[2], -ACactual[2]};
                                Av0 = VecMath.mxv(invM0,b0); // length 2

                                double M1[][] = {
                                    {0,0,1},
                                    {ACactual[0],ACactual[1],1},
                                    {ADactual[0],ADactual[1],1},
                                };
                                double invM1[][] = VecMath.invertmat(M1);
                                // actually only need first two rows...
                                invM1 = new double[][] {invM1[0], invM1[1]};
                                double b1[] = {0, -ACactual[2], -ADactual[2]};
                                Av1 = VecMath.mxv(invM1,b1); // length 2
                            }
                            else if (true)
                            {
                                SolveForDualPointActual(0., 0., 0.,
                                                        ABactual[0], ABactual[1], ABactual[2],
                                                        ACactual[0], ACactual[1], ACactual[2],
                                                        Av0);
                                SolveForDualPointActual(0., 0., 0.,
                                                        ACactual[0], ACactual[1], ACactual[2],
                                                        ADactual[0], ADactual[1], ADactual[2],
                                                        Av1);
                                // convert from actual to virtual...  // XXX don't care, for final result
                                Av0[2] += .5 * (SQR(Av0[0]) + SQR(Av0[1]));
                                Av1[2] += .5 * (SQR(Av1[0]) + SQR(Av1[1]));
                            }
                            else
                            {
                                SolveForDualPoint(0., 0., 0.,
                                                  ABvirtual[0], ABvirtual[1], ABvirtual[2],
                                                  ACvirtual[0], ACvirtual[1], ACvirtual[2],
                                                  Av0);
                                SolveForDualPoint(0., 0., 0.,
                                                  ACvirtual[0], ACvirtual[1], ACvirtual[2],
                                                  ADvirtual[0], ADvirtual[1], ADvirtual[2],
                                                  Av1);

                            }

                            if (true)
                            {
                                // sanity check...
                                double v0coords[] = new double[3];
                                double v1coords[] = new double[3];
                                VecMath.vpv(v0coords, Avirtual, Av0);
                                VecMath.vpv(v1coords, Avirtual, Av1);
                                assert(EQ(v0.x, v0coords[0], 1e-6));
                                assert(EQ(v0.y, v0coords[1], 1e-6));
                                //assert(EQ(v0.h, v0coords[2], 1e-6)); // XXX fails, but we don't need it
                                assert(EQ(v1.x, v1coords[0], 1e-6));
                                assert(EQ(v1.y, v1coords[1], 1e-6));
                                //assert(EQ(v1.h, v1coords[2], 1e-6)); // XXX fails, but we don't need it
                            }

                            double dualEdgeVec[] = VecMath.xv2(ACactual);
                            //double edgeLength = VecMath.norm(2, ACactual); // ARGH!
                            double edgeLength = VecMath.norm(VecMath.copyvec(2,ACactual));
                            double dot0 = VecMath.dot(2, Av0, dualEdgeVec);
                            double dot1 = VecMath.dot(2, Av1, dualEdgeVec);
                            assert(EQ((dot1-dot0) / edgeLength, actualDualEdgeLength, 1e-6));
                            PRINT("yeah!");
                        }
                        else
                        {
                            double Aactual[] = {Avert.x, Avert.y, Avert.h - .5 * (SQR(Avert.x)+SQR(Avert.y))};
                            double Bactual[] = {Bvert.x, Bvert.y, Bvert.h - .5 * (SQR(Bvert.x)+SQR(Bvert.y))};
                            double Cactual[] = {Cvert.x, Cvert.y, Cvert.h - .5 * (SQR(Cvert.x)+SQR(Cvert.y))};
                            double Dactual[] = {Dvert.x, Dvert.y, Dvert.h - .5 * (SQR(Dvert.x)+SQR(Dvert.y))};
                            double v0coords[] = new double[3];
                            double v1coords[] = new double[3];
                            SolveForDualPointActual(Aactual[0], Aactual[1], Aactual[2],
                                                    Bactual[0], Bactual[1], Bactual[2],
                                                    Cactual[0], Cactual[1], Cactual[2],
                                                    v0coords);
                            SolveForDualPointActual(Aactual[0], Aactual[1], Aactual[2],
                                                    Cactual[0], Cactual[1], Cactual[2],
                                                    Dactual[0], Dactual[1], Dactual[2],
                                                    v1coords);
                            // convert from actual to virtual...
                            v0coords[2] += .5 * (SQR(v0coords[0]) + SQR(v0coords[1]));
                            v1coords[2] += .5 * (SQR(v1coords[0]) + SQR(v1coords[1]));

                            PRINT(v0.x);
                            PRINT(v0.y);
                            PRINT(v0.h);
                            PRINTVEC(v0coords);
                            PRINT(v1.x);
                            PRINT(v1.y);
                            PRINT(v1.h);
                            PRINTVEC(v1coords);
                            assert(EQ(v0.x, v0coords[0], 1e-6));
                            assert(EQ(v0.y, v0coords[1], 1e-6));
                            assert(EQ(v0.h, v0coords[2], 1e-6));
                            assert(EQ(v1.x, v1coords[0], 1e-6));
                            assert(EQ(v1.y, v1coords[1], 1e-6));
                            assert(EQ(v1.h, v1coords[2], 1e-6));

                            assert(EQ(VecMath.dist(2, v0coords, v1coords), actualDualEdgeLength, 1e-6));

                            double dualEdgeVec[] = VecMath.xv2(ACvirtual);
                            //double edgeLength = VecMath.norm(2, ACvirtual); // ARGH!
                            double edgeLength = VecMath.norm(VecMath.copyvec(2,ACvirtual));

                            double v0dot = VecMath.dot(2, v0coords, dualEdgeVec);
                            double v1dot = VecMath.dot(2, v1coords, dualEdgeVec);
                            assert(EQ((v1dot-v0dot) / edgeLength, actualDualEdgeLength, 1e-6));
                        }




                        // TODO: simplify simplify simplify
                    }
                }
            } // end of length prediction

            return dual;
        } // makeDualMesh()



        private static double[][] generateBlueNoiseOnUnitSquare(double stubbornness,
                                                                double overlappingDiskRadiusX,
                                                                double overlappingDiskRadiusY) // radius of disks that half-overlap.  this is twice the radius of disks that don't overlap.
        {
            System.out.println("    in generateBlueNoiseOnUnitSquare");
            long t0millis = System.currentTimeMillis();
            // adding margin of 2*overlappingDiskRadius and then throwing it away afterwards
            // should be enough to avoid any boundary artifacts.
            // XXX add another 2 so we don't need to check... ?
            double minX = -2*overlappingDiskRadiusX;
            double maxX = 1+2*overlappingDiskRadiusX;
            double minY = -2*overlappingDiskRadiusY;
            double maxY = 1+2*overlappingDiskRadiusY;

            // we work with cells of size 1, in which overlappingDiskRadius is .5 (nonoverlapping disk radius is 1)
            int nWorkCellsX = (int)Math.ceil((maxX-minX)/overlappingDiskRadiusX);
            int nWorkCellsY = (int)Math.ceil((maxY-minY)/overlappingDiskRadiusY);
            PRINT(nWorkCellsX);
            PRINT(nWorkCellsY);
            double cells[][][][] = new double[nWorkCellsY][nWorkCellsX][6][2];
            int cellSizes[][] = new int[nWorkCellsY][nWorkCellsX]; // zeros initially
            int nSuccesses = 0;
            int nTries;
            for (nTries = 0;
                 nTries==0
              || nTries < nSuccesses * stubbornness;  // first one is guaranteed to be a success
                 ++nTries)
            {
                double x = Math.random() * nWorkCellsX;
                double y = Math.random() * nWorkCellsY;
                int iX1 = (int)(x+.5);
                int iX0 = iX1-1;
                int iY1 = (int)(y+.5);
                int iY0 = iY1-1;
                iX0 = CLAMP(iX0, 0, nWorkCellsX-1);
                iX1 = CLAMP(iX1, 0, nWorkCellsX-1);
                iY0 = CLAMP(iY0, 0, nWorkCellsY-1);
                iY1 = CLAMP(iY1, 0, nWorkCellsY-1);
                boolean bad = false;
                for (int iY = iY0; iY <= iY1 && !bad; ++iY)
                {
                    for (int iX = iX0; iX <= iX1 && !bad; ++iX)
                    {
                        double cell[][] = cells[iY][iX];
                        double cellSize = cellSizes[iY][iX];
                        for (int i = 0; i < cellSize; ++i)
                        {
                            double q[] = cell[i];
                            // if distance from q to new point < .5
                            if (SQR(x-q[0])+SQR(y-q[1]) < .25)
                            {
                                bad = true;
                                break;
                            }
                        }
                    }
                }
                if (!bad)
                {
                    int iX = (int)x;
                    int iY = (int)y;
                    iX = CLAMP(iX, 0, nWorkCellsX-1);
                    iY = CLAMP(iY, 0, nWorkCellsY-1);
                    double entry[] = cells[iY][iX][cellSizes[iY][iX]++];
                    entry[0] = x;
                    entry[1] = y;
                    nSuccesses++;
                }
            }

            PRINT(nTries);
            PRINT(nSuccesses);

            double answer[][] = new double[nSuccesses][];
            int iInCells = 0;
            int iAnswer = 0;
            int margin = 1; // should be 1, can set to 0 to see the margin too
            FORI (iX, nWorkCellsX-2*margin)
            FORI (iY, nWorkCellsY-2*margin)
            {
                double cell[][] = cells[iY+margin][iX+margin];
                double cellSize = cellSizes[iY+margin][iX+margin];
                for (int i = 0; i < cellSize; ++i)
                {
                    double scratch[] = cell[i]; 
                    answer[iAnswer] = scratch;
                    scratch[0] = LERP(minX, maxX, scratch[0]/nWorkCellsX);
                    scratch[1] = LERP(minY, maxY, scratch[1]/nWorkCellsY);
                    if (INRANGE(0 <=, scratch[0], <= 1)
                     && INRANGE(0 <=, scratch[1], <= 1))
                        iAnswer++;
                    iInCells++;
                }
            }
            if (margin == 0)
                assert(iInCells == answer.length);
            answer = (double[][])Arrays.subarray(answer, 0, iAnswer);
            long t1millis = System.currentTimeMillis();
            double seconds = (t1millis-t0millis) * 1e-3;
            System.out.println("    out generateBlueNoiseOnUnitSquare ("+seconds+" seconds)");
            return answer;
        } // generateBlueNoiseOnUnitSquare


        // Holds the information needed to undo and redo a mesh editing operation.
        // This implementation is very simple and inefficient;
        // it just stores a complete copy of the mesh before and after
        // the editing operation.
        private static class UndoItem
        {
            public static class State
            {
                public Mesh mesh;
                public boolean doContinuouslyDelaunayize;
                public boolean doOptimize;
                public int optimizationTypeIndex;
                public int selectedDualVertIndices[];
                public State(Mesh mesh, boolean doContinuouslyDelaunayize, boolean doOptimize, int optimizationTypeIndex, int selectedDualVertIndices[])
                {
                    this.mesh = new Mesh(mesh);
                    this.doContinuouslyDelaunayize = doContinuouslyDelaunayize;
                    this.doOptimize = doOptimize;
                    this.optimizationTypeIndex = optimizationTypeIndex;
                    this.selectedDualVertIndices = VecMath.copyvec(selectedDualVertIndices);
                }
            }
            public State before;
            public State after;
            public UndoItem(State before, State after)
            {
                this.before = before;
                this.after = after;
            }
        } // class UndoItem


        /*
            Note, the h given here are the "actual" positions v.h - .5 * (x^2 + y^2).
            where v.h is the offset stored in the vertex.

            Given:
                x0,y0,h0
                x1,y1,h1
                x2,y2,h2
            representing an infinitesimal triangle
            whose vertices are infinitesimally-squared away from the unit sphere
            at the tangent plane z=1:
                x0 eps, y0 eps, 1 + h0 eps^2
                x1 eps, y1 eps, 1 + h1 eps^2
                x2 eps, y2 eps, 1 + h2 eps^2
            we want to find x,y,h
            representing the point:
                x eps, y eps, 1 + h eps^2
            that is the intersection point of the 3 planes
            whose closest-points-to-origin are the reciprocals of the original 3 points.
            That is,
                [x0 eps, y0 eps, 1 + h0 eps^2] [x eps      ]   [1]
                [x1 eps, y1 eps, 1 + h1 eps^2] [y eps      ] = [1]
                [x2 eps, y2 eps, 1 + h2 eps^2] [1 + h eps^2]   [1]
            i.e.
                [ x x0 eps^2 + y y0 eps^2 + 1 + (h+h0)eps^2 + h h0 eps^4]   [1]
                [ x x1 eps^2 + y y1 eps^2 + 1 + (h+h1)eps^2 + h h1 eps^4] = [1]
                [ x x2 eps^2 + y y2 eps^2 + 1 + (h+h2)eps^2 + h h2 eps^4]   [1]
            the eps^4 terms are insignificant, so drop them:
                [ x x0 eps^2 + y y0 eps^2 + 1 + (h+h0)eps^2]   [1]
                [ x x1 eps^2 + y y1 eps^2 + 1 + (h+h1)eps^2] = [1]
                [ x x2 eps^2 + y y2 eps^2 + 1 + (h+h2)eps^2]   [1]
            i.e.
                [ x x0 eps^2 + y y0 eps^2 + (h+h0)eps^2]   [0]
                [ x x1 eps^2 + y y1 eps^2 + (h+h1)eps^2] = [0]
                [ x x2 eps^2 + y y2 eps^2 + (h+h2)eps^2]   [0]
            Divide both sides by eps^2:
                [ x x0 + y y0 + (h+h0)]   [0]
                [ x x1 + y y1 + (h+h1)] = [0]
                [ x x2 + y y2 + (h+h2)]   [0]
            i.e.
                [ x x0 + y y0 + h]   [-h0]
                [ x x1 + y y1 + h] = [-h1]
                [ x x2 + y y2 + h]   [-h2]
            i.e.
                [ x0 y0 1] [x]   [-h0]
                [ x1 y1 1] [y] = [-h1]
                [ x2 y2 1] [h]   [-h2]
            Easy!
        */
        private static void SolveForDualPointActual(double x0, double y0, double h0,
                                              double x1, double y1, double h1,
                                              double x2, double y2, double h2,
                                              double result[])
        {
            double M[][] = {
                {x0,y0,1},
                {x1,y1,1},
                {x2,y2,1},
            };
            double b[] = {
                -h0,
                -h1,
                -h2,
            };

            if (result.length == 3)
                VecMath.invmxv(result,M,b);
            else // result.length == 2, just copy the first two
                VecMath.copyvec(result, VecMath.invmxv(M,b));
        } // SolveForDualPointActual

        private static void SolveForDualPoint(double x0, double y0, double h0,
                                              double x1, double y1, double h1,
                                              double x2, double y2, double h2,
                                              double result[])
        {
            SolveForDualPointActual(x0, y0, h0 - .5 * (SQR(x0) + SQR(y0)),
                                    x1, y1, h1 - .5 * (SQR(x1) + SQR(y1)),
                                    x2, y2, h2 - .5 * (SQR(x2) + SQR(y2)),
                                    result);
            if (result.length == 3)
                result[2] += .5 * (SQR(result[0]) + SQR(result[1]));
        } // SolveForDualPoint

        // Experimenting with when it's more than a triangle... invmxv will do a least-squares solve,
        // which will be what we want in the case the input is coplanar
        private static void SolveForDualPointActual(double coords[][/*3*/],
                                              double result[])
        {
            double M[][] = new double[coords.length][3];
            double b[] = new double[coords.length];
            FORI (i, coords.length)
            {
                M[i][0] = coords[i][0];
                M[i][1] = coords[i][1];
                M[i][2] = 1.;
                b[i] = -coords[i][2];
            }
            if (result.length == 3)
                VecMath.invmxv(result,M,b);
            else // result.length == 2, just copy the first two
                VecMath.copyvec(result, VecMath.invmxv(M,b));
        } // SolveForDualPointActual, more than 3 inputs

        // Calculate the angle C, opposite side c,
        // given side lengths a, b, c,
        // using c^2 = a^2 + b^2 - 2*a*b*cos(C)
        private static double triangleAngle(double a, double b, double c)
        {
            return Math.acos((a*a + b*b - c*c) / (2*a*b));
        }

        // Find vertex v2 that completes the triangle with given edge lengths,
        // such that v0,v1,v2 are CCW.
        private static double[] completeTriangle(double v0[],
                                                 double v1[],
                                                 double dist12,
                                                 double dist20)
        {
            // Make sure has only 2 entries
            v0 = new double[]{v0[0],v0[1]};
            v1 = new double[]{v1[0],v1[1]};
            double ang0 = triangleAngle(VecMath.dist(v0,v1), dist20, dist12);
            double dir01[] = VecMath.normalize(VecMath.vmv(v1,v0));
            double v2[] = VecMath.sxvpsxvpsxv(
                1.,                    v0,
                dist20*Math.cos(ang0), dir01,
                dist20*Math.sin(ang0), VecMath.xv2(dir01));
            return v2;
        } // completeTriangle

        private static double twiceTriangleArea(double x0, double y0,
                                                double x1, double y1,
                                                double x2, double y2)
        {
            return (x1-x0)*(y2-y0) - (x2-x0)*(y1-y0);
        }
        private static double twiceTriangleArea(double v0[],
                                           double v1[],
                                           double v2[])
        {
            return twiceTriangleArea(v0[0], v0[1],
                                     v1[0], v1[1],
                                     v2[0], v2[1]);
        }

        // eps is in linear units
        private static boolean edgesCrossOrCloseToIt(double a0x, double a0y,
                                                     double a1x, double a1y,
                                                     double b0x, double b0y,
                                                     double b1x, double b1y,
                                                     double eps)
        {
            return twiceTriangleArea(a0x,a0y,
                                     a1x,a1y,
                                     b1x,b1y)
                 * twiceTriangleArea(a1x,a1y,
                                     a0x,a0y,
                                     b0x,b0y) >= -eps*eps*eps*eps
                && twiceTriangleArea(b0x,b0y,
                                     b1x,b1y,
                                     a0x,a0y)
                 * twiceTriangleArea(b1x,b1y,
                                     b0x,b0y,
                                     a1x,a1y) >= -eps*eps*eps*eps;
        } // edgesCrossOrCloseToIt

        private static double distSqrdFromPointToSeg(double x, double y,
                                                     double x0, double y0,
                                                     double x1, double y1)
        {
            double v[] = {x-x0,y-y0};
            double v1[] = {x1-x0,y1-y0};
            if (VecMath.normsqrd(v1) == 0.)
                return VecMath.normsqrd(v);
            double t = VecMath.dot(v,v1)
                     / VecMath.dot(v1,v1);
            t = CLAMP(t, 0., 1.);
            double vprojectedOntoV1[] = VecMath.sxv(t, v1);
            return VecMath.distsqrd(v, vprojectedOntoV1);
        }
        private static double distSqrdFromPointToRay(double x, double y,
                                                     double x0, double y0,
                                                     double xDir, double yDir) // need not be unit length
        {
            double v[] = {x-x0,y-y0};
            double v1[] = {xDir, yDir};
            if (VecMath.normsqrd(v1) == 0.)
                return VecMath.normsqrd(v);
            double t = VecMath.dot(v,v1)
                     / VecMath.dot(v1,v1);
            t = MAX(t, 0.);
            double vprojectedOntoV1[] = VecMath.sxv(t, v1);
            return VecMath.distsqrd(v, vprojectedOntoV1);
        }


        public void drawBitmapCentered(java.awt.Graphics g,
                                       java.awt.Dimension size,
                                       String[] rows)
        {
            int x0 = (size.width - rows[0].length())/2;
            int y0 = (size.height - rows.length)/2;
            FORI (iRow, rows.length)
            {
                String row = rows[iRow];
                int nCols = row.length();
                FORI (iCol, nCols)
                {
                    char c = row.charAt(iCol);
                    if (c != ' ')
                        g.fillRect(x0+iCol, y0+iRow, 1, 1);
                }
            }
        } // drawBitmapCentered


    //
    // App-specific variables...
    //
        private UndoTreeSquirrel undoTreeSquirrel = new UndoTreeSquirrel();
        private Mesh mesh = new Mesh();
        private int beingDraggedVertIndex = -1;
        private boolean rubberBandingNewEdge = false;
        private int[] selectedDualVertIndices = {};
        private boolean selectAllDualVertsAtNextOpportunity = false;

        // XXX is there an easier way to associate that stuff with a certain object? maybe be able to just pass this object to addListener, and make it automatically remove the listener when I go away?
        private Listenable.Listener doContinuouslyDelaunayizeListener = null;
        private Listenable.Listener doOptimizeListener = null;
        private Listenable.Listener optimizationTypeIndexListener = null;

        private Listenable.Boolean doContinuouslyDelaunayize = new Listenable.Boolean(false);
        private Listenable.Boolean doOptimize = new Listenable.Boolean(false);
            private static final int OPTIMIZE_BARYCENTRICS_LEAST_SQUARES = 0;
            private static final int OPTIMIZE_BARYCENTRICS_INFINITY_NORM = 1;
            private static final int OPTIMIZE_BARYCENTRICS_MAX_MIN = 2;
            private static final int OPTIMIZE_LENGTHS_LEAST_SQUARES = 3;
            private static final int OPTIMIZE_LENGTHS_INFINITY_NORM = 4;
            private static final int OPTIMIZE_LENGTHS_MAX_MIN = 5;
            private static final int OPTIMIZE_LENGTHS_SUM = 6;
            private static final String optimizationTypeNames[] = {
                "OPTIMIZE_BARYCENTRICS_LEAST_SQUARES from all 1/3's",
                "OPTIMIZE_BARYCENTRICS_INFINITY_NORM from all 1/3's",
                "OPTIMIZE_BARYCENTRICS_MAX_MIN",
                "OPTIMIZE_LENGTHS_LEAST_SQUARES from all .25's",
                "OPTIMIZE_LENGTHS_INFINITY_NORM from all .25's",
                "OPTIMIZE_LENGTHS_MAX_MIN with fixed sum",
                //"OPTIMIZE_LENGTHS_SUM with every edge length >= .25",
            };
            private static final int availableOptimizationTypes[] = {
                OPTIMIZE_BARYCENTRICS_LEAST_SQUARES,
                OPTIMIZE_BARYCENTRICS_INFINITY_NORM,
                OPTIMIZE_BARYCENTRICS_MAX_MIN,
                OPTIMIZE_LENGTHS_LEAST_SQUARES,
                OPTIMIZE_LENGTHS_INFINITY_NORM,
                OPTIMIZE_LENGTHS_MAX_MIN,
                //OPTIMIZE_LENGTHS_SUM,
            };
        private Listenable.Int optimizationTypeIndex = new Listenable.Int(0, availableOptimizationTypes.length-1, OPTIMIZE_LENGTHS_MAX_MIN); // min, max, default
        int optimizationType = availableOptimizationTypes[optimizationTypeIndex.get()];
        private java.awt.Canvas theCanvas = null;

        // hack
        private int netless8OptimizationIndex = -1;
        private double netless8OptimizationPath[][][] = null;

        private boolean doLabels = false;
        private boolean doArrowsTowardsSharpestDihedrals = false;
        private boolean doArrowsTowardsShortestEdges = false;
        private boolean doShowInsideOutDualVerts = false; // might also be nice to have option for implicit primal vertex in middle of outer face, so that dual will be single-face-bounded... and maybe ctrl-up,ctrl-down will adjust the height of that face

        private boolean doShowPositiveOrthantnessVisualization = false; // XXX total hack-- it's cool but put it somewhere else!!
        private int showTriangles = 2; // 0: nothing, 1: verts, 2: and tris
        private boolean showNet = false;
        private Mesh mostRecentDualMesh = null;
        private int highlightedDualEdgeIndex = -1;

    //
    // Applet-generic member variables...
    //
        private GraphicsAntiAliasingSetter graphicsAntiAliasingSetter;
        private int eventVerbose = 0; // can set with eventVerbose=1 on command line
        private static int nonEventVerbose = 0; // so static classes can refer to it
        private boolean doAntiAliasing = false;
        private boolean implementAntiAliasingInHardware = true; // XXX should have a better name for this-- really mean let java runtime do it
        private boolean doDoubleBuffer = true;
        private java.awt.Image backBufferImage = null;
        private MyGraphics mostRecentGraphics = null;
        private int nDrawnDualVerts = 0;

        private double prevP[] = null;

    //
    // Track mouse state...
    // (I think java newer versions of java (XXX starting when?)
    // let you query from the events themselves,
    // but e.g. in 1.1 there is no way to tell whether button1
    // is down during a drag without keeping state
    //
        private boolean button1IsDown = false;
        private boolean button2IsDown = false;
        private boolean button3IsDown = false;
        private UndoItem.State stateWhenPressed = null;


    //
    // Main...
    //
    public static void main(final String args[])
    {
        System.out.println("in main");

        final java.awt.Frame frame = new java.awt.Frame("Shephards Play Applet") {
            public boolean handleEvent(java.awt.Event event)
            {
                switch(event.id)
                {
                    case java.awt.Event.WINDOW_DESTROY:
                        System.out.println("bye!");
                        // Empirically, either of the following
                        // cause the app to exit-- do both to be safe!
                        // (XXX I've heard rumors that just doing dispose()
                        //  messes up the debugger)
                        // (XXX but doing exit is evil)
                        dispose(); // hide() doesn't delete the windows
                        System.exit(0);
                        return true;
                }
                return super.handleEvent(event);
            }
        };

        // ARGH! The above no longer works in java 1.5!
        // have to use a listener I guess...
        frame.addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent we) {
                System.out.println("ciao!");
                frame.dispose(); // hide() doesn't delete the windows
                System.exit(0);
            }
        });

        final ShephardsPlayApplet applet = new ShephardsPlayApplet();

        // XXX the following seems to be necessary, or getParameter() will crash, at least in 1.4.  Want to send params from command line anyway.
        applet.setStub(new java.applet.AppletStub() {
             public void appletResize(int width, int height)
                 { /* should resize frame, but a ShephardsPlayApplet never asks to be resized */ }
             public java.applet.AppletContext getAppletContext() { return null;}             public java.net.URL getCodeBase() { return null; }
             public java.net.URL getDocumentBase() { return null; }
             public String getParameter(String name)
             {
                 // case insensitive... and unfortunately there's no
                 // startsWithIgnoreCase
                 String prefix = name.toLowerCase() + "=";
                 int i;
                 FOR (i, args.length)
                     if (args[i].toLowerCase().startsWith(prefix))
                         return args[i].substring(prefix.length());
                 return null;
             }
             public boolean isActive() { return true; }
        });

        frame.add(applet);

        applet.init();
        applet.start();

        frame.move(200, 20);
        frame.resize(1250, 500);
        frame.show();

        //Misc.printPlatonicSolidVertexCurvatures();

        System.out.println("out main");
    } // main
} // class ShephardsPlayApplet
