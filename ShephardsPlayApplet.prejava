/*
Trying to make a little applet
that will let me play with triangulations with heights,
and produce the dual diagrams with heights.

BUGS:
  Minkowski related:
    - in order to get nice picture, need to:
        - turn on "Calc underside when delaunayizing"
        - turn on and off "Keep delaunayized"
        - hit the "Set mesh to primal/dual Minkowski average
      that's pretty obscure.
    - do the above, then either:
        - undo and redo, or
        - scale using + or -, and undo
      it gives a CHECK failure here:
        Exception in thread "AWT-EventQueue-0" java.lang.Error: Assertion failed at MeshUtils.prejava(2458): (edgeJ.direction)!=(null) (null vs. null)
            at MeshUtils.getFacings(MeshUtils.prejava:2458)
  Dual related:
    - dual vert numbering isn't sane (maybe nothing can be done about that...
      I think they come out in order based on tri order,
      which is based on edge order (rather than original tri order; that gets lost)
      (can we fix that though?? seems like we should be able to)
    - "swap primal with dual" sane only when it's a tetrahedron

  Gui-related:
    - gui button to do equiv of 'S' key (i.e. set vertex heights above surface to 0)
    - scale/pan with ctrl down should do less, with shift down should do more. (doesn't conflict with different meaning of ctrl for 'frame')
    - rearrange gui to make room for single-exit lagoon controls, somehow
    - Show Dual verts/edges not right
    - maybe checkboxes next to the sliders for:
        showGridFlag
        showBackFaces
        wrapAroundSphere
    - I hear Swing double-buffers by default so I don't need to
       - ARGH! can't just rip it out, the magnifying glass depends on it!
       - also I think antialiasing is massively cheaper when we render to a back buffer
    - need to put stuff in event thread? not sure
    - arrow keys don't scroll help window

  Wrap-sphere related:
    - I'm just frickin confused. Need to write up a clear design plan.
      I have a vague idea that:
          - there's a surface:
            - by default it's the xy plane, i.e. a sphere or paraboloid with infinitesimal curvature
            - when rotated out of initial orientation, it becomes a paraboloid (but I think that's just a viewing xform)
            - when in "wrap around sphere" mode, it's a sphere of some curvature
              - if "center sphere" is off, it's tangent to the xy plane at the origin
              - if "center sphere" is on, it's centered at the origin
              - switching from "center sphere" to not makes verts that were on the surface
                stay on the surface-- that is, their h coord stays 0 if it was 0 (and maybe even stays completely the same)
                whereas their z coord changes since x/w,y/w,z/w is position in space which is changing.
          - there's a primal polyhedron (the tris)
              - verts that are on the surface stay on the surface even through global xforms
          - there's a viewing xform... maybe?
          - maybe can manipulate the three parts independently and/or together?
              - what kinds of manipulations are there?
                - well, definitely toggling "center sphere" moves the verts... and see below "manipulation is all confusing".
              - what kinds *could* there be?
                - change only the surface
                   - e.g. between plane, paraboloid, different curvatures, different centers or tangents
                - change only the verts
                   - freely move them in space
                   - constrain them to be in "surface" space, i.e. they naturally stay at same height above surface (or whatever)
                - change only the viewing xform
                   - just look at the whole thing from a different view
                   - especially, shrink or expand or pan the whole picture in 2d without actually changing anything--
                     it's really clunky without that!
                - change surface and verts together while leaving view fixed
                   - including homo xforms that xform between plane,paraboloid,ellipsoid,sphere,hyperboloid
                - mobius-ish xforms: e.g. clustering verts more towards one side of the sphere
    - manipulation is all confusing.
      - non-sphere mode:
        - middle rotates about origin in tilt/twirl mode, changing surface from plane to paraboloid when not top down
          (idea: would it make sense not to rotate around the surface point, but around a point 1 unit below it, instead?
           that might give a better transition to/from sphere mode, where it's naturally centered. maybe.)
        - shift-middle pans the primal around in the plane
      - sphere mode, not centered:
        - middle still rotates about origin in tilt/twirl mode, but doesn't do any of that curvature changing when not top down
        - shift-middle does something bizarro, wtf
            (*should* slide the figure around on the surface, I think?)
      - sphere mode, centered
        - middle rotates around origin in tilt/twirl mode still, but since sphere is centered at origin
          this has the effect of sliding the verts around on the sphere.
        - shift-middle still does something bizarro, wtf
          (not sure what it should do-- same as without shift in this case, probably)
    - it's crazy to be adjusting every vertex on every manipulation-- roundoff error will accumulate.
      maybe should accumulate a global xform, then either:
        - never change initial verts, but always introduce and move verts through the global xform,
          i.e. always change the verts in model space
          - pro: existing verts always stay the same
          - con: new verts will not have consistent kinds of roundoff errors
                 since introduced through different global xform
        - whenever about to move a vert or introduce a new one, that's the time to bake the accumulated
          viewing xform into the model.
    - tilt/twirl is actually confusing me for sphere-- maybe trackball mode instead, or option
    - for Surface, most important thing is that offset is right-- should adjust final result to make it right
    - doesn't interact correctly with undo/redo or save/restore
    - should compute ray lengths in flat space or something so they don't overshoot
      the point that goes to infinity.  or, just recognize the point
      at infinity and go only halfway there, or something. I don't completely understand yet.
    - use homogeneous coords of some sort, so it doesn't blow up due to singularities
      when converting in either direction?
      Could just always store sphere coords, but the problem is
      we'd lose precise info about the heights, especially when heights are zero
      or exactly equal
    - draw horizon of surface (done) and of ground plane?

  Homogeneous related:
    - DUMP.infinitePrimalVerts.off, the infinite verts are rendered badly
      when flat paraboloid

  Symmetry-related:
    - on command line: continuouslyDelaunayizeFlag=true pRotationalSymmetryIntent=9 qRotationalSymmetryIntent=3 -> it brings up the q textfield in red
    - make a 3-symmetry grid, change symmetry to 3,3, turn on remap-when-change-sym, change symmetry to 3,4, then 3,5 ... there's a glitch in the symmetry.  more subtle glitches when going straight from 3,3 to 3,5
    - (somewhat done) wouldn't hurt to allow {4,4}, {6,3}, {3,6}, to make quilts... just show a few layers, or actually support the toroidal space?
        actually hmm, is there a projection from 4d torus that makes
        this actually work?  hmm I'm thinking no.
    - "force symmetry" on "crack goes in spiral" gives fuzzy exception.  I think I need to use max-mag-normalized w coords? no... maybe new kind of fuzzy hash table that uses relative sizes?  but then this might conflict with normal usage for which we'd want to merge verts near origin. need to think about this.
    - enable only flips that don't mess up current symmetry
    - symmetry averaging is wrong on sphere--- it shrinks towards sphere center (and even worse now that I'm doing it in homo space, I think).  need a height-above-sphere-preserving average. (then again, is that even possible? I never was able to find a reasonable notion of average in 3d)
    - respect symmetry:
        - rubberbanding
    - collapse to-add verts via symmetries (e.g. so we don't add multiple verts at origin)
          (I think this works correctly on mouse down, but not when dragging new vert from non-origin to origin)
    - improve kaleidescope:
        - detect and use center
        - detect and use complete symmetry group
        - key to increase or decrease period (requires vertex in center?)
        - snap closest image to exact image? hmm, not sure
        - mode to place new verts in kaleidescope? (draw dots at images of cursor? might be subtle)
    - when increasing or decreasing rotational symmetry, show animation?
        (hmm, can this be done in changing between cube and dodecahedron? would be wacky)

  Net-related:
    - BUG (I think): out stressor spiral: why does number of cuts change when I zoom in and out!?
    - organize methods better!
      maybe make a uniform interface with consistent methods.
        - params (names, types, defaults)
        - doit
           - inputs:
             - maxIters and subiters... something like that?
                 subIters would be (maybe) index among:
                   - PRE_ITER
                   - ... ?
                   - POST_ITER
           - outputs:
             - visualizations (list of colored&thicknessed points, segments, circles)
               - current focus in algorithm
               - problem spots
               - other?

      - it's sort of a matrix:
          [cut, fold] x [sharpest, dullest, shortest, longest, sweepmost, antisweepmost, adhoc]
        (per v) (per f)
        where "sweepmost" is relative to sweep direction, one of:
            [0,0,1] = outward
            [0,-1,0] = upward
            ... or arbitrary center or direction

      - algorithm selection ui looks like:
            manual
            random
            generic (using params below)

            generic params:
              cut (at vertex)     sharpest         sweep origin: [    ] [x] outward    max full iters:[  ]
              fold (at face)      dullest                               [x] upward     and subiters:[  ]
                                  shortest
                                  longest
                                  sweepmost
                                  antisweepmost
                                  best>=0?1:0
                                  best
                                  random
                                  (and should be primary&secondary... does tertiary make sense?)

      interface NetAlgorithmInterface
      {
          ParamSpec paramSpec()
          NetAndVisualizations doIt(params, mesh, dualMesh, sweepOriginHomo, maxIters, maxSubIters, putVisualizationsHere);
      }

      - ability to "refine"/"polish"/"makeGood" afterwards... maybe separate section? think about how to coordinate

    - polish should show graphical progress!
    - take net of triangle, turn on "Show primal underside and second dual sheet (if any)"; it draws a strange extra cut that looks wrong
    - can we color some edges red even when net is not complete?  I think the parts that are connected to the infinite can be colored.
      (extra credit: when *not* connected to infinite yet, can still color but in general need two different colors
      depending on which direction the edge will eventualy go.  can that be conveyed?)
      (also e.g. for facesweep, in many cases enough has been decided that we can color edges)
    - net flow doesn't work (since doesn't think net is complete) when delaunayized with "calc underside when delaunayizing"
    - netless8 / sharpest at every vertex / net -> assertion failed: _W == 1
    - netless9 / outward / net -> assertion failed: _W == 1

  Inside-outedness-related:
    - I think I do need an option to exclude backfaces, or combine them, when delaunayizing--
      the backfacing edges are a nuisance.
      (XXX what was I saying here?  is this done now?)

  Blue noise related:
    - Re-implement blue noise using 2012 paper "A Simple Algorithm for Maximal Poisson-Disk Sampling in High Dimensions"; it's bias-free and maximal (no "stubbornness" parameter needed) and fast, I think.
      - make it respect symmetry
      - can it be done on sphere? if so, do it and make that respect symmetry too

  Misc:
    - blue10000 prewarp, radial match, UPWARD, polish, save/load: it changes! wtf? I think it un-polishes!?
       simpler: FaceSweepKiller, polish, save/load: it changes!
       oh hmm, it happens only when delaunayize is on.  I guess that makes sense...
       after load, it delaunayizes, and doesn't realize nothing changed, so assumes net got trashed
       and recomputes it. so, maybe should recognize when already delaunay and not trash things
       in that case?
    - blue100,000 , prewarp, radial match: I saw a diagonal pattern in center! can't reproduce though
    - DUMP.off.ConvexNoise1_1000_makes_my_algorithm_infinite_loop : bogus lines with one endpoint at origin!? wtf?
    - SweepKiller1epsMultiplePolar: works only for n>=19 or so, not sure why.
      (n=15: just barely, the alternate way; n=16: just barely, the intended way)

    - DUMP.delaunayfailed.off gives assert fail (made it using 3-fold and left-right symmetry, maybe not a good thing to do)
    - the final un-fudge in SweepKiller0 makes the 3 top horiz edges disappear. why? commented it out for now.
    - on cygwin, can I make it listen for ctrl-z on console, and suspend, just like vim does?
    - don't swap diagonals I can't see (backfacing)
    - think about whether current non-uniform scaling is more useful than keeping primal on sphere and re-computing dual, and/or whether both are useful
      and the horizon in between.  or else use zbuffer?
    - should ConvexHull use fuzzy equality testing in more places, to avoid twinkling on grid? (hmm, maybe twinkling on grid is actually useful in a way?)
    - picking net edges is wrong, need to do it in screen space
    - dragging edges doesn't work yet when not ortho
    - 'd' to delete edge not working in non-ortho
    - clear and click with shift down-- creates a zero-length edge, I think it shouldn't.
      just make it so the rubberbanding won't create a new vert to exact same place.
    - tri grid, '+' 3 times, tilt 180 degrees -> assert fail in IsMiniBall
        (very big radius?)
    - Hexes Spiral Alt -> assert fail in IsMiniBall
    - miniball still not handling dup vertices well
    - circle drawing is off by a pixel sometimes, e.g. miniball with:
        radius 3/8:
            top is too low by 1 pixel
            bottom can be too low by 1 pixel (if translated)
            left is too right by 1 pixel
        radius 1/2:
            left is too right by 1 pixel
    - why do I need that extendAndOrthogonalize?  it shouldn't be getting non-orthogonal so quickly! (that was when using trackball... maybe a moot issue now)

TO DO:
  MyAlgorithmMaybe:
    - BUG: fails on sweepkiller1epsmultpolar 3 (because almost-coincident vertex, I think... that's pretty lame anyway)
    - Visualization:
      - circle/line should weave in and out of verts done, in case multiple appear to be on sweep circle/line
      - really need to know good/bad on partial net!  argh.
        also need to visualize the edges being considered at each step, and their statuses.
        really need more extensive annotations, I think. hmm.
    - I think when curving downward, we can always keep it from curving ridiculously far,
      by something similar to the priscilla&dudley lemma.
      That is, if we're being forced to curve, then weight is increasing, which means at some point we can reverse and veer towards upwards/outwards again.
    - Can we prove that, if we veer and bite own tail one way, then we can instead go the other way and won't bite own tail?
      Hmm.
      Seems to be all about tail biting.
      Can we make a hierarchy of cracks, all of which are guaranteed to be heavy enough to not bite own tail?
      1. prove that it can't be that *every* crack is forced to bite own tail, so must be one path from center to infinity.
      2. add to it, preserving that property, going with both grain and sweep dir, allowing going with grain even if it veers (but not too much)
         from sweep dir
      Observe that in random upward net on "Just Noise", reds are all close to leaves.  This is because if there's a very long vertical crack,
      the top edges will almost surely be good cuts.  Therefore, at least in this example, the bad cuts are almost always easily fixable.

      Is there or is there not an example where a crack is *forced* to cut own tail?

  Misc:
    - Maybe mega-undo and mega-redo, that skip any xforms?  Hmm.  Probably not ready for that, until xforms are separable.

    - Hey!  Is there more than one way to uniformly scale the dual? Or, to put it another way, we can apply some height fudge and keep the dual in place, which is weird.  E.g. do a Grid with 3 layers
      Partial answer: I guess if *all* verts get their heights altered by the same amount?  Ok maybe that's expected.

    - make some usable way to make an infinitesimal-ish curvature mesh on the face of another mesh; ctrl-Grid is a start, with degrees.
      - Needs a way to "scale dual" of just the verts we're adding.  Hmm.  How?  Provide a way to select a subset of primal verts and apply xforms to them only?  (that might be useful in general, actually)
      - very ad-hoc way:
                 - symmetry 6 (so hex grid)
                 - keep delaunayized
                 - Grid 3
                 - hit "scale dual only" shrink 6 times
                 - + (zoom in) 9 or 10 times
                 - delete middle vertex
                 - ctrl-Grid 3, rotated 30
              that's excessive, though.  can just do:
                 - or, shrink dual only 3 times, zoom in 6 times
                 - or, shrink dual only 2 times, zoom in 5 times
                 - or, shrink dual only 1 time, zoom in 4 times

    - get VERY clear on what negative weights/W's mean through the pipeline
    - maybe use quadratic surds to avoid losing precision, e.g. for sqrt(2) scales?
    - need a way to ask where remaining bad lagoon exits are (finding them visually is a needle in a haystack sometimes)
    - idea: save should operate in xyh when not wrapped around sphere, xyzw when wrapped around sphere? and load should set wrap based on it(but what about center? hmm, maybe should automatically uncenter for purpose of saving/loading? not sure. and the buttons can change

    - idea: actually infinite figures?  E.g. CrackGoesInSpiral could be recursive, it could go outward to infinity and/or inward to infinity
        - special-case less ambitious sub-idea:
          certain figures such as CrackGoesInSpiral could be annotated with such knowledge,
          that it's self-similar on a certain number of magnifications.
          Hmm, would magPerCircle have to be a power of 2, or commensurate with a power of 2? Maybe not,
          just store the relative scale.
    - use vert.arity to determine arity, silly
    - highlight vert when close enough to pick it?
    - get rid of all calcInsideOutDualVertsFlag=false code, just always calculate them (I think)
    - really need a concept of separate viewing matrix,
      that can be changed without accumulating rounding error in the verts
    - thank about attaching a listener to a tuple of values, so they just get one callback when multiple values changed?
    - also get-on-demand (so can make a push-dirty pull-clean dag)
    - don't draw edges if dihedral angle is flat?  would prevent flicker
    - make verts smaller when not part of convex hull?
    - can we make ConvexHull incremental? might be useful when just dragging a single point.
      hmm, tricky, since interior points can become non-interior.  is there a nice data structure
      that includes them? or, maybe there are not too many, so just add them all explicitly and it might still be a win
    - need different way of expressing drag-all-verts than shift-middle; middle should be for view manip I think
    - get rid of "in/out makeDualMesh" message, maybe replace with in-image counter (for convexHull / makeDualMesh, redraws)
    - actually merge vertices when edge super small? (or guarantee cut?)
    - think about how user can express grid params
    - uniform hyperbolic grid? hmm
    - I think I can get rid of the mesh x,y,h
      and have just have the momentAndArea
      (call it coords? not sure)
      it's okay to edit the x,y,h coords directly
      on the primal, since weights are all 1...
      and on the dual, no one ever just tweaks one in isolation.
      (however, note that things like rescale get incredibly painful)
      (I think I'm going to scratch this, it would make everything
      more opaque)
      (then again it would allow higher dimensions
      or alternate interpretations)

    - when dragging a point with continuouslyDelaunayizeFlag true,
      show the nearest-neighbor-interpolation thing
      (i.e. use the DT of all but the dragged point,
      and show the new cell stealing area from others, in a diff color)
    - make IsMiniBall robust to degeneracies
    - color lagoon edges yellow when dragging cut?
    - showNetFlag should go in the undo item, otherwise it's weird when you do something
      that changes it but undo doesn't change it back

    - put in dump files:
        - selected verts
        - net
        - wrapAroundSphereFlag?  (using heuristic for save/load, works pretty much, except for center flag)

    - try to maintain selection when swapping diagonals and stuff

    - think about which optimization types to retain if any. "LENGTHS_MAX_MIN with fixed sum" has definitely been helpful.
        - maybe optimization should always be max min length, but choice should be how to match scale and translate afterwards.
          Translate:
              - match overall cg of verts to cg of tris
              - match overall cg of verts to circumcenter of tris (can be tricky if degenerate)
          Scale:
              - match variance in some sense?
              - match total length?
              - match bbox?
        - however, max min length leaves ambiguity in large parts, if there's wide dynamic range
          (e.g. "Crack Goes In Spiral Big" or "Sweep Killer 1eps mult polar" or "Out Stressor").
          need some kind of hierarchical scheme, or something that takes that into account?  hmm.


    - +/- should maybe look at undo and redo stack, and use it if possible, to save memory?

    - animation of optimization
    - animation of swap (what was I talking about here?)
    - animation of delete vertex (maybe-- might have to triangulate the face to get this to work, which wouldn't be a bad thing)
    - key to delaunayize?
    - don't draw crap when resizing (and fix whatever other applet I got this from too)
    - figure out why stack traces show .java on top even after renumbering
    - write a generic applet to reduce pain each time
    - other mesh editing operations (split face by edge, split edge by vertex, join adjacent vertices, separate a vertex into two (but how to assign the neighbors?))  (idea: same interface as split face by edge... but works only if on two different faces... maybe connec dual verts?)
    - BUG: figure out how to make it not repaint continuously when resizing (my other appets too) (is this just a canvas problem?)
    - BUG: when only part of window gets exposed, only the exposed part gets painted?  hmm, not sure I have control over this
    - look at this, maybe clues about positive octant penalty functions...
        http://www.cs.indiana.edu/~yingfeng/ABSURDIST/javadoc/penalty/PenaltyMinimizer.html
      something about "translating into a positive orthant problem" and "optimizing over the positive orthant"
      intersection of a linear subspace with the positive orthant
      http://projecteuclid.org/Dienst/UI/1.0/Summarize/euclid.mmj/1028988894
      The knee-jerk mapping:
      http://www.math.dartmouth.edu/~doyle/docs/jerk/jerk.pdf
*/

#include "macros.h"

import com.donhatchsw.util.Arrays;
import com.donhatchsw.util.BlueNoise;
import com.donhatchsw.util.Complex;
import com.donhatchsw.util.MyMath;
import com.donhatchsw.util.VecMath;
import com.donhatchsw.util.SortStuff;
import com.donhatchsw.util.LinearProgramming;
import com.donhatchsw.util.MergeFind;
import com.donhatchsw.util.UndoTreeSquirrel;
import com.donhatchsw.util.TriangulationOptimizer;
import com.donhatchsw.util.MiniBall;
import com.donhatchsw.util.Minimizer;
import com.donhatchsw.util.NewtonSolver;
import com.donhatchsw.util.Listenable;
import com.donhatchsw.util.FuzzyPointHashTable;
import com.donhatchsw.compat.Format;
import com.donhatchsw.compat.IntArrayList;
import com.donhatchsw.compat.DoubleArrayList;

import com.donhatchsw.awt.ColLayout;
import com.donhatchsw.awt.JRow;
import com.donhatchsw.awt.JCol;
import com.donhatchsw.awt.JTablePanel;

import javax.swing.ButtonGroup;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JLabel;
import javax.swing.JButton;
import javax.swing.JRadioButton;
import javax.swing.JTextField;
import javax.swing.JTextArea;
import javax.swing.JToggleButton;
import javax.swing.JScrollPane;
import javax.swing.JSeparator;
import javax.swing.JSlider;
import javax.swing.JMenuBar;
import javax.swing.JMenu;
import javax.swing.JMenuItem;
import javax.swing.JComboBox;
import javax.swing.JCheckBox;


// TODO: rename ShephardsPlayApp, it's not an applet any more
@SuppressWarnings("serial")
public class ShephardsPlayApplet
    extends JFrame
{
    private static String repeat(String s, int n) { return new String(new char[n]).replace("\0", s); }

        // ButtonGroup doesn't support *at most* one checked.
        // Implement one that does.
        private static class ButtonGroupThatAllowsNone
        {
            private java.util.ArrayList<JToggleButton> buttons = new java.util.ArrayList<JToggleButton>();
            private java.util.ArrayList<java.awt.event.ActionListener> actionListeners = new java.util.ArrayList<java.awt.event.ActionListener>();  // TODO: not needed?
            public void add(final JToggleButton button) // checkbox or radio button
            {
                java.awt.event.ActionListener actionListener = new java.awt.event.ActionListener() {
                    @Override public void actionPerformed(java.awt.event.ActionEvent e)
                    {
                        if (button.isSelected())
                        {
                            // then deselect everyone else
                            int nButtons = buttons.size();
                            for (int i = 0; i < nButtons; ++i)
                            {
                                JToggleButton otherButton = buttons.get(i);
                                if (otherButton != button)
                                    if (otherButton.isSelected())
                                        otherButton.setSelected(false);
                            }
                        }
                    }
                };
                button.addActionListener(actionListener);
                buttons.add(button);
                actionListeners.add(actionListener);
            }
        }; // class ButtonGroupThatAllowsNone
        // That was fun, let's make another that enforces
        // that the selection is a prefix of the set of buttons.
        private static class PrefixButtonGroup
        {
            private java.util.ArrayList<JToggleButton> buttons = new java.util.ArrayList<JToggleButton>();
            private java.util.ArrayList<java.awt.event.ActionListener> actionListeners = new java.util.ArrayList<java.awt.event.ActionListener>();  // TODO: not needed?
            public void add(final JToggleButton button) // checkbox or radio button
            {
                java.awt.event.ActionListener actionListener = new java.awt.event.ActionListener() {
                    @Override public void actionPerformed(java.awt.event.ActionEvent e)
                    {
                        int nButtons = buttons.size();
                        if (button.isSelected())
                        {
                            // then select everyone before me
                            FORI (i, nButtons)
                            {
                                JToggleButton otherButton = buttons.get(i);
                                if (otherButton == button)
                                    break;
                                if (!otherButton.isSelected())
                                    otherButton.setSelected(true);
                            }
                        }
                        else
                        {
                            // deselect everyone after me
                            FORIDOWN(i, nButtons)
                            {
                                JToggleButton otherButton = buttons.get(i);
                                if (otherButton == button)
                                    break;
                                if (otherButton.isSelected())
                                    otherButton.setSelected(false);
                            }
                        }
                    }
                };
                button.addActionListener(actionListener);
                buttons.add(button);
                actionListeners.add(actionListener);
            }
        } // PrefixButtonGroup

        private static class PlusMinusButton extends JButton {
            public PlusMinusButton(String myText, final java.awt.Component collapsibleThing, final JFrame window)
            {
                super("");  // must be "" since we call super.paint()
                this.myText = myText;

                this.asciiToColor = new java.awt.Color[128];
                this.asciiToColor[' '] = null;
                this.asciiToColor['b'] = java.awt.Color.BLACK;

                addActionListener(new java.awt.event.ActionListener() {
                    @Override public void actionPerformed(java.awt.event.ActionEvent e)
                    {
                        boolean wasVisible = collapsibleThing.isVisible();
                        setMyText(wasVisible ? "+" : "-");
                        collapsibleThing.setVisible(!wasVisible);
                        window.pack();
                    }
                });
            }
            public void setMyText(String myText) { this.myText = myText; }
            public String getMyText() { return this.myText; }
            OVERRIDE public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(12*hidpimag,12*hidpimag); }
            OVERRIDE public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(12*hidpimag,12*hidpimag); }
            OVERRIDE public void paint(java.awt.Graphics g)
            {
                CHECK(super.getText().equals(""));
                super.paint(g);
                if (getMyText().equals("-")) {
                    drawPixmapCentered(g, getSize(), hidpimag, this.asciiToColor,
                                       new String[] {
                                          "bbbbbb",
                                          "bbbbbb",
                                       });
                } else {
                    drawPixmapCentered(g, getSize(), hidpimag, this.asciiToColor,
                                       new String[] {
                                          "  bb  ",
                                          "  bb  ",
                                          "bbbbbb",
                                          "bbbbbb",
                                          "  bb  ",
                                          "  bb  ",
                                       });
                }
            }
            private java.awt.Color asciiToColor[/*128*/];
            private String myText;
        } // PlusMinusButton

        private static java.awt.Component MakeCollapsibleSection(final String label, final JFrame window, final java.awt.Component collapsibleContent) {
            final java.awt.GridBagConstraints stretchx = new java.awt.GridBagConstraints(){{fill=HORIZONTAL;weightx=1.;}};
            return new JCol() {
                // My natural height, the collapsible content's natural width
                @Override public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(collapsibleContent.getPreferredSize().width, super.getPreferredSize().height); }
                @Override public java.awt.Dimension getMinimumSize() { return new java.awt.Dimension(collapsibleContent.getMinimumSize().width, super.getMinimumSize().height); }
            {
              add(new JRow() {
              {
                  add(new PlusMinusButton("+", collapsibleContent, window));
                  add(new JLabel(" "+label), stretchx);
              }}, stretchx);
              add(collapsibleContent, stretchx);
            }};
        }  // MakeCollapsibleSection

        // http://tech-eureka.blogspot.com/2010/12/how-to-implement-repeating-swing.html
        private static class JRepeatingButton extends JButton
        {
            public JRepeatingButton(String text)
            {
                super(text);
            }
            @Override public void addActionListener(final java.awt.event.ActionListener actionListener)
            {
                addMouseListener(new java.awt.event.MouseAdapter() {
                    private javax.swing.Timer repeatTimer = null;
                    private java.awt.event.ActionEvent synthesizedActionEvent = null;
                    @Override public void mousePressed(java.awt.event.MouseEvent mouseEvent)
                    {
                        // TODO: this used to be mouseEvent.getModifiers(), but that got
                        // deprecated.  Unfortunately the value returned by getModifiersEx()
                        // isn't suitable for constructing the ActionEvent, since the bits
                        // are interpreted differently.  E.g. BUTTON1_MASK=16 vs. BUTTON1_DOWN_MASK=1024.
                        int modifiers = 0;  // for now, can't modify
                        synthesizedActionEvent = new java.awt.event.ActionEvent(
                            JRepeatingButton.this,
                            java.awt.event.ActionEvent.ACTION_PERFORMED,
                            JRepeatingButton.this.getText(),
                            modifiers);
                        // the ctor that takes "when" introduced some time in (1.3, 1.6]
                        // so don't use it, so we can compile using 1.3
                        // TODO: use it!
                        actionListener.actionPerformed(synthesizedActionEvent); // initial execution

                        repeatTimer = new javax.swing.Timer(100, new java.awt.event.ActionListener() {
                            @Override public void actionPerformed(java.awt.event.ActionEvent timerActionEvent)
                            {
                                actionListener.actionPerformed(synthesizedActionEvent);
                            }
                        });
                        repeatTimer.setInitialDelay(500);
                        repeatTimer.start();
                    }
                    @Override public void mouseReleased(java.awt.event.MouseEvent arg0)
                    {
                        repeatTimer.stop();
                        repeatTimer = null;
                        synthesizedActionEvent = null;
                    }
                });
            }
        } // JRepeatingButton

        // A textfield that turns green or red when editing and not yet committed.
        // Esc reverts.
        private static class JValidatingTextField extends JTextField
        {
            // subclass can override this
            public boolean validate(String text)
            {
                return true; // it's all good by default
            }

            private String committedText;
            public JValidatingTextField(String text)
            {
                super(text);
                committedText = getText();

                getDocument().addDocumentListener(new javax.swing.event.DocumentListener() {
                    private void anyUpdate(javax.swing.event.DocumentEvent e)
                    {
                        if (!getText().equals(committedText)) // TODO: == doesn't work here?  I forget the difference
                        {
                            if (validate(getText()))
                            {
                                // TODO: if value semantically equals committed value, turn white instead.  hmm, can build this into validate() by having it return a value (Object), maybe?
                                setBackground(new java.awt.Color(192,255,192)); // light green
                            }
                            else
                                setBackground(new java.awt.Color(255,192,192)); // pink
                        }
                        else
                            setBackground(java.awt.Color.WHITE);
                    }
                    @Override public void insertUpdate(javax.swing.event.DocumentEvent e)  {anyUpdate(e);}
                    @Override public void removeUpdate(javax.swing.event.DocumentEvent e)  {anyUpdate(e);}
                    @Override public void changedUpdate(javax.swing.event.DocumentEvent e) {anyUpdate(e);}
                });
                addKeyListener(new java.awt.event.KeyAdapter() {
                    @Override public void keyPressed(java.awt.event.KeyEvent e)
                    {
                        if (e.getKeyCode() == java.awt.event.KeyEvent.VK_ESCAPE)
                        {
                            setText(committedText);
                        }
                    }
                });
                addActionListener(new java.awt.event.ActionListener() {
                    @Override public void actionPerformed(java.awt.event.ActionEvent e)
                    {
                        if (validate(getText()))
                        {
                            committedText = getText();
                            setBackground(java.awt.Color.WHITE);
                        }
                    }
                });
            }
            @Override public void setText(String text)
            {
                super.setText(text);
                if (validate(getText()))
                {
                    committedText = getText();
                    setBackground(java.awt.Color.WHITE);
                }
            }
        } // JValidatingTextField

        private abstract static class JTableOfPanIcons extends JTablePanel
        {
            // concrete subclass must implement this
            abstract public void buttonPressed(int iRow, int iCol);

            JTableOfPanIcons(int nRows, int nCols, final java.awt.Color asciiToColor[])
            {
                // used as "fill" argument to add()
                final java.awt.GridBagConstraints stretchxy = new java.awt.GridBagConstraints(){{fill=BOTH;weightx=weighty=1.;}};

                final String panIcons[][][] = makePanIcons();
                FORI (iRow, nRows)
                {
                    FORI (iCol, nCols)
                    {
                        // take center chunk out of icons array
                        int iIconRow = iRow + (panIcons.length-nRows)/2;
                        int iIconCol = iCol + (panIcons[iIconRow].length-nCols)/2;
                        final String panIcon[] = panIcons[iIconRow][iIconCol];
                        final int iRowFinal = iRow;
                        final int iColFinal = iCol;
                        add(new JRepeatingButton("") {
                            @Override public java.awt.Dimension getMinimumSize() { return new java.awt.Dimension(panIcon[0].length()*hidpimag, panIcon.length*hidpimag); }
                            @Override public java.awt.Dimension getPreferredSize() { return getMinimumSize(); }
                            @Override public void paint(java.awt.Graphics g)
                            {
                                drawPixmapCentered(g, getSize(), hidpimag, asciiToColor, panIcon);
                            }
                        {
                            addActionListener(new java.awt.event.ActionListener() {
                                @Override public void actionPerformed(java.awt.event.ActionEvent e)
                                {
                                    buttonPressed(iColFinal, iRowFinal);
                                }
                            });
                        }}, stretchxy);
                    }
                    advanceRow();
                }
            }

            // utility function to make a 5x5 array of pan icons
            private static String[][][] makePanIcons()
            {
                // Initialize with a fundamental region;
                // will reflect to get all of them
                String panIcons[][][] = {
                    {
                        {
                            "             ",
                            " *******     ",
                            " ******      ",
                            " *****       ",
                            " **********  ",
                            " *********   ",
                            " ** *****    ",
                            " *  ******   ",
                            "    *******  ",
                            "    ** ***** ",
                            "    *   **** ",
                            "         *** ",
                            "             ",
                        },
                        {
                            "           ",
                            "  ***      ",
                            "  ******   ",
                            "  ******   ",
                            " *****     ",
                            " ******    ",
                            " ** ****** ",
                            "    ****** ",
                            "   *****   ",
                            "   ******  ",
                            "   ** ***  ",
                            "      ***  ",
                            "           ",
                        },
                        {
                            "         ",
                            "    *    ",
                            "   ***   ",
                            "  *****  ",
                            " ******* ",
                            "   ***   ",
                            "  *****  ",
                            " ******* ",
                            "   ***   ",
                            "   ***   ",
                            "   ***   ",
                            "   ***   ",
                            "         ",
                        },
                        null,
                        null
                    },
                    {
                        null,
                        {
                            "           ",
                            "           ",
                            "  *******  ",
                            "  ******   ",
                            "  *****    ",
                            "  ******   ",
                            "  *******  ",
                            "  ** ****  ",
                            "  *   ***  ",
                            "           ",
                            "           ",
                        },
                        {
                            "         ",
                            "         ",
                            "    *    ",
                            "   ***   ",
                            "  *****  ",
                            " ******* ",
                            "   ***   ",
                            "   ***   ",
                            "   ***   ",
                            "         ",
                            "         ",
                        },
                        null,
                        null
                    },
                    {
                        null,
                        null,
                        {
                            "         ",
                            "         ",
                            "         ",
                            "         ",
                            "         ",
                            "         ",
                            "         ",
                            "         ",
                            "         ",
                        },
                        null,
                        null
                    },
                    {null,null,null,null,null},
                    {null,null,null,null,null},
                };
                int mats[][][] = {
                    {{0,1},{1,0}},  // transpose
                    {{-1,0},{0,1}}, // left/right reflect
                    {{1,0},{0,-1}}, // up/down reflect
                };
                FORI (iMat, mats.length)
                {
                    int mat[][] = mats[iMat];
                    final int nRows = panIcons.length;
                    final int nCols = panIcons[0].length;
                    FORI (iRow, nRows)
                    FORI (iCol, nCols)
                    {
                        String panIconIn[] = panIcons[iRow][iCol];
                        if (panIconIn != null)
                        {
                            //System.out.println("            it's not null!");
                            // transform by mat.
                            // what's the destination row and column?
                            int in[] = {1-nCols + 2*iCol,
                                        1-nRows + 2*iRow};
                            int out[] = VecMath.vxm(in, mat);
                            int jCol = (out[0] - (1-nCols))/2;
                            int jRow = (out[1] - (1-nRows))/2;
                            if (panIcons[jRow][jCol] == null)
                            {

                                // xform panIconIn into panIcons[jRow][jCol]

                                int widthIn = panIconIn[0].length();
                                int heightIn = panIconIn.length;
                                int widthOut = mat[0][0]==0. ? heightIn : widthIn;
                                int heightOut = mat[0][0]==0. ? widthIn : heightIn;
                                char charsOut[][] = new char[heightOut][widthOut];
                                FORI (iiRow, heightIn)
                                FORI (iiCol, widthIn)
                                {
                                    // reuse in,out
                                    in[0] = 1-widthIn + 2*iiCol;
                                    in[1] = 1-heightIn + 2*iiRow;
                                    VecMath.vxm(out, in, mat);
                                    int jjCol = (out[0] - (1-widthOut))/2;
                                    int jjRow = (out[1] - (1-heightOut))/2;
                                    charsOut[jjRow][jjCol] = panIconIn[iiRow].charAt(iiCol);
                                }
                                String panIconOut[] = new String[heightOut];
                                FORI (jjRow, heightOut)
                                    panIconOut[jjRow] = new String(charsOut[jjRow]);
                                panIcons[jRow][jCol] = panIconOut;
                            }
                        }
                    }
                }
                return panIcons;
            } // makePanIcons
        } // abstract class JTableOfPanIcons


        private static class ShephardsPlayAppletControlPanel
            extends JPanel
        {
            public ShephardsPlayAppletControlPanel(final ShephardsPlayApplet applet)
            {
                java.awt.Container contentPane = this;

                contentPane.setLayout(new ColLayout());

                // used as "fill" argument to add()
                final java.awt.GridBagConstraints stretchx = new java.awt.GridBagConstraints(){{fill=HORIZONTAL;weightx=1.;}};
                final java.awt.GridBagConstraints stretchy = new java.awt.GridBagConstraints(){{fill=VERTICAL;weighty=1.;}};
                final java.awt.GridBagConstraints stretchxy = new java.awt.GridBagConstraints(){{fill=BOTH;weightx=weighty=1.;}};
                final java.awt.GridBagConstraints rightjustify = new java.awt.GridBagConstraints(){{anchor=EAST;}};
                final java.awt.GridBagConstraints centerjustify = new java.awt.GridBagConstraints(){{anchor=CENTER;}};

                // used as arg to setMargin().  XXX doesn't seem to do anything on mac? (if anywhere)
                final java.awt.Insets nomargin = new java.awt.Insets(0,0,0,0);


                //
                // Make a bunch of named components that we know we'll want;
                // we can decide where to put them later
                //
                final JRepeatingButton undoButton = new JRepeatingButton("Undo") {{
                    setMargin(nomargin);
                    addActionListener(new java.awt.event.ActionListener() {
                        @Override public void actionPerformed(java.awt.event.ActionEvent e)
                        {
                            UndoItem item = (UndoItem)applet.undoTreeSquirrel.undo();
                            if (item != null)
                            {
                                applet.applyUndoItemState(item.before);
                            }
                            else
                            {
                                System.out.println("Nothing to undo!");
                            }
                            applet.theCanvas.repaint();
                        }
                    });
                }};
                final JRepeatingButton redoButton = new JRepeatingButton("Redo") {{
                    setMargin(nomargin);
                    addActionListener(new java.awt.event.ActionListener() {
                        @Override public void actionPerformed(java.awt.event.ActionEvent e)
                        {
                            UndoItem item = (UndoItem)applet.undoTreeSquirrel.redo();
                            if (item != null)
                            {
                                applet.applyUndoItemState(item.after);
                            }
                            else
                            {
                                System.out.println("Nothing to redo!");
                            }
                            applet.theCanvas.repaint();
                        }
                    });
                }};
                final JButton cloneButton = new JButton("Clone") {{
                    setMargin(nomargin);
                    addActionListener(new java.awt.event.ActionListener() {
                        @Override public void actionPerformed(java.awt.event.ActionEvent e)
                        {
                            applet.cloneApplet();
                        }
                    });
                }};
                final JButton clearButton = new JButton("Clear") {{
                    setMargin(nomargin);
                    addActionListener(new java.awt.event.ActionListener() {
                        @Override public void actionPerformed(java.awt.event.ActionEvent e)
                        {
                            applet.clear();
                            applet.theCanvas.repaint();
                        }
                    });
                }};
                final JButton loadButton = new JButton("Load DUMP.off") {{
                    setMargin(nomargin);
                    addActionListener(new java.awt.event.ActionListener() {
                        @Override public void actionPerformed(java.awt.event.ActionEvent e)
                        {
                            UndoItem.State before = applet.newUndoItemState();

                            applet.load("DUMP.off");

                            UndoItem.State after = applet.newUndoItemState();
                            applet.undoTreeSquirrel.Do(new UndoItem(before, after));

                            applet.theCanvas.repaint();
                        }
                    });
                }};

#ifdef TOO_HELPFUL
                // Actually not sure this was a good idea
                final JButton smartSaveButton = new JButton("Save DUMP.off I AM SO SMART") {Listenable.Listener listener;{
                    setMargin(nomargin);
                    setText(applet.wrapAroundSphereFlag.get() ? "Save DUMP.off (XYZW)"
                                                              : "Save DUMP.off (xyh)");
                    applet.wrapAroundSphereFlag.addListener(listener = new Listenable.Listener() {
                        @Override public void valueChanged()
                        {
                            setText(applet.wrapAroundSphereFlag.get() ? "Save DUMP.off (XYZW)"
                                                                      : "Save DUMP.off (xyh)");
                        }
                    });
                    addActionListener(new java.awt.event.ActionListener() {
                        @Override public void actionPerformed(java.awt.event.ActionEvent e)
                        {
                            boolean saveHomo = applet.wrapAroundSphereFlag.get();
                            // ARGH! really need to be able to save/load in either mode, e.g. OutStressor is most naturally expressed with W's instead of H's
                            applet.save("DUMP.off", saveHomo);
                        }
                    });
                }};
#endif // TOO_HELPFUL

                final JButton saveDualButton = new JButton("Save DUALVERTS.txt") {{
                    setMargin(nomargin);
                    addActionListener(new java.awt.event.ActionListener() {
                        @Override public void actionPerformed(java.awt.event.ActionEvent e)
                        {
                            applet.dualSave("DUALVERTS.txt");
                        }
                    });
                }};
                final JTextFieldForNumber theGridNTextField = new JTextFieldForNumber(applet.gridN)
                  {{ setToolTipText("number of layers for Grid"); }};
                final JTextFieldForNumber theGridRotDegreesTextField = new JTextFieldForNumber(applet.gridRotDegrees)
                  {{ setToolTipText("rotation degrees for Grid "); }};
                final JTextFieldForNumber theBlueNoiseNTextField = new JTextFieldForNumber(applet.blueNoiseN)
                  {{ setToolTipText("approximate number of points for Blue Noise"); }};
                final JTextFieldForNumber theJustNoiseNTextField = new JTextFieldForNumber(applet.justNoiseN)
                  {{ setToolTipText("number of points for Just Noise"); }};;
                final JTextFieldForNumber theConvexNoiseNTextField = new JTextFieldForNumber(applet.convexNoiseN)
                  {{ setToolTipText("number of points for Convex Noise"); }};

                final java.awt.Component cannedThingButtons[] = {
                    new JButton("Hexes Spiral") {{
                        addActionListener(new java.awt.event.ActionListener() {
                            @Override public void actionPerformed(java.awt.event.ActionEvent e)
                            {
                                UndoItem.State before = applet.newUndoItemState();

                                applet.doCannedThingHexesSpiral();

                                UndoItem.State after = applet.newUndoItemState();
                                applet.undoTreeSquirrel.Do(new UndoItem(before, after));

                                applet.theCanvas.repaint();
                            }
                        });
                    }},
                    new JButton("Hexes Spiral Alt") {{
                        addActionListener(new java.awt.event.ActionListener() {
                            @Override public void actionPerformed(java.awt.event.ActionEvent e)
                            {
                                UndoItem.State before = applet.newUndoItemState();

                                applet.doCannedThingHexesSpiralOther();

                                UndoItem.State after = applet.newUndoItemState();
                                applet.undoTreeSquirrel.Do(new UndoItem(before, after));

                                applet.theCanvas.repaint();
                            }
                        });
                    }},
                    new JButton("netless8 symmetric") {{
                        addActionListener(new java.awt.event.ActionListener() {
                            @Override public void actionPerformed(java.awt.event.ActionEvent e)
                            {
                                UndoItem.State before = applet.newUndoItemState();

                                applet.doCannedThingNetless8Symmetric();

                                UndoItem.State after = applet.newUndoItemState();
                                applet.undoTreeSquirrel.Do(new UndoItem(before, after));

                                applet.theCanvas.repaint();
                            }
                        });
                    }},
                    new JButton("netless8") {{
                        addActionListener(new java.awt.event.ActionListener() {
                            @Override public void actionPerformed(java.awt.event.ActionEvent e)
                            {
                                UndoItem.State before = applet.newUndoItemState();

                                applet.doCannedThingNetless8();

                                UndoItem.State after = applet.newUndoItemState();
                                applet.undoTreeSquirrel.Do(new UndoItem(before, after));

                                applet.theCanvas.repaint();
                            }
                        });
                    }},
                    new JButton("netless8 slope opt") {{
                        addActionListener(new java.awt.event.ActionListener() {
                            @Override public void actionPerformed(java.awt.event.ActionEvent e)
                            {
                                UndoItem.State before = applet.newUndoItemState();

                                applet.doCannedThingNetless8SlopeOptimized();

                                UndoItem.State after = applet.newUndoItemState();
                                applet.undoTreeSquirrel.Do(new UndoItem(before, after));

                                applet.theCanvas.repaint();
                            }
                        });
                    }},
                    new JButton("Refinement Killer") {{
                        addActionListener(new java.awt.event.ActionListener() {
                            @Override public void actionPerformed(java.awt.event.ActionEvent e)
                            {
                                UndoItem.State before = applet.newUndoItemState();

                                applet.doCannedThingRefinementKiller();

                                UndoItem.State after = applet.newUndoItemState();
                                applet.undoTreeSquirrel.Do(new UndoItem(before, after));

                                applet.theCanvas.repaint();
                            }
                        });
                    }},
                    new JButton("netless9") {{
                        addActionListener(new java.awt.event.ActionListener() {
                            @Override public void actionPerformed(java.awt.event.ActionEvent e)
                            {
                                UndoItem.State before = applet.newUndoItemState();

                                applet.doCannedThingNetless9();

                                UndoItem.State after = applet.newUndoItemState();
                                applet.undoTreeSquirrel.Do(new UndoItem(before, after));

                                applet.theCanvas.repaint();
                            }
                        });
                    }},
                    new JButton("eyeball") {{
                        addActionListener(new java.awt.event.ActionListener() {
                            @Override public void actionPerformed(java.awt.event.ActionEvent e)
                            {
                                UndoItem.State before = applet.newUndoItemState();

                                applet.doCannedThingEyeball();

                                UndoItem.State after = applet.newUndoItemState();
                                applet.undoTreeSquirrel.Do(new UndoItem(before, after));

                                applet.theCanvas.repaint();
                            }
                        });
                    }},
                    new JButton("Crack Goes In Spiral Small") {{
                        addActionListener(new java.awt.event.ActionListener() {
                            @Override public void actionPerformed(java.awt.event.ActionEvent e)
                            {
                                UndoItem.State before = applet.newUndoItemState();

                                applet.doCannedThingCrackGoesInSpiralSmall();

                                UndoItem.State after = applet.newUndoItemState();
                                applet.undoTreeSquirrel.Do(new UndoItem(before, after));

                                applet.theCanvas.repaint();
                            }
                        });
                    }},
                    new JButton("Crack Goes In Spiral Big") {{
                        addActionListener(new java.awt.event.ActionListener() {
                            @Override public void actionPerformed(java.awt.event.ActionEvent e)
                            {
                                UndoItem.State before = applet.newUndoItemState();

                                applet.doCannedThingCrackGoesInSpiralBig();

                                UndoItem.State after = applet.newUndoItemState();
                                applet.undoTreeSquirrel.Do(new UndoItem(before, after));

                                applet.theCanvas.repaint();
                            }
                        });
                    }},
                    new JButton("Simple Outward Sweep Killer") {{
                        addActionListener(new java.awt.event.ActionListener() {
                            @Override public void actionPerformed(java.awt.event.ActionEvent e)
                            {
                                UndoItem.State before = applet.newUndoItemState();

                                applet.doCannedThingSimpleOutwardSweepKiller();

                                UndoItem.State after = applet.newUndoItemState();
                                applet.undoTreeSquirrel.Do(new UndoItem(before, after));

                                applet.theCanvas.repaint();
                            }
                        });
                    }},
                    new JButton("Sweep Killer") {{
                        addActionListener(new java.awt.event.ActionListener() {
                            @Override public void actionPerformed(java.awt.event.ActionEvent e)
                            {
                                UndoItem.State before = applet.newUndoItemState();

                                applet.doCannedThingSweepKiller0();

                                UndoItem.State after = applet.newUndoItemState();
                                applet.undoTreeSquirrel.Do(new UndoItem(before, after));

                                applet.theCanvas.repaint();
                            }
                        });
                    }},
                    new JButton("Sweep Killer 1") {{
                        addActionListener(new java.awt.event.ActionListener() {
                            @Override public void actionPerformed(java.awt.event.ActionEvent e)
                            {
                                UndoItem.State before = applet.newUndoItemState();

                                applet.doCannedThingSweepKiller1();

                                UndoItem.State after = applet.newUndoItemState();
                                applet.undoTreeSquirrel.Do(new UndoItem(before, after));

                                applet.theCanvas.repaint();
                            }
                        });
                    }},
                    new JButton("Sweep Killer 1eps") {{
                        addActionListener(new java.awt.event.ActionListener() {
                            @Override public void actionPerformed(java.awt.event.ActionEvent e)
                            {
                                UndoItem.State before = applet.newUndoItemState();

                                applet.doCannedThingSweepKiller1eps();

                                UndoItem.State after = applet.newUndoItemState();
                                applet.undoTreeSquirrel.Do(new UndoItem(before, after));

                                applet.theCanvas.repaint();
                            }
                        });
                    }},
                    new JRow() {{
                        add(new JLabel(" "));
                        add(new JButton("Sweep Killer 1eps mult") {{
                            setMargin(nomargin); // TODO: just traverse and set this on all children?  already doing it on top level I think
                            addActionListener(new java.awt.event.ActionListener() {
                                @Override public void actionPerformed(java.awt.event.ActionEvent e)
                                {
                                    UndoItem.State before = applet.newUndoItemState();

                                    applet.doCannedThingSweepKiller1epsMultiple(applet.sweepKiller1Multiplicity.get(),
                                                                                applet.sweepKiller1Multiplicity.get(),
                                                                                false);

                                    UndoItem.State after = applet.newUndoItemState();
                                    applet.undoTreeSquirrel.Do(new UndoItem(before, after));

                                    applet.theCanvas.repaint();
                                }
                            });
                        }});
                        add(new JTextFieldForNumber(applet.sweepKiller1Multiplicity)); // XXX why aren't they all this simple?  oh, it's because I like to make the button start by flushing the textfield into the listenable if it's green. hmm, should do that here.  or, maybe disable button when textfield is red or green?  hmm.
                        add(new JButton("polar") {{
                            setMargin(nomargin); // TODO: just traverse and set this on all children?  already doing it on top level I think
                            addActionListener(new java.awt.event.ActionListener() {
                                @Override public void actionPerformed(java.awt.event.ActionEvent e)
                                {
                                    UndoItem.State before = applet.newUndoItemState();

                                    applet.doCannedThingSweepKiller1epsMultiplePolar(applet.sweepKiller1Multiplicity.get(),
                                                                                     applet.sweepKiller1Multiplicity.get());

                                    UndoItem.State after = applet.newUndoItemState();
                                    applet.undoTreeSquirrel.Do(new UndoItem(before, after));

                                    applet.theCanvas.repaint();
                                }
                            });
                        }});
                        add(new JLabel(" "));
                    }},
                    new JRow() {{
                        add(new JLabel(" "));
                        add(new JButton("Out Stressor") {{
                            setToolTipText("<html>Thing for which naive outward gives a lot of bad cuts. Number is number of levels (i.e. num verts / 4, approximately.)</html>");
                            setMargin(nomargin); // TODO: just traverse and set this on all children?  already doing it on top level I think
                            addActionListener(new java.awt.event.ActionListener() {
                                @Override public void actionPerformed(java.awt.event.ActionEvent e)
                                {
                                    UndoItem.State before = applet.newUndoItemState();

                                    applet.doCannedThingOutStressor(applet.outStressorNLevels.get());

                                    UndoItem.State after = applet.newUndoItemState();
                                    applet.undoTreeSquirrel.Do(new UndoItem(before, after));

                                    applet.theCanvas.repaint();
                                }
                            });
                        }});
                        add(new JTextFieldForNumber(applet.outStressorNLevels));
                        add(new JLabel(" "));
                    }},
                    new JRow() {{
                        add(new JLabel(" "));
                        add(new JButton("Out Stressor Spiral") {{
                            setToolTipText("<html>Thing for which naive outward gives a lot of bad cuts, arranged in spiral. Number is number of verts.</html>");
                            setMargin(nomargin); // TODO: just traverse and set this on all children?  already doing it on top level I think
                            addActionListener(new java.awt.event.ActionListener() {
                                @Override public void actionPerformed(java.awt.event.ActionEvent e)
                                {
                                    UndoItem.State before = applet.newUndoItemState();

                                    applet.doCannedThingOutStressorSpiral(applet.outStressorSpiralN.get());

                                    UndoItem.State after = applet.newUndoItemState();
                                    applet.undoTreeSquirrel.Do(new UndoItem(before, after));

                                    applet.theCanvas.repaint();
                                }
                            });
                        }});
                        add(new JTextFieldForNumber(applet.outStressorSpiralN));
                        add(new JLabel(" "));
                    }},
                    new JButton("Sweep Killer (not) 2") {{
                        addActionListener(new java.awt.event.ActionListener() {
                            @Override public void actionPerformed(java.awt.event.ActionEvent e)
                            {
                                UndoItem.State before = applet.newUndoItemState();

                                applet.doCannedThingSweepKiller2();

                                UndoItem.State after = applet.newUndoItemState();
                                applet.undoTreeSquirrel.Do(new UndoItem(before, after));

                                applet.theCanvas.repaint();
                            }
                        });
                    }},
                    new JButton("Face Sweep Killer") {{
                        setToolTipText("<html>Counterexample to the class of face sweep algorithms<br>in which each new face attaches to a previous one.</html>");
                        addActionListener(new java.awt.event.ActionListener() {
                            @Override public void actionPerformed(java.awt.event.ActionEvent e)
                            {
                                UndoItem.State before = applet.newUndoItemState();

                                applet.doCannedThingFaceSweepKiller();

                                UndoItem.State after = applet.newUndoItemState();
                                applet.undoTreeSquirrel.Do(new UndoItem(before, after));

                                applet.theCanvas.repaint();
                            }
                        });
                    }},
                    new JButton("<html><small>Simpler</small> Face Sweep Killer</html>") {{
                        setToolTipText("<html>Simpler (and spherical!) counterexample to the class of face sweep algorithms<br>in which each new face attaches to a previous one.</html>");
                        addActionListener(new java.awt.event.ActionListener() {
                            @Override public void actionPerformed(java.awt.event.ActionEvent e)
                            {
                                UndoItem.State before = applet.newUndoItemState();

                                applet.doCannedThingSimplerFaceSweepKiller();

                                UndoItem.State after = applet.newUndoItemState();
                                applet.undoTreeSquirrel.Do(new UndoItem(before, after));

                                applet.theCanvas.repaint();
                            }
                        });
                    }},
                    new JButton("<html><small>Not vertex but</small> Face Sweep Killer</html>") {{
                        setToolTipText("<html>Simpler (and spherical!) counterexample to the class of face sweep algorithms<br>in which each new face attaches to a previous one.</html>");
                        addActionListener(new java.awt.event.ActionListener() {
                            @Override public void actionPerformed(java.awt.event.ActionEvent e)
                            {
                                UndoItem.State before = applet.newUndoItemState();

                                applet.doCannedThingSimplerFaceSweepKillerNotVertexSweepKiller();

                                UndoItem.State after = applet.newUndoItemState();
                                applet.undoTreeSquirrel.Do(new UndoItem(before, after));

                                applet.theCanvas.repaint();
                            }
                        });
                    }},
                    new JButton("Steep Killer") {{
                        setToolTipText("<html>This one forces a downward slope of -2<br>(and can be easily modified to any steepness)</html>");
                        addActionListener(new java.awt.event.ActionListener() {
                            @Override public void actionPerformed(java.awt.event.ActionEvent e)
                            {
                                UndoItem.State before = applet.newUndoItemState();

                                applet.doCannedThingSteepKiller();

                                UndoItem.State after = applet.newUndoItemState();
                                applet.undoTreeSquirrel.Do(new UndoItem(before, after));

                                applet.theCanvas.repaint();
                            }
                        });
                    }},
                    new JButton("Algorithm5 Killer0") {{
                        addActionListener(new java.awt.event.ActionListener() {
                            @Override public void actionPerformed(java.awt.event.ActionEvent e)
                            {
                                UndoItem.State before = applet.newUndoItemState();

                                applet.doCannedThingAlgorithm5Killer0();

                                UndoItem.State after = applet.newUndoItemState();
                                applet.undoTreeSquirrel.Do(new UndoItem(before, after));

                                applet.theCanvas.repaint();
                            }
                        });
                    }},
                    new JButton("Algorithm5 Killer1") {{
                        addActionListener(new java.awt.event.ActionListener() {
                            @Override public void actionPerformed(java.awt.event.ActionEvent e)
                            {
                                UndoItem.State before = applet.newUndoItemState();

                                applet.doCannedThingAlgorithm5Killer1();

                                UndoItem.State after = applet.newUndoItemState();
                                applet.undoTreeSquirrel.Do(new UndoItem(before, after));

                                applet.theCanvas.repaint();
                            }
                        });
                    }},
                    new JButton("Far Lagoon Killer 1") {{
                        {setToolTipText("<html>Farthest-from-center lagoon exiting goes into an endless loop.<br>To follow what this is doing, see description in source code.</html>");}
                        addActionListener(new java.awt.event.ActionListener() {
                            @Override public void actionPerformed(java.awt.event.ActionEvent e)
                            {
                                UndoItem.State before = applet.newUndoItemState();

                                applet.doCannedThingFarthestLagoonExitKiller();

                                UndoItem.State after = applet.newUndoItemState();
                                applet.undoTreeSquirrel.Do(new UndoItem(before, after));

                                applet.theCanvas.repaint();
                            }
                        });
                    }},
                    new JButton("Far Lagoon Killer 2") {{
                        {setToolTipText("<html>Farthest-from-center lagoon exiting goes into an endless loop.<br>To follow what this is doing, see description in source code.</html>");}
                        addActionListener(new java.awt.event.ActionListener() {
                            @Override public void actionPerformed(java.awt.event.ActionEvent e)
                            {
                                UndoItem.State before = applet.newUndoItemState();

                                applet.doCannedThingFarthestLagoonExitKillerAltB();

                                UndoItem.State after = applet.newUndoItemState();
                                applet.undoTreeSquirrel.Do(new UndoItem(before, after));

                                applet.theCanvas.repaint();
                            }
                        });
                    }},
                    new JRow() {{
                        add(new JButton("Grid") {{
                            {setToolTipText("<html>Square grid,<br>or, if rotational symmetry is a multiple of 3, hex grid.<br>ctrl to add to existing grid verts.<html>");}
                            setMargin(nomargin); // XXX remind me what this is for and why I don't have it on, for example, Far Lagoon Killer 1 and 2?
                            addActionListener(new java.awt.event.ActionListener() {
                                @Override public void actionPerformed(java.awt.event.ActionEvent e)
                                {
                                    // Flush the textfield value into gridN
                                    try
                                    {
                                        // XXX shouldn't this be setDouble?
                                        applet.gridN.setDouble(Double.valueOf(theGridNTextField.getText()).doubleValue());
                                    }
                                    catch (java.lang.NumberFormatException nfe)
                                    {
                                        // maybe should print an error message or something
                                        theGridNTextField.updateText(applet.gridN);
                                    }

                                    // Flush the textfield value into gridRotDegrees
                                    try
                                    {
                                        applet.gridRotDegrees.setDouble(Double.valueOf(theGridRotDegreesTextField.getText()).doubleValue());
                                    }
                                    catch (java.lang.NumberFormatException nfe)
                                    {
                                        // maybe should print an error message or something
                                        theGridRotDegreesTextField.updateText(applet.gridRotDegrees);
                                    }


                                    UndoItem.State before = applet.newUndoItemState();

                                    boolean controlIsDown = ((e.getModifiers() & java.awt.event.ActionEvent.CTRL_MASK) != 0);
                                    applet.doUniformGridThing(applet.gridN.get(), applet.gridRotDegrees.get(), /*augment_existing_mesh=*/controlIsDown);

                                    if (applet.continuouslyDelaunayizeFlag.get()) applet.delaunayize();
                                    UndoItem.State after = applet.newUndoItemState();
                                    applet.undoTreeSquirrel.Do(new UndoItem(before, after));

                                    applet.theCanvas.repaint();
                                }
                            });
                        }}, stretchx);
                        add(theGridNTextField, stretchx);
                        add(theGridRotDegreesTextField, stretchx);
                    }},
                    new JRow() {{
                        add(new JRepeatingButton("Blue Noise") {{
                            {setToolTipText("Blue noise on the plane, or, if \"Wrap around sphere\", on the sphere.");}
                            setMargin(nomargin);
                            addActionListener(new java.awt.event.ActionListener() {
                                @Override public void actionPerformed(java.awt.event.ActionEvent e)
                                {
                                    // Flush the textfield value into blueNoiseN
                                    try
                                    {
                                        applet.blueNoiseN.setDouble(Double.valueOf(theBlueNoiseNTextField.getText()).doubleValue());
                                    }
                                    catch (java.lang.NumberFormatException nfe)
                                    {
                                        // maybe should print an error message or something
                                        theBlueNoiseNTextField.updateText(applet.blueNoiseN);
                                    }

                                    UndoItem.State before = applet.newUndoItemState();

                                    applet.doBlueNoiseThing(applet.blueNoiseN.get());

                                    if (applet.continuouslyDelaunayizeFlag.get()) applet.delaunayize();
                                    UndoItem.State after = applet.newUndoItemState();
                                    applet.undoTreeSquirrel.Do(new UndoItem(before, after));

                                    applet.theCanvas.repaint();
                                }
                            });
                        }}, stretchx);
                        add(theBlueNoiseNTextField, stretchx);
                    }},
                    new JRow() {{
                        add(new JRepeatingButton("Just Noise") {{
                            {setToolTipText("Just noise on the plane, or, if \"Wrap around sphere\", on the sphere.");}
                            setMargin(nomargin);
                            addActionListener(new java.awt.event.ActionListener() {
                                @Override public void actionPerformed(java.awt.event.ActionEvent e)
                                {
                                    // Flush the textfield value into justNoiseN
                                    try
                                    {
                                        applet.justNoiseN.setDouble(Double.valueOf(theJustNoiseNTextField.getText()).doubleValue());
                                    }
                                    catch (java.lang.NumberFormatException nfe)
                                    {
                                        // maybe should print an error message or something
                                        theJustNoiseNTextField.updateText(applet.justNoiseN);
                                    }

                                    UndoItem.State before = applet.newUndoItemState();

                                    applet.doJustNoiseThing(applet.justNoiseN.get());

                                    if (applet.continuouslyDelaunayizeFlag.get()) applet.delaunayize();
                                    UndoItem.State after = applet.newUndoItemState();
                                    applet.undoTreeSquirrel.Do(new UndoItem(before, after));

                                    applet.theCanvas.repaint();
                                }
                            });
                        }}, stretchx);
                        add(theJustNoiseNTextField, stretchx);
                    }},
                    new JRow() {{
                        add(new JRepeatingButton("Convex Noise") {{
                            {setToolTipText("<html>Convex noise on the plane, or, if \"Wrap around sphere\", on the sphere. <span style='color:red;'>QUADRATIC ALERT</span>: don't make n very big!</html>");}
                            setMargin(nomargin);
                            addActionListener(new java.awt.event.ActionListener() {
                                @Override public void actionPerformed(java.awt.event.ActionEvent e)
                                {
                                    // Flush the textfield value into convexNoiseN
                                    try
                                    {
                                        applet.convexNoiseN.setDouble(Double.valueOf(theConvexNoiseNTextField.getText()).doubleValue());
                                    }
                                    catch (java.lang.NumberFormatException nfe)
                                    {
                                        // maybe should print an error message or something
                                        theConvexNoiseNTextField.updateText(applet.convexNoiseN);
                                    }

                                    UndoItem.State before = applet.newUndoItemState();

                                    applet.doConvexNoiseThing(applet.convexNoiseN.get());

                                    if (applet.continuouslyDelaunayizeFlag.get()) applet.delaunayize();
                                    UndoItem.State after = applet.newUndoItemState();
                                    applet.undoTreeSquirrel.Do(new UndoItem(before, after));

                                    applet.theCanvas.repaint();
                                }
                            });
                        }}, stretchx);
                        add(theConvexNoiseNTextField, stretchx);
                    }},
                    new JRow() {{
                        add(new JCol() {{
                            add(new JButton("Single-Exit Lagoon") {{
                                setMargin(nomargin); // TODO: just traverse and set this on all children?  already doing it on top level I think
                                addActionListener(new java.awt.event.ActionListener() {
                                    @Override public void actionPerformed(java.awt.event.ActionEvent e)
                                    {
                                        UndoItem.State before = applet.newUndoItemState();

                                        applet.doCannedThingSingleExitLagoonPolygon(
                                            applet.singleExitLagoonVirtualN.get(),

                                            applet.singleExitLagoonNBeforeApex.get(),
                                            applet.singleExitLagoonNAfterApex.get(),
                                            applet.singleExitLagoonQuillSlopeNumerator.get(),
                                            applet.singleExitLagoonQuillSlopeDenominator.get(),

                                            applet.singleExitLagoonNBeforeBeforeApex.get(),
                                            applet.singleExitLagoonNAfterAfterApex.get(),
                                            applet.singleExitLagoonQuillSlopeNumeratorNumerator.get(),
                                            applet.singleExitLagoonQuillSlopeDenominatorDenominator.get(),

                                            applet.singleExitLagoonPointApexUpFlag.get(),
                                            applet.singleExitLagoonSynthesizeExactDualFlag.get(),
                                            applet.singleExitLagoonFudgeWeightsSoApexIsFarthestFromCurvatureCenterFlag.get());

                                        UndoItem.State after = applet.newUndoItemState();
                                        applet.undoTreeSquirrel.Do(new UndoItem(before, after));

                                        applet.theCanvas.repaint();
                                    }
                                });
                            }});
                            add(new JCheckBoxForBoolean("<html>Highlight<br>primal/dual<br>feature</html>", applet.primalDualVisFlag) {{
                                setToolTipText("<html>continuously highlight closest primal/dual feature<br>to mouse cursor angle</html>");
                            }});
                        }});
                        add(new JCol() {{
                            add(new JRow() {{
                                setToolTipText("internal angles of dual polygon are based on this"); // TODO: seems to apply to the label but not the textfield, bleah!
                                add(new JLabel("nVirtual:"));
                                add(new JTextFieldForNumber(applet.singleExitLagoonVirtualN));
                                add(new JLabel("        "));
                                add(new JCheckBoxForBoolean("point apex up", applet.singleExitLagoonPointApexUpFlag));
                            }});
                            add(new JTablePanel() {{
                                add(new JLabel("<html>after<br>apex:</html>") {{
                                    setToolTipText("number of dual verts after (on left of) apex");
                                }});
                                add(new JTextFieldForNumber(applet.singleExitLagoonNAfterApex));
                                add(new JLabel("<html>before<br>apex:</html>") {{
                                    setToolTipText("number of dual verts before (on right of) apex");
                                }});
                                add(new JTextFieldForNumber(applet.singleExitLagoonNBeforeApex));
                                add(new JLabel("<html>quill<br>slope:</html>") {{
                                    setToolTipText("slope of quills: 0 means laying flat");
                                }});
                                add(new JTextFieldForNumber(applet.singleExitLagoonQuillSlopeNumerator));
                                add(new JLabel("/"));
                                add(new JTextFieldForNumber(applet.singleExitLagoonQuillSlopeDenominator));
                                add(new JCol() {{
                                    add(new JCheckBoxForBoolean("synth exact dual", applet.singleExitLagoonSynthesizeExactDualFlag) {{
                                        setToolTipText("<html>when checked, the dual (blue) is computed directly<br>(but with parts missing, so certain operations like scaling will be broken).<br>this is necessary when quill slope is 0 or close to it,<br>since in that case the primal is not well defined<br>and the dual can't be computed accurately from it.<br>NOTE: undo/redo will foil this.</html>");
                                    }});
                                    add(new JCheckBoxForBoolean("fudge bottom heavy", applet.singleExitLagoonFudgeWeightsSoApexIsFarthestFromCurvatureCenterFlag) {{
                                        setToolTipText("<html>When checked, the dual (blue) vertex weights are fudged to be bottom heavy.</html>");
                                    }});
                                }});
                                advanceRow();
                                add(new JLabel("<html>after<br>after:</html>") {{
                                    setToolTipText("number of dual verts after (on left of) apex");
                                }});
                                add(new JTextFieldForNumber(applet.singleExitLagoonNAfterAfterApex));
                                add(new JLabel("<html>before<br>before:</html>") {{
                                    setToolTipText("number of dual verts before (on right of) apex");
                                }});
                                add(new JTextFieldForNumber(applet.singleExitLagoonNBeforeBeforeApex));
                                add(new JLabel("<html>quill<br>slope:</html>") {{
                                    setToolTipText("slope of quills: 0 means laying flat");
                                }});
                                add(new JTextFieldForNumber(applet.singleExitLagoonQuillSlopeNumeratorNumerator));
                                add(new JLabel("/"));
                                add(new JTextFieldForNumber(applet.singleExitLagoonQuillSlopeDenominatorDenominator));
                            }});
                        }});
                    }},
                };

                final java.awt.Component theGridBrightnessLabel = new JLabel("Grid brightness:");
                final java.awt.Component theGridBrightnessTextField = new JTextFieldForNumber(applet.gridBrightness) {{setMargin(nomargin); }};
                final java.awt.Component theGridBrightnessSlider = new SliderForFloat(applet.gridBrightness);
                final java.awt.Component theBackfaceBrightnessLabel = new JLabel("Backface brightness:");
                final java.awt.Component theBackfaceBrightnessTextField = new JTextFieldForNumber(applet.backfaceBrightness);
                final java.awt.Component theBackfaceBrightnessSlider = new SliderForFloat(applet.backfaceBrightness);
                final java.awt.Component theWrapRadiusLabel = new JLabel("Wrap radius:") {Listenable.Listener enabledListener; {enabledListener = tieEnabledTo(this, applet.wrapAroundSphereFlag);}};
                final java.awt.Component theWrapRadiusTextField = new JTextFieldForNumber(applet.wrapSphereSymbolicRadius) {Listenable.Listener enabledListener; {enabledListener = tieEnabledTo(this, applet.wrapAroundSphereFlag);}};
                final java.awt.Component theWrapRadiusSlider = new SliderForFloat(applet.wrapSphereSymbolicRadius) {Listenable.Listener enabledListener; {enabledListener = tieEnabledTo(this, applet.wrapAroundSphereFlag);}};

                // for making pixmaps from ascii
                final java.awt.Color asciiToColor[] = new java.awt.Color[128];
                asciiToColor[' '] = java.awt.Color.BLACK;
                asciiToColor['w'] = java.awt.Color.WHITE;
                asciiToColor['B'] = new java.awt.Color(64,64,255); // slightly light blue
                asciiToColor['b'] = new java.awt.Color(224,224,255); // very light blue

                int flowLayoutGap = 0; // jam buttons together
                if (System.getProperty("os.name").equals("Mac OS X"))
                {
                    // so much extra padding on mac! setting hgap=vgap=0 helps, hgap=vgap=-5 helps even more,
                    // although it causes the first row to be cut off a bit :-(
                    // Oh what the fuck!  This causes the "Save DUALVERTS.txt" button to disappear!?  So don't do it on the File/Edit section
                    flowLayoutGap = -5;
                }
                final int finalFlowLayoutGap = flowLayoutGap;

                contentPane.add(new JSeparator(), stretchx);
                contentPane.add(MakeCollapsibleSection("File/Edit", applet.theControlPanelWindow, new JRow() {{
                    setVisible(false);
                    add(new JLabel("        ")); // indent a bit
                    add(new JPanel() {{ // flow layout
                        // ARGH! The following causes the "Save DUALVERTS.txt" button to disappear, on mac!?  This is so fucked.
                        //setLayout(new java.awt.FlowLayout(java.awt.FlowLayout.CENTER, finalFlowLayoutGap, finalFlowLayoutGap));
                        setLayout(new java.awt.FlowLayout(java.awt.FlowLayout.CENTER, 0, 0));

                        add(new JCol() {{
                            add(new JRow() {{
                                add(cloneButton);
                                add(clearButton);
                                add(new JRow() {{ // so no space between this pair
                                    add(undoButton);
                                    add(redoButton);
                                }});
                            }});
                            add(new JRow() {{
                                add(loadButton);
#ifdef TOO_HELPFUL
                                add(smartSaveButton);
#endif // TOO_HELPFUL
                                add(new JButton("Save DUMP.off (xyh)") {Listenable.Listener listener;{
                                    setMargin(nomargin);
                                    addActionListener(new java.awt.event.ActionListener() {
                                        @Override public void actionPerformed(java.awt.event.ActionEvent e)
                                        {
                                            boolean saveHomo = false;
                                            applet.save("DUMP.off", saveHomo);
                                        }
                                    });
                                }});
                                add(new JButton("Save DUMP.off (XYZW)") {Listenable.Listener listener;{
                                    setMargin(nomargin);
                                    addActionListener(new java.awt.event.ActionListener() {
                                        @Override public void actionPerformed(java.awt.event.ActionEvent e)
                                        {
                                            boolean saveHomo = true;
                                            applet.save("DUMP.off", saveHomo);
                                        }
                                    });
                                }});
                                add(saveDualButton);
                                // scale?
                            }});
                        }});
                    }});
                }}));
                contentPane.add(new JSeparator(), stretchx);
                contentPane.add(MakeCollapsibleSection("Canned Things", applet.theControlPanelWindow, new JRow() {{
                    setVisible(false);
                    add(new JLabel("        ")); // indent a bit
                    add(new JPanel() {{ // flow layout
                        setLayout(new java.awt.FlowLayout(java.awt.FlowLayout.CENTER, finalFlowLayoutGap, finalFlowLayoutGap)); // hgap,vgap
                        FORI (i, cannedThingButtons.length)
                        {
                            if (cannedThingButtons[i] instanceof JButton)
                                ((JButton)cannedThingButtons[i]).setMargin(nomargin);
                            add(cannedThingButtons[i], stretchx);
                        }
                        // TODO: now that I'm doing the collapsible panels, this logic isn't quite right, it leaves some space at bottom
                        // because the prefHeight was chosen based on flowing using prefWidth... but in reality, we stretch in x because of some other pane
                        int prefWidth = calcMaxChildPreferredWidth(this) + 2*5; // 5 = flow layout's hgap
                        prefWidth += 8; // fudge for known current items: to get two slightly longer first rows instead of short third row
                        int prefHeight = calcFlowLayoutPreferredHeightGivenPreferredWidth(this, prefWidth);
                        // Experts advise don't ever use this, override getMinimumSize and getPreferredSize instead...
                        // whatever, this is far simpler.
                        setPreferredSize(new java.awt.Dimension(prefWidth, prefHeight));
                        setMinimumSize(new java.awt.Dimension(prefWidth, prefHeight));
                    }}, stretchx);
                }}), stretchx);
                contentPane.add(new JSeparator(), stretchx);
                contentPane.add(MakeCollapsibleSection("Topological modifications", applet.theControlPanelWindow, new JRow() {{
                    setVisible(false);
                    add(new JLabel("        ")); // indent a bit
                    add(new JButton("Maybe make more difficult by truncating") {{
                        setMargin(nomargin); // gets rid of space around button label
                        addActionListener(new java.awt.event.ActionListener() {
                            @Override public void actionPerformed(java.awt.event.ActionEvent e)
                            {
                                UndoItem.State before = applet.newUndoItemState();

                                double truncationFrac = .9;
                                MeshUtils.maybeMakeMoreDifficultByTruncatingDual(applet.mesh,
                                                                                 applet.getDualMesh(),
                                                                                 truncationFrac,
                                                                                 applet.randomNumberGenerator);
                                applet.dirtyDualMesh();
                                if (applet.continuouslyDelaunayizeFlag.get()) applet.delaunayize(); // probably not necessary though
                                UndoItem.State after = applet.newUndoItemState();
                                applet.undoTreeSquirrel.Do(new UndoItem(before, after));
                                applet.dirtyDualMesh(); // XXX why is this necessary here, and not, for example, for Delaunayize? I'm confused. need get straight on this.
                                applet.theCanvas.repaint();
                            }
                        });
                    }});
                }}));
                contentPane.add(new JSeparator(), stretchx);
                contentPane.add(MakeCollapsibleSection("Optimization of primal vertex heights (dual plane offsets)", applet.theControlPanelWindow, new JRow() {{
                    setVisible(false);
                    add(new JLabel("        ")); // indent a bit
                    add(new JCol() {{
                        add(new JRow() {{
                            add(new JCheckBox("Optimize", applet.optimizeFlag.get()) {{
                                    addItemListener(new java.awt.event.ItemListener() {
                                        @Override public void itemStateChanged(java.awt.event.ItemEvent e)
                                        {
                                            UndoItem.State before = applet.newUndoItemState();
                                            applet.optimizeFlag.set(isSelected());
                                            System.out.println("optimizeFlag -> "+applet.optimizeFlag.get());
                                            if (applet.continuouslyDelaunayizeFlag.get()) applet.delaunayize();
                                            UndoItem.State after = applet.newUndoItemState();
                                            applet.undoTreeSquirrel.Do(new UndoItem(before, after));
                                            applet.dirtyDualMesh(); // XXX why is this necessary here, and not, for example, for Delaunayize? I'm confused
                                            applet.theCanvas.repaint();
                                        }
                                    });
                                    applet.optimizeFlag.addListener(applet.optimizeFlagListener = new Listenable.Listener() {
                                        @Override public void valueChanged()
                                        {
                                            setSelected(applet.optimizeFlag.get()); // of the checkbox
                                        }
                                    });
                                }
                            });

                            add(new JComboBox<String>() {{


                                FORI (i, Mesh.optimizationTypeNames.length)
                                    addItem(Mesh.optimizationTypeNames[Mesh.availableOptimizationTypes[i]]);

                                setSelectedIndex(applet.optimizationTypeIndex.get());
                                addItemListener(new java.awt.event.ItemListener() {
                                    @Override public void itemStateChanged(java.awt.event.ItemEvent e)
                                    {
                                        int newValue = getSelectedIndex();
                                        if (newValue != applet.optimizationTypeIndex.get())
                                        {
                                            UndoItem.State before = applet.newUndoItemState();


                                            applet.optimizationTypeIndex.set(newValue);
                                            applet.optimizationType = Mesh.availableOptimizationTypes[applet.optimizationTypeIndex.get()];
                                            System.out.println("optimizationType -> "+Mesh.optimizationTypeNames[applet.optimizationType]);


                                            if (applet.continuouslyDelaunayizeFlag.get()) applet.delaunayize();
                                            UndoItem.State after = applet.newUndoItemState();
                                            applet.undoTreeSquirrel.Do(new UndoItem(before, after));
                                            applet.dirtyDualMesh(); // XXX why is this necessary here, and not, for example, for Delaunayize? I'm confused
                                            applet.theCanvas.repaint();
                                            System.out.println("calling repaint!");
                                        }
                                    }
                                });
                                applet.optimizationTypeIndex.addListener(applet.optimizationTypeIndexListener = new Listenable.Listener() {
                                    @Override public void valueChanged()
                                    {
                                        int newValue = applet.optimizationTypeIndex.get();
                                        if (newValue != getSelectedIndex())
                                            setSelectedIndex(newValue);
                                    }
                                });
                            }});
                            add(new JLabel("  "));
                            add(new JRow() {
                                String toolTipText = "<html>Apply tiepoints, which should be an even-length list of numbers, interpreted as {primal radius, dual radius} pairs.<br>Identity mapping is \"0. 0. 1. 1.\" or simply empty string.</html>";
                            {
                                add(new JCol() {{
                                    add(new JButton("Prewarp") {{
                                        setToolTipText("<html>Pre-warp x,y positions so that, if original distribution was uniform, distribution after radial match will again be uniform</html>");
                                        setMargin(nomargin); // gets rid of space around button label
                                        addActionListener(new java.awt.event.ActionListener() {
                                            @Override public void actionPerformed(java.awt.event.ActionEvent e)
                                            {
                                                applet.preWarpForRadialHeightField();
                                            }
                                        });
                                    }});
                                    add(new JButton("Un-prewarp") {{
                                        setToolTipText("<html>Undo effect of Prewarp.</html>");
                                        setMargin(nomargin); // gets rid of space around button label
                                        addActionListener(new java.awt.event.ActionListener() {
                                            @Override public void actionPerformed(java.awt.event.ActionEvent e)
                                            {
                                                applet.unPreWarpForRadialHeightField();
                                            }
                                        });
                                    }});
                                }});
                                add(new JButton("Apply radial match:") {{
                                    setToolTipText(toolTipText);
                                    setMargin(nomargin); // gets rid of space around button label
                                    addActionListener(new java.awt.event.ActionListener() {
                                        @Override public void actionPerformed(java.awt.event.ActionEvent e)
                                        {
                                            // name "ReSpherize" is accurate only if radial heightfield is identity
                                            applet.turnOffOptimizeAndReSpherize();
                                        }
                                    });
                                }});
                                add(new JTextFieldForString(applet.radialHeightFieldSpec) {
                                    {setToolTipText(toolTipText);}
                                    @Override public boolean validate(String text)
                                    {
                                        return MeshUtils.parseRadialHeightFieldPairs(text) != null;
                                    }
                                }, stretchx);
                                add(new JCol() {{
                                    add(new JButton() {{
                                        final String whatToSetItTo = "0. 0.  1. 1.";
                                        setToolTipText("<html>Set it to "+whatToSetItTo+"</html>");
                                        setMargin(nomargin); // gets rid of space around button label
                                        setPreferredSize(new java.awt.Dimension(5*hidpimag,5*hidpimag));
                                        setMinimumSize(new java.awt.Dimension(5*hidpimag,5*hidpimag));
                                        addActionListener(new java.awt.event.ActionListener() {
                                            @Override public void actionPerformed(java.awt.event.ActionEvent e)
                                            {
                                                applet.radialHeightFieldSpec.set(whatToSetItTo);
                                            }
                                        });
                                    }});
                                    add(new JButton() {{
                                        final String whatToSetItTo = ".06 .095  .14 .105    .16 .195  .24 .205    .26 .295  .34 .305  .36 .395  .44 .405  .46 .495";
                                        setToolTipText("<html>Set it to "+whatToSetItTo+"</html>");
                                        setMargin(nomargin); // gets rid of space around button label
                                        setPreferredSize(new java.awt.Dimension(5*hidpimag,5*hidpimag));
                                        setMinimumSize(new java.awt.Dimension(5*hidpimag,5*hidpimag));
                                        addActionListener(new java.awt.event.ActionListener() {
                                            @Override public void actionPerformed(java.awt.event.ActionEvent e)
                                            {
                                                applet.radialHeightFieldSpec.set(whatToSetItTo);
                                            }
                                        });
                                    }});
                                    add(new JButton() {{
                                        final String whatToSetItTo = ".055 .075  .145 .125    .155 .175  .245 .225    .255 .275  .345 .325  .355 .375  .445 .425  .455 .475";
                                        setToolTipText("<html>Set it to "+whatToSetItTo+"</html>");
                                        setMargin(nomargin); // gets rid of space around button label
                                        setPreferredSize(new java.awt.Dimension(5*hidpimag,5*hidpimag));
                                        setMinimumSize(new java.awt.Dimension(5*hidpimag,5*hidpimag));
                                        addActionListener(new java.awt.event.ActionListener() {
                                            @Override public void actionPerformed(java.awt.event.ActionEvent e)
                                            {
                                                applet.radialHeightFieldSpec.set(whatToSetItTo);
                                            }
                                        });
                                    }});
                                }});
                            }}, stretchx);
                        }}, stretchx);
                    }}, stretchx);
                }}));
                contentPane.add(new JSeparator(), stretchx);
                contentPane.add(MakeCollapsibleSection("Behavior", applet.theControlPanelWindow, new JRow() {{
                    setVisible(false);
                    add(new JLabel("        ")); // indent a bit
                    add(new JCol() {{
                        add(new JRow() {{
                            add(new JCheckBox("Keep delaunayized", applet.continuouslyDelaunayizeFlag.get()) {{
                                    setToolTipText("<html>Turning this on delaunayizes the triangulation (i.e. untangles the dual mesh) and keeps it delaunayized on every mesh editing operation.<br>To just delaunayize it once, turn this on and then off again.</html>");
                                    addItemListener(new java.awt.event.ItemListener() {
                                        @Override public void itemStateChanged(java.awt.event.ItemEvent e)
                                        {
                                            UndoItem.State before = applet.newUndoItemState();
                                            applet.continuouslyDelaunayizeFlag.set(isSelected());
                                            System.out.println("continuouslyDelaunayizeFlag -> "+applet.continuouslyDelaunayizeFlag.get());
                                            if (applet.continuouslyDelaunayizeFlag.get()) applet.delaunayize();
                                            UndoItem.State after = applet.newUndoItemState();
                                            applet.undoTreeSquirrel.Do(new UndoItem(before, after));
                                            applet.theCanvas.repaint();
                                        }
                                    });
                                    applet.continuouslyDelaunayizeFlag.addListener(applet.continuouslyDelaunayizeFlagListener = new Listenable.Listener() {
                                        @Override public void valueChanged()
                                        {
                                            setSelected(applet.continuouslyDelaunayizeFlag.get()); // of the checkbox
                                            // XXX wait a minute, isn't this where we should delaunayize, rather than above?
                                        }
                                    });
                                }
                            });
                            add(new JCheckBoxForBoolean("Calc underside when delaunayizing, and second dual sheet (must be false for most net generation)", applet.calcInsideOutDualVertsFlag));
                        }});
                    }});
                }}));
                contentPane.add(new JSeparator(), stretchx);
                contentPane.add(MakeCollapsibleSection("Appearance/Transforms", applet.theControlPanelWindow, new JRow() {{
                    setVisible(false);
                    add(new JLabel("        ")); // indent a bit
                    add(new JCol() {{
                        add(new JRow() {{
                            add(new JRow() {{
                                {setToolTipText("<html>Scale primal (white figure)<br>while adusting heights of primal vertices so as to leave dual stationary.<html>");}
                                add(new JLabel("<html>Scale<br>primal<br>only:</html>"));
                                add(new JTablePanel() {{
                                    add(new JLabel(""));
                                    add(new JLabel(""));
                                    add(new JRepeatingButton("") {
                                        @Override public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(20*hidpimag,20*hidpimag); }
                                        @Override public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(20*hidpimag,20*hidpimag); }
                                        @Override public void paint(java.awt.Graphics g)
                                        {
                                            drawPixmapCentered(g, getSize(), hidpimag, asciiToColor,
                                                               new String[] {
                                                                  "                 ",
                                                                  "        w        ",
                                                                  "       www       ",
                                                                  "      ww ww      ",
                                                                  "                 ",
                                                                  "                 ",
                                                                  "   w         w   ",
                                                                  "  ww         ww  ",
                                                                  " ww           ww ",
                                                                  "  ww         ww  ",
                                                                  "   w         w   ",
                                                                  "                 ",
                                                                  "                 ",
                                                                  "      ww ww      ",
                                                                  "       www       ",
                                                                  "        w        ",
                                                                  "                 ",
                                                               });
                                        }
                                    {
                                        addActionListener(new java.awt.event.ActionListener() {
                                            @Override public void actionPerformed(java.awt.event.ActionEvent e)
                                            {
                                                applet.rescalePrimalOnly(Math.sqrt(2.));
                                            }
                                        });
                                    }}, stretchxy);
                                    advanceRow();
                                    add(new JLabel(""));
                                    add(new JButton("f") {
                                        @Override public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(20*hidpimag,20*hidpimag); }
                                        @Override public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(20*hidpimag,20*hidpimag); }
                                        @Override public void paint(java.awt.Graphics g)
                                        {
                                            drawPixmapCentered(g, getSize(), hidpimag, asciiToColor,
                                                               new String[] {
                                                                  "wwwwwwwwwwwwwww",
                                                                  "w  w   w   w  w",
                                                                  "w  w   w   w  w",
                                                                  "wwwwwwwwwwwwwww",
                                                                  "w  w       w  w",
                                                                  "w  w  www  w  w",
                                                                  "w  w  w    w  w",
                                                                  "wwww  ww   wwww",
                                                                  "w  w  w    w  w",
                                                                  "w  w  w    w  w",
                                                                  "w  w       w  w",
                                                                  "wwwwwwwwwwwwwww",
                                                                  "w  w   w   w  w",
                                                                  "w  w   w   w  w",
                                                                  "wwwwwwwwwwwwwww",
                                                               });
                                        }
                                    {
                                        {setToolTipText("frame primal (white figure). ctrl to not bring dual along.");}
                                        addActionListener(new java.awt.event.ActionListener() {
                                            @Override public void actionPerformed(java.awt.event.ActionEvent e)
                                            {
                                                boolean controlIsDown = ((e.getModifiers() & java.awt.event.ActionEvent.CTRL_MASK) != 0);
                                                boolean gangFlag = !controlIsDown;
                                                applet.frame(true,false,gangFlag);
                                            }
                                        });
                                    }}, stretchxy);
                                    add(new JLabel(""));
                                    advanceRow();
                                    add(new JRepeatingButton("") {
                                        @Override public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(20*hidpimag,20*hidpimag); }
                                        @Override public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(20*hidpimag,20*hidpimag); }
                                        @Override public void paint(java.awt.Graphics g)
                                        {
                                            drawPixmapCentered(g, getSize(), hidpimag, asciiToColor,
                                                               new String[] {
                                                                  "                 ",
                                                                  "                 ",
                                                                  "                 ",
                                                                  "                 ",
                                                                  "      ww ww      ",
                                                                  "       www       ",
                                                                  "    w   w   w    ",
                                                                  "    ww     ww    ",
                                                                  "     ww   ww     ",
                                                                  "    ww     ww    ",
                                                                  "    w   w   w    ",
                                                                  "       www       ",
                                                                  "      ww ww      ",
                                                                  "                 ",
                                                                  "                 ",
                                                                  "                 ",
                                                                  "                 ",
                                                               });
                                        }
                                    {
                                        addActionListener(new java.awt.event.ActionListener() {
                                            @Override public void actionPerformed(java.awt.event.ActionEvent e)
                                            {
                                                applet.rescalePrimalOnly(1./Math.sqrt(2.));
                                            }
                                        });
                                    }}, stretchxy);
                                    add(new JLabel(""));
                                    add(new JLabel(""));
                                }}); // table
                            }});
                            add(new JRow() {{
                                {setToolTipText("<html>Pan primal (white figure)<br>while adusting heights of primal vertices so as to leave dual stationary.<html>");}
                                add(new JLabel("<html>Pan<br>primal<br>only:</html>"), rightjustify); // TODO: right justify isn't working here

                                final java.awt.Color asciiToColor[] = new java.awt.Color[128];
                                asciiToColor[' '] = java.awt.Color.BLACK;
                                asciiToColor['*'] = java.awt.Color.WHITE;
                                add(new JTableOfPanIcons(5,5,asciiToColor) {
                                    // note, dup code in the three tables of pan icons
                                    final double panIncr = 1./256;
                                    final double PanIncr = 1./16;
                                    final double panIncrs[] = {-panIncr,0,panIncr};
                                    final double PanIncrs[] = {-PanIncr,-PanIncr/2,0,PanIncr/2,PanIncr};
                                    // implement abstract superclass's
                                    @Override public void buttonPressed(int iCol, int iRow)
                                    {
                                        iRow = PanIncrs.length-1-iRow;
                                        if (INRANGE(1<=,iCol,<=3)
                                         && INRANGE(1<=,iRow,<=3))
                                          applet.panPrimalOnly(panIncrs[iCol-1], panIncrs[iRow-1]);
                                        else
                                          applet.panPrimalOnly(PanIncrs[iCol], PanIncrs[iRow]);
                                    }
                                });
                            }});
                            add(new JRow() {{
                                add(new JLabel("Scale: "));
                                add(new JTablePanel() {{
                                    add(new JRepeatingButton("") {
                                        @Override public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(20*hidpimag,20*hidpimag); }
                                        @Override public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(20*hidpimag,20*hidpimag); }
                                        @Override public void paint(java.awt.Graphics g)
                                        {
                                            drawPixmapCentered(g, getSize(), hidpimag, asciiToColor,
                                                               new String[] {
                                                                  "        w        ",
                                                                  "       www       ",
                                                                  "      ww ww      ",
                                                                  "                 ",
                                                                  "      BB BB      ",
                                                                  "       BBB       ",
                                                                  "  B w   B   w B  ",
                                                                  " BB ww     ww BB ",
                                                                  "BB   ww   ww   BB",
                                                                  " BB ww     ww BB ",
                                                                  "  B w   B   w B  ",
                                                                  "       BBB       ",
                                                                  "      BB BB      ",
                                                                  "                 ",
                                                                  "      ww ww      ",
                                                                  "       www       ",
                                                                  "        w        ",
                                                               });
                                        }
                                    {
                                        addActionListener(new java.awt.event.ActionListener() {
                                            @Override public void actionPerformed(java.awt.event.ActionEvent e)
                                            {
                                                applet.rescale(1./Math.sqrt(2.), Math.sqrt(2.));
                                            }
                                        });
                                    }}, stretchxy);
                                    add(new JRepeatingButton("") {
                                        @Override public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(20*hidpimag,20*hidpimag); }
                                        @Override public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(20*hidpimag,20*hidpimag); }
                                        @Override public void paint(java.awt.Graphics g)
                                        {
                                            drawPixmapCentered(g, getSize(), hidpimag, asciiToColor,
                                                               new String[] {
                                                                  "                 ",
                                                                  "        w        ",
                                                                  "       www       ",
                                                                  "      ww ww      ",
                                                                  "                 ",
                                                                  "                 ",
                                                                  "   B         B   ",
                                                                  "  BB         BB  ",
                                                                  " BB           BB ",
                                                                  "  BB         BB  ",
                                                                  "   B         B   ",
                                                                  "                 ",
                                                                  "                 ",
                                                                  "      ww ww      ",
                                                                  "       www       ",
                                                                  "        w        ",
                                                                  "                 ",
                                                               });
                                        }
                                    {
                                        addActionListener(new java.awt.event.ActionListener() {
                                            @Override public void actionPerformed(java.awt.event.ActionEvent e)
                                            {
                                                applet.rescale(1., Math.sqrt(2.));
                                            }
                                        });
                                    }}, stretchxy);
                                    add(new JRepeatingButton("") {
                                        @Override public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(20*hidpimag,20*hidpimag); }
                                        @Override public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(20*hidpimag,20*hidpimag); }
                                        @Override public void paint(java.awt.Graphics g)
                                        {
                                            drawPixmapCentered(g, getSize(), hidpimag, asciiToColor,
                                                               new String[] {
                                                                  "                 ",
                                                                  "        b        ",
                                                                  "       bbb       ",
                                                                  "      bb bb      ",
                                                                  "                 ",
                                                                  "                 ",
                                                                  "   b         b   ",
                                                                  "  bb         bb  ",
                                                                  " bb           bb ",
                                                                  "  bb         bb  ",
                                                                  "   b         b   ",
                                                                  "                 ",
                                                                  "                 ",
                                                                  "      bb bb      ",
                                                                  "       bbb       ",
                                                                  "        b        ",
                                                                  "                 ",
                                                               });
                                        }
                                    {
                                        addActionListener(new java.awt.event.ActionListener() {
                                            @Override public void actionPerformed(java.awt.event.ActionEvent e)
                                            {
                                                applet.rescale(Math.sqrt(2.), Math.sqrt(2.));
                                            }
                                        });
                                    }}, stretchxy);
                                    advanceRow();
                                    add(new JRepeatingButton("") {
                                        @Override public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(20*hidpimag,20*hidpimag); }
                                        @Override public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(20*hidpimag,20*hidpimag); }
                                        @Override public void paint(java.awt.Graphics g)
                                        {
                                            drawPixmapCentered(g, getSize(), hidpimag, asciiToColor,
                                                               new String[] {
                                                                  "                 ",
                                                                  "                 ",
                                                                  "                 ",
                                                                  "      BB BB      ",
                                                                  "       BBB       ",
                                                                  "    w   B   w    ",
                                                                  "    ww     ww    ",
                                                                  "     ww   ww     ",
                                                                  "    ww     ww    ",
                                                                  "    w   B   w    ",
                                                                  "       BBB       ",
                                                                  "      BB BB      ",
                                                                  "                 ",
                                                                  "                 ",
                                                                  "                 ",
                                                               });
                                        }
                                    {
                                        addActionListener(new java.awt.event.ActionListener() {
                                            @Override public void actionPerformed(java.awt.event.ActionEvent e)
                                            {
                                                applet.rescale(1./Math.sqrt(2.), 1.);
                                            }
                                        });
                                    }}, stretchxy);
                                    add(new JButton("f") {
                                        @Override public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(20*hidpimag,20*hidpimag); }
                                        @Override public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(20*hidpimag,20*hidpimag); }
                                        @Override public void paint(java.awt.Graphics g)
                                        {
                                            drawPixmapCentered(g, getSize(), hidpimag, asciiToColor,
                                                               new String[] {
                                                                  "bbbbbbbbbbbbbbb",
                                                                  "b  b   b   b  b",
                                                                  "b  b   b   b  b",
                                                                  "bbbbbbbbbbbbbbb",
                                                                  "b  b       b  b",
                                                                  "b  b  bbb  b  b",
                                                                  "b  b  b    b  b",
                                                                  "bbbb  bb   bbbb",
                                                                  "b  b  b    b  b",
                                                                  "b  b  b    b  b",
                                                                  "b  b       b  b",
                                                                  "bbbbbbbbbbbbbbb",
                                                                  "b  b   b   b  b",
                                                                  "b  b   b   b  b",
                                                                  "bbbbbbbbbbbbbbb",
                                                               });
                                        }
                                    {
                                        {setToolTipText("frame both primal (white) and dual (blue). ctrl to frame them independently.");}
                                        addActionListener(new java.awt.event.ActionListener() {
                                            @Override public void actionPerformed(java.awt.event.ActionEvent e)
                                            {
                                                boolean controlIsDown = ((e.getModifiers() & java.awt.event.ActionEvent.CTRL_MASK) != 0);
                                                boolean gangFlag = !controlIsDown;
                                                applet.frame(true,true,gangFlag);
                                            }
                                        });
                                    }}, stretchxy);
                                    add(new JRepeatingButton("") {
                                        @Override public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(20*hidpimag,20*hidpimag); }
                                        @Override public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(20*hidpimag,20*hidpimag); }
                                        @Override public void paint(java.awt.Graphics g)
                                        {
                                            drawPixmapCentered(g, getSize(), hidpimag, asciiToColor,
                                                               // leave 4 spaces horizontally, 2 spaces vertically
                                                               new String[] {
                                                                  "                 ",
                                                                  "        B        ",
                                                                  "       BBB       ",
                                                                  "      BB BB      ",
                                                                  "                 ",
                                                                  "                 ",
                                                                  "   w         w   ",
                                                                  "  ww         ww  ",
                                                                  " ww           ww ",
                                                                  "  ww         ww  ",
                                                                  "   w         w   ",
                                                                  "                 ",
                                                                  "                 ",
                                                                  "      BB BB      ",
                                                                  "       BBB       ",
                                                                  "        B        ",
                                                                  "                 ",
                                                               });
                                        }
                                    {
                                        addActionListener(new java.awt.event.ActionListener() {
                                            @Override public void actionPerformed(java.awt.event.ActionEvent e)
                                            {
                                                applet.rescale(Math.sqrt(2.), 1.);
                                            }
                                        });
                                    }}, stretchxy);
                                    advanceRow();
                                    add(new JRepeatingButton("") {
                                        @Override public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(20*hidpimag,20*hidpimag); }
                                        @Override public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(20*hidpimag,20*hidpimag); }
                                        @Override public void paint(java.awt.Graphics g)
                                        {
                                            drawPixmapCentered(g, getSize(), hidpimag, asciiToColor,
                                                               new String[] {
                                                                  "                 ",
                                                                  "                 ",
                                                                  "                 ",
                                                                  "                 ",
                                                                  "      bb bb      ",
                                                                  "       bbb       ",
                                                                  "    b   b   b    ",
                                                                  "    bb     bb    ",
                                                                  "     bb   bb     ",
                                                                  "    bb     bb    ",
                                                                  "    b   b   b    ",
                                                                  "       bbb       ",
                                                                  "      bb bb      ",
                                                                  "                 ",
                                                                  "                 ",
                                                                  "                 ",
                                                                  "                 ",
                                                               });
                                        }
                                    {
                                        addActionListener(new java.awt.event.ActionListener() {
                                            @Override public void actionPerformed(java.awt.event.ActionEvent e)
                                            {
                                                applet.rescale(1./Math.sqrt(2.), 1./Math.sqrt(2.));
                                            }
                                        });
                                    }}, stretchxy);
                                    add(new JRepeatingButton("") {
                                        @Override public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(20*hidpimag,20*hidpimag); }
                                        @Override public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(20*hidpimag,20*hidpimag); }
                                        @Override public void paint(java.awt.Graphics g)
                                        {
                                            drawPixmapCentered(g, getSize(), hidpimag, asciiToColor,
                                                               new String[] {
                                                                  "                 ",
                                                                  "                 ",
                                                                  "                 ",
                                                                  "                 ",
                                                                  "      ww ww      ",
                                                                  "       www       ",
                                                                  "    B   w   B    ",
                                                                  "    BB     BB    ",
                                                                  "     BB   BB     ",
                                                                  "    BB     BB    ",
                                                                  "    B   w   B    ",
                                                                  "       www       ",
                                                                  "      ww ww      ",
                                                                  "                 ",
                                                                  "                 ",
                                                                  "                 ",
                                                                  "                 ",
                                                               });
                                        }
                                    {
                                        addActionListener(new java.awt.event.ActionListener() {
                                            @Override public void actionPerformed(java.awt.event.ActionEvent e)
                                            {
                                                applet.rescale(1., 1./Math.sqrt(2.));
                                            }
                                        });
                                    }}, stretchxy);
                                    add(new JRepeatingButton("") {
                                        @Override public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(20*hidpimag,20*hidpimag); }
                                        @Override public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(20*hidpimag,20*hidpimag); }
                                        @Override public void paint(java.awt.Graphics g)
                                        {
                                            drawPixmapCentered(g, getSize(), hidpimag, asciiToColor,
                                                               new String[] {
                                                                  "        B        ",
                                                                  "       BBB       ",
                                                                  "      BB BB      ",
                                                                  "                 ",
                                                                  "      ww ww      ",
                                                                  "       www       ",
                                                                  "  w B   w   B w  ",
                                                                  " ww BB     BB ww ",
                                                                  "ww   BB   BB   ww",
                                                                  " ww BB     BB ww ",
                                                                  "  w B   w   B w  ",
                                                                  "       www       ",
                                                                  "      ww ww      ",
                                                                  "                 ",
                                                                  "      BB BB      ",
                                                                  "       BBB       ",
                                                                  "        B        ",
                                                               });
                                        }
                                    {
                                        addActionListener(new java.awt.event.ActionListener() {
                                            @Override public void actionPerformed(java.awt.event.ActionEvent e)
                                            {
                                                applet.rescale(Math.sqrt(2.), 1./Math.sqrt(2.));
                                            }
                                        });
                                    }}, stretchxy);
                                }}); // table
                            }});
                            add(new JRow() {{
                                add(new JLabel("<html>Pan: </html>"), rightjustify); // TODO: right justify isn't working here

                                final java.awt.Color asciiToColor[] = new java.awt.Color[128];
                                asciiToColor[' '] = java.awt.Color.BLACK;
                                asciiToColor['*'] = new java.awt.Color(224,224,255); // very light blue
                                add(new JTableOfPanIcons(5,5,asciiToColor) {
                                    // note, dup code in the three tables of pan icons
                                    final double panIncr = 1./256;
                                    final double PanIncr = 1./16;
                                    final double panIncrs[] = {-panIncr,0,panIncr};
                                    final double PanIncrs[] = {-PanIncr,-PanIncr/2,0,PanIncr/2,PanIncr};
                                    // implement abstract superclass's
                                    @Override public void buttonPressed(int iCol, int iRow)
                                    {
                                        iRow = PanIncrs.length-1-iRow;
                                        if (INRANGE(1<=,iCol,<=3)
                                         && INRANGE(1<=,iRow,<=3))
                                          applet.pan(panIncrs[iCol-1], panIncrs[iRow-1]);
                                        else
                                          applet.pan(PanIncrs[iCol], PanIncrs[iRow]);
                                    }
                                });
                            }});
                            add(new JRow() {{
                                {setToolTipText("<html>Scale dual (blue figure)<br>by adjusting heights of primal vertices.<html>");}
                                add(new JLabel("<html>Scale<br>dual<br>only: </html>"), rightjustify); // TODO: right justify isn't working here
                                add(new JTablePanel() {{
                                    add(new JLabel(""));
                                    add(new JLabel(""));
                                    add(new JRepeatingButton("") {
                                        @Override public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(20*hidpimag,20*hidpimag); }
                                        @Override public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(20*hidpimag,20*hidpimag); }
                                        @Override public void paint(java.awt.Graphics g)
                                        {
                                            drawPixmapCentered(g, getSize(), hidpimag, asciiToColor,
                                                               new String[] {
                                                                  "                 ",
                                                                  "        B        ",
                                                                  "       BBB       ",
                                                                  "      BB BB      ",
                                                                  "                 ",
                                                                  "                 ",
                                                                  "   B         B   ",
                                                                  "  BB         BB  ",
                                                                  " BB           BB ",
                                                                  "  BB         BB  ",
                                                                  "   B         B   ",
                                                                  "                 ",
                                                                  "                 ",
                                                                  "      BB BB      ",
                                                                  "       BBB       ",
                                                                  "        B        ",
                                                                  "                 ",
                                                               });
                                        }
                                    {
                                        addActionListener(new java.awt.event.ActionListener() {
                                            @Override public void actionPerformed(java.awt.event.ActionEvent e)
                                            {
                                                applet.rescaleDualOnly(Math.sqrt(2.));
                                            }
                                        });
                                    }}, stretchxy);
                                    advanceRow();
                                    add(new JLabel(""));
                                    add(new JButton("f") {
                                        @Override public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(20*hidpimag,20*hidpimag); }
                                        @Override public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(20*hidpimag,20*hidpimag); }
                                        @Override public void paint(java.awt.Graphics g)
                                        {
                                            drawPixmapCentered(g, getSize(), hidpimag, asciiToColor,
                                                               new String[] {
                                                                  "BBBBBBBBBBBBBBB",
                                                                  "B  B   B   B  B",
                                                                  "B  B   B   B  B",
                                                                  "BBBBBBBBBBBBBBB",
                                                                  "B  B       B  B",
                                                                  "B  B  BBB  B  B",
                                                                  "B  B  B    B  B",
                                                                  "BBBB  BB   BBBB",
                                                                  "B  B  B    B  B",
                                                                  "B  B  B    B  B",
                                                                  "B  B       B  B",
                                                                  "BBBBBBBBBBBBBBB",
                                                                  "B  B   B   B  B",
                                                                  "B  B   B   B  B",
                                                                  "BBBBBBBBBBBBBBB",
                                                               });
                                        }
                                    {
                                        {setToolTipText("frame dual (blue figure). ctrl to not bring primal along.");}
                                        addActionListener(new java.awt.event.ActionListener() {
                                            @Override public void actionPerformed(java.awt.event.ActionEvent e)
                                            {
                                                boolean controlIsDown = ((e.getModifiers() & java.awt.event.ActionEvent.CTRL_MASK) != 0);
                                                boolean gangFlag = !controlIsDown;
                                                applet.frame(false,true,gangFlag);
                                            }
                                        });
                                    }}, stretchxy);
                                    add(new JLabel(""));
                                    advanceRow();
                                    add(new JRepeatingButton("") {
                                        @Override public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(20*hidpimag,20*hidpimag); }
                                        @Override public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(20*hidpimag,20*hidpimag); }
                                        @Override public void paint(java.awt.Graphics g)
                                        {
                                            drawPixmapCentered(g, getSize(), hidpimag, asciiToColor,
                                                               new String[] {
                                                                  "                 ",
                                                                  "                 ",
                                                                  "                 ",
                                                                  "                 ",
                                                                  "      BB BB      ",
                                                                  "       BBB       ",
                                                                  "    B   B   B    ",
                                                                  "    BB     BB    ",
                                                                  "     BB   BB     ",
                                                                  "    BB     BB    ",
                                                                  "    B   B   B    ",
                                                                  "       BBB       ",
                                                                  "      BB BB      ",
                                                                  "                 ",
                                                                  "                 ",
                                                                  "                 ",
                                                                  "                 ",
                                                               });
                                        }
                                    {
                                        addActionListener(new java.awt.event.ActionListener() {
                                            @Override public void actionPerformed(java.awt.event.ActionEvent e)
                                            {
                                                applet.rescaleDualOnly(1./Math.sqrt(2.));
                                            }
                                        });
                                    }}, stretchxy);
                                    add(new JLabel(""));
                                    add(new JLabel(""));
                                }}); // table
                            }});
                            add(new JRow() {{
                                {setToolTipText("<html>Pan dual (blue figure)<br>by adjusting heights of primal vertices.<html>");}
                                add(new JLabel("<html>Pan<br>dual<br>only: </html>"), rightjustify); // TODO: right justify isn't working here

                                final java.awt.Color asciiToColor[] = new java.awt.Color[128];
                                asciiToColor[' '] = java.awt.Color.BLACK;
                                asciiToColor['*'] = new java.awt.Color(64,64,255); // slightly light blue
                                add(new JTableOfPanIcons(5,5,asciiToColor) {
                                    // note, dup code in the three tables of pan icons
                                    final double panIncr = 1./256;
                                    final double PanIncr = 1./16;
                                    final double panIncrs[] = {-panIncr,0,panIncr};
                                    final double PanIncrs[] = {-PanIncr,-PanIncr/2,0,PanIncr/2,PanIncr};
                                    // implement abstract superclass's
                                    @Override public void buttonPressed(int iCol, int iRow)
                                    {
                                        iRow = PanIncrs.length-1-iRow;
                                        if (INRANGE(1<=,iCol,<=3)
                                         && INRANGE(1<=,iRow,<=3))
                                          applet.panDualOnly(panIncrs[iCol-1], panIncrs[iRow-1]);
                                        else
                                          applet.panDualOnly(PanIncrs[iCol], PanIncrs[iRow]);
                                    }
                                });
                            }});
                            add(new JLabel("        "));
                            add(new JCol() {{
                                add(new JRow() {{
                                    add(new JLabel("Rot: "));
                                    add(new JTablePanel() {{
                                        add(new JRepeatingButton("CCW") {
                                            @Override public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(13*hidpimag,13*hidpimag); }
                                            @Override public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(13*hidpimag,13*hidpimag); }
                                            @Override public void paint(java.awt.Graphics g)
                                            {
                                                drawPixmapCentered(g, getSize(), hidpimag, asciiToColor,
                                                                   new String[] {
                                                                      "         ",
                                                                      "   bbbbb ",
                                                                      "   b     ",
                                                                      "   b     ",
                                                                      "   b     ",
                                                                      " bbbbb   ",
                                                                      "  bbb    ",
                                                                      "   b     ",
                                                                      "         ",
                                                                   });
                                            }
                                            {
                                                setToolTipText("<html>rotate CCW 90 degrees.<br>shift: 45 degrees and expand by sqrt(2).<br>ctrl: 1 degree</html>");
                                                addActionListener(new java.awt.event.ActionListener() {
                                                    @Override public void actionPerformed(java.awt.event.ActionEvent e)
                                                    {
                                                        UndoItem.State before = applet.newUndoItemState();

                                                        if (false)
                                                        {
                                                            // cop out
                                                            applet.mesh.flipUpperLeftLowerRight();
                                                            applet.mesh.flipLeftRight();
                                                            applet.dirtyDualMesh(); // flip doesn't work when verts missing
                                                            // should be no need to re-delaunayize
                                                        }
                                                        else
                                                        {
                                                            double mat[][];
                                                            boolean shiftIsDown = ((e.getModifiers() & java.awt.event.ActionEvent.SHIFT_MASK) != 0);
                                                            boolean controlIsDown = ((e.getModifiers() & java.awt.event.ActionEvent.CTRL_MASK) != 0);
                                                            if (shiftIsDown)
                                                            {
                                                                mat = new double[][] {
                                                                    {1,1,0,0},
                                                                    {-1,1,0,0},
                                                                    {0,0,2,0},
                                                                    {0,0,0,1},
                                                                };
                                                            }
                                                            else if (controlIsDown)
                                                            {
                                                                double c = Math.cos(DTOR(1.));
                                                                double s = Math.sin(DTOR(1.));
                                                                mat = new double[][] {
                                                                    {c,s,0,0},
                                                                    {-s,c,0,0},
                                                                    {0,0,1,0},
                                                                    {0,0,0,1},
                                                                };
                                                            }
                                                            else
                                                            {
                                                                mat = new double[][] {
                                                                    {0,1,0,0},
                                                                    {-1,0,0,0},
                                                                    {0,0,1,0},
                                                                    {0,0,0,1},
                                                                };
                                                            }
                                                            applet.xformTheMesh(mat);
                                                            // CBB: xformTheMesh dirties dual mesh-- could just xform the dual mesh too, instead
                                                            // CBB: xformTheMesh re-delaunayizes; should be no need for that
                                                        }

                                                        UndoItem.State after = applet.newUndoItemState();
                                                        applet.undoTreeSquirrel.Do(new UndoItem(before, after));
                                                        applet.theCanvas.repaint();
                                                    }
                                                });
                                            }
                                        });
                                        add(new JRepeatingButton("CW") {
                                            @Override public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(13*hidpimag,13*hidpimag); }
                                            @Override public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(13*hidpimag,13*hidpimag); }
                                            @Override public void paint(java.awt.Graphics g)
                                            {
                                                drawPixmapCentered(g, getSize(), hidpimag, asciiToColor,
                                                                   new String[] {
                                                                      "         ",
                                                                      " bbbbb   ",
                                                                      "     b   ",
                                                                      "     b   ",
                                                                      "     b   ",
                                                                      "   bbbbb ",
                                                                      "    bbb  ",
                                                                      "     b   ",
                                                                      "         ",
                                                                   });
                                            }
                                            {
                                                setToolTipText("<html>rotate CW 90 degrees.<br>shift: 45 degrees and expand by sqrt(2).<br>ctrl: 1 degree</html>");
                                                addActionListener(new java.awt.event.ActionListener() {
                                                    @Override public void actionPerformed(java.awt.event.ActionEvent e)
                                                    {
                                                        UndoItem.State before = applet.newUndoItemState();

                                                        if (false)
                                                        {
                                                            // cop out
                                                            applet.mesh.flipLowerLeftUpperRight();
                                                            applet.mesh.flipLeftRight();
                                                        }
                                                        else
                                                        {
                                                            double mat[][];
                                                            boolean shiftIsDown = ((e.getModifiers() & java.awt.event.ActionEvent.SHIFT_MASK) != 0);
                                                            boolean controlIsDown = ((e.getModifiers() & java.awt.event.ActionEvent.CTRL_MASK) != 0);
                                                            if (shiftIsDown)
                                                            {
                                                                mat = new double[][] {
                                                                    {1,-1,0,0},
                                                                    {1,1,0,0},
                                                                    {0,0,2,0},
                                                                    {0,0,0,1},
                                                                };
                                                            }
                                                            else if (controlIsDown)
                                                            {
                                                                double c = Math.cos(DTOR(1.));
                                                                double s = Math.sin(DTOR(1.));
                                                                mat = new double[][] {
                                                                    {c,-s,0,0},
                                                                    {s,c,0,0},
                                                                    {0,0,1,0},
                                                                    {0,0,0,1},
                                                                };
                                                            }
                                                            else
                                                            {
                                                                mat = new double[][] {
                                                                    {0,-1,0,0},
                                                                    {1,0,0,0},
                                                                    {0,0,1,0},
                                                                    {0,0,0,1},
                                                                };
                                                            }
                                                            applet.xformTheMesh(mat);
                                                            // CBB: xformTheMesh dirties dual mesh-- could just xform the dual mesh too, instead
                                                            // CBB: xformTheMesh re-delaunayizes; should be no need for that
                                                        }

                                                        applet.dirtyDualMesh(); // flip doesn't work when verts missing
                                                        // should be no need to re-delaunayize
                                                        UndoItem.State after = applet.newUndoItemState();
                                                        applet.undoTreeSquirrel.Do(new UndoItem(before, after));
                                                        applet.theCanvas.repaint();
                                                    }
                                                });
                                            }
                                        });
                                    }});
                                }});
                                add(new JLabel("")); // just a little vertical space
                                add(new JRow() {{
                                    add(new JLabel("Flip: "));
                                    add(new JTablePanel() {{
                                        add(new JRepeatingButton("/") {
                                            @Override public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(13*hidpimag,13*hidpimag); }
                                            @Override public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(13*hidpimag,13*hidpimag); }
                                            @Override public void paint(java.awt.Graphics g)
                                            {
                                                drawPixmapCentered(g, getSize(), hidpimag, asciiToColor,
                                                                   new String[] {
                                                                      "         ",
                                                                      " bbb   b ",
                                                                      " bb   b  ",
                                                                      " b b b   ",
                                                                      "    b    ",
                                                                      "   b b b ",
                                                                      "  b   bb ",
                                                                      " b   bbb ",
                                                                      "         ",
                                                                   });
                                            }
                                            {
                                                setToolTipText("reflect upper-left to lower-right");
                                                addActionListener(new java.awt.event.ActionListener() {
                                                    @Override public void actionPerformed(java.awt.event.ActionEvent e)
                                                    {
                                                        UndoItem.State before = applet.newUndoItemState();
                                                        applet.mesh.flipUpperLeftLowerRight();
                                                        applet.dirtyDualMesh(); // flip doesn't work when verts missing
                                                        // should be no need to re-delaunayize
                                                        UndoItem.State after = applet.newUndoItemState();
                                                        applet.undoTreeSquirrel.Do(new UndoItem(before, after));
                                                        applet.theCanvas.repaint();
                                                    }
                                                });
                                            }
                                        });
                                        add(new JRepeatingButton("-") {
                                            @Override public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(13*hidpimag,13*hidpimag); }
                                            @Override public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(13*hidpimag,13*hidpimag); }
                                            @Override public void paint(java.awt.Graphics g)
                                            {
                                                drawPixmapCentered(g, getSize(), hidpimag, asciiToColor,
                                                                   new String[] {
                                                                      "    b    ",
                                                                      "   bbb   ",
                                                                      "  bbbbb  ",
                                                                      "    b    ",
                                                                      "         ",
                                                                      " bbbbbbb ",
                                                                      "         ",
                                                                      "    b    ",
                                                                      "  bbbbb  ",
                                                                      "   bbb   ",
                                                                      "    b    ",
                                                                   });
                                            }
                                            {
                                                setToolTipText("flop");
                                                addActionListener(new java.awt.event.ActionListener() {
                                                    @Override public void actionPerformed(java.awt.event.ActionEvent e)
                                                    {
                                                        UndoItem.State before = applet.newUndoItemState();
                                                        applet.mesh.flipUpDown();
                                                        applet.dirtyDualMesh(); // flip doesn't work when verts missing
                                                        // should be no need to re-delaunayize
                                                        UndoItem.State after = applet.newUndoItemState();
                                                        applet.undoTreeSquirrel.Do(new UndoItem(before, after));
                                                        applet.theCanvas.repaint();
                                                    }
                                                });
                                            }
                                        });
                                        add(new JRepeatingButton("\\") {
                                            @Override public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(13*hidpimag,13*hidpimag); }
                                            @Override public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(13*hidpimag,13*hidpimag); }
                                            @Override public void paint(java.awt.Graphics g)
                                            {
                                                drawPixmapCentered(g, getSize(), hidpimag, asciiToColor,
                                                                   new String[] {
                                                                      "         ",
                                                                      " b   bbb ",
                                                                      "  b   bb ",
                                                                      "   b b b ",
                                                                      "    b    ",
                                                                      " b b b   ",
                                                                      " bb   b  ",
                                                                      " bbb   b ",
                                                                      "         ",
                                                                   });
                                            }
                                            {
                                                setToolTipText("reflect lower-left to upper-right");
                                                addActionListener(new java.awt.event.ActionListener() {
                                                    @Override public void actionPerformed(java.awt.event.ActionEvent e)
                                                    {
                                                        UndoItem.State before = applet.newUndoItemState();
                                                        applet.mesh.flipLowerLeftUpperRight();
                                                        applet.dirtyDualMesh(); // flip doesn't work when verts missing
                                                        // should be no need to re-delaunayize
                                                        UndoItem.State after = applet.newUndoItemState();
                                                        applet.undoTreeSquirrel.Do(new UndoItem(before, after));
                                                        applet.theCanvas.repaint();
                                                    }
                                                });
                                            }
                                        });
                                        advanceRow();
                                        add(new JRepeatingButton("|") {
                                            @Override public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(13*hidpimag,13*hidpimag); }
                                            @Override public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(13*hidpimag,13*hidpimag); }
                                            @Override public void paint(java.awt.Graphics g)
                                            {
                                                drawPixmapCentered(g, getSize(), hidpimag, asciiToColor,
                                                                   new String[] {
                                                                      "           ",
                                                                      "     b     ",
                                                                      "  b  b  b  ",
                                                                      " bb  b  bb ",
                                                                      "bbbb b bbbb",
                                                                      " bb  b  bb ",
                                                                      "  b  b  b  ",
                                                                      "     b     ",
                                                                      "           ",
                                                                   });
                                            }
                                            {
                                                setToolTipText("flip");
                                                addActionListener(new java.awt.event.ActionListener() {
                                                    @Override public void actionPerformed(java.awt.event.ActionEvent e)
                                                    {
                                                        UndoItem.State before = applet.newUndoItemState();
                                                        applet.mesh.flipLeftRight();
                                                        applet.dirtyDualMesh(); // flip doesn't work when verts missing
                                                        // should be no need to re-delaunayize
                                                        UndoItem.State after = applet.newUndoItemState();
                                                        applet.undoTreeSquirrel.Do(new UndoItem(before, after));
                                                        applet.theCanvas.repaint();
                                                    }
                                                });
                                            }
                                        });
                                    }});
                                }});
                            }});
                        }});
                        add(new JRow() {{
                                add(new JRow() {{
                                    add(new JCheckBoxForBoolean("Wrap around sphere", applet.wrapAroundSphereFlagIntent) {{ setMargin(nomargin); }});
                                    add(new JCheckBoxForBoolean("Center sphere", applet.centerSphereFlag) {{ setMargin(nomargin); }});
                                    add(new JLabel("    "));
                                    add(new JCheckBoxForBoolean("transform when changing wrap or curvature or center", applet.transformWhenChangingWrapOrCenterFlag) {{ setMargin(nomargin); }});
                                }});
                        }});
                        add(new JRow() {{
                            add(new JLabel("Show Primal:"));
                            final PrefixButtonGroup buttonGroup = new PrefixButtonGroup();
                            add(new JCheckBoxForBoolean("verts", applet.showPrimalVertsFlag) {{
                                setMargin(nomargin);
                                // don't add to button group, it's independent now
                            }});
                            add(new JCheckBoxForBoolean("edges", applet.showPrimalEdgesFlag) {{
                                setMargin(nomargin);
                                buttonGroup.add(this);
                            }});
                            add(new JCheckBoxForBoolean("and flat edges", applet.showFlatPrimalEdgesFlag) {{
                                setMargin(nomargin);
                                buttonGroup.add(this);
                            }});
                            add(new JCheckBoxForBoolean("naive", applet.naivePrimalEdgesFlag) {{
                                setToolTipText("display all primal edges as internal (rather than to infinity if to inside-out vert)");
                                setMargin(nomargin);
                            }});
                        }});
                        add(new JRow() {{
                            add(new JLabel("Show Dual:"));
                            add(new JCheckBoxForBoolean("verts", applet.showDualVertsFlag) {{ setMargin(nomargin); }});
                            add(new JCheckBoxForBoolean("edges", applet.showDualEdgesFlag) {{ setMargin(nomargin); }});
                            add(new JCheckBoxForBoolean("naive", applet.naiveDualEdgesFlag) {{
                                setToolTipText("display all dual edges as internal (rather than to infinity if to inside-out vert)");
                                setMargin(nomargin);
                            }});
                        }});
                        add(new JCheckBoxForBoolean("Show primal underside and second dual sheet (if any) (if not naive) (see Behavior to compute it)", applet.showInsideOutDualVertsFlag) {{ setMargin(nomargin); }});
                        add(new JTablePanel() {{
                            add(theGridBrightnessLabel);
                            add(theGridBrightnessTextField);
                            add(theGridBrightnessSlider, stretchx);
                            advanceRow();
                            add(theBackfaceBrightnessLabel);
                            add(theBackfaceBrightnessTextField);
                            add(theBackfaceBrightnessSlider, stretchx);
                            advanceRow();
                            add(theWrapRadiusLabel);
                            add(theWrapRadiusTextField);
                            add(theWrapRadiusSlider, stretchx);
                        }}, stretchx);
                    }}, stretchx);
                }}));
                contentPane.add(new JSeparator(), stretchx);
                contentPane.add(MakeCollapsibleSection("Symmetry", applet.theControlPanelWindow, new JRow() {{
                    setVisible(false);
                    add(new JLabel("        ")); // indent a bit
                    add(new JCol() {{
                        add(new JRow() {{
                            add(new JCheckBox("left-right") {
                                {setToolTipText("Left-right symmetry");}
                                Listenable.Listener listener;
                                {
                                    //setMargin(nomargin);
                                    addActionListener(new java.awt.event.ActionListener() {
                                        @Override public void actionPerformed(java.awt.event.ActionEvent e)
                                        {
                                            boolean newLeftRightSymmetry = isSelected();
                                            applet.changeSymmetry(/*p=*/applet.pRotationalSymmetry.get(), /*q=*/applet.qRotationalSymmetry.get(), /*leftRight=*/newLeftRightSymmetry, /*central=*/applet.sphereCentralSymmetry.get(), /*repeatWorkInProgress=*/applet.q346meanRepeatRegardlessOfPFlag.get());
                                        }
                                    });
                                    setSelected(applet.leftRightSymmetry.get());
                                    applet.leftRightSymmetry.addListener(listener = new Listenable.Listener() {
                                        @Override public void valueChanged()
                                        {
                                            setSelected(applet.leftRightSymmetry.get());
                                        }
                                    });
                                }
                            });
                            //add(new JLabel("    ")); // hack, just give a little space
                            add(new JCheckBox("sphere-central") {
                                {setToolTipText("Sphere-central symmetry.  Probably looks symmetrical only when wrapped around sphere.");}
                                Listenable.Listener listener;
                                {
                                    //setMargin(nomargin);
                                    addActionListener(new java.awt.event.ActionListener() {
                                        @Override public void actionPerformed(java.awt.event.ActionEvent e)
                                        {
                                            boolean newSphereCentralSymmetry = isSelected();
                                            applet.changeSymmetry(/*p=*/applet.pRotationalSymmetry.get(), /*q=*/applet.qRotationalSymmetry.get(), /*leftRight=*/applet.leftRightSymmetry.get(), /*central=*/newSphereCentralSymmetry, /*repeatWorkInProgress=*/applet.q346meanRepeatRegardlessOfPFlag.get());
                                        }
                                    });
                                    setSelected(applet.sphereCentralSymmetry.get());
                                    applet.sphereCentralSymmetry.addListener(listener = new Listenable.Listener() {
                                        @Override public void valueChanged()
                                        {
                                            setSelected(applet.sphereCentralSymmetry.get());
                                        }
                                    });
                                }
                            });
                            add(new JLabel("    ")); // hack, just give a little space
                            add(new JTablePanel() {
                                private Listenable.Listener pOverallListener, qOverallListener; // needed to keep strong refs for as long as I'm alive
                                {
                                    final int maxpq = 12;

                                    // These button groups are somewhat redundant.
                                    // Thinking about the things needed:
                                    //     - when a toggle clicked when selected, should forcibly keep it selected
                                    //       (button group enforces this) (and I don't want to try to enforce this myself)
                                    //     - when a toggle clicked when not selected, should change the value
                                    //       and deselect the others (button group enforces this)
                                    //     - when value changed from outside, to one of the button values,
                                    //       should select that one and deselect the others
                                    //       (button group enforces the deselecting as long as we explicitly select the one)
                                    //     - when value changes from outside, to none of the button values,
                                    //       all buttons should be deselected.
                                    // So the button group by itself isn't adequate,
                                    // because it doesn't track external changes.
                                    // (Could implement that by a single callback at the end that listens for external
                                    // changes and then either selects one or calls clearSelection()... but that's a pain)
                                    // And the per-button listener by itself isn't adequate,
                                    // because it allows a button to be toggled off.
                                    // Note, even with the button group and per-button listeners,
                                    // we must *still* call buttongroup.clearSelected() even though
                                    // the per-button listeners set them all to setSelected(false),
                                    // otherwise the buttongroup will reject it!
                                    final ButtonGroup pButtonGroup = new ButtonGroup();
                                    final ButtonGroup qButtonGroup = new ButtonGroup();
                                    {
                                        add(new JLabel(""), rightjustify);
                                        final int preferredWidthOfToggle = new JRadioButton(""){{setMargin(nomargin);}}.getPreferredSize().width;
                                        for (int i = 1; i <= maxpq; ++i)
                                        {
                                            //add(new JLabel(i<=9?" "+i+" ":""+i), centerjustify);  // no good, 10,11,12 jammed together
                                            //add(new JLabel(" "+i+" "), centerjustify);  // no good, stuff moves around when visibility set, argh
                                            //add(new JLabel(i<=9?"  "+i+"  ":" "+i+" "), centerjustify);  // no good, too wide
                                            add(new JLabel(" "+i+" ") {
                                                @Override public java.awt.Dimension getPreferredSize()
                                                {
                                                    java.awt.Dimension answer = super.getPreferredSize();
                                                    answer.width = Math.max(answer.width, preferredWidthOfToggle);
                                                    return answer;
                                                }
                                            }, centerjustify);
                                        }
                                    }
                                    advanceRow();
                                    {
                                        add(new JLabel("p:") {{
                                            setToolTipText("\"p\" symmetry: rotational symmetry about z axis");
                                        }}, rightjustify);
                                        for (int i = 1; i <= maxpq; ++i)
                                        {
                                            final int final_i = i;
                                            add(new JRadioButton("") {
                                                Listenable.Listener pListener, qListener; // needed to keep strong refs to them for as long as I'm alive
                                                {
                                                    addActionListener(new java.awt.event.ActionListener() {
                                                        @Override public void actionPerformed(java.awt.event.ActionEvent e)
                                                        {
                                                            int p = final_i;
                                                            System.out.println("p = "+p);
                                                            applet.pRotationalSymmetryIntent.set(p); // which triggers listener below
                                                        }
                                                    });
                                                    setSelected(final_i == applet.pRotationalSymmetry.get());
                                                    setMargin(nomargin);
                                                    pButtonGroup.add(this);

                                                    // The per-button listener described above
                                                    applet.pRotationalSymmetryIntent.addListener(pListener = new Listenable.Listener() {
                                                        @Override public void valueChanged()
                                                        {
                                                            int p = final_i;
                                                            setSelected(applet.pRotationalSymmetryIntent.get() == p);
                                                        }
                                                    });
                                                    applet.qRotationalSymmetryIntent.addListener(qListener = new Listenable.Listener() {
                                                        @Override public void valueChanged()
                                                        {
                                                            int p = final_i;
                                                            int q = applet.qRotationalSymmetryIntent.get();
                                                            //int maxp = q<=2 ? Integer.MAX_VALUE : q==3 ? 5 : q==4 ? 3 : q==5 ? 3 : 2;
                                                            int maxp = q<=2 ? Integer.MAX_VALUE : q==3 ? 6 : q==4 ? 4 : q==5 ? 3 : q==6 ? 3 : 2;
                                                            boolean visibility = p <= maxp || (applet.q346meanRepeatRegardlessOfPFlag.get() && (q==3||q==4||q==6));
                                                            setVisible(visibility);
                                                        }
                                                    });
                                                    applet.q346meanRepeatRegardlessOfPFlag.addListener(qListener);  // same valueChanged action
                                                    qListener.valueChanged();  // to set visibility correctly initially
                                                }
                                            }, centerjustify);
                                        }
                                        add(new JTextFieldForNumber(applet.pRotationalSymmetryIntent) {
                                            @Override public boolean validate(String text)
                                            {
                                                int p;
                                                try {
                                                    p = Integer.parseInt(text);
                                                } catch (Exception e) {
                                                    return false;
                                                }
                                                if (p < 1) return false;
                                                int q = applet.qRotationalSymmetryIntent.get();
                                                //int maxp = q<=2 ? Integer.MAX_VALUE : q==3 ? 5 : q==4 ? 3 : q==5 ? 3 : 2;
                                                int maxp = q<=2 ? Integer.MAX_VALUE : q==3 ? 6 : q==4 ? 4 : q==5 ? 3 : q==6 ? 3 : 2;
                                                return p <= maxp || applet.q346meanRepeatRegardlessOfPFlag.get();
                                            }
                                        });
                                        applet.pRotationalSymmetryIntent.addListener(pOverallListener = new Listenable.Listener() {
                                            @Override public void valueChanged()
                                            {
                                                System.out.println("Hey! p rotational symmetry intent changed to "+applet.pRotationalSymmetryIntent.get());
                                                if (applet.pRotationalSymmetryIntent.get() > maxpq) // from outside button group
                                                {
                                                    // Yes, necessary, if we don't explicitly clearSelection,
                                                    // the button group will reject the last button's attempt
                                                    // to deselect itself.  More details above.
                                                    pButtonGroup.clearSelection();
                                                }
                                                applet.changeSymmetry(applet.pRotationalSymmetryIntent.get(), applet.qRotationalSymmetryIntent.get(), /*leftRight=*/applet.leftRightSymmetry.get(), /*central=*/applet.sphereCentralSymmetry.get(), /*repeatWorkInProgress=*/applet.q346meanRepeatRegardlessOfPFlag.get());
                                            }
                                        });
                                    }
                                    advanceRow();
                                    {
                                        add(new JLabel("q:") {{
                                          setToolTipText("\"q\" symmetry: rotational symmetry about an axis somewhere between +z and +y");
                                        }}, rightjustify);
                                        for (int i = 1; i <= maxpq; ++i)
                                        {
                                            final int final_i = i;
                                            add(new JRadioButton("") {
                                                Listenable.Listener qListener, pListener; // needed to keep strong refs to them for as long as I'm alive
                                                Listenable.Listener enabledListener;
                                                {
                                                    addActionListener(new java.awt.event.ActionListener() {
                                                        @Override public void actionPerformed(java.awt.event.ActionEvent e)
                                                        {
                                                            int q = final_i;
                                                            System.out.println("q = "+q);
                                                            applet.qRotationalSymmetryIntent.set(q); // which triggers listener below
                                                        }
                                                    });
                                                    setSelected(final_i == applet.qRotationalSymmetry.get());
                                                    setMargin(nomargin);
                                                    qButtonGroup.add(this);

                                                    // The per-button listener described above
                                                    applet.qRotationalSymmetryIntent.addListener(qListener = new Listenable.Listener() {
                                                        @Override public void valueChanged()
                                                        {
                                                            int q = final_i;
                                                            setSelected(applet.qRotationalSymmetryIntent.get() == q);
                                                        }
                                                    });
                                                    applet.pRotationalSymmetryIntent.addListener(pListener = new Listenable.Listener() {
                                                        @Override public void valueChanged()
                                                        {
                                                            int q = final_i;
                                                            int p = applet.pRotationalSymmetryIntent.get();
                                                            //int maxq = p<=2 ? Integer.MAX_VALUE : p==3 ? 5 : p==4 ? 3 : p==5 ? 3 : 2;
                                                            int maxq = p<=2 ? Integer.MAX_VALUE : p==3 ? 6 : p==4 ? 4 : p==5 ? 3 : p==6 ? 3 : 2;
                                                            boolean visibility = q <= maxq
                                                                              || ((q==3||q==4||q==6)
                                                                                &&applet.q346meanRepeatRegardlessOfPFlag.get());
                                                            setVisible(visibility);
                                                        }
                                                    });
                                                    applet.q346meanRepeatRegardlessOfPFlag.addListener(pListener);  // same valueChanged action
                                                    pListener.valueChanged();  // to set visibility correctly initially
                                                }
                                            }, centerjustify);
                                        }
                                        add(new JTextFieldForNumber(applet.qRotationalSymmetryIntent) {
                                            @Override public boolean validate(String text)
                                            {
                                                int q;
                                                try {
                                                    q = Integer.parseInt(text);
                                                } catch (Exception e) {
                                                    return false;
                                                }
                                                if (q < 1) return false;
                                                int p = applet.pRotationalSymmetryIntent.get();
                                                //int maxq = p<=2 ? Integer.MAX_VALUE : p==3 ? 5 : p==4 ? 3 : p==5 ? 3 : 2;
                                                int maxq = p<=2 ? Integer.MAX_VALUE : p==3 ? 6 : p==4 ? 4 : p==5 ? 3 : p==6 ? 3 : 2;
                                                return q <= maxq || ((q==3||q==4||q==6)&&applet.q346meanRepeatRegardlessOfPFlag.get());
                                            }
                                        });
                                        applet.qRotationalSymmetryIntent.addListener(qOverallListener = new Listenable.Listener() {
                                            @Override public void valueChanged()
                                            {
                                                System.out.println("Hey! q rotational symmetry intent changed to "+applet.qRotationalSymmetryIntent.get());
                                                // Yes, necessary, see explanation above
                                                if (applet.qRotationalSymmetryIntent.get() > maxpq) // from outside button group
                                                    pButtonGroup.clearSelection();
                                                applet.changeSymmetry(/*p=*/applet.pRotationalSymmetryIntent.get(), /*q=*/applet.qRotationalSymmetryIntent.get(), applet.leftRightSymmetry.get(), applet.sphereCentralSymmetry.get(), /*repeatWorkInProgress=*/applet.q346meanRepeatRegardlessOfPFlag.get());
                                            }
                                        });
                                    }
                                }
                            });
                            add(new JLabel("    "));
                            add(new JCol() {{
                                add(new JLabel(" "));  // just some vertical space 
                                add(new JLabel(" "));  // just some vertical space 
                                add(new JCheckBoxForBoolean("q=3,4,6 mean planar repeat regardless of p", applet.q346meanRepeatRegardlessOfPFlag) {
                                    Listenable.Listener pqListener = new Listenable.Listener() {
                                        @Override public void valueChanged()
                                        {
                                            int p = applet.pRotationalSymmetryIntent.get();
                                            int q = applet.qRotationalSymmetryIntent.get();
                                            boolean wouldBeIllegalNormally = (p-2)*(q-2) > 4;
                                            if (wouldBeIllegalNormally) {
                                                applet.q346meanRepeatRegardlessOfPFlag.set(true);
                                            }
                                            setEnabled(!wouldBeIllegalNormally);
                                        }
                                    };
                                {
                                    // Whenever p and q would be illegal if not for q346meanRepeatRegardlessOfPFlag,
                                    // force q346meanRepeatRegardlessOfPFlag to true (this generally can't happen
                                    // at runtime from gui, but can happen due to initial conditions or maybe
                                    // when p,q changed via keys that don't know about restrictions)
                                    // and disable the checkbox.
                                    applet.pRotationalSymmetryIntent.addListener(pqListener);
                                    applet.qRotationalSymmetryIntent.addListener(pqListener);
                                    pqListener.valueChanged();  // to set initial enabledness
                                }});
                            }});
                        }});
                        add(new JCol() {{
                            add(new JCheckBox("remap fundamental region when changing rotational symmetry") { Listenable.Listener listener; {
                                setSelected(applet.remapFundamentalRegionWhenChangingRotationalSymmetry.get());
                                setMargin(nomargin);
                                addActionListener(new java.awt.event.ActionListener() {
                                    @Override public void actionPerformed(java.awt.event.ActionEvent e)
                                    {
                                        applet.remapFundamentalRegionWhenChangingRotationalSymmetry.set(isSelected());
                                    }
                                });
                                applet.remapFundamentalRegionWhenChangingRotationalSymmetry.addListener(listener = new Listenable.Listener() {
                                    @Override public void valueChanged()
                                    {
                                        setSelected(applet.remapFundamentalRegionWhenChangingRotationalSymmetry.get());
                                    }
                                });
                            }});
                            add(new JRow() {{
                                add(new JLabel("    "));
                                add(new JCol() {{
                                    final ButtonGroup buttonGroup = new ButtonGroup(); // to prevent toggling off
                                    add(new JRadioButton("replicate unmatched verts when remapping") { Listenable.Listener listener; {
                                        buttonGroup.add(this);
                                        setSelected(!applet.deleteUnmatchedVertsWhenChangingRotationalSymmetry.get());
                                        setMargin(nomargin);
                                        addActionListener(new java.awt.event.ActionListener() {
                                            @Override public void actionPerformed(java.awt.event.ActionEvent e)
                                            {
                                                applet.deleteUnmatchedVertsWhenChangingRotationalSymmetry.set(!isSelected());
                                            }
                                        });
                                        applet.deleteUnmatchedVertsWhenChangingRotationalSymmetry.addListener(listener = new Listenable.Listener() {
                                            @Override public void valueChanged()
                                            {
                                                setSelected(!applet.deleteUnmatchedVertsWhenChangingRotationalSymmetry.get());
                                            }
                                        });
                                    }});
                                    add(new JRadioButton("delete unmatched verts  when remapping") { Listenable.Listener listener; {
                                        buttonGroup.add(this);
                                        setSelected(applet.deleteUnmatchedVertsWhenChangingRotationalSymmetry.get());
                                        setMargin(nomargin);
                                        addActionListener(new java.awt.event.ActionListener() {
                                            @Override public void actionPerformed(java.awt.event.ActionEvent e)
                                            {
                                                applet.deleteUnmatchedVertsWhenChangingRotationalSymmetry.set(isSelected());
                                            }
                                        });
                                        applet.deleteUnmatchedVertsWhenChangingRotationalSymmetry.addListener(listener = new Listenable.Listener() {
                                            @Override public void valueChanged()
                                            {
                                                setSelected(applet.deleteUnmatchedVertsWhenChangingRotationalSymmetry.get());
                                            }
                                        });
                                    }});
                                }});
                            }});
                            add(new JRow() {
                                private void fixEnableds()
                                {
                                    boolean enabled = (applet.pRotationalSymmetry.get() > 1
                                                    || applet.qRotationalSymmetry.get() > 1
                                                    || applet.leftRightSymmetry.get()
                                                    || applet.sphereCentralSymmetry.get()
                                                    || applet.q346meanRepeatRegardlessOfPFlag.get());
                                    int n = this.getComponentCount();
                                    FORI (i, n)
                                    {
                                        java.awt.Component component = this.getComponent(i);
                                        component.setEnabled(enabled);
                                    }
                                }
                                private Listenable.Listener listener = new Listenable.Listener() {
                                    @Override public void valueChanged()
                                    {
                                        fixEnableds();
                                    }
                                };
                                {
                                    add(new JLabel("force symmetry now by "));
                                    add(new JButton("replicating") {{
                                        addActionListener(new java.awt.event.ActionListener() {
                                            @Override public void actionPerformed(java.awt.event.ActionEvent e)
                                            {
                                                applet.forceSymmetryByReplicatingVerts();
                                            }
                                        });
                                    }});
                                    add(new JButton("deleting") {{
                                        addActionListener(new java.awt.event.ActionListener() {
                                            @Override public void actionPerformed(java.awt.event.ActionEvent e)
                                            {
                                                applet.forceSymmetryByDeletingVerts();
                                            }
                                        });
                                    }});
                                    add(new JLabel(" unmatched verts"));

                                    applet.pRotationalSymmetry.addListener(listener);
                                    applet.qRotationalSymmetry.addListener(listener);
                                    applet.leftRightSymmetry.addListener(listener);
                                    applet.sphereCentralSymmetry.addListener(listener);
                                    applet.q346meanRepeatRegardlessOfPFlag.addListener(listener);
                                    fixEnableds();
                                }
                            });
                        }});
                    }});
                }}));
                contentPane.add(new JSeparator(), stretchx);
                contentPane.add(MakeCollapsibleSection("Net", applet.theControlPanelWindow, new JRow() {{
                    setVisible(false);
                    add(new JLabel("        ")); // indent a bit
                    add(new JCol() {{
                        add(new JRow() {{
                            add(new JCol() {{
                                add(new JCheckBox("Net", applet.showNetFlag.get()) {{
                                        setMargin(nomargin);
                                        addItemListener(new java.awt.event.ItemListener() {
                                            @Override public void itemStateChanged(java.awt.event.ItemEvent e)
                                            {
                                                synchronized(applet.showNetFlag) // since another thread checks it once in a while
                                                {
                                                    applet.showNetFlag.set(isSelected());
                                                }
                                                applet.theCanvas.repaint();
                                            }
                                        });
                                        applet.showNetFlag.addListener(applet.showNetFlagListener = new Listenable.Listener() {
                                            @Override public void valueChanged()
                                            {
                                                setSelected(applet.showNetFlag.get()); // of the checkbox

                                                // XXX TODO: arguably this should be in a different listener... it should happen even if we decided not to have this checkbox
                                                final int fps = 60; // XXX need user control of this I think
                                                // XXX TODO: dup code
                                                if (applet.showNetFlag.get() && applet.showNetFlowFlag.get())
                                                {
                                                    Runnable runnable = new Runnable() {
                                                        public void run()
                                                        {
                                                            System.out.println("starting animator thread");
                                                            while (true) // while (applet.showNetFlag.get() && applet.showNetFlowFlag.get()), but synchronized
                                                            {
                                                                synchronized(applet.showNetFlag)
                                                                {
                                                                    synchronized(applet.showNetFlowFlag)
                                                                    {
                                                                        if (!applet.showNetFlag.get() || !applet.showNetFlowFlag.get())
                                                                            break;
                                                                    }
                                                                }

                                                                applet.theCanvas.repaint();
                                                                //System.out.println("    sleeping for "+(1000/fps)+" ms");
                                                                try {
                                                                    Thread.sleep(1000/fps);
                                                                } catch (InterruptedException e) {
                                                                    break;
                                                                }
                                                            }
                                                            System.out.println("terminating animator thread");
                                                            // XXX TODO: does master thread need to join?
                                                        }
                                                    };
                                                    Thread animatorThread = new Thread(runnable);
                                                    animatorThread.setDaemon(true); // make it so the java vm won't wait for it to finish before exiting
                                                    animatorThread.start();
                                                }

                                            }
                                        });
                                    }
                                });
                                add(new JCheckBox("Flow", applet.showNetFlowFlag.get()) {Listenable.Listener enabledListener; {
                                        enabledListener = tieEnabledTo(this, applet.showNetFlag);
                                        setMargin(nomargin);
                                        addItemListener(new java.awt.event.ItemListener() {
                                            @Override public void itemStateChanged(java.awt.event.ItemEvent e)
                                            {
                                                synchronized(applet.showNetFlowFlag) // since another thread checks it once in a while
                                                {
                                                    applet.showNetFlowFlag.set(isSelected());
                                                }
                                                applet.theCanvas.repaint();
                                            }
                                        });
                                        applet.showNetFlowFlag.addListener(applet.showNetFlowFlagListener = new Listenable.Listener() {
                                            @Override public void valueChanged()
                                            {
                                                setSelected(applet.showNetFlowFlag.get()); // of the checkbox

                                                // XXX TODO: arguably this should be in a different listener... it should happen even if we decided not to have this checkbox
                                                // XXX TODO: dup code
                                                if (applet.showNetFlag.get() && applet.showNetFlowFlag.get())
                                                {
                                                    Runnable runnable = new Runnable() {
                                                        public void run()
                                                        {
                                                            System.out.println("starting animator thread");
                                                            int fps = 60; // XXX need user control of this?
                                                            while (true) // while (applet.showNetFlag.get() && applet.showNetFlowFlag.get()), but synchronized
                                                            {
                                                                synchronized(applet.showNetFlag)
                                                                {
                                                                    synchronized(applet.showNetFlowFlag)
                                                                    {
                                                                        if (!applet.showNetFlag.get() || !applet.showNetFlowFlag.get())
                                                                            break;
                                                                    }
                                                                }

                                                                applet.theCanvas.repaint();
                                                                //System.out.println("    sleeping for "+(1000/fps)+" ms");
                                                                try {
                                                                    Thread.sleep(1000/fps);
                                                                } catch (InterruptedException e) {
                                                                    break;
                                                                }
                                                            }
                                                            System.out.println("terminating animator thread");
                                                            // XXX TODO: does master thread need to join?
                                                        }
                                                    };
                                                    Thread animatorThread = new Thread(runnable);
                                                    animatorThread.setDaemon(true); // make it so the java vm won't wait for it to finish before exiting
                                                    animatorThread.start();
                                                }

                                            }
                                        });
                                    }
                                });
                            }});
                            add(new JCol() {{
                                add(new JComboBox<String>(netMethodNames) {{
                                    setSelectedIndex(applet.netMethod.get());
                                    addItemListener(new java.awt.event.ItemListener() {
                                        @Override public void itemStateChanged(java.awt.event.ItemEvent e)
                                        {
                                            // evidently this gets called twice??
                                            // no idea why (java.awt.Choice doesn't behave like that)
                                            // (well it had a different bug,
                                            // namely it called the callback on mouse up
                                            // even if the user selected what was already selected).
                                            // so check whether the new value is really new,
                                            // and if not, don't do anything.
                                            // (not that the extra stuff was expensive...
                                            // but I was noticing the "netMethod -> whatever"
                                            // was coming out 4 times)
                                            int newValue = getSelectedIndex();
                                            if (getSelectedIndex() != applet.netMethod.get())
                                            {
                                                applet.netMethod.set(newValue);
                                                System.out.println("netMethod -> "+ShephardsPlayApplet.netMethodNames[applet.netMethod.get()]);
                                                applet.theNet = null;
                                                applet.theCanvas.repaint();
                                            }
                                        }
                                    });
                                    applet.netMethod.addListener(applet.netMethodListener = new Listenable.Listener() {
                                        @Override public void valueChanged()
                                        {
                                            int newValue = applet.netMethod.get();
                                            // setSelectedIndex does callbacks
                                            // even if the value isn't new,
                                            // so don't call it unless the value is new
                                            if (newValue != getSelectedIndex())
                                                setSelectedIndex(newValue);
                                        }
                                    });
                                }});
                                add(new JRow() {{
                                    add(new JLabel(" my algorithm max iters:"));
                                    add(makeIncrementableTextFieldForNumber(applet.myAlgorithmMaxIters,
                                                                            "my algorithm max iters (negative means unlimited)",
                                                                            1.));
                                }});
                                add(new JRow() {{
                                    add(new JLabel(" my alg sweep origin homo:"));
                                    add(new JTextFieldForString(applet.myAlgorithmSweepOriginHomoSpec) {
                                        @Override public boolean validate(String text)
                                        {
                                            return parseSweepOriginHomo(text) != null;
                                        }
                                    });
                                    add(new JCol() {{
                                        add(new JCheckBox("outward") {Listenable.Listener listener; {
                                            final String mySpec = "0 0 1"; // outward
                                            setSelected(applet.myAlgorithmSweepOriginHomoSpec.get().trim().equals(mySpec));
                                            final JCheckBox thisCheckBox = this;
                                            addActionListener(new java.awt.event.ActionListener() {
                                                @Override public void actionPerformed(java.awt.event.ActionEvent e)
                                                {
                                                    applet.myAlgorithmSweepOriginHomoSpec.set(mySpec);
                                                    thisCheckBox.setSelected(true); // so turning it off turns it back on again
                                                }
                                            });
                                            applet.myAlgorithmSweepOriginHomoSpec.addListener(listener = new Listenable.Listener() {
                                                @Override public void valueChanged()
                                                {
                                                    thisCheckBox.setSelected(applet.myAlgorithmSweepOriginHomoSpec.get().trim().equals(mySpec));
                                                }
                                            });
                                        }});
                                        add(new JCheckBox("upward") {Listenable.Listener listener; {
                                            final String mySpec = "0 -1 0"; // upward
                                            setSelected(applet.myAlgorithmSweepOriginHomoSpec.get().trim().equals(mySpec));
                                            final JCheckBox thisCheckBox = this;
                                            addActionListener(new java.awt.event.ActionListener() {
                                                @Override public void actionPerformed(java.awt.event.ActionEvent e)
                                                {
                                                    applet.myAlgorithmSweepOriginHomoSpec.set(mySpec);
                                                    thisCheckBox.setSelected(true); // so turning it off turns it back on again
                                                }
                                            });
                                            applet.myAlgorithmSweepOriginHomoSpec.addListener(listener = new Listenable.Listener() {
                                                @Override public void valueChanged()
                                                {
                                                    thisCheckBox.setSelected(applet.myAlgorithmSweepOriginHomoSpec.get().trim().equals(mySpec));
                                                }
                                            });
                                        }});
                                    }});
                                }});
                            }});
                            add(new JLabel("    "));
                            add(new JCol() {{
                                add(new JCheckBox("Polish", applet.showNetPolishFlag.get()) {Listenable.Listener enabledListener; {
                                    enabledListener = tieEnabledTo(this, applet.showNetFlag);
                                    setMargin(nomargin);
                                    addItemListener(new java.awt.event.ItemListener() {
                                        @Override public void itemStateChanged(java.awt.event.ItemEvent e)
                                        {
                                            synchronized(applet.showNetPolishFlag) // since another thread checks it once in a while
                                            {
                                                applet.showNetPolishFlag.set(isSelected());
                                            }
                                            applet.theCanvas.repaint();
                                        }
                                    });
                                    applet.showNetPolishFlag.addListener(applet.showNetPolishFlagListener = new Listenable.Listener() {
                                        @Override public void valueChanged()
                                        {
                                            setSelected(applet.showNetPolishFlag.get()); // of the checkbox

                                            // XXX TODO: arguably this should be in a different listener... it should happen even if we decided not to have this checkbox
                                            final int fps = 10; // XXX need user control of this I think
                                            // XXX TODO: dup code
                                            if (applet.showNetFlag.get() && applet.showNetPolishFlag.get())
                                            {
                                                Runnable runnable = new Runnable() {
                                                    public void run()
                                                    {
                                                        System.out.println("starting animator thread");
                                                        while (true) // while (applet.showNetFlag.get() && applet.showNetPolishFlag.get()), but synchronized
                                                        {
                                                            synchronized(applet.showNetFlag)
                                                            {
                                                                synchronized(applet.showNetPolishFlag)
                                                                {
                                                                    if (!applet.showNetFlag.get() || !applet.showNetPolishFlag.get())
                                                                        break;
                                                                }
                                                            }

                                                            applet.theCanvas.repaint();
                                                            //System.out.println("    sleeping for "+(1000/fps)+" ms");
                                                            try {
                                                                Thread.sleep(1000/fps);
                                                            } catch (InterruptedException e) {
                                                                break;
                                                            }
                                                        }
                                                        System.out.println("terminating animator thread");
                                                        // XXX TODO: does master thread need to join?
                                                    }
                                                };
                                                Thread animatorThread = new Thread(runnable);
                                                animatorThread.setDaemon(true); // make it so the java vm won't wait for it to finish before exiting
                                                animatorThread.start();
                                            }

                                        }
                                    });
                                }});
                                add(new JCheckBoxForBoolean("very fast", applet.showNetPolishVeryFastFlag) {{
                                    setMargin(nomargin);
                                    setToolTipText("repaint after each quantum during Polish(i.e. don't wait for fps)");
                                }});
                            }});
                            add(new JLabel("  quantum=") {Listenable.Listener enabledListener; {
                                setToolTipText("how many lagoon-exit-switches to do consecutively when Polish is in progress");
                                enabledListener = tieEnabledTo(this, applet.showNetFlag);
                            }});
                            add(new JTextFieldForNumber(applet.showNetPolishQuantum) {Listenable.Listener enabledListener; {enabledListener = tieEnabledTo(this, applet.showNetFlag); }});
                            //add(new JLabel("    "));  // makes overall window a bit too wide for comfort on macbook
                            add(new JLabel(" "));
                            add(new JCol() {{
                                add(new JCheckBoxForBoolean("Continue after quantum done", applet.showNetContinueAfterQuantumDoneFlag) {Listenable.Listener enabledListener; {
                                    setMargin(nomargin);
                                    enabledListener = tieEnabledTo(this, applet.showNetFlag);
                                }});
                                add(new JCheckBoxForBoolean("New mesh when polish succeeds", applet.showNetMakeBadAgainFlag) {Listenable.Listener enabledListener; {
                                    setToolTipText("If set, whenever Polish succeeds, a new \"Convex Noise\" mesh will be created, made more difficult by truncating, and a net generated, and it will continue.");
                                    setMargin(nomargin);
                                    enabledListener = tieEnabledTo(this, applet.showNetFlag);
                                }});
                            }});
                        }});
                    }});
                }}));
                contentPane.add(new JSeparator(), stretchx);
                contentPane.add(MakeCollapsibleSection("Debug", applet.theControlPanelWindow, new JRow() {{
                    setVisible(false);
                    add(new JLabel("        ")); // indent a bit
                    add(new JCol() {{
                        add(new JRow() {{
                            add(new JLabel("Labels:"));
                            add(new JCheckBoxForBoolean("primal verts", applet.labelPrimalVertsFlag));
                            add(new JCheckBoxForBoolean("primal edges", applet.labelPrimalEdgesFlag));
                            add(new JCheckBoxForBoolean("dual verts", applet.labelDualVertsFlag));
                            add(new JCheckBoxForBoolean("dual edges", applet.labelDualEdgesFlag));
                        }});
                        add(new JRow() {{
                            add(new JCheckBox("Magnifying glass", applet.showMagFlag.get()) {{
                                    addItemListener(new java.awt.event.ItemListener() {
                                        @Override public void itemStateChanged(java.awt.event.ItemEvent e)
                                        {
                                            applet.showMagFlag.set(isSelected());
                                            // CBB: haphazard printing, there's also one when I hit ctrl-M.  should be doing this in a value listener, not in either of those places
                                            System.out.println("(from checkbox itemStateChanged) showMagFlag -> "+applet.showMagFlag.get()+" (which affects home grown double buffering which is "+applet.homeGrownDoubleBufferFlag+")");
                                            applet.theCanvas.repaint();
                                        }
                                    });
                                    applet.showMagFlag.addListener(applet.showMagFlagListener = new Listenable.Listener() {
                                        @Override public void valueChanged()
                                        {
                                            setSelected(applet.showMagFlag.get()); // of the checkbox
                                        }
                                    });
                                }
                            });
                            add(new JLabel("    "));
                            add(new JButton("Random seed:") {{
                                setMargin(nomargin);
                                addActionListener(new java.awt.event.ActionListener() {
                                    @Override public void actionPerformed(java.awt.event.ActionEvent e)
                                    {
                                        OUT("calling setSeed("+applet.randomSeed.get()+")");
                                        applet.randomNumberGenerator.setSeed(applet.randomSeed.get());
                                    }
                                });
                            }});
                            add(new JTextFieldForNumber(applet.randomSeed) {
                                @Override public java.awt.Dimension getPreferredSize()
                                {
                                    java.awt.Dimension answer = super.getPreferredSize();
                                    answer.width += 100; // hack, probly won't look good everywhere
                                    return answer;
                                }
                                @Override public java.awt.Dimension getMinimumSize()
                                {
                                    java.awt.Dimension answer = super.getMinimumSize();
                                    answer.width += 100; // hack, probly won't look good everywhere
                                    return answer;
                                }
                            });
                        }});
                        add(new JRow() {{
                            add(new JButton("Dump window positions and sizes") {{
                                setMargin(nomargin);
                                addActionListener(new java.awt.event.ActionListener() {
                                    @Override public void actionPerformed(java.awt.event.ActionEvent e)
                                    {
                                        System.out.println("----------------");
                                        System.out.println("      main applet: "+applet.theMainAppletWindow.getWidth()+"x"+applet.theMainAppletWindow.getHeight()+"+"+applet.theMainAppletWindow.getX()+"+"+applet.theMainAppletWindow.getY()+"");
                                        System.out.println("    control panel: "+applet.theControlPanelWindow.getWidth()+"x"+applet.theControlPanelWindow.getHeight()+"+"+applet.theControlPanelWindow.getX()+"+"+applet.theControlPanelWindow.getY()+"");
                                        System.out.println("             help: "+applet.theHelpWindow.getWidth()+"x"+applet.theHelpWindow.getHeight()+"+"+applet.theHelpWindow.getX()+"+"+applet.theHelpWindow.getY()+"");
                                        System.out.println("----------------");
                                    }
                                });
                            }});
                            add(new JLabel("    "));
                            add(new JRow() {{
                                add(new JLabel("Window title:"));
                                add(new JTextFieldForString(applet.windowTitle), stretchx);
                            }}, stretchx);
                        }}, stretchx);
                    }}, stretchx);
                }}));
                contentPane.add(new JSeparator(), stretchx);
                contentPane.add(MakeCollapsibleSection("Experimental work in progress", applet.theControlPanelWindow, new JRow() {{
                    setVisible(false);
                    add(new JLabel("        ")); // indent a bit
                    add(new JCol() {{
                        add(new JCheckBoxForBoolean("show topo region of dragged vert", applet.showTopologicalRegionWhenDraggingVertexFlag));
                        add(new JCheckBoxForBoolean("show primal/dual intersection", applet.showPrimalDualIntersectionFlag));
                        add(new JRow() {{
                            add(new JCheckBoxForBoolean("show primal/dual minkowski average", applet.showPrimalDualMinkowskiAverageFlag));
                            add(new JButton("Set mesh to primal/dual minkowski average") {{
                                setMargin(nomargin);
                                addActionListener(new java.awt.event.ActionListener() {
                                    @Override public void actionPerformed(java.awt.event.ActionEvent e)
                                    {
                                        Mesh[] minkowskiAverageAndDual = MeshUtils.MakePrimalDualMinkowskiAverageAndDual(applet.mesh, applet.getDualMesh());
                                        if (minkowskiAverageAndDual != null) {
                                          UndoItem.State before = applet.newUndoItemState();
                                          Mesh minkowskiAverage = minkowskiAverageAndDual[0];
                                          Mesh minkowskiAverageDual = minkowskiAverageAndDual[1];

                                          applet.mesh = minkowskiAverage;
                                          applet._dualMesh = minkowskiAverageDual;
                                          applet._primalMeshOfDualMesh = applet.mesh; // counter-counter-espionage, prevents dual from thinking it's dirty
                                          UndoItem.State after = applet.newUndoItemState();
                                          applet.undoTreeSquirrel.Do(new UndoItem(before, after));
                                          applet.theCanvas.repaint();
                                        }
                                    }
                                });
                            }});
                        }});
                    }});
                }}));
                contentPane.add(new JSeparator(), stretchx);

                //randomlyColorize(this, applet.randomNumberGenerator);
                //dumpComponentHierarchy(this, 0, 0, 1);

            } // ShephardsPlayAppletControlPanel ctor
        } // class ShephardsPlayAppletControlPanel

    //
    // Implementing Applet methods...
    //
        public ShephardsPlayApplet()
        {
            if (true)
            {
                // Note, there's a MetalLookAndFeel.setCurrentTheme,
                // not sure how to get it, or even how to get the look and feel.
                // Anyway, the following seems to be a good heuristic.
                javax.swing.plaf.metal.DefaultMetalTheme defaultMetalTheme = new javax.swing.plaf.metal.DefaultMetalTheme();
                javax.swing.plaf.FontUIResource controlTextFont = defaultMetalTheme.getControlTextFont();
                int size = controlTextFont.getSize();
                //PRINT(controlTextFont);
                //PRINT(size);
                // Expected: size=12 is the default.
                // Anything bigger means it was probably messed with on the command line.
                if (true)
                {
                    if (size > 12)
                    {
                        hidpimag = 2;
                        System.out.println("Default controlFont size is "+size+">12, assuming my pixels are the tiny pixels of a hidpi display, setting hidpimag to "+hidpimag);
                      }
                    else
                    {
                        System.out.println("Default controlFont size is "+size+"<=12, not messing with hidpimag");
                    }
                }
            }

            // Content pane doesn't need to be a JPanel, with double buffering and background and opaqueness semantics; just make it a JComponent.
            // TODO: could we even just make it the canvas?
            setContentPane(new javax.swing.JComponent() {{ setName("my content pane"); }});
            getContentPane().setLayout(new java.awt.BorderLayout());

            getContentPane().add(theCanvas = new TheCanvas());

            //
            // Make the menu bar
            //
            if (true)
            {
                // http://www.isr.umd.edu/~austin/ence688r.d/java-swing/menu.d/DemoMenuItem.java
                JMenuBar menuBar = new JMenuBar();

                menuBar.setBorderPainted(false); // true is default. false makes it blend into the background a tiny bit more, which is good.

                this.setJMenuBar(menuBar);

                JMenu fileMenu = new JMenu("File", true);
                menuBar.add(fileMenu);

                fileMenu.add(new JMenuItem("New"));
                fileMenu.addSeparator();
                fileMenu.add(new JMenuItem("Load DUMP.off"));
                fileMenu.add(new JMenuItem("Save DUMP.off"));
                fileMenu.addSeparator();
                fileMenu.addSeparator();

                JMenu editMenu = new JMenu("Edit", true);
                menuBar.add(editMenu);
                editMenu.add(new JMenuItem("Undo (not implemented here, use button in control panel)"));
                editMenu.add(new JMenuItem("Redo (not implemented here, use button in control panel)"));
                editMenu.addSeparator();
                editMenu.add(new JMenuItem("Clear (not implemented here, use button in control panel)"));

                JMenu windowsMenu = new JMenu("Windows", true);
                menuBar.add(windowsMenu);
                windowsMenu.add(new JMenuItem("Control Panel") {{
                    addActionListener(new java.awt.event.ActionListener() {
                        @Override public void actionPerformed(java.awt.event.ActionEvent e)
                        {
                            theControlPanelWindow.setState(JFrame.NORMAL); // not iconified
                            theControlPanelWindow.setVisible(true); // also brings it to front, apparently
                        }
                    });
                }});

                JMenu helpMenu = new JMenu("Help", true);
                menuBar.add(helpMenu);
                helpMenu.add(new JMenuItem("Help") {{
                    addActionListener(new java.awt.event.ActionListener() {
                        @Override public void actionPerformed(java.awt.event.ActionEvent e)
                        {
                            help();
                        }
                    });
                }});
                helpMenu.add(new JMenuItem("About...") {{
                    // TODO: do me
                }});
            }

            //randomlyColorize(this, randomNumberGenerator);

            //
            // Make the control panel window
            //
            if (true)
            {
                theControlPanelWindow = new JFrame(windowTitle + " Control Panel");
                // no need for setDefaultCloseOperation
                // since the default is HIDE_ON_CLOSE which is what we want


                theControlPanelWindow.getContentPane().add(new JScrollPane(new ShephardsPlayAppletControlPanel(this)));

                //theControlPanelWindow.setLocation(730, 10);
                //theControlPanelWindow.setLocation(810, 10);
                //theControlPanelWindow.setLocation(20,225);
                theControlPanelWindow.setLocation(603,109);
                theControlPanelWindow.pack();
                theControlPanelWindow.setVisible(true);
            }


            //
            // Make the help window
            //
            {
                theHelpWindow = new JFrame("Shephard's Play Applet Help");
                // no need for setDefaultCloseOperation
                // since the default is HIDE_ON_CLOSE which is what we want

                // TODO: figure out how to make it scroll in response to arrow keys

                if (true)
                {
                    // Use a JTextArea made to look like a label so text will be selectable
                    String text = "";
                    FORI (i, helpMessage.length)
                        text += "  " + helpMessage[i] + "  \n";
                    theHelpWindow.getContentPane().add(
                        new JScrollPane(
                            new JTextArea(text) {{
                                // make it like a JLabel as much as possible, but text selectable
                                this.setEditable(false);
                                this.setDisabledTextColor(java.awt.Color.BLACK);
                                this.setBackground(null); // same as JLabel
                                this.setBorder(null); // same as JLabel
                            }}
                        ) {{
                            // if we don't do the following, it will screw up
                            // and pick a width that forces a horizontal scrollbar... lame!
                            this.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
                        }}
                    );
                }
                else
                {
                    // Use a JLabel -- text not selectable :-(
                    String htmlHelpMessage = "<html><pre>";
                    FORI (i, helpMessage.length)
                        htmlHelpMessage += helpMessage[i] + "  \n";
                    htmlHelpMessage += "</pre></html>";

                    theHelpWindow.getContentPane().add(new JScrollPane(new JLabel(htmlHelpMessage)) {{

                        // if we don't do the following, it will screw up
                        // and pick a width that forces a horizontal scrollbar... lame!
                        this.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
                    }});
                }

                theHelpWindow.setLocation(210,30); // XXX do I really want this?  can I center it instead? doing it so the help window doesn't end up in same place as main window.
                theHelpWindow.pack(); // so that getWidth() will be the preferred width
                theHelpWindow.setSize(theHelpWindow.getWidth(),700); // XXX heuristic for my screen
                //theHelpWindow.setVisible(true); // uncomment when debugging
            }


            gridBrightness.addListener(gridBrightnessListener = new Listenable.Listener() {
                @Override public void valueChanged()
                {
                    System.out.println("in gridBrightness valueChanged");
                    PRINT(gridBrightness.get());
                    theCanvas.repaint();
                    System.out.println("out gridBrightness valueChanged");
                }
            });
            backfaceBrightness.addListener(backfaceBrightnessListener = new Listenable.Listener() {
                @Override public void valueChanged()
                {
                    System.out.println("in backfaceBrightness valueChanged");
                    PRINT(backfaceBrightness.get());
                    theCanvas.repaint();
                    System.out.println("out backfaceBrightness valueChanged");
                }
            });

            wrapAroundSphereFlagIntent.addListener(wrapAroundSphereFlagIntentListener = new Listenable.Listener() {
                @Override public void valueChanged()
                {
                    // TODO: this interaction is fucked-- undo needs to restore wrapAroundSphereFlag or wrapAroundSphereFlagIntent (not sure which at the moment)
                    if (transformWhenChangingWrapOrCenterFlag.get())
                    {
                        // not during load (i.e. when toggling the button), we do it this way
                        UndoItem.State before = newUndoItemState();
                        // This should be the *only* setting of extent. In particular, there should be no
                        // gui elements connected directly to wrapAroundSphereFlag, unless read-only.
                        // Oh, maybe make wrapAroundSphereFlag (or wrapAroundSphereFlagExtent) be not a Listenable!
                        wrapAroundSphereFlag.set(wrapAroundSphereFlagIntent.get()); // set the extent
                        System.out.println("wrapAroundSphereFlag -> "+wrapAroundSphereFlag.get());
                        UndoItem.State after = newUndoItemState();
                        undoTreeSquirrel.Do(new UndoItem(before, after));
                    }
                    else
                    {
                        // during load, we do it this way
                        wrapAroundSphereFlag.set(wrapAroundSphereFlagIntent.get()); // set the extent
                        PRINT(wrapAroundSphereFlagIntent);
                        PRINT(wrapAroundSphereFlag);
                    }
                }
            });
            wrapAroundSphereFlag.addListener(wrapAroundSphereFlagListener = new Listenable.Listener() {
                @Override public void valueChanged()
                {
                    if (wrapAroundSphereFlag.get())
                        theSurface = theSphereSurface;
                    else
                        theSurface = theParaboloidSurface;
                    if (transformWhenChangingWrapOrCenterFlag.get())
                    {
                        if (wrapAroundSphereFlag.get())
                            wrapAroundSphere(wrapSphereCurvature.get(), centerSphereFlag.get());
                        else
                            unwrapAroundSphere(wrapSphereCurvature.get(), centerSphereFlag.get());
                        theCanvas.repaint();
                    }
                }
            });
            wrapSphereSymbolicRadius.addListener(wrapSphereSymbolicRadiusListener = new Listenable.Listener() {
                @Override public void valueChanged()
                {
                    //System.out.println("in wrapSphereSymbolicRadius valueChanged");
                    // the widgets control this, not wrapSphereCurvature directly
                    double value = wrapSphereSymbolicRadius.get();
                    if (value <= 1.)
                        wrapSphereCurvature.set(1./value);
                    else
                        wrapSphereCurvature.set(2.-value);
                    //System.out.println("out wrapSphereSymbolicRadius valueChanged");
                }
            });
            wrapSphereCurvature.addListener(wrapSphereCurvatureListener = new Listenable.Listener() {
                double previousValue = wrapSphereCurvature.get(); // track value of the Listenable
                @Override public void valueChanged()
                {
                    //System.out.println("    in wrapSphereCurvature valueChanged");
                    double currentValue = wrapSphereCurvature.get();
                    CHECK_NE(currentValue, previousValue); // Listenable wouldn't notify us otherwise

                    theSphereSurface.radius = 1./currentValue;
                    if (!centerSphereFlag.get())
                        theSphereSurface.center[2] = -theSphereSurface.radius;

                    if (transformWhenChangingWrapOrCenterFlag.get())
                    {
                        if (wrapAroundSphereFlag.get())
                        {
                            unwrapAroundSphere(previousValue, centerSphereFlag.get());
                            wrapAroundSphere(currentValue, centerSphereFlag.get());
                            theCanvas.repaint();
                        }
                    }

                    previousValue = currentValue;
                    //System.out.println("    out wrapSphereCurvature valueChanged");
                }
            });
            centerSphereFlag.addListener(centerSphereFlagListener = new Listenable.Listener() {
                boolean previousValue = centerSphereFlag.get(); // track value of the Listenable
                @Override public void valueChanged()
                {
                    //System.out.println("    in centerSphereFlag valueChanged");
                    boolean currentValue = centerSphereFlag.get();
                    CHECK_NE(currentValue, previousValue); // Listenable wouldn't notify us otherwise

                    if (centerSphereFlag.get())
                        theSphereSurface.center[2] = 0.;
                    else
                    {
                        theSphereSurface.radius = 1./wrapSphereCurvature.get();
                        theSphereSurface.center[2] = -theSphereSurface.radius;
                    }

                    if (transformWhenChangingWrapOrCenterFlag.get())
                    {
                        if (wrapAroundSphereFlag.get())
                        {
                            unwrapAroundSphere(wrapSphereCurvature.get(), previousValue);
                            wrapAroundSphere(wrapSphereCurvature.get(), currentValue);
                            theCanvas.repaint();
                        }
                    }

                    previousValue = currentValue;
                    //System.out.println("    out centerSphereFlag valueChanged");
                }
            });
            calcInsideOutDualVertsFlag.addListener(calcInsideOutDualVertsFlagListener = new Listenable.Listener() {
                @Override public void valueChanged()
                {
                    System.out.println("calcInsideOutDualVertsFlag -> "+calcInsideOutDualVertsFlag.get());
                    if (continuouslyDelaunayizeFlag.get())
                    {
                        UndoItem.State before = newUndoItemState();
                        delaunayize();
                        UndoItem.State after = newUndoItemState();
                        undoTreeSquirrel.Do(new UndoItem(before, after));
                        theCanvas.repaint();
                    }
                }
            });
            showInsideOutDualVertsFlag.addListener(showInsideOutDualVertsFlagListener = new Listenable.Listener() {
                @Override public void valueChanged()
                {
                    System.out.println("showInsideOutDualVertsFlag -> "+showInsideOutDualVertsFlag.get());
                    theCanvas.repaint();
                }
            });
            showPrimalVertsFlag.addListener(showPrimalVertsFlagListener = new Listenable.Listener() {
                @Override public void valueChanged()
                {
                    System.out.println("showPrimalVertsFlag -> "+showPrimalVertsFlag.get());
                    theCanvas.repaint();
                }
            });
            showPrimalEdgesFlag.addListener(showPrimalEdgesFlagListener = new Listenable.Listener() {
                @Override public void valueChanged()
                {
                    System.out.println("showPrimalEdgesFlag -> "+showPrimalEdgesFlag.get());
                    theCanvas.repaint();
                }
            });
            showFlatPrimalEdgesFlag.addListener(showFlatPrimalEdgesFlagListener = new Listenable.Listener() {
                @Override public void valueChanged()
                {
                    System.out.println("showFlatPrimalEdgesFlag -> "+showFlatPrimalEdgesFlag.get());
                    theCanvas.repaint();
                }
            });
            showDualVertsFlag.addListener(showDualVertsFlagListener = new Listenable.Listener() {
                @Override public void valueChanged()
                {
                    System.out.println("showDualVertsFlag -> "+showDualVertsFlag.get());
                    theCanvas.repaint();
                }
            });
            showDualEdgesFlag.addListener(showDualEdgesFlagListener = new Listenable.Listener() {
                @Override public void valueChanged()
                {
                    System.out.println("showDualEdgesFlag -> "+showDualEdgesFlag.get());
                    theCanvas.repaint();
                }
            });
            naivePrimalEdgesFlag.addListener(naivePrimalEdgesFlagListener = new Listenable.Listener() {
                @Override public void valueChanged()
                {
                    System.out.println("naivePrimalEdgesFlag -> "+naivePrimalEdgesFlag.get());
                    theCanvas.repaint();
                }
            });
            naiveDualEdgesFlag.addListener(naiveDualEdgesFlagListener = new Listenable.Listener() {
                @Override public void valueChanged()
                {
                    System.out.println("naiveDualEdgesFlag -> "+naiveDualEdgesFlag.get());
                    theCanvas.repaint();
                }
            });
            labelPrimalVertsFlag.addListener(labelPrimalVertsFlagListener = new Listenable.Listener() {
                @Override public void valueChanged()
                {
                    System.out.println("labelPrimalVertsFlag -> "+labelPrimalVertsFlag.get());
                    theCanvas.repaint();
                }
            });
            labelPrimalEdgesFlag.addListener(labelPrimalEdgesFlagListener = new Listenable.Listener() {
                @Override public void valueChanged()
                {
                    System.out.println("labelPrimalEdgesFlag -> "+labelPrimalEdgesFlag.get());
                    theCanvas.repaint();
                }
            });
            labelDualVertsFlag.addListener(labelDualVertsFlagListener = new Listenable.Listener() {
                @Override public void valueChanged()
                {
                    System.out.println("labelDualVertsFlag -> "+labelDualVertsFlag.get());
                    theCanvas.repaint();
                }
            });
            labelDualEdgesFlag.addListener(labelDualEdgesFlagListener = new Listenable.Listener() {
                @Override public void valueChanged()
                {
                    System.out.println("labelDualEdgesFlag -> "+labelDualEdgesFlag.get());
                    theCanvas.repaint();
                }
            });
            showTopologicalRegionWhenDraggingVertexFlag.addListener(showTopologicalRegionWhenDraggingVertexFlagListener = new Listenable.Listener() {
                @Override public void valueChanged()
                {
                    System.out.println("showTopologicalRegionWhenDraggingVertexFlag -> "+showTopologicalRegionWhenDraggingVertexFlag.get());
                    theCanvas.repaint();
                }
            });
            showPrimalDualIntersectionFlag.addListener(showPrimalDualIntersectionFlagListener = new Listenable.Listener() {
                @Override public void valueChanged()
                {
                    System.out.println("showPrimalDualIntersectionFlag -> "+showPrimalDualIntersectionFlag.get());
                    theCanvas.repaint();
                }
            });
            showPrimalDualMinkowskiAverageFlag.addListener(showPrimalDualMinkowskiAverageFlagListener = new Listenable.Listener() {
                @Override public void valueChanged()
                {
                    System.out.println("showPrimalDualMinkowskiAverageFlag -> "+showPrimalDualMinkowskiAverageFlag.get());
                    theCanvas.repaint();
                }
            });
            primalDualVisFlag.addListener(primalDualVisFlagListener = new Listenable.Listener() {
                @Override public void valueChanged()
                {
                    System.out.println("primalDualVisFlag -> "+primalDualVisFlag.get());
                    theCanvas.repaint();
                }
            });
            windowTitle.addListener(windowTitleListener = new Listenable.Listener() {
                @Override public void valueChanged()
                {
                    System.out.println("Changing main window title to "+windowTitle.get());
                    theMainAppletWindow.setTitle(windowTitle.get());
                    theControlPanelWindow.setTitle(windowTitle.get()+" Control Panel");
                }
            });
            myAlgorithmMaxIters.addListener(myAlgorithmMaxItersListener = new Listenable.Listener() {
                @Override public void valueChanged()
                {
                    // dirty the net
                    theNet = null;
                    theCanvas.repaint();
                }
            });
            myAlgorithmSweepOriginHomoSpec.addListener(myAlgorithmSweepOriginHomoSpecListener = new Listenable.Listener() {
                @Override public void valueChanged()
                {
                    // dirty the net
                    theNet = null;
                    theCanvas.repaint();
                }
            });
        } // ShephardsPlayApplet ctor

        static final String helpMessage[] = {
            "===================================================================",
            "Mouse:",
            "    left: add or drag a vertex",
            "    middle (or alt-left): rotate picture in 3d",
            "    right click: delete a vertex (ctrl:x10 shift:x100 ctrl-shift:x1000)",
            "    shift-middle drag: pan entire picture",
            "    shift-left drag: create new edge between two vertices",
            "    ctrl-left: snap to grid when creating and dragging vertices",
            "Keys:",
            "    '1'...'9' - set rotational symmetry for creating and dragging verts (1=none)",
            "    shift-'1'...shift-'9' - set left-right mirror and rotational symmetry",
            "    '0' - set rotational symmetry to 10",
            "    shift-'0' - set left-right mirror and rotational symmetry to 10",
            "    'V' - cycle event verbosity (to java console or system output)",
            "    ' ' - just repaint",
            "    'A' - toggle antiAliasingFlag",
            "    't'/'T' - toggle primary (triangle) mesh",
            "    'i'/'+'/'=' - zoom in",
            "    'o'/'-' - zoom out",
            "    'f' - frame picture",
            "    ctrl-'f' - frame primal and dual independently",
            "    '|' - flip left-right",
            "    '_' - flip up-down",
            "    '/' - flip upper-left lower-right",
            "    '\' - flip lower-left upper-right",
            "    's' - swap a diagonal",
            "    ctrl-'s' - swap a diagonal if the result is more Delaunay",
            "    'D' - Delaunay triangulate",
            "    'w' - add or remove closest dual vertex from list of points to show curvature center of",
            "    'W' - select *all* dual verts for weighting (positive weight, of arity 3), or deselect all if selected all previously",
            "    'e' - toggle also showing centroid and orthocenter and euler line, whenever showing curvature center of selected dual verts",
            "    'O' - toggle optimizeFlag",
            "    'l' - toggle showLabels",
            //"    '0' - toggle showOrigin",
            "    'g' - toggle showGrid",
            "    'M'/'m' - increase/decrease magnification focus region",
            "    'P'/'p' - increase/decrease magnified pixel size",
            "    ctrl-'m' - toggle magnifying glass",
            "    'a' - toggle arrowsTowardsSharpestDihedralsFlag (green)",
            "    alt-'a' - toggle arrowsTowardsShortestEdgesFlag (cyan)",
            "    'n' - toggle showNet",
            "    'F' - toggle Polish",
            "    Left/Right arrow - rotate closest cut or fold CCW or CW around its lagoon in the net",
            "    'S' - turn off optimize, and set vertex heights above surface to 0 (actually radial height field spec)",
            "    'd' - delete closest edge",
            "    ctrl-'d' - swap primal with dual",
            "    ctrl-'i' - toggle showInsideOutDualVertsFlag",
            "    ctrl-'o' - cycle optimizationType",
            "    ctrl-'v' - toggle nonEventVerbose",
            "    ctrl-'b' - uniform grid",
            "    'b' - blue noise",
            "    'j' - just noise",
            "    Esc - clear topo region picture",
            "    Up/Down arrow (non-net mode): push/pull face plane of closest vertex in/out",
            "    Up/Down arrow (net mode): incr/decr my algorithm max iters (ctrl:x10 shift:x100 ctrl-shift:x1000)",
            "    'c' - clear",
            "    'u' / ctrl-'z' - undo",
            "    'r' / 'U' / ctrl-'r' / ctrl-'y' - redo",
            "    'z' - pan closest vertex to origin",
            "    'h' - help",
            "    ctrl-'q' - quit",
            "",
            "    'C' - toggle XXXcentroidHack",
            "===================================================================",
        }; // helpMessage

        private void help()
        {
            theHelpWindow.setState(java.awt.Frame.NORMAL); // not ICONTIFIED
            theHelpWindow.setVisible(true);
            theHelpWindow.toFront();

            if (true)
            {
                FORI (i, helpMessage.length)
                    System.out.println(helpMessage[i]);
            }
        } // help

        // used by dumpComponentHierarchy
        private static String classNameAncestors(Class<?> classs)
        {
            String text = classs.getName();

            if (text.indexOf("java.lang.") == 0)
                text = text.substring(10);
            if (text.indexOf("java.awt.") == 0)
                text = text.substring(9);
            if (text.indexOf("javax.swing.J") == 0)
                text = text.substring(12);

            //if (text.indexOf('$') != -1)
            if (classs.getSuperclass() != null)
                text += " > " + classNameAncestors(classs.getSuperclass());
            return text;
        } // classNameAncestors
        // used by dumpComponentHierarchy
        private static String xcolorstring(java.awt.Color color) {
          if (color == null) return "null";
          int argb = color.getRGB();
          if (((argb >> 24)&0xff) == 0xff) {
            return String.format("#%06x", argb&0xffffff);
          } else {
            return String.format("#%08x", argb);
          }
        }
        // used by dumpComponentHierarchy
        private static String colored(java.awt.Color fg, java.awt.Color bg, String text) {
          if (fg == null || bg == null) return "";
          int fg_rgb = fg.getRGB();
          int bg_rgb = bg.getRGB();
          String answer = String.format("\033[38;2;%d;%d;%dm\033[48;2;%d;%d;%dm%s\033[0m",
                ((fg_rgb>>16)&0xff),
                ((fg_rgb>>8)&0xff),
                ((fg_rgb>>0)&0xff),
                ((bg_rgb>>16)&0xff),
                ((bg_rgb>>8)&0xff),
                ((bg_rgb>>0)&0xff),
                text);
          return answer;
        }

        // TODO: publish this somewhere more legit
        public static void dumpComponentHierarchy(java.awt.Component component, int depth, int iChildInParent, int nChildrenInParent)
        {
            FORI (i, depth) System.out.print(" ");

            System.out.print(iChildInParent+"/"+nChildrenInParent+" ");
            //System.out.print(component+" ");  // interesting but too much
            System.out.print(classNameAncestors(component.getClass()));
            System.out.print("  (fg="+xcolorstring(component.getForeground())+" bg="+xcolorstring(component.getBackground())+")");
            System.out.print("  (name="+component.getName()+")");
            if (false) {
              boolean desiredDoubleBufferedness = true;
              if (component instanceof javax.swing.JComponent) {
                if (component.isDoubleBuffered() != desiredDoubleBufferedness) {
                  System.out.print("  (FORCING DOUBLE BUFFERED TO "+desiredDoubleBufferedness+")");
                  ((javax.swing.JComponent)component).setDoubleBuffered(desiredDoubleBufferedness);
                  CHECK(component.isDoubleBuffered() == desiredDoubleBufferedness);
                }
              }
            }
            if (false) {
              boolean desiredOpaqueness = false;
              if (component instanceof javax.swing.JComponent) {
                if (component.isOpaque() != desiredOpaqueness) {
                  System.out.print("  (FORCING OPAQUE TO "+desiredOpaqueness+")");
                  ((javax.swing.JComponent)component).setOpaque(desiredOpaqueness);
                  CHECK(component.isOpaque() == desiredOpaqueness);
                }
              }
            }


            System.out.print("  (db="+component.isDoubleBuffered()+")");
            System.out.print(" (op="+component.isOpaque()+")");
            System.out.print("  "+colored(component.getForeground(), component.getBackground(), " HELLO "));
            System.out.println();

            if (component instanceof java.awt.Container)
            {
                java.awt.Container C = (java.awt.Container)component;
                if (true) {
                  FORI (i, depth) System.out.print(" ");
                  System.out.print("    "+C.getLayout()+(C.getLayout()==null?"":" ("+classNameAncestors(C.getLayout().getClass())+")"));
                  System.out.println();
                }
                int n = C.getComponentCount();
                for (int iChild = 0; iChild < n; ++iChild)
                {
                    dumpComponentHierarchy(C.getComponent(iChild), depth+1, iChild, n);
                }
            }
        } // dumpComponentHierarchy

        private interface DoSomethingToComponent { void apply(java.awt.Component c); };
        private interface DoSomethingToSwingComponent { void apply(javax.swing.JComponent jc); };
        public static void doToAllComponents(java.awt.Component c, DoSomethingToComponent doSomethingToComponent) {
          // pre-order (so, for instance, if it's paintComponent, it will do it in a sensible order)
          doSomethingToComponent.apply(c);
          if (c instanceof java.awt.Container)
          {
              java.awt.Container C = (java.awt.Container)c;
              int n = C.getComponentCount();
              for (int i = 0; i < n; ++i)
                  doToAllComponents(C.getComponent(i), doSomethingToComponent);
          }
        }

        public static void doToAllSwingComponents(java.awt.Component c, DoSomethingToSwingComponent doSomethingToSwingComponent) {
          doToAllComponents(c, c1 -> {
            if (c1 instanceof javax.swing.JComponent) {
              doSomethingToSwingComponent.apply((javax.swing.JComponent)c1);
            }
          });
        }

        // TODO: publish this somewhere more legit
        public static void randomlyColorize(java.awt.Component c,
                                            final java.util.Random randomNumberGenerator)
        {
            doToAllComponents(c, c1 -> {
              c1.setBackground(new java.awt.Color((float)randomNumberGenerator.nextDouble(),
                                                 (float)randomNumberGenerator.nextDouble(),
                                                 (float)randomNumberGenerator.nextDouble()));
              c1.setForeground(new java.awt.Color((float)randomNumberGenerator.nextDouble(),
                                                 (float)randomNumberGenerator.nextDouble(),
                                                 (float)randomNumberGenerator.nextDouble()));
            });
        } // randomlyColorize

        // This is a bit ridiculous, but... figure out the height a flowLayout wants to be, given a width.
        // Maybe ask on stackOverflow?
        private static int calcFlowLayoutPreferredHeightGivenPreferredWidth(java.awt.Container container, int width) {
            // Strategy:
            //    - set size to given width and large height
            //    - do layout
            //    - traverse children and see what the bottom is
            java.awt.FlowLayout flowLayout = (java.awt.FlowLayout)container.getLayout();
            int hgap = flowLayout.getHgap();
            int vgap = flowLayout.getVgap();
            int n = container.getComponentCount();

            // height upper bound is the height we'd get if every child on different row
            int heightUpperBound = vgap;
            for (int i = 0; i < n; ++i)
            {
                int childPreferredHeight = container.getComponent(i).getPreferredSize().height;
                heightUpperBound += childPreferredHeight + vgap;
            }
            container.setSize(width, heightUpperBound);
            container.doLayout();  // validate() doesn't seem to do it
            int maxBottom = 0;
            for (int i = 0; i < n; ++i) {
                java.awt.Component child = container.getComponent(i);
                int childBottom = child.getY() + child.getHeight();
                maxBottom = MAX(maxBottom, childBottom);
            }
            return maxBottom + vgap;
        }  // calcFlowLayoutPreferredHeightGivenPreferredWidth
        private static int calcMaxChildPreferredWidth(java.awt.Container container)
        {
            int n = container.getComponentCount();
            int answer = 0;
            for (int i = 0; i < n; ++i)
            {
                int childPreferredWidth = container.getComponent(i).getPreferredSize().width;
                answer = MAX(answer, childPreferredWidth);
            }
            return answer;
        } // calcMaxChildPreferredWidth

        public void dualSave(String fileName)
        {
            System.out.println("Saving dual verts to "+fileName+"... ");
            System.out.flush();
            try {
                java.io.PrintWriter writer = new java.io.PrintWriter(new java.io.BufferedWriter(new java.io.FileWriter(fileName)));
                // XXX want \r\n no matter which platform I'm on, I think

                Mesh dualMesh = getDualMesh();
                int nDualVerts = dualMesh.verts.size();
                boolean showInsideOutDualVertsFlagValue = showInsideOutDualVertsFlag.get();
                FORI (iDualVert, nDualVerts)
                {
                    Mesh.Vertex dualVert = dualMesh.getVert(iDualVert);
                    if (dualVert.arity == 3
                     && (showInsideOutDualVertsFlagValue
                      || dualVert.weight >= 0))
                    {
                        writer.println("        {" + dualVert.X()
                                            + ", " + dualVert.Y()
                                            + ", " + dualVert.Z()
                                            + ", " + dualVert.W()
                                            + "},");
                    }
                    else
                        writer.println("null");
                }

                writer.flush();
                writer.close();
            }
            catch (Exception exc)
            {
                System.out.println("save to file "+fileName+" failed:" + exc);
            }
            System.out.println("done.");
        } // dualSave

        public void save(String fileName,
                         boolean saveHomo)
        {
            MeshUtils.saveToOFF(mesh, theNet, fileName, saveHomo);
        } // save

        public void load(String fileName)
        {
            try {
                int edgeStatusesPtr[/*1*/][] = {null};
                boolean firstVertexExistedAndWasHomoPtr[/*1*/] = {false}; // bleah, ugly
                Mesh loadedMesh = MeshUtils.loadFromOFF(fileName, edgeStatusesPtr, firstVertexExistedAndWasHomoPtr);
                if (loadedMesh != null)
                {
                    mesh = loadedMesh;
                    {
                        boolean desiredWrapAroundSphereFlag = false;
                        if (false) // NOT.  If I want wrapAroundSphereFlag to be in there, have to store it explicitly, not this automagic crap.
                        {
                            // Guess what wrapAroundSphere should be based on first vertex (although theoretically they can be mixed).
                            desiredWrapAroundSphereFlag = firstVertexExistedAndWasHomoPtr[0];
                        }

                        // Have to suppress transforming when setting wrap flag.
                        boolean savedTransformFlag = transformWhenChangingWrapOrCenterFlag.get();
                        transformWhenChangingWrapOrCenterFlag.set(false);
                        wrapAroundSphereFlagIntent.set(desiredWrapAroundSphereFlag);
                        transformWhenChangingWrapOrCenterFlag.set(savedTransformFlag);
                    }

                    int edgeStatuses[] = edgeStatusesPtr[0];
                    if (edgeStatuses != null) // if there was Cut and/or Fold info at the end...
                        theNet = new Net(getDualMesh(), loadedMesh, edgeStatuses);

                    if (continuouslyDelaunayizeFlag.get()) delaunayize();

                }
            }
            catch (Exception exc)
            {
                exc.printStackTrace();
                System.out.println("load from file "+fileName+" or something afterwards failed:" + exc);
                mesh = null;
            }
        } // load

        public void pan(double dx, double dy)
        {
            UndoItem.State before = newUndoItemState();
            uniformScaleAndTranslateNoUndoRedo(1., dx, dy, /*primalFlag=*/true, /*dualFlag=*/true);
            UndoItem.State after = newUndoItemState();
            undoTreeSquirrel.Do(new UndoItem(before, after));
            theCanvas.repaint();
        } // pan

        public void panDualOnly(double dx, double dy)
        {
            UndoItem.State before = newUndoItemState();
            uniformScaleAndTranslateNoUndoRedo(1., dx, dy, /*primalFlag=*/false, /*dualFlag=*/true);
            UndoItem.State after = newUndoItemState();
            undoTreeSquirrel.Do(new UndoItem(before, after));
            theCanvas.repaint();
        } // panDualOnly

        public void panPrimalOnly(double dx, double dy)
        {
            UndoItem.State before = newUndoItemState();
            uniformScaleAndTranslateNoUndoRedo(1., dx, dy, /*primalFlag=*/true, /*dualFlag=*/false);
            UndoItem.State after = newUndoItemState();
            undoTreeSquirrel.Do(new UndoItem(before, after));
            theCanvas.repaint();
        }

        // This only sort of makes sense---
        // the dual verts will be spread into roughly correct places,
        // but with preserved angles, which means topology can change.
        // Okay, so, rescaleDualOnly is accomplished by setXYZ(x,y,z*scale).
        // And z = h-(x^2+y^2)/2
        //     h = z+(x^2+y^2)/2
        // I.e. setxyz(x,y,(h-(x^2+y^2)/2)*scale)
        //      setxyz(x,y,h*scale - (x^2+y^2)/2*scale)
        //      setxyh(x,y,h*scale - (x^2+y^2)/2*scale + (x^2+y^2)/2
        //      setxyh(x,y,h*scale + (x^2+y^2)/2*(1-scale))
        //      setxyh(x,y,lerp((x^2+y^2)/2, h, scale)
        // Fuckin hell, this is complicated.
        // Anyway, apparently if I use only one of x or y in the lerp, I can get scale in just that direction. Sort of.
        // I.e. moving from h towards (x^2+y^2)/2 (i.e. planar) scales dual towards 0,
        // and moving towards x^2/2 scales just x part towards 0 while leaving y part the way it is (?)

        // Four coeffs of interest, maybe:
        //      1-scaleX  scaleX
        //      1-scaleY  scaleY
        public void rescaleDualOnlySortOf(double scaleX, double scaleY)
        {
            UndoItem.State before = newUndoItemState();
            FORIDOWN(iVert, mesh.verts.size())
            {
                Mesh.Vertex vert = mesh.getVert(iVert);
                double x = vert.x();
                double y = vert.y();
                double h = vert.h();
                double z = vert.z();

                if (false)
                {
                    // XXX This can't possibly be meaningful.  The two operations don't commute.
                    // However, the following commute, almost:
                    //      (1/16,1)*(1,1/2) = (1,1/16)*(1,1/2) = (1/4.something, 1/4.something)
                    // but that's only almost... the result is stretched a bit more in x than in y.
                    //
                    h = LERP(.5*SQR(x), h, scaleX);
                    h = LERP(.5*SQR(y), h, scaleY);
                }
                else
                {
                    // Idea: to half in x, just uniformly flatten in x, i.e. add a paraboloid.
                    // Do it in log space so things will return to original
                    // when doubled then halved.  Kind of weird, and I don't think it's really right, but...
                    h -= .5*SQR(x)*(Math.log(scaleX)/Math.log(2));
                    h -= .5*SQR(y)*(Math.log(scaleY)/Math.log(2));
                }

                vert.setXYHW(x, y, h, 1.);
                CHECK_EQ(vert.momentAndArea, null);
            }
            if (continuouslyDelaunayizeFlag.get()) delaunayize();
            dirtyDualMesh();
            UndoItem.State after = newUndoItemState();
            undoTreeSquirrel.Do(new UndoItem(before, after));
            theCanvas.repaint();
        }

        public void rescaleDualOnly(double scale)
        {
            UndoItem.State before = newUndoItemState();
            FORIDOWN(iVert, mesh.verts.size())
            {
                Mesh.Vertex vert = mesh.getVert(iVert);
                vert.setXYZW(vert.X(),
                             vert.Y(),
                             vert.Z() * scale,
                             vert.W());
                CHECK_EQ(vert.momentAndArea, null);
            }
            dirtyDualMesh();
            UndoItem.State after = newUndoItemState();
            undoTreeSquirrel.Do(new UndoItem(before, after));
            theCanvas.repaint();
        } // rescaleDualOnly

        public void rescalePrimalOnly(double scale)
        {
            UndoItem.State before = newUndoItemState();
            FORIDOWN(iVert, mesh.verts.size())
            {
                Mesh.Vertex vert = mesh.getVert(iVert);
                vert.setXYZW(vert.X() * scale,
                             vert.Y() * scale,
                             vert.Z() * scale,  // not scale*scale (which is what rescale(scale) would do)
                             vert.W());
                CHECK_EQ(vert.momentAndArea, null);
            }
            dirtyDualMesh();
            UndoItem.State after = newUndoItemState();
            undoTreeSquirrel.Do(new UndoItem(before, after));
            theCanvas.repaint();
        }  // rescalePrimalOnly

        public void rescale(double scaleX, double scaleY)
        {
            rescale(scaleX, scaleY, true);
        }

        // rescales dual too, in the dual way.
        public void rescale(double scaleX, double scaleY, boolean undoRedoFlag)
        {
            int verboseLevel = 1;
            if (verboseLevel >= 1) OUT("        in rescale(scaleX="+scaleX+", scaleY="+scaleY+", undoRedoFlag="+undoRedoFlag);
            UndoItem.State before = undoRedoFlag ? newUndoItemState() : null;
            Mesh dualMesh = getDualMesh(); // before scaling mesh!
            if (!wrapAroundSphereFlag.get())
            {
                if (verboseLevel >= 1) OUT("          before:");
                if (verboseLevel >= 2) PRINT(mesh);
                if (verboseLevel >= 2) PRINT(getDualMesh());
                mesh.sanityCheckCoords(1e-6);
                getDualMesh().sanityCheckCoords(1e-6); // XXX ISSUE: sanityCheckCoords assumes paraboloid
                if (verboseLevel >= 1) OUT("          sane.");
            }
            FORIDOWN (iVert, mesh.verts.size())
            {
                Mesh.Vertex vert = mesh.getVert(iVert);
                // non-naive when wrapped around sphere or when was wrapped and then unwrapped
                // TODO: what was I saying in the above comment?
                vert.setXYZW(vert.X() * scaleX,
                             vert.Y() * scaleY,
                             vert.Z() * scaleX * scaleY,
                             vert.W());
                CHECK_EQ(vert.momentAndArea, null); // moments and areas aren't maintained for primal (triangles) mesh
            }

            if (scaleX != scaleY && continuouslyDelaunayizeFlag.get()) // no need to re-delaunayize if uniform scale   TODO: actually if everything's working right, shouldn't have to do this anyway!?
            {
                delaunayize();
                dirtyDualMesh();
            }
            else
            {
                // don't recalculate dual mesh, rather, just rescale its points accordingly.
                // this makes it so we don't have to blow away the net,
                // and possibly retains better accuracy if dual mesh was created explicitly rather than automatically from primal.
                FORIDOWN(iDualVert, dualMesh.verts.size())
                {
                    Mesh.Vertex dualVert = dualMesh.getVert(iDualVert);
                    double scaleW = scaleX*scaleY;
                    {
                        CHECK_EQ(dualVert.weight*2, dualVert.W()); // i.e. W is twice primal tri area

                        // The following two are equivalent.
                        // CBB: vertex should maybe remember which of H and Z was originally set, and use that one
                        if (false)
                        {
                            dualVert.setXYHW(dualVert.X() * scaleY * scaleW, // converse
                                             dualVert.Y() * scaleX * scaleW, // converse
                                             dualVert.H() * CUB(scaleW),
                                             dualVert.W() * scaleW);
                        }
                        else
                        {
                            // Seems to get a bit better precision? noticed that when zooming way in
                            // to SweepKiller1epsMult polar before I fixed the sanity check, could get
                            // a couple more iterations this way.
                            dualVert.setXYZW(dualVert.X() * scaleY * scaleW, // converse
                                             dualVert.Y() * scaleX * scaleW, // converse
                                             dualVert.Z() * SQR(scaleW),
                                             dualVert.W() * scaleW);
                        }

                        dualVert.weight *= scaleW; // i.e. scaleX*scaleY. makes sense since weight is tri area
                        CHECK_EQ(dualVert.weight*2, dualVert.W()); // i.e. W is twice primal tri area
                    }

                    if (dualVert.momentAndArea != null) // it will be null in strange cases such as when I created it by hand in cannedThingSingleExitLagoonPolygon
                    {
                        // Yes, redundant.
                        CHECK_EQ(dualVert.momentAndArea.length, 4);
                        dualVert.momentAndArea[0] = dualVert.X();
                        dualVert.momentAndArea[1] = dualVert.Y();
                        dualVert.momentAndArea[2] = dualVert.H();
                        dualVert.momentAndArea[3] = dualVert.W();
                    }
                }

                // dual directions are now totally messed up... fix them
                Mesh.fixDualDirections(mesh, dualMesh, wrapAroundSphereFlag.get(), centerSphereFlag.get(), wrapSphereCurvature.get());

                // Scale the ad-hoc algorithm visualizations
                // CBB: make this generic "annotations"
                if (sweepCircleToDrawThroughPoint != null)
                {
                    if (scaleX == scaleY)
                        sweepCircleToDrawThroughPoint = VecMath.sxv(2, scaleX, sweepCircleToDrawThroughPoint);
                    else
                        sweepCircleToDrawThroughPoint = null;
                }
                if (sweepCircleToDrawCenterHomo != null)
                {
                    if (scaleX == scaleY)
                        VecMath.sxv(2, scaleX, sweepCircleToDrawCenterHomo);
                    else
                        sweepCircleToDrawCenterHomo = null;
                }
                if (sweepVisualizationGraphics != null)
                {
                    int nGraphics = sweepVisualizationGraphics.size();
                    FORI (iGraphic, nGraphics)
                    {
                        MyAlgorithmMaybe.Graphic graphic = sweepVisualizationGraphics.get(iGraphic);
                        double graphicVerts[][] = graphic.verts;
                        FORI (iGraphicVert, graphicVerts.length)
                        {
                            CHECK_EQ(graphicVerts[iGraphicVert].length, 2);
                            // Need to separate verts, otherwise shared verts will get double-scaled
                            graphicVerts[iGraphicVert] = new double[]{
                                graphicVerts[iGraphicVert][0] * scaleY,
                                graphicVerts[iGraphicVert][1] * scaleX,
                            };
                        }
                    }

                }
            }
            if (!wrapAroundSphereFlag.get())
            {
                if (verboseLevel >= 1) OUT("          after:");
                if (verboseLevel >= 2) PRINT(mesh);
                if (verboseLevel >= 2) PRINT(getDualMesh());
                mesh.sanityCheckCoords(1e-6);
                getDualMesh().sanityCheckCoords(1e-6);
                if (verboseLevel >= 1) OUT("          sane.");
            }
            if (undoRedoFlag)
            {
                UndoItem.State after = newUndoItemState();
                undoTreeSquirrel.Do(new UndoItem(before, after));
                theCanvas.repaint();
            }
            if (verboseLevel >= 1) OUT("        out rescale(scaleX="+scaleX+", scaleY="+scaleY+", undoRedoFlag="+undoRedoFlag);
        } // rescale

        // Not modified by ctrl (gangFlag=true):
        //   - "scale primal only" 'f' -> frame primal and take dual along with it
        //   - "scale" 'f' ->          -> frame the union
        //   - "scale dual only" 'f'   -> frame dual and take primal along with it
        // Modified by ctrl (gangFlag=false):
        //   - "scale primal only" 'f' -> frame primal without moving dual
        //   - "scale" 'f' -> frame each simultaneously, independent of each other
        //   - "scale dual only" 'f' -> frame dual without moving primal
        public void frame(boolean framePrimalFlag, boolean frameDualFlag, boolean gangFlag)
        {
            CHECK(framePrimalFlag || frameDualFlag);
            UndoItem.State before = newUndoItemState();
            {
                // XXX do I want this?
                resetLocalToWorld();
            }
            frameNoUndoRedo(framePrimalFlag, frameDualFlag, gangFlag);
            // should be no need to re-delaunayize, since uniform scale
            UndoItem.State after = newUndoItemState();
            undoTreeSquirrel.Do(new UndoItem(before, after));
            theCanvas.repaint();
        }

        public void frameNoUndoRedo(boolean framePrimalFlag, boolean frameDualFlag, boolean gangFlag)
        {
            //OUT("in frameNoUndoRedo(primal="+framePrimalFlag+", dual="+frameDualFlag+", gang="+gangFlag+")");
            CHECK(framePrimalFlag || frameDualFlag);
            if (!gangFlag && framePrimalFlag && frameDualFlag)
            {
                frameNoUndoRedo(true, false, false);
                frameNoUndoRedo(false, true, false);
                OUT("out frameNoUndoRedo(primal="+framePrimalFlag+", dual="+frameDualFlag+", gang="+gangFlag+")");
                return;
            }

            double minx = Double.POSITIVE_INFINITY;
            double miny = Double.POSITIVE_INFINITY;
            double maxx = Double.NEGATIVE_INFINITY;
            double maxy = Double.NEGATIVE_INFINITY;
            if (framePrimalFlag)
            {
                FORIDOWN(iVert, mesh.verts.size())
                {
                    Mesh.Vertex vert = mesh.getVert(iVert);
                    minx = MIN(minx, vert.x());
                    maxx = MAX(maxx, vert.x());
                    miny = MIN(miny, vert.y());
                    maxy = MAX(maxy, vert.y());
                }
            }
            if (frameDualFlag)
            {
                Mesh dualMesh = getDualMesh();
                FORIDOWN(iDualVert, dualMesh.verts.size())
                {
                    Mesh.Vertex dualVert = dualMesh.getVert(iDualVert);
                    minx = MIN(minx, dualVert.x());
                    maxx = MAX(maxx, dualVert.x());
                    miny = MIN(miny, dualVert.y());
                    maxy = MAX(maxy, dualVert.y());
                }
            }
            double center[] = {(minx+maxx)*.5, (miny+maxy)*.5};
            if (pRotationalSymmetry.get() > 1)
                VecMath.zerovec(center);

            double maxRadius = MAX4(maxx-center[0], center[0]-minx,
                                    maxy-center[1], center[1]-miny);
            double scale = 1./maxRadius;
            if (maxRadius > 0.)  // don't do anything when inside out? not sure what my reasoning was here. I guess I figured it would get even more messed up.
            {
                // Goal: translate original center to origin, and scale.
                // In other words, scale and then translate origin to minus scaled center.
                double dx = -center[0] * scale;
                double dy = -center[1] * scale;
                uniformScaleAndTranslateNoUndoRedo(scale, dx, dy, framePrimalFlag||gangFlag, frameDualFlag||gangFlag);
            }
            //OUT("out frameNoUndoRedo(primal="+framePrimalFlag+", dual="+frameDualFlag+", gang="+gangFlag+")");
        } // frameNoUndoRedo

        // IDEA: splitting uniformScaleAndTranslate into two things
        // TODO: isn't this redundant with rescale() and rescaleDualOnly() and rescalePrimalOnly()?  consolidate!  (or maybe it isn't)
        public void uniformScaleNoUndoRedoUnchecked(double scale, boolean primalFlag, boolean dualFlag)
        {
            int verboseLevel = 1;
            if (verboseLevel >= 1) OUT("            in uniformScaleNoUndoRedoUnchecked(primal="+primalFlag+", dual="+dualFlag+")");

            CHECK(primalFlag || dualFlag); // or both
            if (primalFlag && !dualFlag)
            {
                FORIDOWN(iVert, mesh.verts.size())
                {
                    Mesh.Vertex vert = mesh.getVert(iVert);
                    vert.setXYHW(vert.X() * scale,
                                 vert.Y() * scale,
                                 vert.H() * scale,
                                 vert.W());
                }
                dirtyDualMesh(); // TODO: do better
            }
            else if (dualFlag && !primalFlag)
            {
                FORIDOWN(iVert, mesh.verts.size())
                {
                    Mesh.Vertex vert = mesh.getVert(iVert);
                    vert.setXYHW(vert.X(),
                                 vert.Y(),
                                 vert.H() * scale,
                                 vert.W());
                }
                dirtyDualMesh(); // TODO: do better
            }
            else // primalFlag && dualFlag
            {
                FORIDOWN(iVert, mesh.verts.size())
                {
                    Mesh.Vertex vert = mesh.getVert(iVert);
                    vert.setXYHW(vert.X() * scale,
                                 vert.Y() * scale,
                                 vert.H() * (scale*scale),
                                 vert.W());
                }
                dirtyDualMesh(); // TODO: do better
            }
            if (verboseLevel >= 1) OUT("            out uniformScaleNoUndoRedoUnchecked(primal="+primalFlag+", dual="+dualFlag+")");
        }  // uniformScaleNoUndoRedoUnchecked

        public void translateNoUndoRedoUnchecked(double dx, double dy, boolean primalFlag, boolean dualFlag)
        {
            int verboseLevel = 1;
            if (verboseLevel >= 1) OUT("            in translateNoUndoRedoUnchecked(primal="+primalFlag+", dual="+dualFlag+")");

            CHECK(primalFlag || dualFlag); // or both
            if (primalFlag && !dualFlag)
            {
                FORIDOWN(iVert, mesh.verts.size())
                {
                    Mesh.Vertex vert = mesh.getVert(iVert);
                    vert.setXYHW(vert.X() + dx*vert.W(),
                                 vert.Y() + dy*vert.W(),
                                 vert.H() + dx*vert.X() + dy*vert.Y(),  // XXX no W? doesn't seem right
                                 vert.W());
                }
                dirtyDualMesh(); // TODO: do better
            }
            else if (dualFlag && !primalFlag)
            {
                FORIDOWN(iVert, mesh.verts.size())
                {
                    Mesh.Vertex vert = mesh.getVert(iVert);
                    vert.setXYHW(vert.X(),
                                 vert.Y(),
                                 vert.H() - dx*vert.X() - dy*vert.Y(),  // XXX no W? doesn't seem right
                                 vert.W());
                }
                dirtyDualMesh(); // TODO: do better
            }
            else // primalFlag && dualFlag
            {
                FORIDOWN(iVert, mesh.verts.size())
                {
                    Mesh.Vertex vert = mesh.getVert(iVert);
                    vert.setXYHW(vert.X() + dx*vert.W(),
                                 vert.Y() + dy*vert.W(),
                                 vert.H(),
                                 vert.W());
                }
                dirtyDualMesh(); // TODO: do better
            }

            if (verboseLevel >= 1) OUT("            out translateNoUndoRedoUnchecked(primal="+primalFlag+", dual="+dualFlag+")");
        }  // translateNoUndoRedoUnchecked

        // TODO: I bet the nonuniform scale could be done in terms of this too.  consolidate!
        public void uniformScaleAndTranslateNoUndoRedo(double scale, double dx, double dy, boolean primalFlag, boolean dualFlag)
        {
            int verboseLevel = 1;
            if (verboseLevel >= 1) OUT("        in uniformScaleAndTranslateNoUndoRedo(primal="+primalFlag+", dual="+dualFlag+")");
            if (!wrapAroundSphereFlag.get())
            {
                if (verboseLevel >= 1) OUT("          before:");
                if (verboseLevel >= 2) PRINT(mesh);
                if (verboseLevel >= 2) PRINT(getDualMesh());
                mesh.sanityCheckCoords(1e-6);
                getDualMesh().sanityCheckCoords(1e-6); // XXX ISSUE: sanityCheckCoords assumes paraboloid
                if (verboseLevel >= 1) OUT("          sane.");
            }

            CHECK(primalFlag || dualFlag); // or both

            if (!(primalFlag && dualFlag))
            {
                // this happens on ctrl-frame-primal and ctrl-frame-dual
                // (ctrl meaning don't bring the other along)
                uniformScaleNoUndoRedoUnchecked(scale, primalFlag, dualFlag);
                translateNoUndoRedoUnchecked(dx, dy, primalFlag, dualFlag);
                // dirties the dual mesh.  // TODO: do better!
            }
            else // primalFlag && dualFlag
            {
                // this happens on Frame

                // TODO: factor all this into scale and translate parts, and put it down inside uniformScaleNoUndoRedoUnchecked and translateNoUndoRedoUnchecked
                FORIDOWN(iVert, mesh.verts.size())
                {
                    Mesh.Vertex vert = mesh.getVert(iVert);
                    vert.setXYHW(vert.X()*scale + dx*vert.W(),
                                 vert.Y()*scale + dy*vert.W(),
                                 vert.H()*scale*scale,
                                 vert.W());
                }
                Mesh dualMesh = getDualMesh();
                //PRINT(dualMesh);
                FORIDOWN(iDualVert, dualMesh.verts.size())
                {
                    Mesh.Vertex dualVert = dualMesh.getVert(iDualVert);
                    CHECK_EQ(dualVert.weight*2, dualVert.W()); // i.e. W is twice primal tri area
                    // dualVert doesn't necessarily have W=1,
                    // so we can't call the "naive" get/set functions.
                    // Do it in homogeneous space.
                    // We're scaling both primal and dual by same amount...
                    // since scaling primal, the dual W (which is proportional to primal tri area)
                    // should get multiplied by scale^2.
                    // TODO: is that true? am I getting W confused with weight?
                    if (false)
                    {
                        // This works but changes W to 1,
                        // which actually messes things up (it ends up changing -1's to 1's
                        // which makes it draw back verts when it shouldn't).
                        dualVert.setXYHW(dualVert.x() * scale + dx,
                                         dualVert.y() * scale + dy,
                                         dualVert.h() * (scale*scale),
                                         1.);
                        // hack to avoid assertion failure
                        dualVert.weight = .5;
                        dualVert.weight /= scale*scale;
                    }
                    else if (false)
                    {
                        // This works and changes W to its proper new value,
                        // but math isn't as direct as it could be
                        double oldW = dualVert.W();
                        double newW = oldW * (scale*scale);
                        dualVert.setXYHW((dualVert.x()*scale+dx) * newW,
                                         (dualVert.y()*scale+dy) * newW,
                                         dualVert.h() * (scale*scale) * newW*newW,
                                         newW);
                    }
                    else if (false)
                    {
                        // Make previous more explicit
                        double oldW = dualVert.W();
                        double newW = oldW * (scale*scale);
                        dualVert.setXYHW((dualVert.X()/oldW*scale+dx) * newW,
                                         (dualVert.Y()/oldW*scale+dy) * newW,
                                         dualVert.H()/oldW/oldW * (scale*scale) * newW*newW,
                                         newW);
                    }
                    else if (false)
                    {
                        // start to rearrange the math
                        double oldW = dualVert.W();
                        double newW = oldW * (scale*scale);
                        dualVert.setXYHW((dualVert.X()*scale+dx*oldW) * newW/oldW,
                                         (dualVert.Y()*scale+dy*oldW) * newW/oldW,
                                         dualVert.H() * (scale*scale) * SQR(newW/oldW),
                                         newW);
                    }
                    else if (true)
                    {
                        // Rearranged. Unfortunately not very illuminating.
                        double oldW = dualVert.W();
                        double scaleW = scale*scale;
                        double newW = oldW * scaleW;
                        dualVert.setXYHW((dualVert.X()*scale+dx*oldW) * scaleW,
                                         (dualVert.Y()*scale+dy*oldW) * scaleW,
                                         dualVert.H() * CUB(scaleW),
                                         newW);
                    }
                    dualVert.weight *= scale*scale; // makes sense since weight is tri area
                    CHECK_EQ(dualVert.weight*2, dualVert.W()); // i.e. W is twice primal tri area
                    if (dualVert.momentAndArea != null)
                    {
                        // Yes, redundant.
                        CHECK_EQ(dualVert.momentAndArea.length, 4);
                        dualVert.momentAndArea[0] = dualVert.X();
                        dualVert.momentAndArea[1] = dualVert.Y();
                        dualVert.momentAndArea[2] = dualVert.H();
                        dualVert.momentAndArea[3] = dualVert.W();
                    }
                }

                // dual directions are now totally messed up... fix them
                Mesh.fixDualDirections(mesh, dualMesh, wrapAroundSphereFlag.get(), centerSphereFlag.get(), wrapSphereCurvature.get());

                // TODO: need to "Scale [and translate] the ad-hoc algorithm visualizations" like in rescale()
            }
            if (!wrapAroundSphereFlag.get())
            {
                if (verboseLevel >= 1) OUT("          after:");
                if (verboseLevel >= 2) PRINT(mesh);
                if (verboseLevel >= 2) PRINT(getDualMesh());
                mesh.sanityCheckCoords(1e-6);
                getDualMesh().sanityCheckCoords(1e-6);
                if (verboseLevel >= 1) OUT("          sane.");
            }
            if (verboseLevel >= 1) OUT("        out uniformScaleAndTranslateNoUndoRedo(primal="+primalFlag+", dual="+dualFlag+")");
        } // uniformScaleAndTranslateNoUndoRedo


        // BUG: sweepKiller1eps, prewarp -> assertion failed: w >= 0
        private void preWarpForRadialHeightField()
        {
            UndoItem.State before = newUndoItemState();

            MeshUtils.preWarpMeshForRadialHeightField(
                this.mesh,
                MeshUtils.parseRadialHeightFieldPairs(radialHeightFieldSpec.get()));

            dirtyDualMesh();
            if (continuouslyDelaunayizeFlag.get()) delaunayize();
            UndoItem.State after = newUndoItemState();
            undoTreeSquirrel.Do(new UndoItem(before, after));
            theCanvas.repaint();
        } // preWarpForRadialHeightField
        private void unPreWarpForRadialHeightField()
        {
            UndoItem.State before = newUndoItemState();

            MeshUtils.unPreWarpMeshForRadialHeightField(
                this.mesh,
                MeshUtils.parseRadialHeightFieldPairs(radialHeightFieldSpec.get()));

            dirtyDualMesh();
            if (continuouslyDelaunayizeFlag.get()) delaunayize();
            UndoItem.State after = newUndoItemState();
            undoTreeSquirrel.Do(new UndoItem(before, after));
            theCanvas.repaint();
        } // preWarpForRadialHeightField

        // This is what gets called by "Apply Radial Match" button.
        // name "ReSpherize" is accurate only if radial heightfield is identity
        // TODO: revisit this. wtf was I thinking? 'S' key doesn't work as expected any more??
        private void turnOffOptimizeAndReSpherize()
        {
            UndoItem.State before = newUndoItemState();
            if (optimizeFlag.get())
            {
                optimizeFlag.set(false);
                System.out.println("optimizeFlag -> "+optimizeFlag.get()+" ('O' to turn back on)");
            }
            if (wrapAroundSphereFlag.get())
            {
                double wrapSphereRadius = 1./wrapSphereCurvature.get();
                boolean centerSphereFlagValue = centerSphereFlag.get();
                double scratch[] = new double[3];
                FORIDOWN (iVert, mesh.verts.size())
                {
                    Mesh.Vertex vert = mesh.getVert(iVert);
                    scratch[0] = vert.x();
                    scratch[1] = vert.y();
                    scratch[2] = vert.z();
                    if (!centerSphereFlagValue)
                        scratch[2] += wrapSphereRadius;
                    VecMath.normalize(scratch, scratch);
                    VecMath.vxs(scratch, scratch, wrapSphereRadius);
                    if (!centerSphereFlagValue)
                        scratch[2] -= wrapSphereRadius;
                    vert.setXYZW(scratch[0],
                                 scratch[1],
                                 scratch[2],
                                 1.);
                }
            }
            else
            {
                if (true)
                {
                    double pairs[][/*3*/] = MeshUtils.parseRadialHeightFieldPairs(radialHeightFieldSpec.get());
                    CHECK_NE(pairs, null); // since it should have been validated already
                    MeshUtils.applyRadialHeightFieldPairsToMesh(this.mesh, pairs);
                }
                else
                {
                    // Simple version... equivalent to applying radial height field {{0,0},{1,1}} or equivalently {}
                    FORIDOWN (iVert, mesh.verts.size())
                    {
                        Mesh.Vertex vert = mesh.getVert(iVert);
                        vert.setxyh(vert.x(),
                                    vert.y(),
                                    0.);
                    }
                }
            }
            dirtyDualMesh();
            if (continuouslyDelaunayizeFlag.get()) delaunayize();
            UndoItem.State after = newUndoItemState();
            undoTreeSquirrel.Do(new UndoItem(before, after));
            theCanvas.repaint();
        } // turnOffOptimizeAndReSpherize

        // wrap from parabola to sphere
        private void wrapAroundSphere(double wrapSphereCurvature, boolean centerSphereFlag)
        {
            xformTheMesh(GeomUtils.getWrapAroundSphereMatrix(wrapSphereCurvature, centerSphereFlag));
        } // wrapAroundSphere


        // unwrap from sphere to parabola
        private void unwrapAroundSphere(double wrapSphereCurvature, boolean centerSphereFlag)
        {
            xformTheMesh(GeomUtils.getUnwrapAroundSphereMatrix(wrapSphereCurvature, centerSphereFlag));
        } // unwrapAroundSphere

        // TODO: move the core of this to MeshUtils
        private void xformTheMesh(double mat[/*4*/][/*4*/])
        {
            double in[] = new double[4];
            double out[] = new double[4];

            // Note: something screwy here.  We apparently allow an arbitrary 4x4 matrix,
            // however we use the "naive" setters/getters all over the place
            // which assert W=1, so setting W!=1 here will cause assertion failures.
            // On the other hand, wrapAroundSphere and unwrapAroundSphere do set W!=1 I think... yeah,
            // checking "wrap around sphere" and then trying to pan gives an assert failure.
            FORIDOWN(iVert, mesh.verts.size())
            {
                Mesh.Vertex vert = mesh.getVert(iVert);
                in[0] = vert.X();
                in[1] = vert.Y();
                in[2] = vert.Z();
                in[3] = vert.W();
                VecMath.vxm(out, in, mat);
                vert.setXYZW(out[0],
                             out[1],
                             out[2],
                             out[3]);
            }
            // TODO: can we explicitly xform the dual instead of dirtying it and recomputing it from scratch?  Would be tricky since
            // each dual vert's W has to be the corresponding primal tri area, and it's different for each one, I think.
            dirtyDualMesh();
            if (continuouslyDelaunayizeFlag.get()) delaunayize();
        } // xformTheMesh


        private void changeSymmetry(int p, int q, boolean leftRight, boolean central, boolean repeatWorkInProgress)
        {
            if (p == pRotationalSymmetry.get()
             && q == qRotationalSymmetry.get()
             && leftRight == leftRightSymmetry.get()
             && central == sphereCentralSymmetry.get()
             && repeatWorkInProgress == q346meanRepeatRegardlessOfPFlag.get())
            {
                return; // no change
            }

            System.out.println("rotationalSymmetry -> "+p+","+q
                + " "+(leftRight?"with":"without")+" left-right symmetry"
                + " "+(central?"with":"without")+" central symmetry");

            UndoItem.State before = newUndoItemState();
            if (remapFundamentalRegionWhenChangingRotationalSymmetry.get()
             && (p != pRotationalSymmetry.get()
              || q != qRotationalSymmetry.get()))
            {
                if (deleteUnmatchedVertsWhenChangingRotationalSymmetry.get())
                {
                    double group[][][] = getTheRotationalSymmetryGroup(); // ignore reflective symmetries here
                    boolean retainConnectivity = false; // since the changeMeshRotationalSymmetry afterwards loses the mesh anyway
                    this.mesh = MeshUtils.forceMeshSymmetryByDeletingVertsDestructive(this.mesh, group, retainConnectivity);
                }
                else
                {
                    // Replicating unmatched verts when changing rotational symmetry.
                    // changeRotationalSymmetry will do the right thing,
                    // so no need to do anything here.
                }

                // changeMeshRotationalSymmetry requires a centered sphere,
                // so xform and un-xform if necessary to make that so.
                boolean needToWrapAndUnwrap = false;
                boolean needToCenterAndUncenter = false;
                if (pRotationalSymmetry.get()!=1 && qRotationalSymmetry.get()!=1 && p!=1 && q!=1)
                {
                    if (!wrapAroundSphereFlag.get())
                        needToWrapAndUnwrap = true;
                    else if (!centerSphereFlag.get())
                        needToCenterAndUncenter = true;
                }
                if (needToWrapAndUnwrap)
                {
                    wrapAroundSphere(wrapSphereCurvature.get(), true);
                }
                else if (needToCenterAndUncenter)
                {
                    xformTheMesh(GeomUtils.getCenterSphereMatrix(wrapSphereCurvature.get()));
                }

                this.mesh = MeshUtils.changeMeshRotationalSymmetry(this.mesh,
                                                                   pRotationalSymmetry.get(),
                                                                   qRotationalSymmetry.get(),
                                                                   p, q);

                if (needToWrapAndUnwrap)
                {
                    unwrapAroundSphere(wrapSphereCurvature.get(), true);
                }
                else if (needToCenterAndUncenter)
                {
                    xformTheMesh(GeomUtils.getUncenterSphereMatrix(wrapSphereCurvature.get()));
                }
            }
            // probably a lot of excess messages going on...
            pRotationalSymmetry.set(p);
            qRotationalSymmetry.set(q);
            leftRightSymmetry.set(leftRight);
            sphereCentralSymmetry.set(central);
            if (continuouslyDelaunayizeFlag.get()) delaunayize();
            UndoItem.State after = newUndoItemState();
            undoTreeSquirrel.Do(new UndoItem(before, after));

            theCanvas.repaint();
        } // changeSymmetry

        private void forceSymmetryByReplicatingVerts()
        {
            double group[][][] = getTheSymmetryGroup();
            UndoItem.State before = newUndoItemState();
            this.mesh = MeshUtils.forceMeshSymmetryByReplicatingVerts(this.mesh, group);
            if (continuouslyDelaunayizeFlag.get()) delaunayize();
            UndoItem.State after = newUndoItemState();
            undoTreeSquirrel.Do(new UndoItem(before, after));
            theCanvas.repaint();
        }
        private void forceSymmetryByDeletingVerts()
        {
            double group[][][] = getTheSymmetryGroup();
            UndoItem.State before = newUndoItemState();
            boolean retainConnectivity = true; // hard-coded, but could be an option
            this.mesh = MeshUtils.forceMeshSymmetryByDeletingVertsDestructive(this.mesh, group, retainConnectivity);
            dirtyDualMesh(); // necessary if it did in-place operations and returned original
            if (continuouslyDelaunayizeFlag.get()) delaunayize();
            UndoItem.State after = newUndoItemState();
            undoTreeSquirrel.Do(new UndoItem(before, after));
            theCanvas.repaint();
        }

        // NOTE: the only reason this is a separate function is that this class used to be derived from JApplet and that's how they liked it
        public void init()
        {
            // Note that eventVerbose can be set on the command line, e.g. eventVerbose=10
            if (eventVerbose >= 1) System.out.println("in init");

            //doCannedThingHexesSpiral();
            //doCannedThingNetless9();
            //doCannedThingEyeball();
            //doCannedThingNetless8();
            //doCannedThingCrackGoesInSpiralSmall();
            //doCannedThingHexesSpiralOther();
            //doCannedThingNetless8Symmetric();
            //doCannedThingNetless8Optimized();
            //doCannedThingNetless8SlopeOptimized();
            //doCannedThingSweepKiller0();
            //doCannedThingSweepKiller1();
            //doCannedThingAlgorithm5Killer0();
            //doCannedThingAlgorithm5Killer1();
            //doCannedThingFarthestLagoonExitKiller();
            //doCannedThingFarthestLagoonExitKillerAltB();
            //doCannedThingFarthestLagoonExitKillerOptimized();
            //doBlueNoiseThing(blueNoiseN.get());
            //doCannedThingSweepKiller1epsMultiple(sweepKiller1Multiplicity.get(), sweepKiller1Multiplicity.get(), false);
            //doCannedThingOutStressor(outStressorNLevels.get());
            //doCannedThingOutStressorSpiral(outStressorSpiralN.get());
            //doCannedThingFaceSweepKiller();

            load("DUMP.off");

            if (false)
                doCannedThingSingleExitLagoonPolygon(
                    singleExitLagoonVirtualN.get(),

                    singleExitLagoonNBeforeApex.get(),
                    singleExitLagoonNAfterApex.get(),
                    singleExitLagoonQuillSlopeNumerator.get(),
                    singleExitLagoonQuillSlopeDenominator.get(),
                    singleExitLagoonNBeforeBeforeApex.get(),
                    singleExitLagoonNAfterAfterApex.get(),
                    singleExitLagoonQuillSlopeNumeratorNumerator.get(),
                    singleExitLagoonQuillSlopeDenominatorDenominator.get(),
                    singleExitLagoonPointApexUpFlag.get(),

                    singleExitLagoonSynthesizeExactDualFlag.get(),
                    singleExitLagoonFudgeWeightsSoApexIsFarthestFromCurvatureCenterFlag.get());

            if (eventVerbose >= 1) System.out.println("out init");
        } // init

        private class TheCanvas
            extends JPanel
        {
            private int inputMethodVerboseLevel = 0;
            private java.awt.im.InputMethodRequests inputMethodRequests = null;
            @Override
            public java.awt.im.InputMethodRequests getInputMethodRequests() {
              if (inputMethodVerboseLevel >= 1) System.out.println("in getInputMethodRequests");
              if (inputMethodVerboseLevel >= 1) System.out.println("  super.getInputMethodRequests() = "+super.getInputMethodRequests());
              if (inputMethodVerboseLevel >= 1) System.out.println("out getInputMethodRequests, returning "+inputMethodRequests);
              return inputMethodRequests;
            }

            TheCanvas()
            {
                // Work around the macos keyrepeat / accent menu bug:
                //       https://bugs.openjdk.java.net/browse/JDK-8167263
                // A systemwide workaround is to disable the character accent menu and enable
                // auto-repeat instead:
                //    defaults write -g ApplePressAndHoldEnabled -bool false
                // (to undo, set it to true).
                // (I was unable to get that to work on a per-app basis.)
                // This inside-app workaround is from here:
                //   https://github.com/brackeen/Scared/commit/17af314c5ebc8a6f6bc3215aed870a20bbb4ec48
                //   https://github.com/TurboVNC/turbovnc/commit/1fcce19ae2930f02c3a222be2ab22d0a7fcc966c which uses the same workaround.
                // I added a note to https://stackoverflow.com/questions/40712283/disable-mac-character-accents-menu-while-my-java-app-is-running#comment89242654_40712283 .
                if (System.getProperty("os.name").toLowerCase().startsWith("mac")) {
                    // Can't use enableInputMethods(false), since that uses the default
                    // broken method (without calling our getInputMethodRequests()).
                    // Can't use the default enableInputMethods(true) with getInputMethodRequests()
                    // returning null, since that uses the default broken method.
                    // So, have to make getInputMethodRequests() return an InputMethodRequests object,
                    // with custom behavior: pop up the accent menu off-screen.
                    inputMethodRequests = new java.awt.im.InputMethodRequests() {
                        // static not allowed in inner class
                        private /*static*/ final java.text.AttributedCharacterIterator EMPTY_TEXT =
                                (new java.text.AttributedString("")).getIterator();
                        @Override
                        public java.text.AttributedCharacterIterator getSelectedText(java.text.AttributedCharacterIterator.Attribute[] attributes) {
                            if (inputMethodVerboseLevel >= 1) System.out.println("in InputMethodRequests getSelectedText");
                            if (inputMethodVerboseLevel >= 1) System.out.println("out InputMethodRequests getSelectedText, returning EMPTY_TEXT");
                            return EMPTY_TEXT;
                        }
                        @Override
                        public java.text.AttributedCharacterIterator cancelLatestCommittedText(java.text.AttributedCharacterIterator.Attribute[] attributes) {
                            if (inputMethodVerboseLevel >= 1) System.out.println("in InputMethodRequests cancelLatestCommittedText");
                            if (inputMethodVerboseLevel >= 1) System.out.println("out InputMethodRequests cancelLatestCommittedText, returning null");
                            return null;
                        }
                        @Override
                        public int getCommittedTextLength() {
                            if (inputMethodVerboseLevel >= 1) System.out.println("in InputMethodRequests getCommittedTextLength");
                            if (inputMethodVerboseLevel >= 1) System.out.println("out InputMethodRequests getCommittedTextLength, returning 0");
                            return 0;
                        }
                        @Override
                        public java.text.AttributedCharacterIterator getCommittedText(int beginIndex, int endIndex,
                                                                            java.text.AttributedCharacterIterator.Attribute[] attributes) {
                            if (inputMethodVerboseLevel >= 1) System.out.println("in InputMethodRequests getCommittedText");
                            if (inputMethodVerboseLevel >= 1) System.out.println("out InputMethodRequests getCommittedText, returning null");
                            return null;
                        }
                        @Override
                        public int getInsertPositionOffset() {
                            if (inputMethodVerboseLevel >= 1) System.out.println("in InputMethodRequests getInsertPositionOffset");
                            if (inputMethodVerboseLevel >= 1) System.out.println("out InputMethodRequests getInsertPositionOffset, returning 0");
                            return 0;
                        }
                        @Override
                        public java.awt.font.TextHitInfo getLocationOffset(int x, int y) {
                            if (inputMethodVerboseLevel >= 1) System.out.println("in InputMethodRequests getLocationOffset");
                            if (inputMethodVerboseLevel >= 1) System.out.println("out InputMethodRequests getLocationOffset, returning null");
                            return null;
                        }

                        @Override
                        public java.awt.Rectangle getTextLocation(java.awt.font.TextHitInfo textHitInfo) {
                            // In screen coordinates, not window coordinates.
                            if (inputMethodVerboseLevel >= 1) System.out.println("in InputMethodRequests getTextLocation");
                            if (inputMethodVerboseLevel >= 1) System.out.println("out InputMethodRequests getTextLocation, returning a weird rectangle");
                            return new java.awt.Rectangle(/*x=*/-32768, /*y=*/-32768, /*width=*/0, /*height=*/0);
                        }
                    };  // inputMethodRequests
                } else {
                    // TODO: not sure I need this?
                    enableInputMethods(false);  // it's enabled by default.  what does this do?
                }

                // Specify an "event listener" object
                // to respond to events: Mouse, MouseMotion, Key.
                // (>= Java 1.1 event model).
                this.addMouseListener(new java.awt.event.MouseListener() {
                    @Override public void mousePressed(java.awt.event.MouseEvent e)
                    {
                        if (eventVerbose >= 1) System.out.println("in mousePressed: "+e);
                        if (eventVerbose >= 1)
                        {
                            if (e.getButton() == java.awt.event.MouseEvent.BUTTON1)
                                System.out.println("    (left mouse)");
                            if (e.getButton() == java.awt.event.MouseEvent.BUTTON2)
                                System.out.println("    (middle mouse)");
                            if (e.getButton() == java.awt.event.MouseEvent.BUTTON3)
                                System.out.println("    (right mouse)");
                        }

                        double thisP[] = new double[2];

                        mostRecentGraphics.pick(e.getX()+.5, e.getY()+.5, thisP);
                        double thisPeffective[] = thisP;

                        double projectedThisPeffective[] = new double[3];
                        pickPointOnSurface(thisPeffective, 0., projectedThisPeffective, false);
                        mousePressWasBackFacing = false;

                        // reset these guys...
                        prevP = thisP;
                        origP = thisP;
                        // and these... may further refine the effective ones below if actually picking a vertex
                        prevPeffective = thisPeffective;
                        origPeffective = thisPeffective;

                        boolean snapToGrid = e.isControlDown();
                        double snappedProjectedThisP[] = !snapToGrid ? projectedThisPeffective : new double[] {
                            (double)Math.round(projectedThisPeffective[0]/gridSnapQuantum)*gridSnapQuantum,
                            (double)Math.round(projectedThisPeffective[1]/gridSnapQuantum)*gridSnapQuantum,
                            projectedThisPeffective[2], // we'll fix this in a moment
                        };

                        if (snapToGrid)
                        {
                            if (wrapAroundSphereFlag.get())
                            {
                                // not sure what snapToGrid means when surface is sphere
                            }
                            else
                                snappedProjectedThisP[2] = 0. - .5 * (SQR(snappedProjectedThisP[0]) + SQR(snappedProjectedThisP[1])); // actual
                        }

                        stateWhenPressed = newUndoItemState();

                        int whichButton = e.getButton();

                        if (whichButton == java.awt.event.MouseEvent.BUTTON1)
                        {
                            button1IsDown = true;

                            if (e.isShiftDown())
                            {
                                //
                                // Add an edge from the closest vertex
                                //
                                System.out.println("    Rubberbanding a new edge from "+snappedProjectedThisP[0]+" "+snappedProjectedThisP[1]+" "+0+"");

                                //
                                // If there are no vertices, add one
                                //
                                java.util.ArrayList<Mesh.Vertex> verts = mesh.verts;
                                if (verts.size() == 0)
                                {
                                    System.out.println("        (Adding a vertex first)");
                                    mesh.addIsolatedVertex(snappedProjectedThisP[0], snappedProjectedThisP[1], 0.);

                                    // added something-- invalidate dual mesh
                                    dirtyDualMesh();
                                    if (continuouslyDelaunayizeFlag.get()) delaunayize();
                                }

                                //
                                // Select closest vertex
                                //
                                beingDraggedVertIndex = mesh.indexOfClosestVert(thisP[0],thisP[1], mostRecentGraphics);
                                mostRecentlyBeingDraggedVertIndex = beingDraggedVertIndex;
                                Mesh.Vertex vert = mesh.getVert(beingDraggedVertIndex);

                                // figure out whether it's on the front or back of its offset surface.
                                // this is a bit of a hack.
                                {
                                    double scratch[] = {vert.x(), vert.y(), vert.z()};
                                    mousePressWasBackFacing = pickedPointIsBackFacingOnSurface(scratch);
                                    PRINT(mousePressWasBackFacing);
                                }

                                beingDraggedVertUnsnappedXY = new double[]{vert.x(), vert.y()};
                                rubberBandingNewEdge = true;
                            }
                            else // shift is not down
                            {
                                if (showNetFlag.get())
                                {
                                    if (e.getX() < thermometerWidth
                                     || e.getX() >= theCanvas.getWidth()-thermometerWidth)
                                    {
                                        thermometerIsLinear ^= true;
                                        System.out.println("thermometerIsLinear -> "+thermometerIsLinear);
                                    }
                                    else
                                    {
                                        if (theNet.nUndecideds() > 0)
                                        {
                                            int iEdge = getDualMesh().indexOfClosestEdge(thisP, true);
                                            if (iEdge != -1 && theNet.getEdgeStatus(iEdge) == Net.UNDECIDED)
                                            {
                                                theNet.cut(iEdge, true);
                                                if (theNet.nUndecideds() == 0)
                                                {
                                                    int root = getDualMesh().verts.size();
                                                    theNet.chooseDirections(root);
                                                }
                                            }
                                            else
                                            {
                                                System.out.println("BONK!");
                                            }
                                        }
                                        else
                                        {
                                            // begin dragging a net edge or fold
                                            PRINT(beingDraggedNetEdgeIndex);
                                            beingDraggedNetEdgeIndex = getDualMesh().indexOfClosestEdge(projectedThisPeffective, true); // XXX not right actually... want closest edge in screen space, not doing this paraboloid thing
                                            PRINT(beingDraggedNetEdgeIndex);
                                            beingDraggedNetEdgeDelta = new double[]{0,0};
                                        }
                                    }
                                    theCanvas.repaint();
                                }
                                else
                                {
                                    //
                                    // Add a vertex...
                                    // but only if not very close to an existing one.
                                    //
                                    int closestVertIndex = mesh.indexOfClosestVert(thisP[0],thisP[1],mostRecentGraphics);
                                    if (closestVertIndex != -1) // if we have a candidate...
                                    {
                                        // we want to measure the distance
                                        // in actual pixels, from the actual
                                        // integer pixel coord where the vertex appears.
                                        // XXX TODO: this is getting really arcane, need a more straightforward procedure
                                        Mesh.Vertex closestVert = mesh.getVert(closestVertIndex);
                                        double scratch[] = new double[3];
                                        mostRecentGraphics.xform(closestVert.X(), closestVert.Y(), closestVert.Z(), closestVert.W(), scratch);
                                        double vertPixelCoords[] = new double[2];
                                        mostRecentGraphics.unpick(scratch[0], scratch[1], vertPixelCoords);
                                        int maxPixelDist = MAX(ABS(e.getX()-(int)Math.round(vertPixelCoords[0]-.5)),
                                                               ABS(e.getY()-(int)Math.round(vertPixelCoords[1]-.5)));
                                        //PRINT(maxPixelDist);
                                        //if (maxPixelDist > 3*hidpimag)
                                        if (maxPixelDist > 6*hidpimag)
                                            closestVertIndex = -1; // too far
                                    }
                                    if (closestVertIndex != -1) // if it wasn't too far
                                    {
                                        beingDraggedVertIndex = closestVertIndex;
                                        mostRecentlyBeingDraggedVertIndex = beingDraggedVertIndex;
                                        System.out.println("Dragging vertex "+beingDraggedVertIndex);
                                        Mesh.Vertex beingDraggedVert = mesh.getVert(beingDraggedVertIndex);
                                        // figure out whether it's on the front or back of its offset surface.
                                        // this is a bit of a hack.
                                        {
                                            double scratch[] = {beingDraggedVert.x(), beingDraggedVert.y(), beingDraggedVert.z()};
                                            mousePressWasBackFacing = pickedPointIsBackFacingOnSurface(scratch);
                                            PRINT(mousePressWasBackFacing);
                                        }
                                        beingDraggedVertUnsnappedXY = new double[]{beingDraggedVert.x(), beingDraggedVert.y()};

                                        Mesh.Vertex closestVert = mesh.getVert(closestVertIndex);
                                        double scratch[] = new double[3];
                                        mostRecentGraphics.xform(closestVert.X(), closestVert.Y(), closestVert.Z(), closestVert.W(), scratch);
                                        thisPeffective = (double[])Arrays.subarray(scratch, 0, 2);
                                        origPeffective = thisPeffective;
                                        prevPeffective = thisPeffective;


                                        if (snapToGrid)
                                        {
                                            double unsnappedCoords[] = {beingDraggedVert.x(), beingDraggedVert.y()};
                                            double snappedCoords[] = {(double)Math.round(beingDraggedVert.x()/gridSnapQuantum)*gridSnapQuantum,
                                                                      (double)Math.round(beingDraggedVert.y()/gridSnapQuantum)*gridSnapQuantum};
                                            double group[][][] = getTheSymmetryGroup();
                                            int nVerts = mesh.verts.size();
                                            FORI (iGroup, group.length)
                                            {
                                                double unsnappedImage[] = VecMath.vxm(unsnappedCoords,group[iGroup]);
                                                FORI (iVert, nVerts)
                                                {
                                                    Mesh.Vertex vertI = mesh.getVert(iVert);
                                                    if (EQ(unsnappedImage[0], vertI.x(), 1e-6)
                                                     && EQ(unsnappedImage[1], vertI.y(), 1e-6))
                                                    {
                                                        double snappedImage[] = VecMath.vxm(snappedCoords,group[iGroup]);
                                                        System.out.println("Snapping vertex "+iVert+" from "+vertI.x()+" "+vertI.y()+" "+vertI.h()+"");
                                                        vertI.setxyh(snappedImage[0],
                                                                     snappedImage[1],
                                                                     vertI.h());
                                                        System.out.println("Dragging vertex "+iVert+" from "+vertI.x()+" "+vertI.y()+" "+vertI.h()+"");
                                                    }
                                                }
                                            }

                                            if (continuouslyDelaunayizeFlag.get()) delaunayize();
                                        }
                                    }
                                    else // closest was too far-- add a new vert
                                    {
                                        double vertsToAdd[][] = {snappedProjectedThisP};

                                        if (pRotationalSymmetry.get() > 1
                                         || qRotationalSymmetry.get() > 1
                                         || leftRightSymmetry.get()
                                         || sphereCentralSymmetry.get()
                                         || q346meanRepeatRegardlessOfPFlag.get())
                                        {
                                            double group[][][] = getTheSymmetryGroup();
                                            vertsToAdd = SymmetryUtils.generateVertices(vertsToAdd, group);
                                        }

                                        // we add them in reverse order, so that the original one
                                        // will be the last one added, so that it will be the one to be dragged
                                        FORIDOWN (iVertToAdd, vertsToAdd.length)
                                        {
                                            double vertToAdd[] = vertsToAdd[iVertToAdd];
                                            double x = vertToAdd[0];
                                            double y = vertToAdd[1];
                                            double z = vertToAdd[2];

                                            if (q346meanRepeatRegardlessOfPFlag.get())
                                            {
                                                double w = vertToAdd[3];
                                                System.out.println("    Adding vertex "+mesh.verts.size()+" at "+x+" "+y+" "+z+" "+w+", hope this is right");
                                                mesh.addIsolatedVertex(x, y, z, w);
                                                System.out.println("        it came out as: "+mesh.verts.get(mesh.verts.size()-1));
                                            }
                                            else if (wrapAroundSphereFlag.get())
                                            {
                                                double w = vertToAdd[3];
                                                System.out.println("    Adding vertex "+mesh.verts.size()+" at "+x+" "+y+" "+z+" "+w);
                                                mesh.addIsolatedVertex(x, y, z, w);
                                            }
                                            else
                                            {
                                                System.out.println("    Adding vertex "+mesh.verts.size()+" at "+x+" "+y+" 0 (ignoring z="+z+")");
                                                mesh.addIsolatedVertex(x, y, 0.);
                                            }

                                            //PRINT(vertOffset(mesh.getVert(mesh.verts.size()-1), wrapAroundSphereFlag.get()));
                                            //CHECK_ALMOST_EQ(vertOffset(mesh.getVert(mesh.verts.size()-1), wrapAroundSphereFlag.get()), 0., 1e-6);

                                            java.util.ArrayList<Mesh.Vertex> verts = mesh.verts;
                                            java.util.ArrayList<Mesh.Edge> edges = mesh.edges;
                                            if (verts.size() >= 2)
                                            {
                                                //
                                                // If are no edges at all, add an edge.
                                                // XXX this is kind of lame when there were more than one isolated vertex, should connect to them all
                                                //
                                                if (edges.size() == 0)
                                                {
                                                    System.out.println("Adding an edge between two verts");
                                                    mesh.addEdgeBetweenTwoIsolatedVertices(verts.get(verts.size()-2),
                                                                                           verts.get(verts.size()-1));
                                                }
                                                else // edges.size() >= 1
                                                {
                                                    // There was already at least one edge.
                                                    // Find out which face we are on
                                                    // (all triangles CCW), and kis that face.
                                                    // if we are not inside any face by that criterion,
                                                    // then assume we are inside the outer face
                                                    // and connect the new vertex to every vertex
                                                    // that's visible from it.
                                                    //
                                                    Mesh.Edge someEdgeOnFaceVertIsIn = MeshUtils.findSomeEdgeOnFaceVertIsIn(mesh, x, y);
                                                    if (someEdgeOnFaceVertIsIn != null)
                                                    {
                                                        mesh.kisIsolatedVertex(verts.get(verts.size()-1),
                                                                               someEdgeOnFaceVertIsIn);
                                                    }
                                                    else
                                                    {
                                                        System.out.println("In the outer face");
                                                        //
                                                        // It wasn't inside any face.
                                                        // Assume it's in the outer face.
                                                        // In this case,
                                                        // make a kiss to the outer face
                                                        // and then delete all newly added edges
                                                        // that cross the boundary of the outer face.
                                                        //
                                                        Mesh.Edge someEdgeOnMostNegativeFace = MeshUtils.findSomeEdgeOnMostNegativeFace(mesh);
                                                        java.util.ArrayList<Mesh.Edge> oldOuterFaceBoundary = new java.util.ArrayList<Mesh.Edge>();
                                                        for (Mesh.Edge edge = someEdgeOnMostNegativeFace;;)
                                                        {
                                                            oldOuterFaceBoundary.add(edge);
                                                            if ((edge = edge.next()) == someEdgeOnMostNegativeFace)
                                                                break;
                                                        }
                                                        int oldOuterFaceBoundarySize = oldOuterFaceBoundary.size();

                                                        int oldNumEdges = mesh.edges.size();
                                                        mesh.kisIsolatedVertex(verts.get(verts.size()-1),
                                                                               someEdgeOnMostNegativeFace);
                                                        if (!showInsideOutDualVertsFlag.get())
                                                        {
                                                            for (int iEdge = oldNumEdges;
                                                                 iEdge < mesh.edges.size();
                                                                 iEdge += 2) // do only one of an edge and its opposite
                                                            {
                                                                for (int iOldBoundaryEdge = 0;
                                                                     iOldBoundaryEdge < oldOuterFaceBoundarySize;
                                                                     ++iOldBoundaryEdge)
                                                                {
                                                                    Mesh.Edge oldEdge = oldOuterFaceBoundary.get(iOldBoundaryEdge);
                                                                    Mesh.Edge newEdge = mesh.getEdge(iEdge);

                                                                    if (newEdge.initialVertex() == oldEdge.initialVertex()
                                                                     || newEdge.initialVertex() == oldEdge.finalVertex()
                                                                     || newEdge.finalVertex() == oldEdge.initialVertex()
                                                                     || newEdge.finalVertex() == oldEdge.finalVertex())
                                                                        continue;
                                                                    //System.out.println("    Seeing whether new edge v"+newEdge.initialVertex().myIndex()+" -> v"+newEdge.finalVertex().myIndex()+" crosses old boundary edges v"+oldEdge.initialVertex().myIndex()+" -> v"+oldEdge.finalVertex().myIndex()+"");
                                                                    if (GeomUtils.edgesCrossOrCloseToIt(
                                                                        oldEdge.initialVertex().x(),
                                                                        oldEdge.initialVertex().y(),
                                                                        oldEdge.finalVertex().x(),
                                                                        oldEdge.finalVertex().y(),
                                                                        newEdge.initialVertex().x(),
                                                                        newEdge.initialVertex().y(),
                                                                        newEdge.finalVertex().x(),
                                                                        newEdge.finalVertex().y(),
                                                                        1e-6))
                                                                    {
                                                                        //System.out.println("        It does.");
                                                                        mesh.deleteEdge(newEdge);
                                                                        iEdge -= 2; // so we don't skip the one that gets moved into the deleted spot
                                                                        break;
                                                                    }
                                                                    else
                                                                    {
                                                                        //System.out.println("        It doesn't.");
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                } // if verts.length >= 3
                                            } // if verts.size() >= 2 after adding the new vertex

                                            mesh.sanityCheckTopology();

                                            beingDraggedVertIndex = verts.size()-1; // start dragging the one we just added
                                            mostRecentlyBeingDraggedVertIndex = beingDraggedVertIndex;
                                            // XXX not sure the following is right, since it's already been snapped, right? or has it?
                                            beingDraggedVertUnsnappedXY = new double[]{vertsToAdd[0][0],
                                                                                       vertsToAdd[0][1]};
                                        }

                                        // added something-- invalidate dual mesh
                                        dirtyDualMesh();
                                        if (continuouslyDelaunayizeFlag.get()) delaunayize();
                                    }
                                } // !showNetFlag
                            } // shift not down

                        }
                        else if (whichButton == java.awt.event.MouseEvent.BUTTON2)
                        {
                            button2IsDown = true;

                            if (e.isShiftDown())
                            {
                                // Drag all verts (XXX need different way of expressing this I think, now that middle button being used for rotate)
                                beingDraggedVertIndex = mesh.indexOfClosestVert(thisP[0],thisP[1],mostRecentGraphics);
                                mostRecentlyBeingDraggedVertIndex = beingDraggedVertIndex;
                                if (beingDraggedVertIndex == -1)
                                    System.out.println("Dragging vertex "+beingDraggedVertIndex);
                                else
                                {
                                    if (snapToGrid)
                                    {
                                        // Snap all the vertices we're about to drag
                                        // XXX need to store unsnapped for all of them!
                                        FORIDOWN (iVert, mesh.verts.size())
                                        {
                                            Mesh.Vertex vert = mesh.getVert(iVert);
                                            vert.setxyh((double)Math.round(vert.x()/gridSnapQuantum)*gridSnapQuantum,
                                                        (double)Math.round(vert.y()/gridSnapQuantum)*gridSnapQuantum,
                                                        vert.h());
                                        }
                                        if (continuouslyDelaunayizeFlag.get()) delaunayize();
                                    }
                                }
                            }
                            else
                            {
                                if (eventVerbose >= 1) System.out.println("setting draggingRotation=true on BUTTON2 down");
                                draggingRotation = true;
                            }
                        }
                        else if (whichButton == java.awt.event.MouseEvent.BUTTON3)
                        {
                            button3IsDown = true;

                            if (showNetFlag.get())
                            {
                                int iEdge = getDualMesh().indexOfClosestEdge(thisP, true);
                                if (iEdge != -1 && theNet.getEdgeStatus(iEdge) == Net.CUT)
                                {
                                    theNet.uncut(iEdge);
                                    beingDraggedNetEdgeIndex = -1;
                                }
                                else
                                {
                                    System.out.println("BONK!");
                                }
                            }
                            else
                            {
                                int nVertsToDelete = 1;
                                if (e.isControlDown()) nVertsToDelete *= 10;
                                if (e.isShiftDown()) nVertsToDelete *= 100;
                                FORI (iiVertToDelete, nVertsToDelete)
                                {
                                    //
                                    // Delete closest vertex,
                                    // and all its reflections and rotations in the symmetry group
                                    //
                                    beingDraggedVertIndex = mesh.indexOfClosestVert(thisP[0],thisP[1],mostRecentGraphics);
                                    mostRecentlyBeingDraggedVertIndex = -1;
                                    PRINT(beingDraggedVertIndex);
                                    int oldToNew[] = VecMath.identityperm(mesh.verts.size());
                                    int newToOld[] = VecMath.identityperm(mesh.verts.size());
                                    if (beingDraggedVertIndex != -1)
                                    {
                                        Mesh.Vertex beingDraggedVert = mesh.getVert(beingDraggedVertIndex);
                                        double v[] = {beingDraggedVert.x(), beingDraggedVert.y(), beingDraggedVert.z()};
                                        double group[][][] = getTheSymmetryGroup();
                                        Mesh.Vertex vertsToDelete[] = MeshUtils.findAllVertsThatAreImages(mesh, v, group, 1e-6);
                                        FORI (iVertToDelete, vertsToDelete.length)
                                            mesh.deleteVertex(vertsToDelete[iVertToDelete], oldToNew, newToOld);
                                    }
                                    beingDraggedVertIndex = -1;
                                    mostRecentlyBeingDraggedVertIndex = -1;  // yes, clear it, it's disappearing

                                    // re-index selectedTris and invalidate selectedDualVertIndices
                                    if (!allDualVertsAreSelected)
                                    {
                                        selectedDualVertIndices = new int[] {}; // TODO: maybe shouldn't even be a member var, it's too volatile
                                        // re-index selectedTris using oldToNew.
                                        // indices of verts that disappeared will turn into -1.

                                        //Arrays.getMany(selectedTris, oldToNew, selectedTris); // TODO: use this when it exists
                                        selectedTris = (int[][])Arrays.getMany(oldToNew, selectedTris);
                                    }

                                    // deleted something-- invalidate dual mesh
                                    dirtyDualMesh();

                                    mesh.sanityCheckTopology();
                                }
                                if (continuouslyDelaunayizeFlag.get()) delaunayize();
                            }

                        } // right mouse


                        theCanvas.repaint();

                        if (eventVerbose >= 1) System.out.println("out mousePressed: "+e);
                    } // mousePressed
                    @Override public void mouseReleased(java.awt.event.MouseEvent e)
                    {
                        if (eventVerbose >= 1) System.out.println("in mouseReleased: "+e);

                        double thisP[] = new double[2];
                        mostRecentGraphics.pick(e.getX()+.5, e.getY()+.5, thisP);
                        double thisPeffective[] = VecMath.vpvmv(thisP,origPeffective,origP);
                        double projectedThisPeffective[] = new double[3];
                        pickPointOnSurface(thisPeffective, 0., projectedThisPeffective, mousePressWasBackFacing);
                        boolean snapToGrid = e.isControlDown();
                        double snappedProjectedThisPeffective[] = !snapToGrid ? projectedThisPeffective : new double[] {
                            (double)Math.round(projectedThisPeffective[0]/gridSnapQuantum)*gridSnapQuantum,
                            (double)Math.round(projectedThisPeffective[1]/gridSnapQuantum)*gridSnapQuantum,
                            0., // we'll fix this in a moment
                        };
                        // XXX TODO: this doesn't seem right... if not snapToGrid, then we're modifying projectedThisPeffective.  confused
                        snappedProjectedThisPeffective[2] = 0. - .5 * (SQR(snappedProjectedThisPeffective[0]) + SQR(snappedProjectedThisPeffective[1]));

                        int whichButton = e.getButton();
                        if (whichButton == java.awt.event.MouseEvent.BUTTON1)
                        {
                            if (rubberBandingNewEdge)
                            {
                                if (mesh.verts.size() == 1)
                                {
                                    System.out.println("    Adding vertex "+mesh.verts.size()+" at "+snappedProjectedThisPeffective[0]+" "+snappedProjectedThisPeffective[1]+" "+0+"");
                                    mesh.addIsolatedVertex(snappedProjectedThisPeffective[0], snappedProjectedThisPeffective[1], 0.);
                                }
                                int finalVertIndex = mesh.indexOfClosestVert(thisP[0],thisP[1],mostRecentGraphics);
                                if (beingDraggedVertIndex != -1
                                 && finalVertIndex != -1
                                 && beingDraggedVertIndex != finalVertIndex)
                                {
                                    System.out.println("Trying to add an edge between "+beingDraggedVertIndex+" and "+finalVertIndex);
                                    java.util.ArrayList<Mesh.Vertex> verts = mesh.verts;
                                    mesh.addEdgeBetweenTwoVertices(mesh.getVert(beingDraggedVertIndex),
                                                                   mesh.getVert(finalVertIndex));
                                    mesh.sanityCheckTopology();
                                    PRINT(mesh.edges.size());

                                    // added something-- invalidate dual mesh
                                    dirtyDualMesh();
                                }
                                if (continuouslyDelaunayizeFlag.get()) delaunayize();
                            }
                            rubberBandingNewEdge = false;

                            if (beingDraggedNetEdgeIndex != -1
                             && showNetFlag.get())
                            {
                                Mesh dualMesh = getDualMesh();
                                int targetEdgeIndex = dualMesh.indexOfClosestEdge(projectedThisPeffective, true); // XXX not really right, see similar comment on mouse down
                                if (targetEdgeIndex != -1
                                 && targetEdgeIndex != beingDraggedNetEdgeIndex
                                 && dualMesh.getEdge(targetEdgeIndex).opposite().myIndex() != beingDraggedNetEdgeIndex)
                                {
                                    // Make sure it's a valid alternative.
                                    // (could do this once on mouse down,
                                    // but whatever, it's O(n) which is fine here)
                                    int alternatives[] = theNet.findAlternatives(beingDraggedNetEdgeIndex);
                                    if (Arrays.indexOf(alternatives, targetEdgeIndex) != -1
                                     || Arrays.indexOf(alternatives, targetEdgeIndex^1) != -1)
                                    {
                                        theNet.swapCutAndFold(beingDraggedNetEdgeIndex,
                                                              targetEdgeIndex);
                                    }
                                    else
                                    {
                                        System.out.println("BONK!");
                                    }
                                }
                            }

                            beingDraggedVertIndex = -1;
                            // do *not* clear mostRecentlyBeingDraggedVertIndex
                            beingDraggedNetEdgeIndex = -1;


                            // HACK to get around stuck isDragging when alt is released before left mouse button,
                            // when simulating middle with alt-left.
                            // This is actually wrong on a 3-button system... I think?  Confusing
                            if (draggingRotation && (e.getModifiersEx() & java.awt.event.InputEvent.BUTTON2_DOWN_MASK) == 0)
                            {
                                if (eventVerbose >= 1) System.out.println("setting draggingRotation=false on BUTTON1 up!!");
                                draggingRotation = false;
                            }

                            button1IsDown = false;
                        }
                        else if (whichButton == java.awt.event.MouseEvent.BUTTON2)
                        {
                            beingDraggedVertIndex = -1;
                            // do *not* clear mostRecentlyBeingDraggedVertIndex
                            beingDraggedNetEdgeIndex = -1;
                            if (eventVerbose >= 1) System.out.println("setting draggingRotation=false on BUTTON2 up");
                            draggingRotation = false;

                            button2IsDown = false;
                        }
                        else if (whichButton == java.awt.event.MouseEvent.BUTTON3)
                        {
                            button3IsDown = false;
                        }

                        if (stateWhenPressed != null)
                        {
                            UndoItem.State stateWhenReleased = newUndoItemState();
                            undoTreeSquirrel.Do(new UndoItem(stateWhenPressed, stateWhenReleased));
                            stateWhenPressed = null;
                        }

                        prevP = thisP;

                        theCanvas.repaint();

                        if (eventVerbose >= 1) System.out.println("out mouseReleased: "+e);
                    }
                    public void mouseEntered(java.awt.event.MouseEvent e)
                    {
                        if (eventVerbose >= 1) System.out.println("in mouseEntered: "+e);
                        // Steal keyboard focus, so user doesn't need to click first.
                        // I think the state of things is:
                        //      - Buttons and TextFields are apparently "focus traversable"
                        //        by default.  Canvases and Applets aren't,
                        //        implying (not obvious) that you need to click to type
                        //        when the app starts,
                        requestFocus(); // hey it works! (javac 1.3, runtime 1.6) so overriding isFocusTraversable() no longer necessary
                        if (eventVerbose >= 1) System.out.println("out mouseEntered: "+e);
                    }
                    public void mouseExited(java.awt.event.MouseEvent e)
                    {
                        if (eventVerbose >= 1) System.out.println("in mouseExited: "+e);
                        if (eventVerbose >= 1) System.out.println("out mouseExited: "+e);
                    }
                    public void mouseClicked(java.awt.event.MouseEvent e)
                    {
                        if (eventVerbose >= 1) System.out.println("in mouseClicked: "+e);
                        if (eventVerbose >= 1) System.out.println("out mouseClicked: "+e);
                    }
                });  // MouseListener
                this.addMouseMotionListener(new java.awt.event.MouseMotionListener() {
                    public void mouseDragged(java.awt.event.MouseEvent e)
                    {
                        if (eventVerbose >= 2) System.out.println("  in mouseDragged: "+e);
                        boolean snapToGrid = e.isControlDown();
                        double thisP[] = new double[2];
                        mostRecentGraphics.pick(e.getX()+.5, e.getY()+.5, thisP);
                        double thisPeffective[] = VecMath.vpvmv(thisP,origPeffective,origP);

                        if (draggingRotation)
                        {
                            // increment tilt according to deltaY,
                            // and twirl according to deltaX
                            double deltaX = thisP[0]-prevP[0];
                            double deltaY = thisP[1]-prevP[1];

                            // too slow unless we multiply it by something!
                            deltaX *= 5.;
                            deltaY *= 5.;

                            // so we ignore pure x jiggle when tilt is maxed...
                            if (!(tilt <= 0. && deltaY <= 0.)
                             && !(tilt >= Math.PI && deltaY >= 0))
                                twirl += deltaX;
                            tilt += deltaY;

                            while (twirl < -Math.PI) twirl += 2*Math.PI;
                            while (twirl >  Math.PI) twirl -= 2*Math.PI;

                            // any excess tilt is turned into twirl towards zero,
                            // making it park at tilt=0, twirl=0
                            if (tilt < 0.)
                            {
                                if (twirl < 0.)
                                    twirl = MIN(twirl + -tilt, 0.);
                                else
                                    twirl = MAX(twirl - -tilt, 0.);
                                tilt = 0.;
                            }
                            else if (tilt > Math.PI)
                            {
                                if (twirl < 0.)
                                    twirl = MIN(twirl + (tilt-Math.PI), 0.);
                                else
                                    twirl = MAX(twirl - (tilt-Math.PI), 0.);
                                tilt = Math.PI;
                            }

                            if (true)
                            {

                                // tweak the scale part:
                                // make it so if the z axis didn't rotate much, z scale is 0.
                                // this is so that all the perpendiculars and stuff will look right
                                // when looking at it top-down.
                                double limitDegrees = 10.;
                                if (tilt < DTOR(limitDegrees))
                                {
                                    localScaleZ = tilt / DTOR(limitDegrees);
                                    //OUT("flattish");
                                }
                                else
                                {
                                    localScaleZ = 1.;
                                    //OUT("bumpy");
                                }
                            }
                        }

                        if (button1IsDown || button2IsDown) // XXX wean away from the button2IsDown thing
                        {
                            if (rubberBandingNewEdge)
                            {
                                if (snapToGrid)
                                {
                                    double projectedThisPeffective[] = new double[3];
                                    pickPointOnSurface(thisPeffective, 0., projectedThisPeffective, mousePressWasBackFacing);
                                    double snappedProjectedThisPeffective[] = !snapToGrid ? projectedThisPeffective : new double[] {
                                        (double)Math.round(projectedThisPeffective[0]/gridSnapQuantum)*gridSnapQuantum,
                                        (double)Math.round(projectedThisPeffective[1]/gridSnapQuantum)*gridSnapQuantum,
                                        0., // we'll fix this in a moment
                                    };
                                    projectedThisPeffective = null; // done with it, transferred ownership
                                    snappedProjectedThisPeffective[2] = 0. - .5 * (SQR(snappedProjectedThisPeffective[0]) + SQR(snappedProjectedThisPeffective[1]));

                                    // now what??? project back to screen and set prevP to it.
                                    // argh, but then it will get clobbered at the bottom.
                                    // oh, set *thisP* to it, so prevP will get set to that! hacky

                                    double scratch[] = new double[3];
                                    mostRecentGraphics.xform(snappedProjectedThisPeffective[0],
                                                             snappedProjectedThisPeffective[1],
                                                             snappedProjectedThisPeffective[2],
                                                             1.,
                                                             scratch);
                                    VecMath.copyvec(2, thisP, scratch);
                                }
                            }
                            else
                            {
                                if (beingDraggedNetEdgeIndex != -1)
                                {
                                    // XXX not really right... see similar comment on mouse down
                                    double projectedThisPeffective[] = new double[3];
                                    pickPointOnSurface(thisP, 0., projectedThisPeffective, mousePressWasBackFacing);
                                    double projectedPrevP[] = new double[3];
                                    pickPointOnSurface(prevP, 0., projectedPrevP, mousePressWasBackFacing);

                                    beingDraggedNetEdgeDelta[0] += projectedThisPeffective[0]-projectedPrevP[0]; // no snap to grid for this
                                    beingDraggedNetEdgeDelta[1] += projectedThisPeffective[1]-projectedPrevP[1]; // no snap to grid for this
                                }
                                else if (e.isShiftDown())
                                {
                                    // Drag all the verts and dual verts.
                                    // No need to invalidate anything.
                                    // XXX use pan()! I think (but do NOT put it in the undo state!).  although currently it dirties dual mesh just like we do here
                                    FORIDOWN (iVert, mesh.verts.size())
                                    {
                                        Mesh.Vertex vert = mesh.getVert(iVert);
                                        // When non-naive needed: when "wrapped around sphere"
                                        // However, this isn't right!  Should retain the same kind of W
                                        vert.setxyh(vert.x() + thisP[0]-prevP[0],
                                                    vert.y() + thisP[1]-prevP[1],
                                                    vert.h());
                                    }
                                    dirtyDualMesh(); // XXX don't do this! but have to currently because above math is wrong
                                }
                                else if (beingDraggedVertIndex != -1)
                                {
                                    Mesh.Vertex beingDraggedVert = mesh.getVert(beingDraggedVertIndex);
                                    double offset = vertOffset(beingDraggedVert, wrapAroundSphereFlag.get()); // XXX TODO: should just snapshot this on mouse down... MAYBE. but keep in mind, user can change offset while dragging, with arrow keys

                                    /*
                                        All right, how should this look?
                                            1. Find closest vert, in pixels, to the mouse cursor (already found, since dragging)
                                            2. determine its surface offset and whether it's front-facing or back-facing
                                            3. project it to screen space
                                            4. apply delta to it in screen space
                                            5. project screen point to offset surface at same height as before to get new position,
                                               with same facing (or opposite facing if ray misses surface)
                                            6. if paraboloid, snap x,y part to grid but retain same offset (height above paraboloid)
                                            7. for any symmetry images, do same thing to them

                                        Spaces:
                                            pixel space   (mouse coords in this space)
                                                most recent graphics mat
                                            eye space (same as world space I think)
                                            world space
                                                localToWorld
                                            vert local space
                                            homogeneous vert space
                                    */
                                    double beingDraggedVertNewCoords[] = new double[3];
                                    pickPointOnSurface(thisPeffective, offset, beingDraggedVertNewCoords, mousePressWasBackFacing);
                                    beingDraggedVertNewCoords = Arrays.append(beingDraggedVertNewCoords, 1.); // TODO: just make this homogeneous throughout

                                    beingDraggedVertUnsnappedXY = new double[] {beingDraggedVertNewCoords[0],beingDraggedVertNewCoords[1]};

                                    double beingDraggedVertNewCoordsSnapped[] = !snapToGrid ? beingDraggedVertNewCoords : new double[] {
                                        (double)Math.round(beingDraggedVertNewCoords[0]/gridSnapQuantum)*gridSnapQuantum,
                                        (double)Math.round(beingDraggedVertNewCoords[1]/gridSnapQuantum)*gridSnapQuantum,
                                        beingDraggedVertNewCoords[2], // we'll fix this in a moment
                                        1.,
                                    };
                                    beingDraggedVertNewCoords = null; // done with it, transferred ownership
                                    if (snapToGrid)
                                        beingDraggedVertNewCoordsSnapped[2] -= .5 * (SQR(beingDraggedVertNewCoordsSnapped[0]) + SQR(beingDraggedVertNewCoordsSnapped[1]));

                                    // we're going to change the position of beingDraggedVert
                                    // to beingDraggedVertNewCoordsSnapped.

                                    if (pRotationalSymmetry.get() > 1
                                     || qRotationalSymmetry.get() > 1
                                     || leftRightSymmetry.get()
                                     || sphereCentralSymmetry.get()
                                     || q346meanRepeatRegardlessOfPFlag.get())
                                    {
                                        double beingDraggedVertOldCoords[] = {beingDraggedVert.x(),
                                                                              beingDraggedVert.y(),
                                                                              beingDraggedVert.z(),
                                                                              1.};
                                        // Drag all points of kaleidoscope.
                                        //
                                        // If any other verts are images of beingDraggedVert in the kaleidescope,
                                        // the new position of that vert should be the new position
                                        // of beingDraggedVert, with the same symmetry applied.
                                        // In cases when another vertex (or beingDraggedVert itself)
                                        // is an image under more than one symmetry (i.e. when exactly on a mirror),
                                        // we average the images under each of the symmetries.
                                        //
                                        double group[][][] = getTheSymmetryGroup();

                                        int nVerts = mesh.verts.size();
                                        double newVertexPositionSums[][] = new double[nVerts][]; // all null initially
                                        int newVertexPositionWeights[] = new int[nVerts]; // all zeros initially
                                        double scratch[] = new double[4];

                                        FORI (iGroup, group.length)
                                        {
                                            double oldImage[] = VecMath.vxm(beingDraggedVertOldCoords, group[iGroup]);
                                            VecMath.normalize(oldImage, oldImage);
                                            double newImage[] = null; // calculated on demand the first time it's needed below
                                            FORI (iVert, nVerts)
                                            {
                                                Mesh.Vertex vert = mesh.getVert(iVert);
                                                scratch[0] = vert.X();
                                                scratch[1] = vert.Y();
                                                scratch[2] = vert.Z();
                                                scratch[3] = vert.W();
                                                VecMath.normalize(scratch, scratch);
                                                if (EQ(oldImage[0], scratch[0], 1e-6)
                                                 && EQ(oldImage[1], scratch[1], 1e-6)
                                                 && EQ(oldImage[2], scratch[2], 1e-6)
                                                 && EQ(oldImage[3], scratch[3], 1e-6))
                                                {
                                                    if (newImage == null)
                                                        newImage = VecMath.vxm(beingDraggedVertNewCoordsSnapped, group[iGroup]);
                                                    if (newVertexPositionSums[iVert] == null)
                                                        newVertexPositionSums[iVert] = new double[4]; // zeros
                                                    // XXX TODO: wow this is totally wrong now, can't just add in homogeneous space
                                                    CHECK_EQ(newImage.length, 4);
                                                    CHECK_EQ(newVertexPositionSums[iVert].length, 4);
                                                    VecMath.vpv(newVertexPositionSums[iVert],
                                                                newVertexPositionSums[iVert],
                                                                newImage);
                                                    newVertexPositionWeights[iVert]++;
                                                }
                                            }
                                        }
                                        FORI (iVert, nVerts)
                                        {
                                            int weight = newVertexPositionWeights[iVert];
                                            if (weight != 0)
                                            {
                                                double newCoords[] = scratch;
                                                VecMath.vxs(newCoords, newVertexPositionSums[iVert], 1./weight);
                                                Mesh.Vertex vert = mesh.getVert(iVert);
                                                if (wrapAroundSphereFlag.get())
                                                {
                                                    vert.setXYZW(newCoords[0],
                                                                 newCoords[1],
                                                                 newCoords[2],
                                                                 newCoords[3]);
                                                }
                                                else
                                                {
                                                    // on paraboloid; h doesn't change, and more accurate if we use the old h
                                                    vert.setxyh(newCoords[0]/newCoords[3],
                                                                newCoords[1]/newCoords[3],
                                                                vert.h());
                                                }
                                            }
                                        }
                                    }
                                    else // there are no non-identity symmetries, just the vert
                                    {
                                        if (wrapAroundSphereFlag.get())
                                        {
                                            beingDraggedVert.setXYZW(beingDraggedVertNewCoordsSnapped[0],
                                                                     beingDraggedVertNewCoordsSnapped[1],
                                                                     beingDraggedVertNewCoordsSnapped[2],
                                                                     beingDraggedVertNewCoordsSnapped[3]);
                                        }
                                        else
                                        {
                                            // on paraboloid; h doesn't change
                                            beingDraggedVert.setxyh(beingDraggedVertNewCoordsSnapped[0]/beingDraggedVertNewCoordsSnapped[3],
                                                                    beingDraggedVertNewCoordsSnapped[1]/beingDraggedVertNewCoordsSnapped[3],
                                                                    beingDraggedVert.h());
                                        }
                                    }

                                    if (continuouslyDelaunayizeFlag.get()) delaunayize();
                                    if (nonEventVerbose >= 1)
                                    {
                                        double verts[][] = new double[mesh.verts.size()][];
                                        FORIDOWN (iVert, mesh.verts.size())
                                            verts[iVert] = new double[] {mesh.getVert(iVert).x(),
                                                                         mesh.getVert(iVert).y(),
                                                                         mesh.getVert(iVert).h()};
                                        int edges[][] = new int[mesh.edges.size()][];
                                        FORIDOWN (iEdge, mesh.edges.size())
                                            edges[iEdge] = new int[] {(mesh.getEdge(iEdge)).initialVertex().myIndex(),
                                                                      (mesh.getEdge(iEdge)).finalVertex().myIndex()};
                                        PRINTARRAY(verts);
                                        PRINTARRAY(edges);
                                    }
                                    // moved something-- invalidate dual mesh XXX could retain structure and just update positions and angles?? then wouldn't have to invalidate net!
                                    dirtyDualMesh();
                                }
                            }
                        }

                        if (button3IsDown) // right mouse
                        {
                        }

                        theCanvas.repaint();

                        prevP = thisP;
                        prevPeffective = thisPeffective;

                        if (eventVerbose >= 2) System.out.println("  out mouseDragged: "+e);
                    } // mouseDragged
                    public void mouseMoved(java.awt.event.MouseEvent e)
                    {
                        if (eventVerbose >= 3) System.out.println("    in mouseMoved: "+e);

                        if (mostRecentGraphics != null)
                        {
                            double thisP[] = new double[2];
                            mostRecentGraphics.pick(e.getX()+.5, e.getY()+.5, thisP);
                            if (showNetFlag.get())
                            {
                                int closestDualEdgeIndex = getDualMesh().indexOfClosestEdge(thisP, true);
                                if (closestDualEdgeIndex != highlightedDualEdgeIndex)
                                {
                                    //System.out.println("    closest dual edge changed: "+getDualMesh().getEdge(closestDualEdgeIndex));
                                    highlightedDualEdgeIndex = closestDualEdgeIndex;
                                    theCanvas.repaint();
                                }
                            }
                            prevP = thisP;

                            if (showMagFlag.get())
                                theCanvas.repaint();

                            if (primalDualVisFlag.get()
                             && primalDualVisAngles != null
                             && primalDualVisPrimalVertInds != null
                             && primalDualVisDualVertInds != null)
                                theCanvas.repaint();
                        }

                        if (eventVerbose >= 3) System.out.println("    out mouseMoved: "+e);
                    } // mouseMoved
                });  // MouseMotionListener
                this.addKeyListener(new java.awt.event.KeyListener() {
                    @Override public void keyPressed(java.awt.event.KeyEvent e)
                    {
                        if (eventVerbose >= 1) System.out.println("in keyPressed: "+e);
                        double incr = .005;
                        if (e.isShiftDown())
                            incr *= 10.;
                        else if (e.isControlDown())
                            incr /= 10.;
                        int keyCode = e.getKeyCode();
                        switch(keyCode)
                        {
                            case java.awt.event.KeyEvent.VK_UP:
                            {
                                if (showNetFlag.get())
                                {
                                    int Incr = 1;
                                    if (e.isControlDown()) Incr *= 10;
                                    if (e.isShiftDown()) Incr *= 100;
                                    myAlgorithmMaxIters.set(myAlgorithmMaxIters.get() + Incr);
                                }
                                else
                                {
                                    UndoItem.State before = newUndoItemState();
                                    if (optimizeFlag.get())
                                    {
                                        optimizeFlag.set(false);
                                        System.out.println("optimizeFlag -> "+optimizeFlag.get()+" ('O' to turn back on)");
                                    }
                                    System.out.print("Up");
                                    System.out.flush();
                                    int iVert = mesh.indexOfClosestVert(prevP[0], prevP[1],mostRecentGraphics);
                                    if (iVert != -1)
                                    {
                                        Mesh.Vertex vertI = mesh.getVert(iVert);
                                        double v[] = {vertI.x(), vertI.y(), vertI.z()};
                                        double group[][][] = getTheSymmetryGroup();
                                        Mesh.Vertex vertsToMove[] = MeshUtils.findAllVertsThatAreImages(mesh, v, group, 1e-6);

                                        // used only in wrapAroundSphere case
                                        boolean wrapAroundSphereFlagValue = wrapAroundSphereFlag.get();

                                        if (wrapAroundSphereFlag.get())
                                        {
                                            double sphereCenterZ = (centerSphereFlag.get() ? 0. : -1./wrapSphereCurvature.get());
                                            FORI (iVertToMove, vertsToMove.length)
                                            {
                                                Mesh.Vertex vert = vertsToMove[iVertToMove];
                                                v[0] = vert.x();
                                                v[1] = vert.y();
                                                v[2] = vert.z() - sphereCenterZ;
                                                double oldR = Math.sqrt(SQR(v[0])+SQR(v[1])+SQR(v[2]));
                                                double newR = oldR - incr;
                                                double scale = newR / oldR;
                                                vert.setXYZW(v[0]*scale, v[1]*scale, v[2]*scale + sphereCenterZ, 1.);
                                            }
                                        }
                                        else
                                        {
                                            FORI (iVertToMove, vertsToMove.length)
                                            {
                                                Mesh.Vertex vert = vertsToMove[iVertToMove];
                                                // pull the dual face *out* of the screen,
                                                // i.e. increase its height,
                                                // i.e. decrease height of primal vert.
                                                vert.setxyh(vert.x(),
                                                            vert.y(),
                                                            vert.h() - incr);
                                                System.out.println("    verts["+vert.myIndex()+"].Hnaive() -> "+vert.Hnaive());
                                            }
                                        }
                                        if (continuouslyDelaunayizeFlag.get()) delaunayize();
                                    }
                                    UndoItem.State after = newUndoItemState();
                                    undoTreeSquirrel.Do(new UndoItem(before, after));
                                    dirtyDualMesh();
                                    theCanvas.repaint();
                                }
                                break;
                            }
                            case java.awt.event.KeyEvent.VK_DOWN:
                            {
                                if (showNetFlag.get())
                                {
                                    int decr = 1;
                                    if (e.isControlDown()) decr *= 10;
                                    if (e.isShiftDown()) decr *= 100;
                                    myAlgorithmMaxIters.set(myAlgorithmMaxIters.get() - decr);
                                }
                                else
                                {
                                    UndoItem.State before = newUndoItemState();
                                    if (optimizeFlag.get())
                                    {
                                        optimizeFlag.set(false);
                                        System.out.println("optimizeFlag -> "+optimizeFlag.get()+" ('O' to turn back on)");
                                    }
                                    System.out.print("Down");
                                    System.out.flush();
                                    int iVert = mesh.indexOfClosestVert(prevP[0], prevP[1],mostRecentGraphics);
                                    if (iVert != -1)
                                    {
                                        Mesh.Vertex vertI = mesh.getVert(iVert);
                                        double v[] = {vertI.x(), vertI.y(), vertI.z()};
                                        double group[][][] = getTheSymmetryGroup();
                                        Mesh.Vertex vertsToMove[] = MeshUtils.findAllVertsThatAreImages(mesh, v, group, 1e-6);

                                        if (wrapAroundSphereFlag.get())
                                        {
                                            double sphereCenterZ = (centerSphereFlag.get() ? 0. : -1./wrapSphereCurvature.get());
                                            FORI (iVertToMove, vertsToMove.length)
                                            {
                                                Mesh.Vertex vert = vertsToMove[iVertToMove];
                                                v[0] = vert.x();
                                                v[1] = vert.y();
                                                v[2] = vert.z() - sphereCenterZ;
                                                double oldR = Math.sqrt(SQR(v[0])+SQR(v[1])+SQR(v[2]));
                                                double newR = oldR + incr;
                                                double scale = newR / oldR;
                                                vert.setXYZW(v[0]*scale, v[1]*scale, v[2]*scale + sphereCenterZ, 1.);
                                            }
                                        }
                                        else
                                        {
                                            FORI (iVertToMove, vertsToMove.length)
                                            {
                                                Mesh.Vertex vert = vertsToMove[iVertToMove];
                                                // push the dual face *into* the screen,
                                                // i.e. decrease its height,
                                                // i.e. increase height of primal vert.
                                                vert.setxyh(vert.x(),
                                                            vert.y(),
                                                            vert.h() + incr);
                                                System.out.println("    verts["+vert.myIndex()+"].Hnaive() -> "+vert.Hnaive());
                                            }
                                        }
                                        if (continuouslyDelaunayizeFlag.get()) delaunayize();
                                    }
                                    UndoItem.State after = newUndoItemState();
                                    undoTreeSquirrel.Do(new UndoItem(before, after));
                                    dirtyDualMesh();
                                    theCanvas.repaint();
                                }
                                break;
                            }
                            case java.awt.event.KeyEvent.VK_LEFT:
                            case java.awt.event.KeyEvent.VK_RIGHT:
                            {
                                if (false) // I'm thinking no... left/right will do this only if already showing net
                                    synchronized(showNetFlag) // since another thread checks it once in a while
                                    {
                                        showNetFlag.set(true);
                                    }
                                if (showNetFlag.get())
                                {
                                    if (_dualMesh != null
                                     && theNet != null
                                     && highlightedDualEdgeIndex != -1)
                                    {
                                        // If edge is a cut, rotate it CCW or CW around its lagoon.
                                        // If it's a fold, rotate it CCW or CW around its circuit.

                                        if (theNet.getEdgeStatus(highlightedDualEdgeIndex) == Net.CUT)
                                        {
                                            // It's a cut; direction matters.
                                            // (for fold, we rely on the closest-edge picking
                                            // to pick the correct one of the two half-edges)
                                            // Make sure edge in question is pointing
                                            // towards root of cut tree.  If not, switch to its opposite.
                                            if (_dualMesh.getEdge(highlightedDualEdgeIndex).initialVertex() == null
                                             || theNet._vertToParentEdgeInd[_dualMesh.getEdge(highlightedDualEdgeIndex).initialVertex().myIndex()] != highlightedDualEdgeIndex)
                                                highlightedDualEdgeIndex = _dualMesh.getEdge(highlightedDualEdgeIndex).opposite().myIndex();
                                            CHECK_EQ(theNet._vertToParentEdgeInd[_dualMesh.getEdge(highlightedDualEdgeIndex).initialVertex().myIndex()], highlightedDualEdgeIndex);
                                        }

                                        int alternatives[] = theNet.findAlternatives(highlightedDualEdgeIndex);
                                        if (alternatives.length > 0)
                                        {
                                            int other = alternatives[(keyCode == java.awt.event.KeyEvent.VK_LEFT ? 0 : alternatives.length-1)];

                                            UndoItem.State before = newUndoItemState();
                                            theNet.swapCutAndFold(highlightedDualEdgeIndex,
                                                                  other);
                                            // Make the highlighted one be the one we swapped with.
                                            // that makes it so, if the user doesn't jiggle the mouse,
                                            // hitting the key repeatedly will rotate around the lagoon or circuit.
                                            // (Note, I later discovered this is way too clever;
                                            // trying to figure out what was going on by feeling around with mouse
                                            // actually changes behavior, so user is lost)
                                            highlightedDualEdgeIndex = other;
                                            UndoItem.State after = newUndoItemState();
                                            undoTreeSquirrel.Do(new UndoItem(before, after));
                                            theCanvas.repaint();
                                        }
                                        else
                                        {
                                            System.out.println("HEY! edge "+_dualMesh.getEdge(highlightedDualEdgeIndex)+" has no alternative! status="+theNet.getEdgeStatus(highlightedDualEdgeIndex));
                                            CHECK_EQ(theNet.getEdgeStatus(highlightedDualEdgeIndex), Net.FOLD);
                                            CHECK(false); // wtf? this shouldn't happen
                                        }

                                        if (true)
                                        {
                                            // just sanity check that we can walk around the net tree starting from highlighted dual edge index

                                            //System.out.println("===================");
                                            //System.out.println("Walking around net tree:");
                                            Mesh.Edge dualEdge = _dualMesh.getEdge(highlightedDualEdgeIndex);
                                            // assert against infinite loop...
                                            boolean seen[] = new boolean[_dualMesh.edges.size()]; // false initially
                                            while (true)
                                            {
                                                CHECK(!seen[dualEdge.myIndex()]);
                                                if (false)
                                                    System.out.println("    "+dualEdge);
                                                seen[dualEdge.myIndex()] = true;
                                                CHECK_EQ(_dualMesh.getEdge(dualEdge.myIndex()), dualEdge); // check that nextInTree didn't get confused and switch trees
                                                dualEdge = theNet.nextInTree(dualEdge);
                                                CHECK_EQ(_dualMesh.getEdge(dualEdge.myIndex()), dualEdge); // check that nextInTree didn't get confused and switch trees
                                                if (dualEdge.myIndex() == highlightedDualEdgeIndex)
                                                    break;
                                            }
                                            //System.out.println("===================");
                                        }
                                    }
                                }
                                else // !showNetFlag.get()
                                {
                                    if (theOptimizationPath != null)
                                    {
                                        int oldIndex = theOptimizationIndex;

                                        if (keyCode == java.awt.event.KeyEvent.VK_LEFT)
                                            theOptimizationIndex = e.isShiftDown() ? 0 : MAX(theOptimizationIndex-1, 0);
                                        else
                                            theOptimizationIndex = e.isShiftDown() ? theOptimizationPath.length-1
                                                                                        : MIN(theOptimizationIndex+1, theOptimizationPath.length-1);
                                        System.out.println("theOptimizationIndex "+oldIndex+" -> "+theOptimizationIndex+"");

                                        if (theOptimizationIndex != oldIndex)
                                        {
                                            double verts[][] = theOptimizationPath[theOptimizationIndex];
                                            if (mesh.verts.size() == verts.length)
                                            {
                                                FORI (iVert, verts.length)
                                                {
                                                    mesh.getVert(iVert).setxyh(verts[iVert][0],
                                                                               verts[iVert][1],
                                                                               verts[iVert][2]);
                                                }
                                            }
                                            dirtyDualMesh();

                                            theCanvas.repaint();
                                        }
                                    }
                                }
                                break;
                            }
                            case java.awt.event.KeyEvent.VK_SHIFT:
                            {
                                shiftIsDown = true;
                                break;
                            }
                            case java.awt.event.KeyEvent.VK_CONTROL:
                            {
                                if (!controlIsDown)
                                {
                                    //System.out.println("ctrl newly down!");
                                    if (beingDraggedVertIndex != -1)
                                    {
                                        Mesh.Vertex beingDraggedVert = mesh.getVert(beingDraggedVertIndex);

                                        double oldCoords[] = {beingDraggedVert.x(), beingDraggedVert.y()};
                                        // only difference between ctrl-newly-down and ctrl-newly-up...
                                        double newCoords[] = {
                                            (double)Math.round(oldCoords[0]/gridSnapQuantum)*gridSnapQuantum,
                                            (double)Math.round(oldCoords[1]/gridSnapQuantum)*gridSnapQuantum,
                                        };

                                        double group[][][] = getTheSymmetryGroup();
                                        int nVerts = mesh.verts.size();
                                        FORI (iGroup, group.length)
                                        {
                                            double oldImage[] = VecMath.vxm(oldCoords,group[iGroup]);
                                            FORI (iVert, nVerts)
                                            {
                                                Mesh.Vertex vertI = mesh.getVert(iVert);
                                                if (EQ(oldImage[0], vertI.x(), 1e-6)
                                                 && EQ(oldImage[1], vertI.y(), 1e-6))
                                                {
                                                    double newImage[] = VecMath.vxm(newCoords,group[iGroup]);
                                                    System.out.println("Snapping vertex "+iVert+" from "+vertI.x()+" "+vertI.y()+" "+vertI.h()+"");
                                                    vertI.setXYnaive(newImage[0],
                                                                     newImage[1]);
                                                    System.out.println("Dragging vertex "+iVert+" from "+vertI.x()+" "+vertI.y()+" "+vertI.h()+"");
                                                }
                                            }
                                        }

                                        if (continuouslyDelaunayizeFlag.get()) delaunayize();

                                        theCanvas.repaint();
                                    }
                                }
                                controlIsDown = true;
                                break;
                            }

                            default:
                                // don't print anything, or we'll print too much (e.g. Shift, and any keys we handle in keyTyped())
                                //System.out.println("Unknown keycode "+java.awt.event.KeyEvent.getKeyText(keyCode)+" ("+keyCode+")");
                                break;
                        }
                        if (eventVerbose >= 1) System.out.println("out keyPressed: "+e);
                    } // keyPressed
                    @Override public void keyReleased(java.awt.event.KeyEvent e)
                    {
                        if (eventVerbose >= 1) System.out.println("in keyReleased: "+e);
                        int keyCode = e.getKeyCode();
                        switch(keyCode)
                        {
                            case java.awt.event.KeyEvent.VK_SHIFT:
                            {
                                shiftIsDown = false;
                                break;
                            }
                            case java.awt.event.KeyEvent.VK_CONTROL:
                            {
                                if (controlIsDown)
                                {
                                    // note, one of the ctrl keys might still be down at this point
                                    // (if they were both down previously),
                                    // but most likely they are both now up.
                                    // if we get this wrong it's not a huge deal.
                                    //System.out.println("ctrl newly up!");
                                    if (beingDraggedVertIndex != -1)
                                    {
                                        Mesh.Vertex beingDraggedVert = mesh.getVert(beingDraggedVertIndex);

                                        double oldCoords[] = {beingDraggedVert.x(), beingDraggedVert.y()};

                                        // only difference between ctrl-newly-down and ctrl-newly-up...
                                        double newCoords[] = beingDraggedVertUnsnappedXY;

                                        double group[][][] = getTheSymmetryGroup();
                                        int nVerts = mesh.verts.size();
                                        FORI (iGroup, group.length)
                                        {
                                            double oldImage[] = VecMath.vxm(oldCoords,group[iGroup]);
                                            FORI (iVert, nVerts)
                                            {
                                                Mesh.Vertex vertI = mesh.getVert(iVert);
                                                if (EQ(oldImage[0], vertI.x(), 1e-6)
                                                 && EQ(oldImage[1], vertI.y(), 1e-6))
                                                {
                                                    double newImage[] = VecMath.vxm(newCoords,group[iGroup]);
                                                    System.out.println("Snapping vertex "+iVert+" from "+vertI.x()+" "+vertI.y()+" "+vertI.h()+"");
                                                    vertI.setxyh(newImage[0],
                                                                 newImage[1],
                                                                 vertI.h());
                                                    System.out.println("Dragging vertex "+iVert+" from "+vertI.x()+" "+vertI.y()+" "+vertI.h()+"");
                                                }
                                            }
                                        }

                                        if (continuouslyDelaunayizeFlag.get()) delaunayize();

                                        theCanvas.repaint();
                                    }
                                }
                                controlIsDown = false;
                                break;
                            }
                            default:
                                break;
                        }
                        if (eventVerbose >= 1) System.out.println("out keyReleased: "+e);
                    } // keyReleased

                    // IDEA: go through verts and see which would be better?
                    //      Multiply each vert by prospective scale,
                    //      then see what denominator is.
                    //      if it's huge, that's bad.
                    //      if it's small, that's good.
                    //      Start with largest magnitude vertex, I think, towards smallest.
                    //      first time we reach one that has a preference
                    //      (i.e. was very irrational, goes to rational that's good one way
                    //      and bad the other) then that's the one.
                    private double chooseBestScale(double scale0, double scale1)
                    {
                        // TODO: do it
                        return scale0;
                    }
                    //========================================================

                    @Override public void keyTyped(java.awt.event.KeyEvent e)
                    {
                        if (eventVerbose >= 1) System.out.println("in keyTyped: "+e);
                        char c = e.getKeyChar();

                        // In java 1.6, apparently ctrl-letter
                        // started coming out as just the letter
                        // (with ke.isControlDown() true).
                        // Detect this and change it to the old behavior...
                        // XXX need to do something else, or nothing at all here, for old javas (1.1) in which isControlDown doesn't exist... or else just stop trying to support 1.1 at all
                        if (c >= 'a' && c <= 'z' && e.isControlDown())
                        {
                            c -= ('a'-1);
                        }

            #define CTRL(upperCaseLetter) ((upperCaseLetter)-'A' + 1)
                        switch (c)
                        {
                            case 'V': // cycle verbosity-- upper-case to minimize possibility of hitting it by accident thus causing subsequent perfomance degradation with no visible reason if Java Console is not visible
                                System.out.print("eventVerbose "+eventVerbose);
                                eventVerbose = (eventVerbose+1) % 4;
                                System.out.println(" -> "+eventVerbose);
                                break;

                            case ' ': // just repaint (i.e. mark dirty)
                                theCanvas.repaint();
                                break;
                            case 'A': // toggle antiAliasingFlag
                                antiAliasingFlag ^= true;
                                System.out.println("antiAliasingFlag -> "+antiAliasingFlag+" (if this platform supports it)");
                                theCanvas.repaint();
                                break;

                            case 't': // cycle showTriangles down
                                if (showPrimalEdgesFlag.get())
                                    showPrimalEdgesFlag.set(false);
                                else if (showPrimalVertsFlag.get())
                                    showPrimalVertsFlag.set(false);
                                else
                                {
                                    showPrimalVertsFlag.set(true);
                                    showPrimalEdgesFlag.set(true);
                                }
                                theCanvas.repaint();
                                break;

                            case 'T': // cycle showTriangles up
                                if (showPrimalEdgesFlag.get())
                                {
                                    showPrimalVertsFlag.set(false);
                                    showPrimalEdgesFlag.set(false);
                                }
                                else if (showPrimalVertsFlag.get())
                                    showPrimalEdgesFlag.set(true);
                                else
                                    showPrimalVertsFlag.set(true);
                                theCanvas.repaint();
                                break;

                            case 'n': // toggle showNetFlag
                                synchronized(showNetFlag) // since another thread checks it once in a while
                                {
                                    showNetFlag.set(!showNetFlag.get());
                                }
                                System.out.println("showNetFlag -> "+showNetFlag.get());
                                theCanvas.repaint();
                                break;

                            case 'R': // toggle pointOutRedNetEdges
                                pointOutRedNetEdges = !pointOutRedNetEdges;
                                System.out.println("pointOutRedNetEdges -> "+pointOutRedNetEdges);
                                theCanvas.repaint();
                                break;

                            case 'x':
                                rescaleDualOnlySortOf(2.,1.);
                                break;
                            case 'X':
                                rescaleDualOnlySortOf(1./2.,1.);
                                break;
                            case 'y':
                                rescaleDualOnlySortOf(1.,2.);
                                break;
                            case 'Y':
                                rescaleDualOnlySortOf(1.,1./2.);
                                break;


                            case 'i': case '+': case '=': // zoom in
                            {
                                // Note that scaling by sqrt(2) twice doesn't give 2,
                                // and repeated scaling by sqrt(2) accumulates roundoff error.
                                // Better to alternate between sqrt(2) and 2/sqrt(2)
                                // which is different.
                                double bestScale = chooseBestScale(Math.sqrt(2.), 2/Math.sqrt(2.));
                                rescale(bestScale, bestScale);
                                break;
                            }
                            case 'o': case '-':           // zoom out
                            {
                                double bestScale = chooseBestScale(1./Math.sqrt(2.), Math.sqrt(2.)/2);
                                rescale(bestScale, bestScale);
                                break;
                            }
                            case 'f': // frame, gang
                            {
                                boolean gangFlag = true;
                                frame(true,true,gangFlag);
                                break;
                            }
                            case CTRL('F'): // frame, no-gang
                            {
                                boolean gangFlag = false;
                                frame(true,true,gangFlag);
                                break;
                            }
                            case '|': // left-to-right flip whole diagram
                            {
                                UndoItem.State before = newUndoItemState();
                                mesh.flipLeftRight();
                                dirtyDualMesh(); // flip doesn't work when verts missing
                                // should be no need to re-delaunayize
                                UndoItem.State after = newUndoItemState();
                                undoTreeSquirrel.Do(new UndoItem(before, after));
                                theCanvas.repaint();
                                break;
                            }
                            case '_': // up-to-down flip whole diagram
                            {
                                UndoItem.State before = newUndoItemState();
                                mesh.flipUpDown();
                                dirtyDualMesh(); // flip doesn't work when verts missing
                                // should be no need to re-delaunayize
                                UndoItem.State after = newUndoItemState();
                                undoTreeSquirrel.Do(new UndoItem(before, after));
                                theCanvas.repaint();
                                break;
                            }
                            case '\\': // lower-left to upper-right flip whole diagram
                            {
                                UndoItem.State before = newUndoItemState();
                                mesh.flipLowerLeftUpperRight();
                                dirtyDualMesh(); // flip doesn't work when verts missing
                                // should be no need to re-delaunayize
                                UndoItem.State after = newUndoItemState();
                                undoTreeSquirrel.Do(new UndoItem(before, after));
                                theCanvas.repaint();
                                break;
                            }
                            case '/': // upper-left to lower-right flip whole diagram
                            {
                                UndoItem.State before = newUndoItemState();
                                mesh.flipUpperLeftLowerRight();
                                dirtyDualMesh(); // flip doesn't work when verts missing
                                // should be no need to re-delaunayize
                                UndoItem.State after = newUndoItemState();
                                undoTreeSquirrel.Do(new UndoItem(before, after));
                                theCanvas.repaint();
                                break;
                            }

                            case 's': // swap diagonal
                            {
                                UndoItem.State before = newUndoItemState();
                                //
                                // Really would like everything selected
                                // that was selected before,
                                // except for the two dual verts that changed...
                                // the new two should both be selected
                                // if the original two were selected,
                                // or both unselected otherwise.
                                // XXX TODO: do this


                                int closestEdgeIndex = mesh.indexOfClosestEdge(prevP, false);
                                if (closestEdgeIndex != -1)
                                {
                                    System.out.println("Swapping diagonal edge e"+closestEdgeIndex);
                                    continuouslyDelaunayizeFlag.set(false); // otherwise it's not obvious what the hell happened
                                    mesh.swapDiagonal(mesh.getEdge(closestEdgeIndex), /*onlyIfMoreDelaunay=*/false, /*verbose=*/true);
                                    mesh.sanityCheckTopology();
                                    dirtyDualMesh();
                                }

                                UndoItem.State after = newUndoItemState();
                                undoTreeSquirrel.Do(new UndoItem(before, after));
                                theCanvas.repaint();
                                break;
                            }

                            case CTRL('S'): // swap diagonal but only if it makes it closer to delaunay
                            {
                                // Swap diagonal but only if it makes it closer to delaunay
                                UndoItem.State before = newUndoItemState();
                                int closestEdgeIndex = mesh.indexOfClosestEdge(prevP, false);
                                if (closestEdgeIndex != -1)
                                {
                                    System.out.println("Swapping diagonal edge e"+closestEdgeIndex);
                                    continuouslyDelaunayizeFlag.set(false); // otherwise it's not obvious what the hell happened
                                    mesh.swapDiagonal(mesh.getEdge(closestEdgeIndex), /*onlyIfMoreDelaunay=*/true, /*verbose=*/true);
                                    mesh.sanityCheckTopology();
                                    dirtyDualMesh();
                                }
                                UndoItem.State after = newUndoItemState();
                                undoTreeSquirrel.Do(new UndoItem(before, after));
                                theCanvas.repaint();
                                break;
                            }

                            case 'D': // delaunayize
                            {
                                UndoItem.State before = newUndoItemState();
                                delaunayize();
                                UndoItem.State after = newUndoItemState();
                                undoTreeSquirrel.Do(new UndoItem(before, after));
                                theCanvas.repaint();
                                break;
                            }

                            case 'W': // select *all* dual verts for weighting (positive weight, of arity 3), or deselect all if all selected
                            {
                                UndoItem.State before = newUndoItemState();
                                {
                                    if (allDualVertsAreSelected)
                                    {
                                        selectedDualVertIndices = new int[0];
                                        selectedTris = new int[0][3];
                                        allDualVertsAreSelected = false;
                                    }
                                    else
                                    {
                                        // TODO: actually I don't think this loop is necessary, it gets done automatically as we continuously update selected array, since we're setting allDualVertsAreSelected = true

                                        Mesh dualMesh = getDualMesh();
                                        int nDualVerts = dualMesh.verts.size();
                                        int nDualEdges = dualMesh.edges.size();

                                        selectedDualVertIndices = new int[nDualVerts];
                                        selectedTris = new int[nDualVerts][];
                                        int nSelected = 0;
                                        FORI (iDualEdge, nDualEdges)
                                        {
                                            Mesh.Edge dualEdge = dualMesh.getEdge(iDualEdge);
                                            Mesh.Vertex dualVert = dualEdge.initialVertex();
                                            if (dualVert != null && dualVert.weight >= 0.)
                                            {
                                                Mesh.Edge primalEdge = (mesh.getEdge(iDualEdge)).opposite();
                                                if (primalEdge.next().next().next() == primalEdge) // if it's a tri
                                                {
                                                    int i0 = primalEdge.initialVertex().myIndex();
                                                    int i1 = primalEdge.finalVertex().myIndex();
                                                    int i2 = primalEdge.prev().initialVertex().myIndex();
                                                    if (i0 < i1 && i0 < i2) // if it's in canonical order
                                                    {
                                                        selectedTris[nSelected] = new int[]{i0,i1,i2};
                                                        selectedDualVertIndices[nSelected] = dualVert.myIndex();
                                                        nSelected++;
                                                    }
                                                }
                                            }
                                        }
                                        selectedDualVertIndices = (int[])Arrays.subarray(selectedDualVertIndices, 0, nSelected);
                                        selectedTris = (int[][])Arrays.subarray(selectedTris, 0, nSelected);
                                        allDualVertsAreSelected = true;
                                    }
                                }
                                UndoItem.State after = newUndoItemState();
                                undoTreeSquirrel.Do(new UndoItem(before, after));
                                theCanvas.repaint();
                                break;
                            }

                            case 'e': // toggle visualization of centroid and euler line, whenever showing dual vertex weights
                            {
                                showEulerLineWhenShowingWeightsFlag.set(!showEulerLineWhenShowingWeightsFlag.get());
                                System.out.println("showEulerLineWhenShowingWeightsFlag -> "+showEulerLineWhenShowingWeightsFlag.get());
                                theCanvas.repaint();
                                break;
                            }
                            case 'w': // toggle closest dual vertex for weighting (think of better mnemonic)
                            {
                                UndoItem.State before = newUndoItemState();
                                {
                                    Mesh dualMesh = getDualMesh();
                                    double closestDistSqrd = Double.POSITIVE_INFINITY;
                                    int closestIndex = -1;
                                    int nDualVerts = dualMesh.verts.size();
                                    PRINT(nDualVerts);
                                    double scratch[] = new double[3];
                                    FORI (iDualVert, nDualVerts) // beginning to end, so we choose first of equal
                                    {
                                        Mesh.Vertex dualVert = dualMesh.getVert(iDualVert);
                                        if (dualVert.arity != 3)
                                            continue; // not a triangle
                                        if (!showInsideOutDualVertsFlag.get())
                                        {
                                            if (dualVert.weight < 0)
                                                continue; // the triangle is inside out; it's the boundary
                                        }

                                        mostRecentGraphics.xform(dualVert.X(), dualVert.Y(), dualVert.Z(), dualVert.W(), scratch);
                                        double thisDistSqrd = VecMath.distsqrd(2, prevP, scratch);
                                        if (thisDistSqrd < closestDistSqrd)
                                        {
                                            closestDistSqrd = thisDistSqrd;
                                            closestIndex = iDualVert;
                                        }
                                    }
                                    if (closestIndex != -1)
                                    {
                                        PRINT(closestIndex);
                                        // figure out the 3 primal verts
                                        int closestTri[] = MeshUtils.findPrimalFaceFromDualVert(mesh, dualMesh, closestIndex);
                                        CHECK_NE(closestTri, null);
                                        PRINTARRAY(closestTri);

                                        int indInd = Arrays.indexOf(selectedDualVertIndices, closestIndex);
                                        double closestDualVertWeight = (dualMesh.getVert(closestIndex)).weight;
                                        double totalWeightBefore = 0.; FORIDOWN(iSelected, selectedDualVertIndices.length) if (selectedDualVertIndices[iSelected] != -1) totalWeightBefore += (dualMesh.getVert(selectedDualVertIndices[iSelected])).weight;

                                        if (indInd != -1)
                                        {
                                            System.out.println("    deselecting dual vert "+closestIndex+" (primal tri "+Arrays.toStringCompact(selectedTris[indInd])+")");
                                            selectedTris = (int[][])Arrays.delete(selectedTris, indInd);
                                            selectedDualVertIndices = Arrays.delete(selectedDualVertIndices, indInd);
                                            allDualVertsAreSelected = false;
                                        }
                                        else
                                        {
                                            System.out.println("    selecting dual vert "+closestIndex);
                                            selectedTris = (int[][])Arrays.append(selectedTris, closestTri);
                                            selectedDualVertIndices = Arrays.append(selectedDualVertIndices, closestIndex);
                                            // don't mess with allDualVertsAreSelected, it's hard to tell. they have to 'W' to get it back
                                            // TODO: fix this
                                        }
                                        double totalWeightAfter = 0.; FORIDOWN(iSelected, selectedDualVertIndices.length) if (selectedDualVertIndices[iSelected] != -1) totalWeightAfter += (dualMesh.getVert(selectedDualVertIndices[iSelected])).weight;
                                        System.out.println("    Total selected weight: "+totalWeightBefore+" "+(indInd!=-1?'-':'+')+" "+closestDualVertWeight+" = "+totalWeightAfter+"");
                                    }
                                }
                                UndoItem.State after = newUndoItemState();
                                undoTreeSquirrel.Do(new UndoItem(before, after));
                                theCanvas.repaint();
                                break;
                            }

                            case 'd': // delete closest edge
                            {
                                UndoItem.State before = newUndoItemState();
                                int closestEdgeIndex = mesh.indexOfClosestEdge(prevP, false);
                                if (closestEdgeIndex != -1)
                                {
                                    System.out.println("Deleting edge e"+closestEdgeIndex);
                                    mesh.deleteEdge(mesh.getEdge(closestEdgeIndex));
                                    mesh.sanityCheckTopology();
                                    // deleted something-- invalidate dual mesh
                                    dirtyDualMesh();
                                }
                                continuouslyDelaunayizeFlag.set(false); // otherwise it will mysteriously come back!
                                UndoItem.State after = newUndoItemState();
                                undoTreeSquirrel.Do(new UndoItem(before, after));
                                theCanvas.repaint();
                                break;
                            }
                            case 'S': // turn off optimize, and re-sphereize
                            {
                                turnOffOptimizeAndReSpherize();
                                break;
                            }

                            case 'l': // toggle showLabelsFlag (which actually doesn't exist)
                            {
                                boolean showLabelsFlag = labelPrimalVertsFlag.get()
                                                      || labelPrimalEdgesFlag.get()
                                                      || labelDualVertsFlag.get()
                                                      || labelDualEdgesFlag.get();
                                showLabelsFlag ^= true;
                                System.out.println("showLabelsFlag -> "+showLabelsFlag);
                                labelPrimalVertsFlag.set(showLabelsFlag);
                                labelPrimalEdgesFlag.set(showLabelsFlag);
                                labelDualVertsFlag.set(showLabelsFlag);
                                labelDualEdgesFlag.set(showLabelsFlag);
                                theCanvas.repaint();
                                break;
                            }
                            case 'g': // toggle showGridFlag
                                showGridFlag ^= true;
                                System.out.println("showGridFlag -> "+showGridFlag);
                                theCanvas.repaint();
                                break;

                            case 'M':
                                System.out.print("magWidth "+magWidth);
                                magWidth += 2;
                                System.out.println(" -> "+magWidth);
                                theCanvas.repaint();
                                break;
                            case 'm':
                                System.out.print("magWidth "+magWidth);
                                magWidth = MAX(1, magWidth-2);
                                System.out.println(" -> "+magWidth);
                                theCanvas.repaint();
                                break;
                            case 'P':
                                System.out.print("magFactor "+magFactor);
                                magFactor += 1;
                                System.out.println(" -> "+magFactor);
                                showMagFlag.set(true); // so it's clear what happened
                                theCanvas.repaint();
                                break;
                            case 'p':
                                System.out.print("magFactor "+magFactor);
                                magFactor = MAX(0, magFactor-1);
                                System.out.println(" -> "+magFactor);
                                showMagFlag.set(true); // so it's clear what happened
                                theCanvas.repaint();
                                break;

                            case CTRL('M'):
                            case CTRL('J'): // ARGH! ctrl-m comes out as ctrl-j!?
                                showMagFlag.set(!showMagFlag.get());
                                System.out.println("(from ctrl-m key) showMagFlag -> "+showMagFlag.get()+" (which affects home grown double buffering which is "+homeGrownDoubleBufferFlag+")");
                                theCanvas.repaint();
                                break;


        #if 0 // conflicts with symmetry stuff... disable for now
                            case '0': // toggle showOriginFlag
                                showOriginFlag ^= true;
                                System.out.println("showOriginFlag -> "+showOriginFlag);
                                theCanvas.repaint();
                                break;
        #endif

                            case 'O': // toggle optimizeFlag
                            {
                                UndoItem.State before = newUndoItemState();
                                optimizeFlag.set(!optimizeFlag.get());
                                System.out.println("optimizeFlag -> "+optimizeFlag.get());
                                if (continuouslyDelaunayizeFlag.get()) delaunayize();
                                UndoItem.State after = newUndoItemState();
                                undoTreeSquirrel.Do(new UndoItem(before, after));
                                theCanvas.repaint();
                                break;
                            }

                            case 'a': // toggle arrowsTowardsSharpestDihedralsFlag or arrowsTowardsShortestEdgesFlag
                            {
                                if (e.isAltDown())
                                {
                                    arrowsTowardsShortestEdgesFlag ^= true;
                                    System.out.println("arrowsTowardsShortestEdgesFlag -> "+arrowsTowardsShortestEdgesFlag);
                                }
                                else
                                {
                                    arrowsTowardsSharpestDihedralsFlag ^= true;
                                    System.out.println("arrowsTowardsSharpestDihedralsFlag -> "+arrowsTowardsSharpestDihedralsFlag);
                                }
                                theCanvas.repaint();
                                break;
                            }

                            case CTRL('D'): // swap primal and dual.  often makes a mess.
                            {
                                UndoItem.State before = newUndoItemState();

                                mesh = Mesh.makeDualMesh(mesh,
                                                         true, // includeNonArity3 (so we get full mesh)
                                                         true, // includeInsideOut
                                                         /*zeroVerts=*/false,
                                                         wrapAroundSphereFlag.get(),
                                                         centerSphereFlag.get(),
                                                         wrapSphereCurvature.get());


                                FORI (iVert, mesh.verts.size())
                                {
                                    Mesh.Vertex vert = mesh.getVert(iVert);
                                    // Some places assume primal W is 1 ...
                                    if (wrapAroundSphereFlag.get())
                                        vert.setXYZW(vert.x(), vert.h(), vert.z(), 1.);
                                    else
                                        vert.setXYHW(vert.x(), vert.y(), vert.h(), 1.);
                                    // Some other places assume primal doesn't have weights nor momentAndArea...
                                    vert.weight = 1.;
                                    vert.momentAndArea = null;
                                }

                                selectedTris = new int[][] {};
                                selectedDualVertIndices = new int[] {};
                                allDualVertsAreSelected = false;
                                if (continuouslyDelaunayizeFlag.get()) delaunayize();
                                UndoItem.State after = newUndoItemState();
                                undoTreeSquirrel.Do(new UndoItem(before, after));
                                theCanvas.repaint();
                                break;
                            }

                            case 'u': case CTRL('Z'): // undo
                            {
                                UndoItem item = (UndoItem)undoTreeSquirrel.undo();
                                if (item != null)
                                {
                                    applyUndoItemState(item.before);
                                }
                                else
                                {
                                    System.out.println("Nothing to undo!");
                                }
                                theCanvas.repaint();
                                break;
                            }
                            case 'r': case 'U': case CTRL('R'): case CTRL('Y'): // redo
                            {
                                UndoItem item = (UndoItem)undoTreeSquirrel.redo();
                                if (item != null)
                                {
                                    applyUndoItemState(item.after);
                                }
                                else
                                {
                                    System.out.println("Nothing to redo!");
                                }
                                theCanvas.repaint();
                                break;
                            }
                            case 'c': // clear
                            {
                                clear();
                                theCanvas.repaint();
                                break;
                            }
                            case 'z': // move closest vertex to origin
                            {
                                int closestVertIndex = mesh.indexOfClosestVert(prevP[0],prevP[1],mostRecentGraphics);
                                if (closestVertIndex != -1) {
                                  Mesh.Vertex vert = mesh.getVert(closestVertIndex);
                                  double dx = -vert.x();
                                  double dy = -vert.y();
                                  pan(dx, dy);
                                }
                                break;
                            }
                            case 'C': // toggle centroid hack
                            {
                                System.out.println("Mesh.XXXcentroidHack "+Mesh.XXXcentroidHack+" -> "+!Mesh.XXXcentroidHack);
                                Mesh.XXXcentroidHack = !Mesh.XXXcentroidHack;
                                dirtyDualMesh();
                                theCanvas.repaint();
                                break;
                            }
                            case CTRL('Q'): // quit
                            {
                                System.out.println("Aww.");
                                System.exit(1);
                                break;
                            }

                            case 'h': // help
                                help();
                                break;

                            case CTRL('I'): // toggle showInsideOutDualVertsFlag
                                showInsideOutDualVertsFlag.set(!showInsideOutDualVertsFlag.get());
                                System.out.println("showInsideOutDualVertsFlag -> "+showInsideOutDualVertsFlag.get());
                                theCanvas.repaint();
                                break;

                            case CTRL('O'): // cycle optimizationType
                                optimizationTypeIndex.set((optimizationTypeIndex.get()+1)%Mesh.availableOptimizationTypes.length);
                                optimizationType = Mesh.availableOptimizationTypes[optimizationTypeIndex.get()];
                                System.out.println("optimizationType -> "+Mesh.optimizationTypeNames[optimizationType]);
                                theCanvas.repaint();
                                break;

                            case CTRL('V'): // toggle nonEventVerbose
                                nonEventVerbose = (nonEventVerbose+1)%2;
                                System.out.println("nonEventVerbose -> "+nonEventVerbose);
                                theCanvas.repaint();
                                break;

                            case '1': case '2': case '3': case '4': case '5':
                            case '6': case '7': case '8': case '9': case '0':
                            {
                                changeSymmetry(/*p=*/ c=='0' ? 10 : c-'0', /*q=*/qRotationalSymmetry.get(), /*leftRight=*/false, /*central=*/false, /*repeatWorkInProgress=*/false);
                                break;
                            }
                            case '!': case '@': case '#': case '$': case '%':
                            case '^': case '&': case '*': case '(': case ')':
                            {
                                changeSymmetry(/*p=*/ c==')' ? 10 : ")!@#$%^&*(".indexOf(c), /*q=*/qRotationalSymmetry.get(), /*leftRight=*/true, /*central=*/false, /*repeatWorkInProgress=*/false);
                                break;
                            }

                            case CTRL('B'): // uniform grid thing
                            {
                                UndoItem.State before = newUndoItemState();

                                doUniformGridThing(gridN.get(), gridRotDegrees.get(), /*augment_existing_mesh=*/false);  // CBB: argh, ctrl on the Mesh button means augment_existing_mesh=true

                                if (continuouslyDelaunayizeFlag.get()) delaunayize();
                                UndoItem.State after = newUndoItemState();
                                undoTreeSquirrel.Do(new UndoItem(before, after));
                                theCanvas.repaint();
                                break;
                            }
                            case 'b': // blue noise pattern
                            {
                                UndoItem.State before = newUndoItemState();

                                doBlueNoiseThing(blueNoiseN.get());

                                if (continuouslyDelaunayizeFlag.get()) delaunayize();
                                UndoItem.State after = newUndoItemState();
                                undoTreeSquirrel.Do(new UndoItem(before, after));
                                theCanvas.repaint();
                                break;
                            }
                            case 'j': // just noise pattern
                            {
                                UndoItem.State before = newUndoItemState();

                                doJustNoiseThing(justNoiseN.get());

                                if (continuouslyDelaunayizeFlag.get()) delaunayize();
                                UndoItem.State after = newUndoItemState();
                                undoTreeSquirrel.Do(new UndoItem(before, after));
                                theCanvas.repaint();
                                break;
                            }
                            case 'J': // convex noise pattern
                            {
                                UndoItem.State before = newUndoItemState();

                                doConvexNoiseThing(convexNoiseN.get());

                                if (continuouslyDelaunayizeFlag.get()) delaunayize();
                                UndoItem.State after = newUndoItemState();
                                undoTreeSquirrel.Do(new UndoItem(before, after));
                                theCanvas.repaint();
                                break;
                            }

                            case CTRL('L'): // optimize farthest lagoon exit killer XXX this should be temporary maybe
                            {
                                UndoItem.State before = newUndoItemState();
                                optimizeFarthestLagoonExitKiller();
                                if (continuouslyDelaunayizeFlag.get()) delaunayize();
                                UndoItem.State after = newUndoItemState();
                                undoTreeSquirrel.Do(new UndoItem(before, after));
                                theCanvas.repaint();
                                break;
                            }

                            case '`': // mess around with delta wye
                            {
                                MeshUtils.messAroundWithDeltaWye(mesh);
                                MeshUtils.messAroundWithDeltaWye(getDualMesh());
                                break;
                            }

                            case CTRL('T'): // analyze random spanning trees
                            {
                                if (false) // can turn this on to do the confidence test.  it's pretty long and it passes now.
                                {
                                    MeshUtils.detConfidenceTest();
                                    break;
                                }

                                if (false)
                                {
                                    MeshUtils.analyzeRandomSpanningTrees(mesh);
                                    MeshUtils.analyzeRandomSpanningTrees(getDualMesh());
                                }
                                java.math.BigInteger nPrimalSpanningTrees = null;
                                if (true) // note, this can take a long time if num verts > 300 or so
                                {
                                    nPrimalSpanningTrees = MeshUtils.countSpanningTrees(mesh, true);
                                    PRINT(nPrimalSpanningTrees);
                                    // If fully triangulated, then the number of spanning trees will be same
                                    // for primal and dual, in which case we don't really need to compute it
                                    // for dual (which is more expensive because about twice as many verts,
                                    // so takes about 8 times as long).
                                    // But, compute it anyway and compare, as long as not too big.
                                    // XXX tell me again why it needs to be fully triangulated?? aren't they equal regardless?
                                    boolean isTriangulated = (getDualMesh().verts.size() * 3 == mesh.edges.size());
                                    PRINT(isTriangulated);

                                    if (getDualMesh().verts.size() <= 300) // 4 seconds or so usually. bigger than this gets painful.
                                    {
                                        java.math.BigInteger nDualSpanningTrees = MeshUtils.countSpanningTrees(getDualMesh(), true);
                                        PRINT(isTriangulated);
                                        PRINT(mesh.verts.size());
                                        PRINT(getDualMesh().verts.size());
                                        PRINT(nPrimalSpanningTrees);
                                        PRINT(nDualSpanningTrees);
                                        if (isTriangulated)
                                        {
                                            CHECK(nPrimalSpanningTrees.equals(nDualSpanningTrees));
                                        }
                                    } else {
                                        PRINT(mesh.verts.size());
                                        PRINT(getDualMesh().verts.size());
                                        OUT("Not counting spanning trees of dual mesh because too many verts.");
                                    }
                                }
                                if (true)
                                {
                                    // 10*1000 is reasonable for larger meshes; 1000*1000 is needed for small ones to get them all but makes large ones take too long getting to the limit.  So, if we know it's going to cross the limit, don't even try.
                                    int max = 1000*1000;
                                    if (BigInt.gt(nPrimalSpanningTrees, max))
                                    {
                                        OUT("    too many spanning trees to enumerate");
                                    }
                                    else
                                    {
                                        final BigInt nGood = new BigInt(-1);
                                        final BigInt nBad = new BigInt(-1);
                                        final BigInt nTotal = new BigInt(-1);

                                        boolean finished = MeshUtils.countGoodBad(
                                            getDualMesh(), mesh, // input (reversed since we want to analyze the dual mesh)
                                            max,
                                            nGood, nBad, nTotal, // output
                                            1); // verboseLevel
                                        CHECK(finished); // since we now don't even try if we're not going to succeed
                                        {
                                            double goodPercent = nGood.doubleValue()/nTotal.doubleValue()*100.;
                                            double badPercent = nBad.doubleValue()/nTotal.doubleValue()*100.;
                                            String goodPercentString = Format.sprintf("%.5g", goodPercent);
                                            String badPercentString = Format.sprintf("%.5g", badPercent);
                                            OUT("    (good:bad)/total = ("+nGood+":"+nBad+")/"+nTotal+" = "+goodPercentString+"%:"+badPercentString+"%");
                                            if (nGood.eq(0))
                                            {
                                                OUT(repeat("!", 1000));
                                            }
                                        }

                                    }
                                }
                                break;
                            }

                            // undocumented
                            case CTRL('W'):
                            {
                                sbaryExperimentType.cycle(-1);
                                theCanvas.repaint();
                                break;
                            }
                            case CTRL('E'):
                            {
                                sbaryExperimentType.cycle(+1);
                                theCanvas.repaint();
                                break;
                            }

                            case 'F':
                            {
                                showNetPolishFlag.set(!showNetPolishFlag.get());
                                break;
                            }

                            case CTRL('['):  // escape
                            {
                                mostRecentlyBeingDraggedVertIndex = -1;
                                theCanvas.repaint();
                                break;
                            }

                            default:
                                System.out.println("Unknown key '"+c+"'("+(int)c+") typed");
                                break;
                        }
                        if (eventVerbose >= 1) System.out.println("out keyTyped: "+e);
                    } // keyTyped
                });  // KeyListener
            }  // TheCanvas ctor

                // common code used twice
                private void drawLabels(MyGraphics3D mg3d,
                                        Mesh mesh,
                                        boolean isDualMesh,
                                        boolean showInsideOutParts,
                                        boolean labelVertsFlag,
                                        boolean labelEdgesFlag,
                                        double edgeInitialCoords[/*nEdges*/][/*at most 2*/][/*4*/], // optional-- used only for dual... for primal, we just get from verts directly
                                        boolean whichEdgesGotDrawn[])
                {
                    boolean trySmartVertexAngles = true;

                    double smartVertexAngles[] = null;
                    if (trySmartVertexAngles)
                    {
                        int nVerts = mesh.verts.size();
                        int nEdges = mesh.edges.size();
                        boolean didVert[] = new boolean[nVerts]; // initialized to false
                        smartVertexAngles = new double[nVerts]; // initialized to 0
                        double angsAroundThisVert[] = new double[nEdges]; // scratch, worst case arity

                        FORI (iEdge0, nEdges)
                        {
                            Mesh.Edge edge0 = mesh.getEdge(iEdge0);
                            Mesh.Vertex vert = edge0.initialVertex();
                            if (vert == null || didVert[vert.myIndex()])
                                continue;
                            didVert[vert.myIndex()] = true;

                            // walk CCW around vertex
                            Mesh.Edge thisEdge = edge0;
                            int nAngsAroundThisVert = 0;
                            do {
                                CHECK_EQ(thisEdge.initialVertex(), vert);
                                double thisAng =
                                    thisEdge.direction != null
                                  ? Math.atan2(thisEdge.direction[1],
                                               thisEdge.direction[0])
                                  : Math.atan2(thisEdge.finalVertex().y()-thisEdge.initialVertex().y(),
                                               thisEdge.finalVertex().x()-thisEdge.initialVertex().x());
                                angsAroundThisVert[nAngsAroundThisVert++] = thisAng;
                            } while ((thisEdge = thisEdge.prev().opposite()) != edge0);

                            SortStuff.sort(angsAroundThisVert, 0, nAngsAroundThisVert);
                            double biggestGap = -1.;
                            double angOfBiggestGap = 0.;
                            FORI (iAng, nAngsAroundThisVert)
                            {
                                double thisAng = angsAroundThisVert[iAng];
                                double nextAng = angsAroundThisVert[(iAng+1)%nAngsAroundThisVert];
                                double thisGap = nextAng - thisAng;
                                if (thisGap < 0.)
                                {
                                    thisGap += 2*Math.PI;
                                }
                                if (thisGap > biggestGap)
                                {
                                    biggestGap = thisGap;
                                    angOfBiggestGap = thisAng + thisGap/2.;
                                }
                            }
                            smartVertexAngles[vert.myIndex()] = angOfBiggestGap;
                        }
                    }



                    if (labelVertsFlag)
                    {
                        //
                        // Vertex labels
                        //
                        java.util.ArrayList<Mesh.Vertex> verts = mesh.verts;
                        FORIDOWN (iVert, verts.size())
                        {
                            Mesh.Vertex vert = verts.get(iVert);
                            if (vert.weight < 0. && !showInsideOutParts)
                                continue;
                            double X = vert.X();
                            double Y = vert.Y();
                            double Z = vert.Z();
                            double W = vert.W();

                            // TODO: re-think the whole damn pipeline, should not be any negative W's at this point I don't think.
                            // TODO: and why isn't this succeeding? I thought when we generated dual verts we did it properly so w is equal to weight? oh it's because primal verts W sometimes come from unwrapping from sphere
                            //CHECK_EQ(W, vert.weight);
                            if (W < 0.)
                            {
                                //System.out.println("ow! label for vertex "+iVert+" needed correcting, W="+W);
                                X *= -1.;
                                Y *= -1.;
                                Z *= -1.;
                                W *= -1.;
                            }

                            double ang;
                            if (trySmartVertexAngles)
                            {
                                ang = smartVertexAngles[iVert];
                            }
                            else
                            {
                                ang = randomNumberGenerator.nextDouble() * 2*Math.PI;
                            }
                            double offr = 5/mg3d.getScaleX(); // pixels
                            double offx = offr*Math.cos(ang);
                            double offy = offr*Math.sin(ang);
                            double offmax = MAX(ABS(offx),ABS(offy));

                            mg3d.drawString("v"+iVert,
                                          X+offx*W,
                                          Y+offy*W,
                                          Z,
                                          W,
                                          -offx/offmax, offy/offmax);
                        }
                    }

                    if (labelEdgesFlag)
                    {
                        //
                        // Edge labels
                        //
                        java.util.ArrayList<Mesh.Edge> edges = mesh.edges;
                        FORIDOWN (iEdge, edges.size())
                        {
                            if (whichEdgesGotDrawn != null
                             && !whichEdgesGotDrawn[iEdge])
                                continue;

                            Mesh.Edge edge = edges.get(iEdge);
                            Mesh.Vertex v0 = edge.initialVertex();
                            Mesh.Vertex v1 = edge.finalVertex();

                            int nParts = showInsideOutParts && edgeInitialCoords!=null ? 2 : 1;
                            FORI (iPart, nParts)
                            {
                                double x0,y0,z0, x1,y1,z1;
                                if (edgeInitialCoords != null)
                                {
                                    if (edgeInitialCoords[iEdge][iPart] == null)
                                        continue;
                                    int oEdge = edge.opposite().myIndex();
                                    x0 = edgeInitialCoords[iEdge][iPart][0]/edgeInitialCoords[iEdge][iPart][3];
                                    y0 = edgeInitialCoords[iEdge][iPart][1]/edgeInitialCoords[iEdge][iPart][3];
                                    z0 = edgeInitialCoords[iEdge][iPart][2]/edgeInitialCoords[iEdge][iPart][3];
                                    x1 = edgeInitialCoords[oEdge][iPart][0]/edgeInitialCoords[oEdge][iPart][3];
                                    y1 = edgeInitialCoords[oEdge][iPart][1]/edgeInitialCoords[oEdge][iPart][3];
                                    z1 = edgeInitialCoords[oEdge][iPart][2]/edgeInitialCoords[oEdge][iPart][3];
                                }
                                else
                                {
                                    double rayLength = 1.;
                                    x0 = (v0!=null ? v0.x() : v1.x() - edge.direction[0]*rayLength);
                                    y0 = (v0!=null ? v0.y() : v1.y() - edge.direction[1]*rayLength);
                                    z0 = (v0!=null ? v0.z() : v1.z() - edge.direction[2]*rayLength);
                                    x1 = (v1!=null ? v1.x() : v0.x() + edge.direction[0]*rayLength);
                                    y1 = (v1!=null ? v1.y() : v0.y() + edge.direction[1]*rayLength);
                                    z1 = (v1!=null ? v1.z() : v0.z() + edge.direction[2]*rayLength);
                                }

                                double x = (x0+x1)/2;
                                double y = (y0+y1)/2;
                                double z = (z0+z1)/2;
                                double ang = Math.PI/2 + Math.atan2(y1-y0, x1-x0);
                                if (isDualMesh)
                                    ang += Math.PI;
                                double offr = 2/mg3d.getScaleX(); // pixels
                                double offx = offr*Math.cos(ang);
                                double offy = offr*Math.sin(ang);
                                double offmax = MAX(ABS(offx),ABS(offy));
                                mg3d.drawString("e"+iEdge,
                                              x+offx,
                                              y+offy,
                                              z,
                                              1.,
                                              -offx/offmax, offy/offmax);
                            }
                        }
                    }
                } // drawLabels


                //
                // Experimental--
                // show the net of the faces in 3d, flattened onto the xy plane
                //
                void drawFlattenedNet(MyGraphics3D mg3d, Mesh mesh, Mesh dualMesh, double dualEdgeInitialCoords[/*nDualEdges*/][/*2*/][/*4*/], int nVerts, int nEdges, java.awt.Color dualEdgeColors[/*nEdges*/])
                {
                    // We want a rotate/translate matrix for each dual face
                    // (i.e. each primal vertex)
                    // that takes the face to the xy plane,
                    // in the form of the net.

                    // Starting face should be the one containing the origin,
                    // but for now we'll just use the dual vertex
                    // closest to the origin.
                    int iStartVert;
                    {
                        int iClosest = -1;
                        double closestDist2 = Double.POSITIVE_INFINITY;
                        FORI(iVert, nVerts)
                        {
                            Mesh.Vertex vert = mesh.getVert(iVert);
                            double dist2 = SQR(vert.x()) + SQR(vert.x());
                            if (dist2 < closestDist2)
                            {
                                iClosest = iVert;
                                closestDist2 = dist2;
                            }
                        }
                        //PRINT(iClosest);
                        iStartVert = iClosest;
                    }


                    double dualFaceMats[][][] = new double[nVerts][][];
                    //
                    // Compute the matrix for the starting dual face.
                    //
                    {
                        Mesh.Vertex startVert = mesh.getVert(iStartVert);

                        //   p dot (x,y,1) == offset
                        //  px,py,scaleZ*pz dot scaleZ*x,scaleZ*y,1 == scaleZ * offset
                        double startDualFacePlaneNormal[] = {localScaleZ*startVert.x(), localScaleZ*startVert.y(), 1}; // not unit length
                        double startDualFacePlaneOffset = -localScaleZ*startVert.z(); // magic!  I don't know why, but this is the correct value

                        // what translation by a multiple of startDualFacePlaneNormal
                        // will take the dual face plane to the origin?
                        // The equation of the face plane is:
                        //      n dot x == offset
                        // we want s such that:
                        //      n dot (x + s*n) == 0
                        // i.e. (n dot x) + s * (n dot n) == 0
                        //      s = -(n dot x) / (n dot n)
                        //        = -offset / (n dot n)
                        double s = -startDualFacePlaneOffset / VecMath.normsqrd(startDualFacePlaneNormal);
                        double translateVector[] = VecMath.sxv(s, startDualFacePlaneNormal);
                        double translateMat[][] = {
                            {1,0,0,0},
                            {0,1,0,0},
                            {0,0,1,0},
                            {translateVector[0],
                             translateVector[1],
                             translateVector[2],1},
                        };
                        double rotMat33[][] = GeomUtils.parallelTransport(VecMath.normalize(startDualFacePlaneNormal),
                                                                          new double[]{0,0,1});
                        // XXX bleah, this seems awkward
                        double rotMat44[][] = VecMath.identitymat(4);
                        VecMath.copymat(rotMat44, rotMat33);
                        double M0[][] = VecMath.mxm(translateMat, rotMat44);
                        dualFaceMats[iStartVert] = M0;
                    }

                    // make a data structure that allows us to find neighbors of each dual face easily...
                    Mesh.Edge firstEdgeStartingAtVertex[] = new Mesh.Edge[nVerts]; // null initially
                    Mesh.Edge nextEdgeStartingAtVertex[] = new Mesh.Edge[nEdges]; // null initially
                    FORI (iEdge, nEdges)
                    {
                        Mesh.Edge edge = mesh.getEdge(iEdge);
                        int iVert = edge.initialVertex().myIndex();
                        nextEdgeStartingAtVertex[edge.myIndex()] = firstEdgeStartingAtVertex[iVert];
                        firstEdgeStartingAtVertex[iVert] = edge;
                    }

                    //
                    // Now traverse outwards from the starting dual face,
                    // computing the transform at each new face
                    // and putting it into dualFaceMats.
                    //

                    int stack[] = new int[nVerts];
                    int stackSize = 0;
                    stack[stackSize++] = iStartVert;
                    while (stackSize > 0)
                    {
                        int iVert = stack[--stackSize];
                        double M0[][] = dualFaceMats[iVert];
                        double M0rotPart[][] = new double[3][3];
                        VecMath.copymat(M0rotPart, M0);
                        // For all neighbor verts whose matrix has not yet been computed...
                        for (Mesh.Edge edge = firstEdgeStartingAtVertex[iVert];
                             edge != null;
                             edge = nextEdgeStartingAtVertex[edge.myIndex()])
                        {
                            int iEdge = edge.myIndex();
                            Mesh.Vertex vertJ = edge.finalVertex();
                            int jVert = vertJ.myIndex();
                            if (theNet.getEdgeStatus(iEdge) == Net.CUT)
                                continue;
                            if (dualFaceMats[jVert] != null) // this can happen if there are some undecideds
                                continue;

                            // Compute matrix for jVert'th dual face.
                            // The incremental matrix should rotate (normal times M0)
                            // to the +z axis, while keeping (dual edge times M0) fixed.

                            // XXX correct for scale!
                            double jDualFacePlaneNormal[] = {localScaleZ*vertJ.x(), localScaleZ*vertJ.y(), 1}; // not unit length
                            jDualFacePlaneNormal = VecMath.vxm(jDualFacePlaneNormal, M0rotPart);


                            Mesh.Edge dualEdge = dualMesh.getEdge(iEdge);
                            Mesh.Vertex someVertOnDualEdge = dualEdge.initialVertex();
                            if (someVertOnDualEdge == null)
                                someVertOnDualEdge = dualEdge.finalVertex();
                            // XXX correct for scale!
                            double thisDualVertCoords[] = {someVertOnDualEdge.x(),
                                                           someVertOnDualEdge.y(),
                                                           someVertOnDualEdge.z()};
                            thisDualVertCoords = VecMath.vxm(thisDualVertCoords, M0);




                            double rotMat33[][] = GeomUtils.parallelTransport(VecMath.normalize(jDualFacePlaneNormal),
                                                                              new double[]{0,0,1});
                            // XXX bleah, this seems awkward
                            double rotMat44[][] = VecMath.identitymat(4);
                            VecMath.copymat(rotMat44, rotMat33);

                            // M = M0 * (translate dual vert to origin)
                            //        * rotate
                            //        * (translate origin to dual vert)
                            double translateDualVertToOrigin[][] = {
                                {1,0,0,0},
                                {0,1,0,0},
                                {0,0,1,0},
                                {-thisDualVertCoords[0],
                                 -thisDualVertCoords[1],
                                 -thisDualVertCoords[2],1},
                            };
                            double translateOriginToDualVert[][] = {
                                {1,0,0,0},
                                {0,1,0,0},
                                {0,0,1,0},
                                {thisDualVertCoords[0],
                                 thisDualVertCoords[1],
                                 thisDualVertCoords[2],1},
                            };
                            double M[][] = VecMath.mxmxmxm(M0,
                                                       translateDualVertToOrigin,
                                                       rotMat44,
                                                       translateOriginToDualVert);
                            dualFaceMats[jVert] = M;

                            stack[stackSize++] = jVert;
                        }
                    }




                    FORI (iEdge, nEdges)
                    {
                        Mesh.Edge edge = mesh.getEdge(iEdge);
                        Mesh.Vertex v0 = edge.initialVertex();
                        Mesh.Edge dualEdge = dualMesh.getEdge(iEdge);
                        double M[][] = dualFaceMats[v0.myIndex()];
                        if (dualEdgeInitialCoords[iEdge][0] == null)
                            continue; // edge has no positively oriented part
                        double coords[][] = {
                            dualEdgeInitialCoords[iEdge][0],
                            dualEdgeInitialCoords[dualEdge.opposite().myIndex()][0],
                        };
                        FORI (i, 2)
                            coords[i] = VecMath.vxm(coords[i], M);
                        if (theNet.getEdgeStatus(iEdge) == Net.CUT)
                            mg3d.setColor(java.awt.Color.YELLOW);
                        else
                            mg3d.setColor(new java.awt.Color(0.f,0.f,1/4.f)); // XXX darkBlue
                        mg3d.setColor(dualEdgeColors[iEdge]);
                        mg3d.drawLine(coords[0][0],
                                    coords[0][1],
                                    coords[0][2],
                                    coords[1][0],
                                    coords[1][1],
                                    coords[1][2],
                                    antiAliasingFlag);
                    }
                } // drawFlattenedNet



            private double sphericalTriangleArea(double v0[],
                                                 double v1[],
                                                 double v2[])
            {
                // inward normals
                double n0[] = VecMath.normalize(VecMath.vxv3(v1,v2));
                double n1[] = VecMath.normalize(VecMath.vxv3(v2,v0));
                double n2[] = VecMath.normalize(VecMath.vxv3(v0,v1));
                double externalAngle0 = VecMath.angleBetweenUnitVectors(n1,n2);
                double externalAngle1 = VecMath.angleBetweenUnitVectors(n2,n0);
                double externalAngle2 = VecMath.angleBetweenUnitVectors(n0,n1);
                // sum = 2*pi -> area = 0
                // sum = 0 -> area = 2*pi
                // area = 2*pi - sum
                double area = 2*Math.PI - (externalAngle0+externalAngle1+externalAngle2);
                double det = VecMath.vxvxv3(n0, n1, n2);
                if (det < 0)
                    area *= -1;
                return area;
            } // sphericalTriangleArea

            // experimental... spherical barycentrics based on triangle areas.
            // This is actually lame, since it doesn't get it right along edge.
            // VecMath.sphericalAverage is better... I think.
            // Hmm interesting though-- look at the blue lines in the experiment;
            // they all meet at three andipodal points!  I wonder if this means I can calculate this
            // analytically?
            private double[] sbary(final double v0[],
                                   final double v1[], double t1,
                                   final double v2[], double t2)
            {
                if (sbaryExperimentType.get() == 2)
                {
                    double answer[] = new double[3];
                    VecMath.sphericalAverage(answer, new double[][]{v0,v1,v2}, new double[]{1-t1-t2,t1,t2});
                    return answer;
                }

                double t0 = 1. - (t1 + t2);
                double Area = sphericalTriangleArea(v0,v1,v2);

                // find s1,s2 such that bary(v0,v1,s1,v2,s2) normalized
                // has the desired areas.
                double targetArea1 = Area * t1;
                double targetArea2 = Area * t2;
                //CHECK(false); // coverage
                NewtonSolver.Fun fun = new NewtonSolver.Fun(2) {
                    @Override public void f(double x[], double answer[])
                    {
                        double s1 = x[0];
                        double s2 = x[1];
                        double v[] = VecMath.normalize(VecMath.bary(v0,v1,s1,v2,s2));
                        double area1 = sphericalTriangleArea(v0,v,v2);
                        double area2 = sphericalTriangleArea(v0,v1,v);
                        answer[0] = area1;
                        answer[1] = area2;
                    }
                };
                double x[] = {t1,t2}; // initial guess
                double y[] = {targetArea1, targetArea2};
                NewtonSolver.solve(x, y, fun,
                                   10, // minIterations-- probably not needed, but that's what the default used to be and I haven't tested this since making it explicit
                                   20,
                                   false); // adaptiveFlag XXX could experiment with this if needed
                double s1 = x[0];
                double s2 = x[1];
                double v[] = VecMath.normalize(VecMath.bary(v0,v1,s1,v2,s2));
                return v;
            }

            // PAINT/DISPLAY/DRAW
            @Override public void paintComponent(java.awt.Graphics frontBufferGraphics)
            {
                if (eventVerbose >= 1) System.out.println("in paintComponent");
                if (eventVerbose >= 1) System.out.println("  homeGrownDoubleBufferFlag = "+homeGrownDoubleBufferFlag);

                CHECK(javax.swing.SwingUtilities.isEventDispatchThread());

                makeSureBackBufferIsRight();
                java.awt.Graphics g;
                java.awt.Dimension size;
                if (homeGrownDoubleBufferFlag || showMagFlag.get())
                {
                    g = backBufferImage.getGraphics();
                    size = new java.awt.Dimension(backBufferImage.getWidth(null),
                                                  backBufferImage.getHeight(null));
                }
                else
                {
                    g = frontBufferGraphics;
                    size = getSize();
                }


                final boolean wrapAroundSphereFlagValue = wrapAroundSphereFlag.get();
                double minSize = (double)MIN(size.width, size.height);
                MyGraphics3D mg3d = new MyGraphics3D(g, size,
                                        -size.width/minSize,size.width/minSize,
                                        -size.height/minSize,size.height/minSize,
                                        getLocalToWorld());
                mostRecentGraphics = mg3d;

                if (implementAntiAliasingInHardware)
                {
                    java.awt.Graphics2D g2d = (java.awt.Graphics2D)g;
                    g2d.setRenderingHint(java.awt.RenderingHints.KEY_ANTIALIASING,
                        antiAliasingFlag ? java.awt.RenderingHints.VALUE_ANTIALIAS_ON
                                       : java.awt.RenderingHints.VALUE_ANTIALIAS_OFF);
                    if (eventVerbose >= 1)
                    {
                        System.out.println("successfully set antialising to "+antiAliasingFlag);
                    }
                }


                //
                // Clear to black...
                //
                mg3d.setColor(java.awt.Color.BLACK);
                mg3d.fillWindow();

                if (showGridFlag)
                {
                    // experiment with grids... not sure exactly what I want yet

                    double gridBrightnessValue = gridBrightness.get();

                    double xmax = size.width/minSize;
                    double ymax = size.height/minSize;


                    // bigger levels are finer
                    // level 0 : 1 apart
                    // level 1: 1/2 apart
                    // level 2: 1/4 apart
                    // etc.
                    int nLevels = 7;
                    FORIDOWN(iLevel, nLevels)
                    {
                        // color for grid and circle
                        {
                            double start = gridBrightnessValue;
                            double speed = 1./3.;
                            float luminance = (float)(start * Math.pow(.5, iLevel*speed));
                            mg3d.setColor(new java.awt.Color(luminance,luminance,luminance));
                        }

                        int gridLinesPerUnit = 1 << iLevel;
                        FORI (iGridLine, gridLinesPerUnit * xmax)
                        {
                            if (iLevel == 0
                             || iGridLine % 2 == 1)
                            {
                                double x = iGridLine / (double)gridLinesPerUnit;
                                mg3d.drawLine(x, -ymax, 0.,
                                            x,  ymax, 0.,
                                            antiAliasingFlag);
                                mg3d.drawLine(-x, -ymax, 0.,
                                            -x,  ymax, 0.,
                                             antiAliasingFlag);
                            }
                        }
                        FORI (iGridLine, gridLinesPerUnit * ymax)
                        {
                            if (iLevel == 0
                             || iGridLine % 2 == 1)
                            {
                                double y = iGridLine / (double)gridLinesPerUnit;
                                mg3d.drawLine(-xmax, y, 0.,
                                             xmax, y, 0.,
                                             antiAliasingFlag);
                                mg3d.drawLine(-xmax, -y, 0.,
                                             xmax, -y, 0.,
                                             antiAliasingFlag);
                            }
                        }



                    }
                }

                boolean showHorizon = true;
                if (showHorizon)
                {
                    double eyeInLocalSpace[] = VecMath.mxv(getRotMat(), eye); // multiply on wrong side, i.e. apply transpose i.e. inverse
                    // gag, that returned a 4d vector
                    eyeInLocalSpace = (double[])Arrays.subarray(eyeInLocalSpace, 0, 3);
                    if (!wrapAroundSphereFlag.get())
                        eyeInLocalSpace[2] /= MAX(localScaleZ, 1e-6);

                    int nPoints = 360;
                    double horizonPoints[][] = theSurface.horizon(0.,eyeInLocalSpace,nPoints);
                    mg3d.setColor(java.awt.Color.RED);
                    FORI (iPoint, horizonPoints.length)
                        mg3d.drawPoint(horizonPoints[iPoint][0],
                                     horizonPoints[iPoint][1],
                                     horizonPoints[iPoint][2],
                                     1);
                }

                if (showSmallestEnclosingDisk)
                {
                    int nVerts = mesh.verts.size();

                    double xys[][] = new double[nVerts][2];
                    // actually this is damn silly... a 3d sphere might make sense... but currently we know how to draw only circles, not ellipses
                    FORI (iVert, nVerts)
                    {
                        Mesh.Vertex vert = mesh.getVert(iVert);
                        mg3d.xform(vert.X(), vert.Y(), vert.Z(), vert.W(), xys[iVert]);
                    }
                    double center[] = new double[2];
                    //MiniBall.verboseLevel = 2; // 2 for nice diagram
                    double radiusSquared = MiniBall.MiniBall(center, xys);
                    MiniBall.verboseLevel = 0;
                    if (pRotationalSymmetry.get() * (leftRightSymmetry.get() ? 2 : 1) <= 3) // otherwise the test degenerates-- more than 3 points on circle, not general position
                    {
                        //PRINTARRAY(xys);
                        //MiniBall.verboseLevel = 1;
                        CHECK(MiniBall.IsMiniBall(center, radiusSquared, xys.length, xys));
                        MiniBall.verboseLevel = 0;
                    }
                    if (radiusSquared >= 0.)
                    {
                        double radius = Math.sqrt(radiusSquared);
                        //PRINTVEC(center);
                        //PRINT(radius);

                        float luminance = MIN(1, (float)(gridBrightness.get()*2));
                        mg3d.setColor(new java.awt.Color(luminance,luminance,luminance));
                        if (GT(radius, 0., 1e-6)) // otherwise I think the arc drawing might go into an infinite loop, not sure.  oh hmm, maybe that was just with NaN, I think I can remove this check
                            mg3d.drawThickArc(center[0]-radius, center[1]-radius,
                                            2*radius, 2*radius,
                                            0., Math.PI*2,
                                            1., // thicknessInPixels,
                                            antiAliasingFlag);
                    }
                }





                //
                // Try optimizing the heights...
                // XXX paint is a funky place for this
                //
                if (optimizeFlag.get())
                    mesh.findAndApplyOptimalVertexHeights(optimizationType);

                boolean makeVert0CoplanarWith145Flag = false;
                if (makeVert0CoplanarWith145Flag)
                {
                    // XXX total hack
                    Mesh.Vertex v0 = mesh.getVert(0);
                    Mesh.Vertex v1 = mesh.getVert(1);
                    Mesh.Vertex v4 = mesh.getVert(4);
                    Mesh.Vertex v5 = mesh.getVert(5);
                    double A[] = {v1.Xnaive(), v1.Ynaive(), v1.Hnaive() - .5 * (SQR(v1.Xnaive()) + SQR(v1.Ynaive()))};
                    double B[] = {v4.Xnaive(), v4.Ynaive(), v4.Hnaive() - .5 * (SQR(v4.Xnaive()) + SQR(v4.Ynaive()))};
                    double C[] = {v5.Xnaive(), v5.Ynaive(), v5.Hnaive() - .5 * (SQR(v5.Xnaive()) + SQR(v5.Ynaive()))};
                    double N[] = VecMath.vxv3(VecMath.vmv(B,A),
                                              VecMath.vmv(C,A));
                    double desiredDot = VecMath.dot(N,A);
                    double D[] = {v0.Xnaive(), v0.Ynaive(), v0.Hnaive()};
                    // Find D[2] such that N dot D == desiredDot
                    // I.e. N[0]*D[0] + N[1]*D[1] + N[2]*D[2] == desiredDot
                    D[2] = (desiredDot - (N[0]*D[0] + N[1]*D[1])) / N[2];

                    v0.setHnaive(D[2]
                          + .5 * (SQR(v0.Xnaive()) + SQR(v0.Ynaive())));
                }



                //
                // Draw the dual diagram in color...
                //
                java.awt.Color lightBlue = new java.awt.Color(128,128,255);
                java.awt.Color darkGreen = new java.awt.Color(0,32,0);
                java.awt.Color darkRed = new java.awt.Color(64,0,0);
                java.awt.Color darkCyan = new java.awt.Color(0,32,32);
                java.awt.Color darkMagenta = new java.awt.Color(64,0,64);
                /*
                java.awt.Color dualVertSelectionColor = java.awt.Color.GREEN;
                java.awt.Color dualColor = java.awt.Color.RED;
                java.awt.Color dualColorBothSelected = lightBlue;
                java.awt.Color dualColorOneSelectedBad = java.awt.Color.MAGENTA;
                java.awt.Color dualColorOneSelectedGood = java.awt.Color.GREEN;
                java.awt.Color perpColorBad = new java.awt.Color(64,0,64); // dark magenta
                java.awt.Color perpColorGood = new java.awt.Color(0,32,0); // dark green
                */
                java.awt.Color dualVertSelectionColor = java.awt.Color.YELLOW;
                java.awt.Color dualColor = lightBlue;
                java.awt.Color dualColorBothSelected = java.awt.Color.YELLOW;
                java.awt.Color dualColorOneSelectedBad = java.awt.Color.RED;
                java.awt.Color dualColorOneSelectedGood = java.awt.Color.GREEN;
                java.awt.Color perpColorBad = darkRed;
                java.awt.Color perpColorGood = darkGreen;

                int nVerts = mesh.verts.size();
                int nEdges = mesh.edges.size();
                Mesh dualMesh = getDualMesh();
                int nDualVerts = dualMesh.verts.size();
                int nDualEdges = dualMesh.edges.size();
                CHECK_EQ(nDualEdges, nEdges);

                //
                // Gather coords of dual verts and dual ray ends.
                // dualEdgeInitialCoords[iDualEdge][iPart] will be dualVertCoords[initial vertex of this part]
                // if there is an initial vertex, otherwise an appropriately computed
                // place to draw the edge from.
                // The coord will be negated if necessary so that the w coord is nonnegative
                // (even if the vert coord's w is negative-- need to get rid of that)
                // What are the "parts" of a dual edge?  Well, part 0 is the part of it on the primal sheet,
                // and part 1 is the part of it on the dual sheet.
                //     - an edge connecting two dual verts on first sheet has only part 0.
                //     - an edge connecting two dual verts on second sheet has only part 1.
                //     - an edge from initial vert on first sheet to final vert on second:
                //        - part 0 is from initial vertex to ray display end, on primal sheet
                //        - part 1 is from ray display beginning to final vertex, on dual sheet
                //     - an edge from initial vert on second sheet to final vert on first:
                //        - part 0 is from ray display beginning to final vert, on first sheet
                //        - part 1 is from initial vert to ray display end, on second sheet
                double dualVertCoords[][] = new double[nDualVerts][]; // TODO: wait a minute, there's also dualVertsHomoNormalized or something
                double dualEdgeInitialCoords[/*nEdges*/][/*2*/][/*4*/] = new double[nEdges][2][];
                {
                    FORI (iDualVert, nDualVerts)
                    {
                        Mesh.Vertex v = dualMesh.getVert(iDualVert);
                        dualVertCoords[iDualVert] = new double[]{v.X(), v.Y(), v.Z(), v.W()};
                    }
                    boolean naiveDualEdgesFlagValue = naiveDualEdgesFlag.get();
                    FORI (iDualEdge, nDualEdges)
                    {
                        Mesh.Edge dualEdge = dualMesh.getEdge(iDualEdge);
                        Mesh.Vertex v0 = dualEdge.initialVertex();
                        Mesh.Vertex v1 = dualEdge.finalVertex();
                        double v0coords[] = v0!=null ? dualVertCoords[v0.myIndex()] : null;
                        double v1coords[] = v1!=null ? dualVertCoords[v1.myIndex()] : null;
                        // TODO REGARDING NEGATIVE WEIGHTS: don't test for [3]<0, test for weight<0.  I think?  not sure.

                        if (naiveDualEdgesFlagValue)
                        {
                            // naive way-- all internal edges
                            if (v0 != null)
                            {
                                dualEdgeInitialCoords[iDualEdge][0] = v0coords[3]<0?VecMath.sxv(-1.,v0coords) : v0coords;
                            }
                            else if (v1 != null)
                            {
                                dualEdgeInitialCoords[iDualEdge][0] = new double[] {
                                    // TODO: do math in homo coords, from v1coords, not v1.x(),y(),z()
                                    v1.x() - dualEdge.direction[0],
                                    v1.y() - dualEdge.direction[1],
                                    v1.z() - dualEdge.direction[2],
                                    1.,
                                };
                            }
                        }
                        else
                        {
                            // proper external edges
                            if (v0 != null)
                            {
                                dualEdgeInitialCoords[iDualEdge][v0coords[3]<0.?1:0] = v0coords[3]<0.?VecMath.sxv(-1.,v0coords) : v0coords;
                            }
                            if (v1 != null && (v0==null || (v1coords[3]<0.) != (v0coords[3]<0.)))
                            {
                                CHECK_EQ(dualEdgeInitialCoords[iDualEdge][v1coords[3]<0.?1:0], null);
                                dualEdgeInitialCoords[iDualEdge][v1coords[3]<0.?1:0] = new double[] {
                                    // TODO: do math in homo coords, from v1coords, not v1.x(),y(),z()
                                    v1.x() - dualEdge.direction[0],
                                    v1.y() - dualEdge.direction[1],
                                    v1.z() - dualEdge.direction[2],
                                    1.,
                                };
                            }
                        }

                        if (v0==null && v1==null)
                        {
                            // Both ends infinite.
                            // This edge is the dual of an isolated edge or whisker
                            // in the primal.
                            // In this case we want to draw a perpendicular line,
                            // of length 1.
                            //
                            // We know the edge direction,
                            // we need its center.
                            // this will lie directly above (or below)
                            // the point on the dual (original primal) edge line
                            // that's deepest in the paraboloid.
                            // the formula for this has to be
                            // lerp(w0,w1,t) where t is some simple
                            // multiple of w0.h-w1.h I bet.
                            Mesh.Edge primalEdge = mesh.getEdge(iDualEdge);
                            Mesh.Vertex w0 = primalEdge.initialVertex();
                            Mesh.Vertex w1 = primalEdge.finalVertex();
                            double t = .5 + (w0.h() - w1.h()) / (SQR(w1.x()-w0.x())+SQR(w1.y()-w0.y())); // XXX beware the zero divide
                            double p[] = {LERP(w0.x(),w1.x(),t),
                                          LERP(w0.y(),w1.y(),t),
                                          LERP(w0.z(),w1.z(),t)};
                            // whatever depth it was below the paraboloid, raise it to that height above it for the dual
                            p[2] = LERP(p[2], -.5*(SQR(p[0])+SQR(p[1])), 2.);
                            // -.5 instead of +.5 in the following is empirical... if we do it the other way, it ends up looking like an external edge
                            VecMath.vpsxv(p, p, -.5, dualEdge.direction); // XXX TODO: should dualEdge.direction be homogeneous?
                            p = Arrays.append(p, 1.);
                            dualEdgeInitialCoords[iDualEdge][0] = p; // TODO: this always makes these positive. is that right?
                        }
                    }
                }


                //
                // Classify the primal and dual elements
                // as frontfacing, backfacing, or side (neither front nor back).
                //
                int faceFacings[] = new int[nDualVerts+1];
                int edgeFacings[] = new int[nEdges];
                int vertFacings[] = new int[nVerts];
                int dualFaceFacings[] = new int[nVerts];
                int dualEdgeFacings[] = new int[nEdges];
                int dualVertFacings[] = new int[nDualVerts+1];
                double eyeInLocalSpace[] = VecMath.mxv(getRotMat(), eye); // multiply on wrong side, i.e. apply transpose i.e. inverse
                // gag, that returned a 4d vector
                eyeInLocalSpace = (double[])Arrays.subarray(eyeInLocalSpace, 0, 3);
                if (!wrapAroundSphereFlag.get())
                    eyeInLocalSpace[2] /= MAX(localScaleZ, 1e-6);

                MeshUtils.getFacings(eyeInLocalSpace, mesh, dualMesh, false, faceFacings, edgeFacings, vertFacings, wrapAroundSphereFlag.get(), centerSphereFlag.get(), wrapSphereCurvature.get());
                MeshUtils.getFacings(eyeInLocalSpace, dualMesh, mesh, true, dualFaceFacings, dualEdgeFacings, dualVertFacings, wrapAroundSphereFlag.get(), centerSphereFlag.get(), wrapSphereCurvature.get());
                //PRINTARRAY(faceFacings);
                //PRINTARRAY(dualFaceFacings);

                //
                // Draw the primal mesh in white.
                // Draw it first (before dual)
                // since the primal edges tend to be behind
                // the dual edges in 3d (primal is inscribed, dual is circumscribed)
                //

                double vertCoordsHomo[][] = new double[nVerts][4];
                double dualVertCoordsHomoNormalized[][] = new double[nDualVerts][4];
                boolean naivePrimalEdgesFlagValue = naivePrimalEdgesFlag.get();
                FORI (iVert, nVerts)
                {
                    Mesh.Vertex v = mesh.getVert(iVert);
                    vertCoordsHomo[iVert] = new double[]{v.X(), v.Y(), v.Z(), v.W()};
                    // XXX not sure this is the right place for this
                    if (naivePrimalEdgesFlagValue && vertCoordsHomo[iVert][3] < 0.) {
                        VecMath.sxv(vertCoordsHomo[iVert], -1., vertCoordsHomo[iVert]);
                    }
                }
                FORI (iDualVert, nDualVerts)
                {
                    Mesh.Vertex v = dualMesh.getVert(iDualVert);
                    dualVertCoordsHomoNormalized[iDualVert] = new double[]{v.X(), v.Y(), v.Z(), v.W()};
                    VecMath.normalize(dualVertCoordsHomoNormalized[iDualVert],
                                      dualVertCoordsHomoNormalized[iDualVert]);
                }

                // bunch of stuff that gets set only if drawing dual diagram...
                java.awt.Color dualVertColors[] = null;
                java.awt.Color dualEdgeColors[] = null;
                double[] avg = null; // we set it to non-null if drawing one
                double[] centroid = null;  // we set it to non-null if drawing one
                double[] orthocenter = null;  // we set it to non-null if drawing one
                double lagoonCenter[] = null; // we set it to non-null if drawing one
                double momentAndWeightStrictlyBelowEachDualVertex[][] = null;
                boolean dualEdgeIsOffBalanceCut[] = null;
                int dualEdgeOffBalanceCuts[] = null;

                int nOffBalanceCuts = -1;
                int nNonZeroLengthWholeEdges = -1;
                int nNonZeroLengthOffBalanceCuts = -1;

                boolean drawDualDiagramFlag = showDualVertsFlag.get()
                                           || showDualEdgesFlag.get();

                boolean showNetFlagValue = showNetFlag.get(); // snapshot to avoid confusion
                boolean showNetFlowFlagValue = showNetFlowFlag.get(); // snapshot to avoid confusion

                if (drawDualDiagramFlag)
                {
                    //
                    // Compute and store the dual mesh if necessary
                    //
                    if (highlightedDualEdgeIndex >= dualMesh.edges.size())
                    {
                        // prevent indexing out of bounds later on
                        System.out.println("clearing highlightedDualEdgeIndex since it's obviously wrong");
                        highlightedDualEdgeIndex = -1;
                    }


                    if (meshOfSelectedTris != mesh)
                    {
                        if (selectedTris.length > 0) System.out.println("MESH CHANGED-- INVALIDATING SELECTION!");
                        selectedTris = new int[][] {};
                        selectedDualVertIndices = new int[] {};
                        allDualVertsAreSelected = false;
                        meshOfSelectedTris = mesh;
                    }
                    if (true)
                    {
                        // Re-generate selectedDualVertIndices from selectedTris.
                        // Mesh topology may have changed, but we consider a tri selected
                        // if any of its three directed edges were part of a selected tri before.
                        // TODO: this works well only if not too much changed.  If a vertex is moved too fast,
                        // it can leave a swath of unselected verts :-(
                        //System.out.println("    Regenerting selectedDualVertIndices from selectedTris...");
                        int dualVertToIndexInSelectedDualVerts[] = Arrays.fill(dualMesh.verts.size(), -1);
                        {
                            IntArrayList selectedDualVertIndicesArrayList = new IntArrayList();
                            //PRINT(allDualVertsAreSelected);
                            if (allDualVertsAreSelected)
                            {
                                // select all dual verts of arity 3 with non-negative weight
                                FORI (iEdge, nEdges)
                                {
                                    Mesh.Edge edge = mesh.getEdge(iEdge);
                                    if (edge.next().next().next() != edge)
                                        continue; // not a triangle
                                    int i0 = edge.initialVertex().myIndex();
                                    int i1 = edge.finalVertex().myIndex();
                                    int i2 = edge.next().finalVertex().myIndex();
                                    if (i0 < i1 && i0 < i2) // if in canonical order
                                    {
                                        Mesh.Edge dualEdge = dualMesh.getEdge(iEdge);
                                        Mesh.Vertex dualVert = dualEdge.finalVertex();
                                        if (dualVert != null && dualVert.weight >= 0.)
                                        {
                                            dualVertToIndexInSelectedDualVerts[dualVert.myIndex()] = selectedDualVertIndicesArrayList.size();
                                            selectedDualVertIndicesArrayList.add(dualVert.myIndex());
                                        }
                                    }
                                }
                            }
                            else
                            {
                                java.util.HashMap<String,Mesh.Edge> edgeEndsToEdge = new java.util.HashMap<String,Mesh.Edge>();
                                CHECK_EQ(nEdges, dualMesh.edges.size());
                                FORI (iEdge, nEdges)
                                {
                                    Mesh.Edge edge = mesh.getEdge(iEdge);
                                    int i0 = edge.initialVertex().myIndex();
                                    int i1 = edge.finalVertex().myIndex();
                                    edgeEndsToEdge.put(""+i0+" "+i1, edge);
                                }
                                FORI (iSelectedTri, selectedTris.length)
                                {
                                    int tri[] = selectedTris[iSelectedTri];
                                    //System.out.println("        tri = "+Arrays.toStringCompact(tri));
                                    FORI (j, tri.length)
                                    {
                                        int i0 = tri[j];
                                        int i1 = tri[(j+1)%tri.length];
                                        Mesh.Edge edge = edgeEndsToEdge.get(""+i0+" "+i1);
                                        if (edge == null)
                                        {
                                            // there's no longer an edge between the two verts-- don't worry about it
                                            continue;
                                        }
                                        if (edge.next().next().next() != edge)
                                        {
                                            // there's no longer a tri here-- don't worry about it
                                            continue;
                                        }

                                        Mesh.Edge dualEdge = dualMesh.getEdge(edge.myIndex()); // right to left
                                        Mesh.Vertex dualVert = dualEdge.finalVertex();
                                        if (dualVert != null && dualVert.weight >= 0.)
                                        {
                                            if (dualVertToIndexInSelectedDualVerts[dualVert.myIndex()] != -1)
                                            {
                                                // already did this one
                                                continue;
                                            }
                                            dualVertToIndexInSelectedDualVerts[dualVert.myIndex()] = selectedDualVertIndicesArrayList.size();
                                            selectedDualVertIndicesArrayList.add(dualVert.myIndex());
                                        }
                                    }
                                }
                            }
                            selectedDualVertIndices = selectedDualVertIndicesArrayList.toArray();
                        }

                        // Re-generate selectedTris from selectedDualVerts.
                        //System.out.println("    Regenerating selectedTris from selectedDualVerts...");
                        {
                            selectedTris = new int[selectedDualVertIndices.length][3];
                            FORI (iEdge, nEdges)
                            {
                                Mesh.Edge edge = mesh.getEdge(iEdge);
                                int i0 = edge.initialVertex().myIndex();
                                int i1 = edge.finalVertex().myIndex();
                                int i2 = edge.next().finalVertex().myIndex();
                                if (i0 < i1 && i0 < i2) // if in canonical order
                                {
                                    Mesh.Edge dualEdge = dualMesh.getEdge(iEdge);
                                    Mesh.Vertex dualVert = dualEdge.finalVertex();
                                    if (dualVert != null)
                                    {
                                        int iSelected = dualVertToIndexInSelectedDualVerts[dualVert.myIndex()];
                                        if (iSelected != -1)
                                        {
                                            int tri[] = selectedTris[iSelected++];
                                            tri[0] = i0;
                                            tri[1] = i1;
                                            tri[2] = i2;
                                        }
                                    }
                                }
                            }
                        }
                    }

                    boolean isSelectedDualVert[] = new boolean[dualMesh.verts.size()]; // all false initially
                    FORI (i, selectedDualVertIndices.length)
                        if (selectedDualVertIndices[i] != -1)
                            isSelectedDualVert[selectedDualVertIndices[i]] = true;

                    dualVertColors = new java.awt.Color[dualMesh.verts.size()];
                    FORI (i, dualVertColors.length)
                        dualVertColors[i] = dualColor; // default-- may change if special
                    dualEdgeColors = new java.awt.Color[dualMesh.edges.size()];
                    FORI (i, dualEdgeColors.length)
                        dualEdgeColors[i] = dualColor; // default-- may change if special

                    //
                    // Set color for selected dual vertices,
                    // and compute their center of curvature "avg".
                    // Also, if showing euler line, compute centroid too.
                    //
                    {
                        double curvatureMomentAndAreaSum[] = new double[4]; // zeros
                        double centroidMomentTimes3[] = showEulerLineWhenShowingWeightsFlag.get() ? new double[2] : null;  // worry about only x and y, for simplicity
                        double orthocenterMoment[] = showEulerLineWhenShowingWeightsFlag.get() ? new double[2] : null;  // worry about only x and y, for simplicity
                        FORI (i, selectedDualVertIndices.length)
                        {
                            int ind = selectedDualVertIndices[i];
                            if (ind == -1)
                                continue;
                            dualVertColors[ind] = dualVertSelectionColor;
                            Mesh.Vertex dualVert = dualMesh.getVert(ind);
                            GeomUtils.accumulateMomentAndArea(curvatureMomentAndAreaSum, dualVert.momentAndArea);
                            if (centroidMomentTimes3 != null) {
                                Mesh.Vertex v0 = mesh.getVert(selectedTris[i][0]);
                                Mesh.Vertex v1 = mesh.getVert(selectedTris[i][1]);
                                Mesh.Vertex v2 = mesh.getVert(selectedTris[i][2]);
                                centroidMomentTimes3[0] += (v0.x() + v1.x() + v2.x()) * dualVert.momentAndArea[3];
                                centroidMomentTimes3[1] += (v0.y() + v1.y() + v2.y()) * dualVert.momentAndArea[3];
                            }
                            if (orthocenterMoment != null) {
                                // What's the orthocenter of a triangle?
                                // https://en.wikipedia.org/wiki/Altitude_(triangle)#Orthocenter
                                Mesh.Vertex v0 = mesh.getVert(selectedTris[i][0]);
                                Mesh.Vertex v1 = mesh.getVert(selectedTris[i][1]);
                                Mesh.Vertex v2 = mesh.getVert(selectedTris[i][2]);
                                // edge lengths squared...
                                double asqrd = SQR(v1.x()-v2.x()) + SQR(v1.y()-v2.y());
                                double bsqrd = SQR(v2.x()-v0.x()) + SQR(v2.y()-v0.y());
                                double csqrd = SQR(v0.x()-v1.x()) + SQR(v0.y()-v1.y());
                                // barycentrics...
                                double abary = (asqrd+bsqrd-csqrd)*(asqrd-bsqrd+csqrd);
                                double bbary = (bsqrd+csqrd-asqrd)*(bsqrd-csqrd+asqrd);
                                double cbary = (csqrd+asqrd-bsqrd)*(csqrd-asqrd+bsqrd);
                                double barysum = (abary+bbary+cbary);
                                abary /= barysum;
                                bbary /= barysum;
                                cbary /= barysum;
                                orthocenterMoment[0] += (v0.x()*abary + v1.x()*bbary + v2.x()*cbary) * dualVert.momentAndArea[3];
                                orthocenterMoment[1] += (v0.y()*abary + v1.y()*bbary + v2.y()*cbary) * dualVert.momentAndArea[3];
                            }
                        }
                        if (selectedDualVertIndices.length > 0)
                            PRINTVEC(curvatureMomentAndAreaSum);
                        double A = curvatureMomentAndAreaSum[3];
                        if (A != 0.) {
                            avg = new double[] {
                                curvatureMomentAndAreaSum[0] / A,
                                curvatureMomentAndAreaSum[1] / A,
                                curvatureMomentAndAreaSum[2] / (A*A),
                            };
                            if (centroidMomentTimes3 != null) {
                                centroid = new double[] {
                                  centroidMomentTimes3[0] / (3.*A),
                                  centroidMomentTimes3[1] / (3.*A),
                                };
                            }
                            if (orthocenterMoment != null) {
                                orthocenter = new double[] {
                                  orthocenterMoment[0] / A,
                                  orthocenterMoment[1] / A,
                                };
                            }
                        }
                    }

                    //
                    // If showing net, compute a net.
                    // If it ends up complete,
                    // color good edges green and off-balance ones red.
                    //
                    // TODO: move net computation to a new file called NetUtils.prejava I think
                    //

                    if (showNetFlagValue)
                    {
                        try
                        {
                            if (theNet == null)
                            {
                                // Clear visualizations before running new algorithm
                                sweepCircleToDrawThroughPoint = null;
                                sweepCircleToDrawCenterHomo = null;
                                sweepVisualizationGraphics = null;

                                // Really better names for these would be "dualEdgeIsKnownToBeCut" etc.
                                boolean dualEdgeIsCut[] = new boolean[mesh.edges.size()]; // all false initially
                                boolean dualEdgeIsFold[] = null; // needed in only some cases

                                Mesh.Edge dualVertIndexToParentEdge[] = new Mesh.Edge[dualMesh.verts.size()]; // all null initially
                                int netMethodValue = netMethod.get();
                                if (netMethodValue == NETMETHOD_MY_ALGORITHM_MAYBE
                                 || netMethodValue == NETMETHOD_MY_ALGORITHM_MAYBE2
                                 || netMethodValue == NETMETHOD_MY_ALGORITHM_MAYBEFACE)
                                {
                                    int maxIters = myAlgorithmMaxIters.get();
                                    double sweepOriginHomo[] = parseSweepOriginHomo(myAlgorithmSweepOriginHomoSpec.get());
                                    CHECK_NE(sweepOriginHomo, null); // because spec was validated
                                    int putProblematicVertsHereForDebugging[/*1*/][] = {null};
                                    double putLastPointSweptHere[/*1*/][/*2*/] = {null};
                                    java.util.ArrayList<MyAlgorithmMaybe.Graphic> putGraphicsOfLastDecisionHere = new java.util.ArrayList<MyAlgorithmMaybe.Graphic>();
                                    try {
                                        if (netMethodValue==NETMETHOD_MY_ALGORITHM_MAYBE)
                                        {
                                            theNet = MyAlgorithmMaybe.doIt(dualMesh, mesh, sweepOriginHomo, randomNumberGenerator, maxIters, putProblematicVertsHereForDebugging); // reversed since we want net of dual mesh
                                        }
                                        else if (netMethodValue==NETMETHOD_MY_ALGORITHM_MAYBE2)
                                        {
                                            theNet = MyAlgorithmMaybe.doIt2(dualMesh, mesh, sweepOriginHomo, maxIters, putProblematicVertsHereForDebugging, putLastPointSweptHere); // reversed since we want net of dual mesh
                                        }
                                        else if (netMethodValue==NETMETHOD_MY_ALGORITHM_MAYBEFACE)
                                        {
                                            theNet = MyAlgorithmMaybe.doItFaceSweep(dualMesh, mesh, sweepOriginHomo, maxIters, putProblematicVertsHereForDebugging, putLastPointSweptHere, putGraphicsOfLastDecisionHere); // reversed since we want net of dual mesh
                                        }
                                        else
                                        {
                                            CHECK(false);
                                        }
                                        // don't choose directions; that's done below (although maybe MyAlgorithm should have done it? not sure)
                                    }
                                    finally { // whether or not throwing
                                        if (putProblematicVertsHereForDebugging[0] != null)
                                        {
                                            selectedDualVertIndices = putProblematicVertsHereForDebugging[0];
                                            PRINTVEC(selectedDualVertIndices);
                                            selectedTris = new int[selectedDualVertIndices.length][];
                                            FORI (i, selectedTris.length)
                                            {
                                                if (selectedDualVertIndices[i] == nDualVerts)
                                                {
                                                    OUT("removing vert selectedDualVertIndices[i]="+nDualVerts+"=nDualVerts");
                                                    selectedDualVertIndices = Arrays.delete(selectedDualVertIndices, i);
                                                    selectedTris = (int[][])Arrays.delete(selectedTris, i);
                                                    --i;
                                                }
                                                else
                                                    selectedTris[i] = MeshUtils.findPrimalFaceFromDualVert(mesh, dualMesh, selectedDualVertIndices[i]);
                                            }
                                            PRINTVEC(selectedDualVertIndices);
                                            PRINTARRAY(selectedTris);
                                        }
                                        if (putLastPointSweptHere[0] != null)
                                        {
                                            sweepCircleToDrawThroughPoint = VecMath.copyvec(putLastPointSweptHere[0]);
                                            sweepCircleToDrawCenterHomo = VecMath.copyvec(sweepOriginHomo);
                                        }
                                        sweepVisualizationGraphics = putGraphicsOfLastDecisionHere;
                                    }
                                }
                                else if (netMethodValue == NETMETHOD_SELECT_VERTSWEEP)
                                {
                                    double sweepOriginHomo[] = parseSweepOriginHomo(myAlgorithmSweepOriginHomoSpec.get());
                                    CHECK_NE(sweepOriginHomo, null); // because spec was validated
                                    BigInt iNet = new BigInt(myAlgorithmMaxIters.get()); // XXX TODO: make this something else
                                    theNet = MyAlgorithmMaybe.selectVertSweepOrNull(dualMesh, mesh, sweepOriginHomo, iNet); // reversed since we want net of dual meah
                                }
                                else if (netMethodValue == NETMETHOD_SELECT_FACESWEEP)
                                {
                                    double sweepOriginHomo[] = parseSweepOriginHomo(myAlgorithmSweepOriginHomoSpec.get());
                                    CHECK_NE(sweepOriginHomo, null); // because spec was validated
                                    BigInt iNet = new BigInt(myAlgorithmMaxIters.get()); // XXX TODO: make this something else
                                    theNet = MyAlgorithmMaybe.selectFaceSweepOrNull(dualMesh, mesh, sweepOriginHomo, iNet); // reversed since we want net of dual meah
                                }
                                else if (netMethodValue == NETMETHOD_SELECT_NET)
                                {
                                    BigInt iNet = new BigInt(myAlgorithmMaxIters.get()); // XXX TODO: make this something else
                                    theNet = MyAlgorithmMaybe.selectNetOrNull(dualMesh, mesh, iNet); // reversed since we want net of dual meah
                                }
                                else if (netMethodValue == NETMETHOD_RANDOM)
                                {
                                    int netVerboseLevel = !(showNetFlagValue && showNetFlowFlag.get()) ? 1 : 0;
                                    if (netVerboseLevel >= 1) System.out.println("   computing random net");

                                    MeshUtils.SimplerMeshDataStructure simplerMeshDataStructure = new MeshUtils.SimplerMeshDataStructure(dualMesh, true);
                                    if (!simplerMeshDataStructure.isConnectedExceptMaybeForIsolatedVerts())
                                    {
                                        System.out.println("      graph is disconnected; not computing net");
                                    }
                                    else if (simplerMeshDataStructure.e2v.length == 0)
                                    {
                                        // Actually not quite sure why I need this case (assert-fails without it)
                                        System.out.println("      no edges; not computing net");
                                    }
                                    else
                                    {
                                        CHECK_EQ(simplerMeshDataStructure.v2e.length, dualMesh.verts.size() + 1); // added an artificial one for the infinite vert and any inside out verts that got merged into it
                                        boolean spanningTree[] = simplerMeshDataStructure.randomSpanningTree(randomNumberGenerator);
                                        int root = dualMesh.verts.size();
                                        int vertToParentEdgeOut[] = simplerMeshDataStructure.getVertToParentEdgeOut(root, spanningTree);
                                        PRINTARRAY(vertToParentEdgeOut);
                                        FORI (iDualVert, vertToParentEdgeOut.length)
                                        {
                                            int iDualEdge = vertToParentEdgeOut[iDualVert];
                                            if (iDualEdge != -1)
                                            {
                                                dualEdgeIsCut[iDualEdge] = true;
                                                dualEdgeIsCut[iDualEdge ^ 1] = true;
                                                dualVertIndexToParentEdge[iDualVert] = dualMesh.getEdge(iDualEdge);
                                            }
                                        }
                                    }
                                } // NETMETHOD_RANDOM
                                else if (netMethodValue == NETMETHOD_UPWARD
                                      || netMethodValue == NETMETHOD_OUTWARD)
                                {
                                    FORIDOWN (iEdge, mesh.edges.size())
                                    {
                                        Mesh.Vertex triCenterDualVert = (dualMesh.getEdge(iEdge)).finalVertex();
                                        if (triCenterDualVert == null)
                                            continue; // primal face was not a triangle, or inside out
                                        if (triCenterDualVert.weight < 0.)
                                            continue; // primal face is on underside (if calculated underside), i.e. inside out
                                        if (dualVertIndexToParentEdge[triCenterDualVert.myIndex()] != null)
                                            continue; // definitely already did this vertex  XXX but root vertex stays null so it will be done 3 times :-(
                                        double triCenterDualVertPos[] = {
                                            triCenterDualVert.x(),
                                            triCenterDualVert.y(),
                                        };

                                        Mesh.Edge e0 = mesh.getEdge(iEdge);
                                        Mesh.Edge e1 = e0.next();
                                        Mesh.Edge e2 = e1.next();
                                        CHECK_EQ(e2.next(), e0);

                                        double threeDirections[][] = {
                                            (dualMesh.getEdge(e0.myIndex())).opposite().direction,
                                            (dualMesh.getEdge(e1.myIndex())).opposite().direction,
                                            (dualMesh.getEdge(e2.myIndex())).opposite().direction,
                                        };

                                        Mesh.Edge threeDualEdges[] = {
                                            (dualMesh.getEdge(e0.myIndex())).opposite(),
                                            (dualMesh.getEdge(e1.myIndex())).opposite(),
                                            (dualMesh.getEdge(e2.myIndex())).opposite(),
                                        };
                                        double threeFinalPositions[][] = new double[3][];
                                        FORI (i, 3)
                                        {
                                            Mesh.Edge dualEdge = threeDualEdges[i];
                                            Mesh.Vertex finalVertex = dualEdge.finalVertex();
                                            if (finalVertex == null)
                                                threeFinalPositions[i] = new double[] {Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY};
                                            else
                                                threeFinalPositions[i] = new double[] {finalVertex.x(), finalVertex.y()};
                                        }

                                        int bestSide = netMethodValue==NETMETHOD_OUTWARD ?
                                                       /*
                                                       MAXI3(VecMath.dot(threeDirections[0], triCenterDualVertPos),
                                                             VecMath.dot(threeDirections[1], triCenterDualVertPos),
                                                             VecMath.dot(threeDirections[2], triCenterDualVertPos))
                                                       */
                                                       MAXI3(VecMath.normsqrd(threeFinalPositions[0]),
                                                             VecMath.normsqrd(threeFinalPositions[1]),
                                                             VecMath.normsqrd(threeFinalPositions[2]))
                                                     : MAXI3(threeDirections[0][1],
                                                             threeDirections[1][1],
                                                             threeDirections[2][1]);
                                        if (true && netMethodValue == NETMETHOD_UPWARD) // XXX do I want something like this for OUTWARD? the following isn't right in that case...
                                        {
                                            // Hack to simulate symbolic perterbation
                                            // by an infinitesimal rotation counterclockwise
                                            if (EQ(threeDirections[bestSide][1], threeDirections[(bestSide+1)%3][1], 1e-6)
                                             && LT(threeDirections[bestSide][0], threeDirections[(bestSide+1)%3][0], 1e-6))
                                            {
                                                bestSide = (bestSide+1)%3;
                                                if (EQ(threeDirections[bestSide][1], threeDirections[(bestSide+1)%3][1], 1e-6)
                                                 && LT(threeDirections[bestSide][0], threeDirections[(bestSide+1)%3][0], 1e-6))
                                                    bestSide = (bestSide+1)%3;
                                            }
                                            else
                                            {
                                                if (EQ(threeDirections[bestSide][1], threeDirections[(bestSide+2)%3][1], 1e-6)
                                                 && LT(threeDirections[bestSide][0], threeDirections[(bestSide+2)%3][0], 1e-6))
                                                    bestSide = (bestSide+2)%3;
                                            }
                                        }
                                        if (true)
                                        {
                                            // Hack to ensure that a negative-weight (assume that means boundary)
                                            // vertex never has a non-negative-weight vertex as parent
                                            Mesh.Edge threeEdges[] = {
                                                (dualMesh.getEdge(e0.myIndex())).opposite(),
                                                (dualMesh.getEdge(e1.myIndex())).opposite(),
                                                (dualMesh.getEdge(e2.myIndex())).opposite(),
                                            };
                                            if (triCenterDualVert.weight < 0.
                                             && threeEdges[bestSide].finalVertex() != null
                                             && threeEdges[bestSide].finalVertex().weight >= 0.)
                                            {
                                                int origBestSide = bestSide;
                                                bestSide = (threeDirections[(bestSide+1)%3][1] >= threeDirections[(bestSide+2)%3][1] ? (bestSide+1)%3 : (bestSide+2)%3);
                                                if (triCenterDualVert.weight < 0.
                                                 && threeEdges[bestSide].finalVertex() != null
                                                 && threeEdges[bestSide].finalVertex().weight >= 0.)
                                                {
                                                    bestSide = 3 - bestSide - origBestSide;
                                                }
                                            }
                                        }

                                        if (false) // set this to true to debug
                                        {
                                            PRINTARRAY(triCenterDualVert);
                                            double whereToDrawMark[] = {
                                                triCenterDualVert.x() + .05 * threeDirections[bestSide][0],
                                                triCenterDualVert.y() + .05 * threeDirections[bestSide][1],
                                            };
                                            mg3d.drawPoint(whereToDrawMark[0],
                                                         whereToDrawMark[1],
                                                         0.,
                                                         5);
                                        }


                                        Mesh.Edge e = bestSide==0 ? e0 : bestSide==1 ? e1 : e2;
                                        // remember each edge gets drawn in an arbitrary one of the two directions,
                                        // so we have to set the flag on both of them
                                        dualEdgeIsCut[e.myIndex()] = true;
                                        dualEdgeIsCut[e.opposite().myIndex()] = true;

                                        // Set parent... but only if the edge
                                        // is really upwards.
                                        // to avoid a cycle in the graph
                                        {
                                            Mesh.Edge maybeParentEdge = (dualMesh.getEdge(e.myIndex())).opposite();
                                            if (netMethodValue == NETMETHOD_OUTWARD)
                                                dualVertIndexToParentEdge[triCenterDualVert.myIndex()] = maybeParentEdge;
                                            else
                                                if (GT(maybeParentEdge.direction[1], 0, 1e-6)
                                                 || (EQ(maybeParentEdge.direction[1], 0, 1e-6)
                                                  && maybeParentEdge.direction[0] > 0.))
                                                dualVertIndexToParentEdge[triCenterDualVert.myIndex()] = maybeParentEdge;
                                        }
                                    }
                                } // UPWARD or OUTWARD
                                else if (netMethodValue == NETMETHOD_CUT_SHARPEST
                                      || netMethodValue == NETMETHOD_CUT_DULLEST
                                      || netMethodValue == NETMETHOD_CUT_LONGEST
                                      || netMethodValue == NETMETHOD_CUT_SHORTEST
                                      || netMethodValue == NETMETHOD_FOLD_SHARPEST
                                      || netMethodValue == NETMETHOD_FOLD_DULLEST
                                      || netMethodValue == NETMETHOD_FOLD_LONGEST
                                      || netMethodValue == NETMETHOD_FOLD_SHORTEST)
                                {
                                    Mesh meshToUse, dualMeshToUse;
                                    if (netMethodValue == NETMETHOD_CUT_SHARPEST
                                     || netMethodValue == NETMETHOD_CUT_DULLEST
                                     || netMethodValue == NETMETHOD_CUT_LONGEST
                                     || netMethodValue == NETMETHOD_CUT_SHORTEST)
                                    {
                                        // In this case we want to cut the something-est edge at each vertex
                                        // of the dual, so we'll be walking around each dual vert, i.e. around each primal face.
                                        //System.out.println("USING PRIMAL MESH");
                                        meshToUse = mesh;
                                        dualMeshToUse = dualMesh;
                                    }
                                    else
                                    {
                                        // In this case we want to fold the something-est edge at each face
                                        // of the dual, so we'll be walking around each dual face.
                                        //System.out.println("USING DUAL MESH");
                                        meshToUse = dualMesh;
                                        dualMeshToUse = mesh;

                                        // need dualEdgeIsFold, not dualEdgeIsCut
                                        dualEdgeIsFold = dualEdgeIsCut;
                                        dualEdgeIsCut = null;
                                    }

                                    boolean seenEdge[] = new boolean[mesh.edges.size()]; // all false initially
                                    FORIDOWN (iEdge, seenEdge.length)
                                    {
                                        if (seenEdge[iEdge])
                                            continue;

                                        // Walk around the primal face,
                                        // accumulating the bestest dual edge.
                                        Mesh.Edge edge = meshToUse.getEdge(iEdge);

                                        boolean verbose = edge.initialVertex() != null && edge.finalVertex() != null && (MIN(edge.initialVertex().myIndex(), edge.finalVertex().myIndex()) == 4
                                                        && MAX(edge.initialVertex().myIndex(), edge.finalVertex().myIndex()) == 5); // XXX get rid when debugged adequately
                                        verbose = false;

                                        if (verbose)
                                            System.out.println("    examining edge "+edge);
                                        double bestValue = Double.NaN; // initialize to something to shut up compiler
                                        int bestIndex = -1;

                                        {
                                            Mesh.Edge thisEdge = edge;
                                            do
                                            {
                                                if (verbose)
                                                    System.out.println("        is this better? "+thisEdge);
                                                int thisEdgeIndex = thisEdge.myIndex();
                                                double thisValue;
                                                if (netMethodValue == NETMETHOD_CUT_SHARPEST
                                                 || netMethodValue == NETMETHOD_CUT_DULLEST
                                                 || netMethodValue == NETMETHOD_FOLD_LONGEST
                                                 || netMethodValue == NETMETHOD_FOLD_SHORTEST)
                                                {
                                                    // sharpest dual edge === longest primal edge
                                                    Mesh.Vertex v0 = thisEdge.initialVertex();
                                                    Mesh.Vertex v1 = thisEdge.finalVertex();
                                                    double edgeLength2 = (v0==null||v1==null ? Double.POSITIVE_INFINITY
                                                                                             : SQR(v1.x()-v0.x())
                                                                                             + SQR(v1.y()-v0.y()));
                                                    thisValue = edgeLength2;
                                                    if (netMethodValue == NETMETHOD_CUT_DULLEST
                                                     || netMethodValue == NETMETHOD_FOLD_SHORTEST)
                                                        thisValue = -thisValue;
                                                }
                                                else // CUT_LONGEST or CUT_SHORTEST or FOLD_SHARPEST or FOLD_DULLEST
                                                {
                                                    Mesh.Edge dualEdge = dualMeshToUse.getEdge(thisEdgeIndex);
                                                    if (verbose)
                                                        System.out.println("        dual edge: "+dualEdge);
                                                    Mesh.Vertex v0 = dualEdge.initialVertex();
                                                    Mesh.Vertex v1 = dualEdge.finalVertex();
                                                    double edgeLength2 = (v0==null||v1==null ? Double.POSITIVE_INFINITY
                                                                                             : SQR(v1.x()-v0.x())
                                                                                             + SQR(v1.y()-v0.y()));
                                                    thisValue = edgeLength2;
                                                    if (netMethodValue == NETMETHOD_CUT_SHORTEST
                                                     || netMethodValue == NETMETHOD_FOLD_DULLEST)
                                                        thisValue = -thisValue;
                                                    if (verbose)
                                                        System.out.println("        thisValue: "+thisValue);
                                                }
                                                if (verbose && bestIndex != -1)
                                                {
                                                    PRINT(thisValue);
                                                    PRINT(bestValue);
                                                    PRINT(GT(thisValue, bestValue, SQR(1e-6)));
                                                    PRINT(GEQ(thisValue, bestValue, SQR(1e-6)));
                                                    PRINT(MIN(thisEdgeIndex,meshToUse.getEdge(thisEdgeIndex).opposite().myIndex()) < MIN(bestIndex,meshToUse.getEdge(bestIndex).opposite().myIndex()));
                                                }
                                                if (bestIndex == -1
                                                 || (GT(thisValue, bestValue, SQR(1e-6))

                                                //|| (GEQ(thisValue, bestValue, SQR(1e-6)) // GEQ macro doesn't work for comparing -Infinity with -Infinity! argh!
                                                  || ((thisValue >= bestValue-SQR(1e-6))

                                                   && (MIN(thisEdgeIndex,meshToUse.getEdge(thisEdgeIndex).opposite().myIndex()) < MIN(bestIndex,meshToUse.getEdge(bestIndex).opposite().myIndex()))) ) ) // tie breaker: lowest index wins
                                                {
                                                    if (verbose)
                                                        System.out.println("            yes better: "+thisEdge);
                                                    bestValue = thisValue;
                                                    bestIndex = thisEdgeIndex;
                                                }
                                                else
                                                {
                                                    if (verbose)
                                                        System.out.println("            no, not better");
                                                }
                                                seenEdge[thisEdgeIndex] = true;
                                            } while ((thisEdge=thisEdge.next()) != edge);
                                        }
                                        if (netMethodValue == NETMETHOD_FOLD_SHARPEST
                                         || netMethodValue == NETMETHOD_FOLD_DULLEST
                                         || netMethodValue == NETMETHOD_FOLD_LONGEST
                                         || netMethodValue == NETMETHOD_FOLD_SHORTEST)
                                        {
                                            // this is kind of silly... should just use the Net directly
                                            dualEdgeIsFold[bestIndex] = true;
                                            dualEdgeIsFold[meshToUse.getEdge(bestIndex).opposite().myIndex()] = true; // currently not necessary but makes things cleaner
                                        }
                                        else
                                        {
                                            dualEdgeIsCut[bestIndex] = true;
                                            dualEdgeIsCut[meshToUse.getEdge(bestIndex).opposite().myIndex()] = true; // currently not necessary but makes things cleaner
                                        }
                                    }
                                }
                                else if (netMethodValue == NETMETHOD_MANUAL)
                                {
                                    // nothing
                                }
                                else
                                {
                                    CHECK(false);
                                }

                                {
                                    if (theNet == null) // i.e. if the method above didn't actually make the net, but populated only dualEdgeIsCut and dualEdgeIsFold
                                    {
                                        theNet = new Net(dualMesh, mesh);
                                        if (dualEdgeIsCut != null)
                                            FORI(iEdge, nEdges)
                                                if (dualEdgeIsCut[iEdge])
                                                    theNet.cut(iEdge, true); // TODO: this is sometimes assert-failing during continuous polishing when net method is RANDOM
                                        if (dualEdgeIsFold != null)
                                            FORI(iEdge, nEdges)
                                                if (dualEdgeIsFold[iEdge])
                                                    theNet.fold(iEdge, true);
                                    }
                                    int root = nDualVerts;
                                    if (theNet.nUndecideds() == 0)
                                        theNet.chooseDirections(root);
                                }

                            } // theNet was null

                            //
                            // Now figure out which ones are off balance.
                            //
                            // accumulate weights...
                            if (theNet._topSortedVertInds != null) // i.e. if complete
                            {
                                momentAndWeightStrictlyBelowEachDualVertex = theNet.computeMomentAndWeightStrictlyBelowEachVertexInitially();
                                dualEdgeIsOffBalanceCut = new boolean[mesh.edges.size()];
                                dualEdgeOffBalanceCuts = new int[mesh.edges.size()];

                                nOffBalanceCuts = theNet.figureOutWhatsOffBalanceInitially(
                                    momentAndWeightStrictlyBelowEachDualVertex,
                                    dualEdgeIsOffBalanceCut,
                                    dualEdgeOffBalanceCuts);

                                // We want to omit zero-length (or very close to zero-length) edges
                                // from the thermometer.
                                // Count number of non-zero-length edges...
                                // TODO: this should maybe just be in the above loop.
                                nNonZeroLengthWholeEdges = 0; // and counting
                                nNonZeroLengthOffBalanceCuts = 0; // and counting
                                FORI (iDualEdge, nEdges)
                                {
                                    int oDualEdge = dualMesh.getEdge(iDualEdge).opposite().myIndex();
                                    CHECK_EQ(oDualEdge, iDualEdge ^ 1); // so that was silly
                                    if (iDualEdge < oDualEdge)
                                    {
                                        double from[] = dualEdgeInitialCoords[iDualEdge][0];
                                        double to[] = dualEdgeInitialCoords[oDualEdge][0];

                                        CHECK_EQ((from==null), (to==null));
                                        if (from==null)
                                            continue; // this part doesn't exist-- edge is wholely on second sheet

                                        CHECK_EQ(from.length, 4);
                                        CHECK_EQ(to.length, 4);

                                        // CBB: should precalculate these
                                        double fromXY[/*2*/] = VecMath.vxs(2, from, 1./from[3]);
                                        double toXY[/*2*/] = VecMath.vxs(2, to, 1./to[3]);
                                        if (GT(VecMath.distsqrd(2, fromXY,toXY), 0., SQR(1e-6)))
                                        {
                                            nNonZeroLengthWholeEdges++;
                                            if (dualEdgeIsOffBalanceCut[iDualEdge])
                                                nNonZeroLengthOffBalanceCuts++;
                                        }
                                    }
                                }
                            }
                            else
                            {
                                dualEdgeIsOffBalanceCut = new boolean[mesh.edges.size()]; // all false
                                nOffBalanceCuts = 0;
                            }
                        }
                        catch (Throwable e)
                        {
                            // an assertion failed, no doubt
                            // TODO: probably need a way to force the animation off whenever anything bad happens in paint, now
                            e.printStackTrace();
                            System.out.println("Well that sucked-- forcing showNetFlag off");
                            theNet = null; // in case it got partially set
                            synchronized(showNetFlag) // since another thread checks it once in a while
                            {
                                showNetFlag.set(false);
                            }
                            showNetFlagValue = false;
                        }
                    } // if (showNetFlagValue)

                    if (!showNetFlagValue)
                    {
                        //
                        // Select colors for the good and bad ways out of the lagoon.
                        //

                        // first identify the edges out of the lagoon...
                        FORI (iDualEdge, dualMesh.edges.size())
                        {
                            Mesh.Edge dualEdge = dualMesh.getEdge(iDualEdge);
                            Mesh.Vertex initialVertex = dualEdge.initialVertex();
                            if (initialVertex == null)
                                continue; // no initial vertex
                            int iDualVert = initialVertex.myIndex();
                            if (!isSelectedDualVert[iDualVert])
                                continue; // doesn't originate in the lagoon
                            int iDualEdgeOpposite = dualEdge.opposite().myIndex();
                            Mesh.Vertex finalVertex = dualEdge.finalVertex();
                            if (finalVertex != null
                             && isSelectedDualVert[finalVertex.myIndex()])
                            {
                                // both ends are in the lagoon.
                                int jDualVert = finalVertex.myIndex();
                                if (iDualVert > jDualVert)
                                    continue; // need to do it only in canonical dir
                                dualEdgeColors[iDualEdge] = dualColorBothSelected;
                                dualEdgeColors[iDualEdgeOpposite] = dualColorBothSelected;
                            }
                            else
                            {
                                // starts in the lagoon, ends outside it.
                                // is it a good exit?
                                double initialVertexCoords[] = {initialVertex.x(), initialVertex.y()};
                                CHECK_NE(dualEdge.direction, null); // XXX TODO: remove when I get this debugged
                                double goodness = VecMath.dot(2, dualEdge.direction,
                                                              VecMath.vmv(2, initialVertexCoords, avg));
                                boolean isGoodExit = GEQ(goodness, 0., SQR(1e-6));

                                if (true)
                                {
                                    if (selectedDualVertIndices.length > 1)
                                    {
                                        if (isGoodExit)
                                            mg3d.setColor(perpColorGood);
                                        else
                                            mg3d.setColor(perpColorBad);

                                        // draw perpendicular at the zero level (not at the vertex),
                                        // to emphasize the wrongness if viewing non-orthogonally
                                        double rayLength = 1.;
                                        mg3d.drawLine(initialVertex.x() - rayLength * dualEdge.direction[1],
                                                    initialVertex.y() + rayLength * dualEdge.direction[0],
                                                    0,
                                                    initialVertex.x() + rayLength * dualEdge.direction[1],
                                                    initialVertex.y() - rayLength * dualEdge.direction[0],
                                                    0,
                                                    antiAliasingFlag);
                                    }
                                }

                                if (isGoodExit)
                                {
                                    dualEdgeColors[iDualEdge] = dualColorOneSelectedGood;
                                    dualEdgeColors[iDualEdgeOpposite] = dualColorOneSelectedGood;
                                }
                                else
                                {
                                    dualEdgeColors[iDualEdge] = dualColorOneSelectedBad;
                                    dualEdgeColors[iDualEdgeOpposite] = dualColorOneSelectedBad;
                                }

                            }
                        }
                    } // if (!showNetFlagValue)
                } // if (drawDualDiagramFlag)

                if (drawDualDiagramFlag && showNetFlagValue)
                {
                    // Draw stuff to help algorithm visualization, BEFORE the main diagram.
                    if (sweepCircleToDrawThroughPoint != null
                     && sweepCircleToDrawCenterHomo != null)
                    {
                        CHECK_EQ(sweepCircleToDrawThroughPoint.length, 2);
                        CHECK_EQ(sweepCircleToDrawCenterHomo.length, 3);
                        double focusX = sweepCircleToDrawThroughPoint[0];
                        double focusY = sweepCircleToDrawThroughPoint[1];
                        CHECK(sweepCircleToDrawCenterHomo[2]==0.
                            || sweepCircleToDrawCenterHomo[2]==1.); // CBB: could do computation more robustly
                        double curvature = (sweepCircleToDrawCenterHomo[2]==0. ? 0. : 1./VecMath.dist(2, sweepCircleToDrawCenterHomo, sweepCircleToDrawThroughPoint));
                        if (Double.isFinite(curvature))
                        {
                            PRINTVEC(sweepCircleToDrawCenterHomo);
                            PRINTVEC(sweepCircleToDrawThroughPoint);
                            PRINT(curvature);
                            double sweepDirectionAtPoint[] = new double[2];
                            VecMath.sxvpsxv(2, sweepDirectionAtPoint,
                                            sweepCircleToDrawCenterHomo[2], sweepCircleToDrawThroughPoint,
                                            -1., sweepCircleToDrawCenterHomo);
                            double focusAngleRadians = Math.atan2(sweepDirectionAtPoint[1], sweepDirectionAtPoint[0]);

                            double start, end;
                            if (curvature != 0.)
                            {
                                start = -Math.PI / curvature;
                                end = Math.PI / curvature;
                            }
                            else
                            {
                                // HACK-- not sure what makes sense
                                start = -10.;
                                end = 10.;
                            }

                            mg3d.setColor(java.awt.Color.RED.darker());
                            mg3d.smartDrawThickArc(
                                1., // thicknessInPixels
                                focusX, focusY,   // a point on the arc
                                focusAngleRadians, // from center to focus
                                curvature,         // 1/radius
                                start, end, // arc goes from focusAngle+start to focusAngle+end in arc length
                                false); // antiAlias-- supposed to be always false according to function doc
                        }

                        if (myAlgorithmMaxIters.get() % 2 == 1)
                        {
                            // swept to but not past the vertex
                            mg3d.setColor(java.awt.Color.RED);
                        }
                        else
                        {
                            // swept past the vertex
                            mg3d.setColor(java.awt.Color.GREEN);
                        }
                        double littleRadius = .025;
                        mg3d.drawThickArc(sweepCircleToDrawThroughPoint[0]-littleRadius, sweepCircleToDrawThroughPoint[1]-littleRadius,
                                        2*littleRadius, 2*littleRadius,
                                        0., Math.PI*2,
                                        1., // thicknessInPixels,
                                        false);
                   }
                }

                boolean whichPrimalEdgesGotDrawn[] = showPrimalEdgesFlag.get() ? new boolean[nEdges] : null; // all false initially
                boolean showInsideOutDualVertsFlagValue = showInsideOutDualVertsFlag.get();

                int frontBrightness = 240;
                int backBrightness = (int)(backfaceBrightness.get() * frontBrightness);
                int passFacings[] = {
                    MeshUtils.FACING_BACK,
                    MeshUtils.FACING_SIDE,
                    MeshUtils.FACING_FRONT,
                    MeshUtils.FACING_UNKNOWN,
                };
                FORI (_iFacingPass, passFacings.length)
                {
                    int passFacing = passFacings[_iFacingPass];
                    if (passFacing == MeshUtils.FACING_BACK && backBrightness <= 0)
                        continue;

                    if (showPrimalVertsFlag.get() || showPrimalEdgesFlag.get())
                    {
                        java.util.ArrayList<Mesh.Vertex> verts = mesh.verts;
                        java.util.ArrayList<Mesh.Edge> edges = mesh.edges;
                        java.util.ArrayList<Mesh.Edge> dualEdges = dualMesh.edges;

                        if (passFacing == MeshUtils.FACING_BACK)
                            mg3d.setColor(new java.awt.Color(backBrightness,backBrightness,backBrightness));
                        else if (passFacing == MeshUtils.FACING_FRONT)
                            mg3d.setColor(new java.awt.Color(frontBrightness,frontBrightness,frontBrightness));
                        else if (passFacing == MeshUtils.FACING_SIDE)
                            mg3d.setColor(java.awt.Color.YELLOW);
                        else if (passFacing == MeshUtils.FACING_UNKNOWN)
                            mg3d.setColor(java.awt.Color.MAGENTA);
                        else
                            CHECK(false);

                        if (showPrimalVertsFlag.get())
                            FORI (iVert, nVerts)
                            {
                                // CBB: ideally if iVert==beingDraggedVertIndex we'd draw the being-dragged vertex on top of everything else, but in its pass color. But that's currently awkward.  For now, just draw it in its natural pass.
                                if (vertFacings[iVert] == passFacing)
                                {
                                    double vCoordHomo[] = vertCoordsHomo[iVert];
                                    mg3d.drawPoint(vCoordHomo[0],
                                                 vCoordHomo[1],
                                                 vCoordHomo[2],
                                                 vCoordHomo[3],
                                                 iVert==beingDraggedVertIndex ? 5 : 3);
                                }
                            }

#if 1 // XXX was this just an experiment? can I get rid?  oh wait, it's actually cool!
                        //if (showTriangles.get() == 3) // spherical barycentrics experiment
                        //if (!showPrimalVertsFlag.get() && !showPrimalEdgesFlag.get()) // spherical barycentrics experiment
                        if (sbaryExperimentType.get() != 0 && passFacing == MeshUtils.FACING_FRONT) // CBB: honor facing for this
                        {
                            OUT("barycentrics experiment! type="+sbaryExperimentType.get());
                            double wrapSphereRadius = 1./wrapSphereCurvature.get();
                            FORIDOWN(iEdge, edges.size())
                            {
                                Mesh.Edge edge0 = edges.get(iEdge);
                                Mesh.Edge edge1 = edge0.next();
                                Mesh.Edge edge2 = edge1.next();
                                if (edge2.next() == edge0)
                                {
                                    // it's a triangle
                                    Mesh.Vertex vert0 = edge0.initialVertex();
                                    Mesh.Vertex vert1 = edge1.initialVertex();
                                    Mesh.Vertex vert2 = edge2.initialVertex();
                                    double ppp[][] = {{vert0.x(),vert0.y(),vert0.z()+wrapSphereRadius},
                                                      {vert1.x(),vert1.y(),vert1.z()+wrapSphereRadius},
                                                      {vert2.x(),vert2.y(),vert2.z()+wrapSphereRadius}};
                                    int N = 4;
                                    int n = 8;

                                    // Not exactly sure what the intent is here, but it seems to be drawing
                                    // blue circles extending the triangle grid lines.  Interesting.
                                    mg3d.setColor(new java.awt.Color(0,0,255)); // blue
                                    FORI (iii, 3)
                                    {
                                        double p0[] = ppp[iii];
                                        double p1[] = ppp[(iii+1)%3];
                                        double p2[] = ppp[(iii+2)%3];
                                        FORI (I, N)
                                        {
                                            double t0 = (double)I/(double)N;
                                            double t1 = (1.-t0)/2.;
                                            double t2 = (1.-t0)/2.;
                                            double midpoint[] = sbary(p0, p1,t1, p2,t2);
                                            double point1[] = sbary(p0, p1,1.-t0, p2, 0.);
                                            double point2[] = sbary(p0, p1,0., p2, 1.-t0);
                                            double normal[] = VecMath.normalize(VecMath.vxv3(VecMath.vmv(midpoint,point1),VecMath.vmv(point2,midpoint)));
                                            double offset = VecMath.dot(normal, midpoint);
                                            double r = Math.sqrt(1.-SQR(offset));
                                            double basis[/*3*/][/*3*/] = {normal,new double[3], new double[3]};
                                            VecMath.extendAndOrthogonalize(1,3,basis,basis);
                                            double from[] = new double[3];
                                            double to[] = new double[3];
                                            double circleCenter[] = VecMath.vxs(normal, offset);
                                            for (int i = 0; i < 360; ++i)
                                            {
                                                double ang0 = (i+0.)/360*(2*Math.PI);
                                                double ang1 = (i+1.)/360*(2*Math.PI);
                                                VecMath.vpsxvpsxv(from, circleCenter, r*Math.cos(ang0), basis[1], r*Math.sin(ang0), basis[2]);
                                                VecMath.vpsxvpsxv(to, circleCenter, r*Math.cos(ang1), basis[1], r*Math.sin(ang1), basis[2]);
                                                mg3d.drawLine(from[0],from[1],from[2]-wrapSphereRadius,
                                                            to[0],to[1],to[2]-wrapSphereRadius,
                                                            antiAliasingFlag);
                                            }


                                            if (false)
                                            {
                                                mg3d.drawLine(midpoint[0],midpoint[1],midpoint[2]-wrapSphereRadius,
                                                            point1[0],point1[1],point1[2]-wrapSphereRadius,
                                                            antiAliasingFlag);
                                                mg3d.drawLine(midpoint[0],midpoint[1],midpoint[2]-wrapSphereRadius,
                                                            point2[0],point2[1],point2[2]-wrapSphereRadius,
                                                            antiAliasingFlag);
                                            }
                                        }
                                    }
                                    mg3d.setColor(java.awt.Color.WHITE);
                                    FORI (iii, 3)
                                    {
                                        double p0[] = ppp[iii];
                                        double p1[] = ppp[(iii+1)%3];
                                        double p2[] = ppp[(iii+2)%3];
                                        FORI (I, N+1)
                                        FORI (J, I+1)
                                        {
                                            double p[] = sbary(p0,
                                                               p1, (double)(N-I)/(double)N,
                                                               p2, (double)J/(double)N);
                                            mg3d.drawPoint(p[0],
                                                         p[1],
                                                         p[2] - wrapSphereRadius,
                                                         2);
                                        }
                                        FORI (I, N+1)
                                        FORI (j, n*I+1)
                                        {
                                            double p[] = sbary(p0,
                                                               p1, (double)(N-I)/(double)N,
                                                               p2, (double)j/(double)n/(double)N);
                                            mg3d.drawPoint(p[0],
                                                         p[1],
                                                         p[2] - wrapSphereRadius,
                                                         1);
                                        }

                                    }


#ifdef NOTYET
                                    // draw three circles that will intersect in a point, hopefully.
                                    // TODO: what was I thinking?
                                    //      - point that equalizes the three areas?
                                    //      - intersection of the three "altitudes"?
                                    double Area = sphericalTriangleArea(p0,p1,p2);
                                    FORI (iii, 3)
                                    {
                                        double p0[] = ppp[iii];
                                        double p1[] = ppp[(iii+1)%3];
                                        double p2[] = ppp[(iii+2)%3];
                                        double t0 = 1/3.;
                                        double t1 = 1/3.;
                                        double t2 = 1/3.;
                                        double area0 = t0*Area;
                                        double area1 = t1*Area;
                                        double area2 = t2*Area;
                                        double point1[] = VecMath.vxs(p1, -1.);
                                        double point2[] = VecMath.vxs(p1, -2.);

                                        // point0 will be on the perpendicular bisector of p1p2, with area area0
                                        // area of a right spherical triangle
                                        // with legs alpha,beta is:


                                        double point3[] = ???
                                    }
#endif // NOTYET
                                }
                            }
                            if (true) continue;
                        }
#endif // 0, or 1

                        if (showPrimalEdgesFlag.get())
                        {
                            boolean showFlatPrimalEdgesFlagValue = showFlatPrimalEdgesFlag.get();
                            FORIDOWN (iWholeEdge, edges.size()/2)
                            {
                                CHECK_EQ(edgeFacings[iWholeEdge*2], edgeFacings[iWholeEdge*2+1]);
                                if (edgeFacings[iWholeEdge*2] == passFacing)
                                {
                                    Mesh.Edge edge = edges.get(iWholeEdge*2);

                                    if (!showFlatPrimalEdgesFlagValue || !showInsideOutDualVertsFlagValue)
                                    {
                                        Mesh.Edge dualEdge = dualEdges.get(iWholeEdge*2);
                                        Mesh.Vertex vert0 = dualEdge.initialVertex();
                                        Mesh.Vertex vert1 = dualEdge.finalVertex();
                                        if (vert0 != null && vert1 != null)
                                        {
                                            double v0[] = dualVertCoordsHomoNormalized[vert0.myIndex()];
                                            double v1[] = dualVertCoordsHomoNormalized[vert1.myIndex()];

                                            if (!showFlatPrimalEdgesFlagValue)
                                            {
                                                // Is it flat?  It's flat if the two dual verts
                                                // are very close together.
                                                // This works even for a triangular dihedron,
                                                // since in that case we negated the whole homogeneous coords of one of them.
                                                // TODO REGARDING NEGATIVE WEIGHTS: except I'm going to stop doing that I think?

                                                //double flatThreshold = 1e-6; // was too coarse, e.g. "convex noise with 225 points" tended to show isolated verts
                                                double flatThreshold = 1e-9;

                                                if (VecMath.distsqrd(v0,v1) < SQR(flatThreshold))
                                                {
                                                    /*
                                                    System.out.println("flat, not showing:");
                                                    PRINTVEC(v0);
                                                    PRINTVEC(v1);
                                                    PRINT(VecMath.distsqrd(v0,v1));
                                                    */
                                                    continue;
                                                }
                                            }
                                            if (!showInsideOutDualVertsFlagValue)
                                            {
                                                if (v0[3] < 0. && v1[3] < 0.)
                                                    continue;
                                            }
                                        }
                                    }

                                    double v0[] = vertCoordsHomo[edge.initialVertex().myIndex()];
                                    double v1[] = vertCoordsHomo[edge.finalVertex().myIndex()];
                                    // Difficult case: if drawing a line between front world to back
                                    // world, and the two points are the same, then there's no way
                                    // for mg3d to figure out the direction.
                                    // In that case, fudge the negative-world vertex
                                    // so that there will be a direction.
                                    if (v1[0] == -v0[0]
                                     && v1[1] == -v0[1]
                                     && v1[2] == -v0[2]
                                     && v1[3] == -v0[3])
                                    {
                                        double[] direction = edge.direction;
                                        if (direction != null)
                                        {
                                            //OUT("pass "+_iFacingPass+":"+passFacing+": DRAWING DIFFICULT LINE FROM v0="+Arrays.toStringCompact(v0)+" to v1="+Arrays.toStringCompact(v1));
                                            //PRINT(edge);
                                            //PRINTARRAY(edge.direction);
                                            if (v1[3] < 0.)
                                                mg3d.drawLine(v0[0],v0[1],v0[2],v0[3],
                                                              v1[0]-direction[0]*v1[3],
                                                              v1[1]-direction[1]*v1[3],
                                                              v1[2]-direction[2]*v1[3],
                                                              v1[3],
                                                              antiAliasingFlag);
                                            else
                                                mg3d.drawLine(v0[0]+direction[0]*v0[3],
                                                              v0[1]+direction[1]*v0[3],
                                                              v0[2]+direction[2]*v0[3],
                                                              v0[3],
                                                              v1[0],v1[1],v1[2],v1[3],
                                                              antiAliasingFlag);
                                        }
                                    }
                                    else
                                    {
                                        mg3d.drawLine(v0[0],v0[1],v0[2],v0[3],
                                                      v1[0],v1[1],v1[2],v1[3],
                                                      antiAliasingFlag);
                                    }

                                    whichPrimalEdgesGotDrawn[iWholeEdge*2+0] = true;
                                    whichPrimalEdgesGotDrawn[iWholeEdge*2+1] = true;
                                }
                            }
                        }
                    } // if showing primal verts or edges or both


                    if (showDualVertsFlag.get() || showDualEdgesFlag.get())
                    {
                        //
                        // Draw dual edges, in chosen colors
                        //

                        //java.awt.Color darkBlue = new java.awt.Color(0.f,0.f,1/4.f);
                        java.awt.Color darkBlue = new java.awt.Color(0.f,0.f,1/2.f);
                        //java.awt.Color darkBlue = new java.awt.Color(0.f,0.f,3/4.f);
                        //java.awt.Color darkBlue = new java.awt.Color(0.f,0.f,7/8.f);
                        java.awt.Color darkGray = new java.awt.Color(1/4.f,1/4.f,1/4.f);


                        if (showNetFlagValue)
                        {
                            //
                            // showing net-- different color scheme,
                            // and draw the being-dragged net edge if any
                            //
                            FORIDOWN(iEdge, mesh.edges.size())
                            {
                                if (dualEdgeIsOffBalanceCut[iEdge])
                                {
                                    dualEdgeColors[iEdge] = java.awt.Color.RED;
                                }
                                else if (theNet.getEdgeStatus(iEdge) == Net.CUT)
                                {
                                    dualEdgeColors[iEdge] = java.awt.Color.GREEN;
                                }
                                else if (theNet.getEdgeStatus(iEdge) == Net.FOLD)
                                {
                                    dualEdgeColors[iEdge] = darkBlue;
                                }
                                else
                                {
                                    dualEdgeColors[iEdge] = darkGray;
                                }
                            }

                            if (beingDraggedNetEdgeIndex != -1)
                            {
                                boolean itsACut = (theNet.getEdgeStatus(beingDraggedNetEdgeIndex) == Net.CUT);
                                if (itsACut)
                                {
                                    // Make sure beingDraggedNetEdgeIndex points towards root of cut tree--
                                    // if not, reverse it.
                                    if (dualMesh.getEdge(beingDraggedNetEdgeIndex).initialVertex() == null
                                     || theNet._vertToParentEdgeInd[dualMesh.getEdge(beingDraggedNetEdgeIndex).initialVertex().myIndex()] != beingDraggedNetEdgeIndex)
                                        beingDraggedNetEdgeIndex = _dualMesh.getEdge(beingDraggedNetEdgeIndex).opposite().myIndex();
                                    CHECK_EQ(theNet._vertToParentEdgeInd[dualMesh.getEdge(beingDraggedNetEdgeIndex).initialVertex().myIndex()], beingDraggedNetEdgeIndex);

                                    // set lagoonCenter from null... this will cause it to be drawn down below, after edges
                                    {
                                        Mesh.Edge netEdgeBeingDragged = dualMesh.getEdge(beingDraggedNetEdgeIndex);
                                        Mesh.Vertex initialVertex = netEdgeBeingDragged.initialVertex();

                                        double lagoonMomentAndWeight[] = new double[4]; // zeros
                                        GeomUtils.accumulateMomentAndArea(lagoonMomentAndWeight, momentAndWeightStrictlyBelowEachDualVertex[initialVertex.myIndex()]);
                                        GeomUtils.accumulateMomentAndArea(lagoonMomentAndWeight, initialVertex.momentAndArea);
                                        lagoonCenter = new double[] {
                                            lagoonMomentAndWeight[0] / lagoonMomentAndWeight[3],
                                            lagoonMomentAndWeight[1] / lagoonMomentAndWeight[3],
                                            lagoonMomentAndWeight[2] / SQR(lagoonMomentAndWeight[3]), // not sure whether this part makes sense or not
                                        };
                                    }
                                }

                                int alternatives[] = theNet.findAlternatives(beingDraggedNetEdgeIndex);

                                // add in the original exit itself, to simplify the loop
                                alternatives = Arrays.append(alternatives, beingDraggedNetEdgeIndex);

                                FORI (iAlternative, alternatives.length)
                                {
                                    Mesh.Edge alternativeExit = dualMesh.getEdge(alternatives[iAlternative]);
                                    Mesh.Vertex alternativeExitVertex = alternativeExit.initialVertex();
                                    java.awt.Color color;
                                    if (itsACut)
                                    {
                                        // Dragging a cut: highlight alternative exits--
                                        // cyan for good, magenta for bad.
                                        boolean isGood = LEQ(VecMath.dot(2, alternativeExit.direction,
                                                                            VecMath.vmv(2, lagoonCenter,
                                                                                           new double[]{alternativeExitVertex.x(),
                                                                                                        alternativeExitVertex.y()})), 0., SQR(1e-6)); // CBB: is this too coarse?
                                        color = isGood ? java.awt.Color.CYAN : java.awt.Color.MAGENTA;
                                    }
                                    else
                                    {
                                        // If dragging a fold: just highlight alternative folds
                                        // in whatever color they are in (cut green->cyan, cut red->magenta, self darkBlue->blue)
                                        color = dualEdgeColors[alternativeExit.myIndex()];
                                        color = (alternativeExit.myIndex()==beingDraggedNetEdgeIndex
                                              || alternativeExit.opposite().myIndex()==beingDraggedNetEdgeIndex) ? java.awt.Color.BLUE :
                                                dualEdgeIsOffBalanceCut[alternativeExit.myIndex()] ? java.awt.Color.MAGENTA
                                                                                                   : java.awt.Color.CYAN;
                                    }

                                    dualEdgeColors[alternativeExit.myIndex()] = color;
                                    dualEdgeColors[alternativeExit.opposite().myIndex()] = color;
                                }

                                if (VecMath.normsqrd(beingDraggedNetEdgeDelta) != 0.)
                                {
                                    if (false) // why did I want it so dark??  I'm crazy sometimes.
                                    {
                                        if (dualEdgeColors[beingDraggedNetEdgeIndex] == java.awt.Color.CYAN)
                                        {
                                            //mg3d.setColor(darkGreen);
                                            mg3d.setColor(darkCyan);
                                        }
                                        else if (dualEdgeColors[beingDraggedNetEdgeIndex] == java.awt.Color.MAGENTA)
                                        {
                                            //mg3d.setColor(darkRed);
                                            mg3d.setColor(darkMagenta);
                                        }
                                        else if (dualEdgeColors[beingDraggedNetEdgeIndex] == java.awt.Color.BLUE)
                                        {
                                            mg3d.setColor(darkBlue);
                                        }
                                    }
                                    else
                                    {
                                        mg3d.setColor(dualEdgeColors[beingDraggedNetEdgeIndex]);
                                    }


                                    double from[] = dualEdgeInitialCoords[beingDraggedNetEdgeIndex][0];
                                    double to[] = dualEdgeInitialCoords[dualMesh.getEdge(beingDraggedNetEdgeIndex).opposite().myIndex()][0];
                                    // Not sure whether it makes sense to do the translation in hom space like this,
                                    // or just do the W-divide and translate&render in plain 3-space.
                                    mg3d.drawLine(from[0]+beingDraggedNetEdgeDelta[0]*from[3],
                                                from[1]+beingDraggedNetEdgeDelta[1]*from[3],
                                                from[2],
                                                from[3],
                                                to[0]+beingDraggedNetEdgeDelta[0]*to[3],
                                                to[1]+beingDraggedNetEdgeDelta[1]*to[3],
                                                to[2],
                                                to[3],
                                                antiAliasingFlag);
                                }
                            }
                        }


                        if (showNetFlagValue
                         && showFlattenedNetFlag.get()
                         && localScaleZ != 0.
                         && tilt > Math.PI*.5) // i.e. if xy plane is behind rest of picture
                        {
                            drawFlattenedNet(mg3d, mesh, dualMesh, dualEdgeInitialCoords, nVerts, nEdges, dualEdgeColors);
                        }

                        double backfaceBrightnessValue = backfaceBrightness.get();

                        //
                        // Dual edges.
                        // If showing the cut tree,
                        // we draw the non-cut edges first, then the cut edges--
                        // this makes the tree appear more connected.
                        //
                        if (showDualEdgesFlag.get())
                        {
                            double destPoint[] = new double[3]; // scratch for loop
                            int nPasses = showNetFlagValue ? 2 : 1;
                            FORI (iPass, nPasses)
                            {
                                FORIDOWN (iDualEdge, mesh.edges.size())
                                {
                                    if (nPasses == 2
                                     && (theNet.getEdgeStatus(iDualEdge)==Net.CUT) != (iPass==1))
                                        continue; // when two passes, draw cuts iff iPass==1

                                    if (dualEdgeFacings[iDualEdge] != passFacing)
                                        continue;

                                    java.awt.Color frontColor = dualEdgeColors[iDualEdge];
                                    if (passFacing == MeshUtils.FACING_BACK)
                                    {
                                        // holy moly this is inefficient, probably
                                        int rgb = frontColor.getRGB();
                                        int R = (rgb>>16)&255;
                                        int G = (rgb>>8)&255;
                                        int B = rgb&255;
                                        java.awt.Color backColor = new java.awt.Color((int)(R*backfaceBrightnessValue),
                                                                                      (int)(G*backfaceBrightnessValue),
                                                                                      (int)(B*backfaceBrightnessValue));
                                        mg3d.setColor(backColor);
                                    }
                                    else
                                    {
                                        // CBB: use sideColor and unknownColor here
                                        mg3d.setColor(frontColor);
                                    }


                                    Mesh.Edge dualEdge = dualMesh.getEdge(iDualEdge);
                                    int oDualEdge = dualEdge.opposite().myIndex();

                                    int nParts = showInsideOutDualVertsFlagValue ? 2 : 1;
                                    FORI (iPart, nParts)
                                    {
                                        double from[] = dualEdgeInitialCoords[iDualEdge][iPart];
                                        double to[] = dualEdgeInitialCoords[oDualEdge][iPart];

                                        CHECK_EQ((from==null), (to==null));
                                        if (from==null)
                                            continue; // this part doesn't exist-- edge is wholely on other sheet

                                        mg3d.drawLine(from[0], from[1], from[2], from[3],
                                                    to[0], to[1], to[2], to[3],
                                                    antiAliasingFlag);

                                        if (showNetFlagValue
                                         && pointOutRedNetEdges
                                         && mg3d.getColor() == java.awt.Color.RED)
                                        {
                                            mg3d.drawPoint((to[0]+from[0])*.5,
                                                         (to[1]+from[1])*.5,
                                                         (to[2]+from[2])*.5,
                                                         7);
                                        }
                                    }
                                }
                            }
                        }

                        //
                        // Draw dual verts
                        // (only if NOT showing net flow... they are disruptive to the flow)
                        // XXX where do I check that? I don't see it
                        //
                        FORIDOWN(iDualVert, dualMesh.verts.size())
                        {
                            // if showing flow, don't show regular verts (show only selected ones)
                            if (showNetFlagValue && showNetFlowFlag.get() && dualVertColors[iDualVert] != dualVertSelectionColor)
                                continue;
                            if (!showDualVertsFlag.get() && dualVertColors[iDualVert] != dualVertSelectionColor)
                                continue;

                            Mesh.Vertex dualVert = dualMesh.getVert(iDualVert);

                            if (!showInsideOutDualVertsFlagValue
                             && dualVert.weight < 0.)
                                continue;

                            //System.out.println("    drawing dual vert at "+Arrays.toStringCompact(dualVert));

                            if (dualVertFacings[iDualVert] != passFacing)
                                continue;

                            java.awt.Color frontColor = dualVertColors[iDualVert];
                            if (passFacing == MeshUtils.FACING_BACK)
                            {
                                // holy moly this is inefficient, probably
                                int rgb = frontColor.getRGB();
                                int R = (rgb>>16)&255;
                                int G = (rgb>>8)&255;
                                int B = rgb&255;
                                java.awt.Color backColor = new java.awt.Color((int)(R*backfaceBrightnessValue), (int)(G*backfaceBrightnessValue), (int)(B*backfaceBrightnessValue));
                                mg3d.setColor(backColor);
                            }
                            else
                            {
                                // CBB: use sideColor and unknownColor here
                                mg3d.setColor(frontColor);
                            }

                            double p[] = dualVertCoords[iDualVert];
                            double sign = p[3]<0. ? -1 : 1;
                            mg3d.drawPoint(sign*p[0], sign*p[1], sign*p[2], sign*p[3],
                                         showNetFlagValue ? 2 : 5);
                        }

                        if (showNetFlagValue && showNetFlowFlag.get()
                         && theNet._topSortedVertInds != null) // TODO: can probably remove this check eventually, when I get topsort working even if only forest
                        {
                            //
                            // Draw the flow, i.e. the marching ants.
                            //

                            //
                            // Figure out distance (both 2-norm and infinity-norm) from each vertex
                            // to the root-most one in its tree, in 2 dimensions
                            //
                            double norm2s[] = new double[nDualVerts]; // zeros initially
                            double normInfs[] = new double[nDualVerts]; // zeros initially
                            FORI (iiChild, theNet._topSortedVertInds.length) // roots to leaves
                            {
                                int iChild = theNet._topSortedVertInds[iiChild];
                                if (iChild == nDualVerts)
                                    continue; // it's the infinite vertex, i.e. the root
                                Mesh.Vertex child = dualMesh.getVert(iChild);
                                int parentEdgeInd = theNet._vertToParentEdgeInd[iChild];
                                if (parentEdgeInd != -1)
                                {
                                    Mesh.Edge parentEdge = dualMesh.getEdge(parentEdgeInd);
                                    Mesh.Vertex parent = parentEdge.finalVertex();
                                    if (parent != null)
                                    {
                                        int iParent = parent.myIndex();
                                        double dx = child.x() - parent.x();
                                        double dy = child.y() - parent.y();
                                        norm2s[iChild] = norm2s[iParent] + MyMath.hypot(dx,dy);
                                        normInfs[iChild] = normInfs[iParent] + MAX(dx,dy);
                                    }
                                }
                            }

                            double unitsPerPixel = 1./mg3d.getScaleX(); // scale is uniform

                            int period = 60; // how many redraws to get back to original state, to traverse a step. this controls the speed.  (probably assumes netflow fps=60)
                            double step = 9 * unitsPerPixel;  // this controls the spacing

                            //mg3d.setColor(lightBlue);
                            mg3d.setColor(java.awt.Color.RED); // lava

                            FORI (iChild, nDualVerts)
                            {
                                Mesh.Vertex child = dualMesh.getVert(iChild);
                                int parentEdgeInd = theNet._vertToParentEdgeInd[iChild];
                                if (parentEdgeInd != -1)
                                {
                                    if (!showInsideOutDualVertsFlagValue
                                     && dualEdgeFacings[parentEdgeInd] == MeshUtils.FACING_BACK)
                                    {
                                        //System.out.println("        skipping flow on e"+parentEdgeInd+" from v"+iChild+" to "+(dualMesh.getEdge(parentEdgeInd).finalVertex()!=null ? "v"+dualMesh.getEdge(parentEdgeInd).finalVertex().myIndex() : "null"));
                                        continue;
                                    }

                                    Mesh.Edge parentEdge = dualMesh.getEdge(parentEdgeInd);
                                    Mesh.Vertex parent = parentEdge.finalVertex();
                                    // TODO: combine the following two cases, using edgeInitialCoords instead of doing the ray calculation yet again
                                    if (parent != null)
                                    {
                                        int iParent = parent.myIndex();
                                        // norm2s[parent] rounded up to multiple of step
                                        // TODO: screwy math, it works but could be made simpler probably
                                        double pos0 = Math.ceil(norm2s[iParent]/step)*step; // XXX should subtract some slack before taking ceil
                                        pos0 -= (netFlowIndex % period)/(double)period * step;
                                        if (pos0 < norm2s[iParent]-1e-6)
                                            pos0 += step;

                                        for (double pos = pos0; LEQ(pos, norm2s[iChild], 1e-6); pos += step)
                                        {
                                            double t = (pos-norm2s[iParent])/(norm2s[iChild]-norm2s[iParent]);
                                            double x = LERP(parent.x(), child.x(), t);
                                            double y = LERP(parent.y(), child.y(), t);
                                            double z = LERP(parent.z(), child.z(), t);
                                            mg3d.drawPoint(x, y, z, 3);
                                        }
                                    }
                                    else
                                    {
                                        double rayLength = 1.;
                                        // TODO: screwy math, it works but could be made simpler probably
                                        double pos0 = ((period-netFlowIndex)%period)/(double)period * step;
                                        while (GT(pos0, 0, 1e-6))
                                            pos0 -= step;
                                        for (double pos = pos0; GEQ(pos, -rayLength, 1e-6); pos -= step)
                                        {
                                            double x = child.x() - pos * parentEdge.direction[0];
                                            double y = child.y() - pos * parentEdge.direction[1];
                                            double z = child.z() - pos * parentEdge.direction[2];
                                            mg3d.drawPoint(x, y, z, 3);
                                        }
                                    }
                                }
                            }

                            netFlowIndex++;
                        }

                        //
                        // Draw center of curvature if we recorded one
                        //
                        if (avg != null)
                        {
                            mg3d.setColor(dualVertSelectionColor);
                            mg3d.drawPoint(avg[0],
                                           avg[1],
                                           avg[2],
                                           7);
                        }
                        // And centroid
                        if (centroid != null) {
                            mg3d.setColor(java.awt.Color.CYAN);
                            mg3d.drawPoint(centroid[0],
                                           centroid[1],
                                           0.,
                                           7);
                        }
                        // And orthocenter
                        if (orthocenter != null) {
                            mg3d.setColor(java.awt.Color.MAGENTA);
                            mg3d.drawPoint(orthocenter[0],
                                           orthocenter[1],
                                           0.,
                                           7);
                        }
                        // And euler line, if we have both centroid and orthocenter.
                        // avg (center of curvature) will be on this line if all heights are 0.
                        if (centroid != null && orthocenter != null)
                        {
                            mg3d.setColor(java.awt.Color.CYAN);
                            // Just do simple 2d math
                            double lengthMultiplier = 10.;
                            double x0 = LERP(centroid[0], orthocenter[0], lengthMultiplier);
                            double y0 = LERP(centroid[1], orthocenter[1], lengthMultiplier);
                            double x1 = LERP(orthocenter[0], centroid[0], lengthMultiplier);
                            double y1 = LERP(orthocenter[1], centroid[1], lengthMultiplier);
                            mg3d.drawLine(x0,y0,0.,
                                          x1,y1,0.,
                                          antiAliasingFlag);
                        }


                        if (lagoonCenter != null)
                        {
                            mg3d.setColor(dualVertSelectionColor);
                            mg3d.drawPoint(lagoonCenter[0],
                                           lagoonCenter[1],
                                           lagoonCenter[2],
                                           3);
                        }




                        //
                        // Now try marking the sharpest dihedral dual edge
                        // out of each dual vertex.
                        // I.e. the dual edge opposite the largest dual angle.
                        // I.e. the dual edge corresponding to the longest of the three primal
                        // triangle sides.
                        // We draw it 3 times, to make sure we get the same logic from each direction. If there are ties, it will get drawn in each place I think.
                        //
                        if (arrowsTowardsSharpestDihedralsFlag)
                        {
                            if (showNetFlagValue)
                                mg3d.setColor(dualColor);
                            else
                                mg3d.setColor(dualVertSelectionColor);
                            FORIDOWN (iEdge, mesh.edges.size())
                            {
                                Mesh.Vertex triCenterDualVert = (dualMesh.getEdge(iEdge)).finalVertex();
                                if (triCenterDualVert == null)
                                    continue; // primary face was not a triangle, or inside out
                                if (triCenterDualVert.weight < 0.)
                                    continue; // primal face is on underside (if calculated underside), i.e. inside out

                                Mesh.Edge e0 = mesh.getEdge(iEdge);
                                Mesh.Edge e1 = e0.next();
                                Mesh.Edge e2 = e1.next();
                                CHECK_EQ(e2.next(), e0);
                                Mesh.Vertex triVerts[] = {e0.initialVertex(),
                                                          e1.initialVertex(),
                                                          e2.initialVertex()};
                                double sideLengths[] = new double[3];
                                FORI (i, 3)
                                    sideLengths[i] = Math.sqrt(SQR(triVerts[i].x()-triVerts[(i+1)%3].x())
                                                             + SQR(triVerts[i].y()-triVerts[(i+1)%3].y()));
                                int bestSide = MAXI3(sideLengths[0], sideLengths[1], sideLengths[2]);

                                double v0[] = {triVerts[bestSide].x(), triVerts[bestSide].y()};
                                double v1[] = {triVerts[(bestSide+1)%3].x(), triVerts[(bestSide+1)%3].y()};
                                double toEdgeVec[] = VecMath.xv2(
                                                         VecMath.vmv(v0, v1));
                                VecMath.normalize(toEdgeVec, toEdgeVec);
                                // XXX be smarter!  maybe 1/3 of the way along the edge, or something
                                double whereToDrawMark[] = {
                                    triCenterDualVert.x() + .02 * toEdgeVec[0],
                                    triCenterDualVert.y() + .02 * toEdgeVec[1],

                                    //triCenterDualVert.h() + .02 * toEdgeVec[2],  // XXX TODO: out of bounds
                                    triCenterDualVert.h(),  // XXX I have no idea what I'm doing

                                };
                                //VecMath.vpsxv(whereToDrawMark, whereToDrawMark, .004, VecMath.random(2));
                                mg3d.drawPoint(whereToDrawMark[0],
                                             whereToDrawMark[1],
                                             whereToDrawMark[2],
                                             5);
                            }
                        } // arrowsTowardsSharpestDihedralsFlag
                        if (arrowsTowardsShortestEdgesFlag)
                        {
                            // XXX we do this in 3 ways, possibly getting different answer each time, in case of a tie... should fix that
                            mg3d.setColor(java.awt.Color.CYAN);
                            FORIDOWN (iEdge, mesh.edges.size())
                            {
                                Mesh.Vertex triCenterDualVert = (dualMesh.getEdge(iEdge)).finalVertex();
                                if (triCenterDualVert == null)
                                    continue; // primary face was not a triangle, or inside out
                                if (triCenterDualVert.weight < 0.)
                                    continue; // primal face is on underside (if calculated underside), i.e. inside out

                                Mesh.Edge e0 = mesh.getEdge(iEdge);
                                Mesh.Edge e1 = e0.next();
                                Mesh.Edge e2 = e1.next();
                                CHECK_EQ(e2.next(), e0);
                                Mesh.Vertex triVerts[] = {e0.initialVertex(),
                                                          e1.initialVertex(),
                                                          e2.initialVertex()};
                                double triCenterDualVertCoords[] = {triCenterDualVert.x(), triCenterDualVert.y()};
                                Mesh.Vertex neighborDualVerts[] = {
                                    (dualMesh.getEdge(e0.myIndex())).initialVertex(),
                                    (dualMesh.getEdge(e1.myIndex())).initialVertex(),
                                    (dualMesh.getEdge(e2.myIndex())).initialVertex(),
                                };

                                double dualSideLengths[] = new double[3];
                                FORI (i, 3)
                                {
                                    if (neighborDualVerts[i] == null)
                                        dualSideLengths[i] = Double.POSITIVE_INFINITY;
                                    else
                                        dualSideLengths[i] = VecMath.dist(triCenterDualVertCoords,
                                                                          new double[]{neighborDualVerts[i].x(),
                                                                                       neighborDualVerts[i].y()});
                                }
                                int bestSide = MINI3(dualSideLengths[0], dualSideLengths[1], dualSideLengths[2]);
                                double v0[] = {triVerts[bestSide].x(), triVerts[bestSide].y()};
                                double v1[] = {triVerts[(bestSide+1)%3].x(), triVerts[(bestSide+1)%3].y()};
                                double toEdgeVec[] = VecMath.xv2(
                                                         VecMath.vmv(v0, v1));
                                VecMath.normalize(toEdgeVec, toEdgeVec);
                                // XXX be smarter!  maybe 1/3 of the way along the edge, or somethin
                                double whereToDrawMark[] = {
                                    triCenterDualVert.x() + .02 * toEdgeVec[0],
                                    triCenterDualVert.y() + .02 * toEdgeVec[1],
                                    triCenterDualVert.h() + .02 * toEdgeVec[2],  // XXX TODO: out of bounds
                                };
                                //VecMath.vpsxv(whereToDrawMark, whereToDrawMark, .005, VecMath.random(2));
                                mg3d.drawPoint(whereToDrawMark[0],
                                             whereToDrawMark[1],
                                             whereToDrawMark[2],
                                             5);

                            }
                        } // arrowsTowardsShortestEdgesFlag


                        if (showNetFlagValue
                         && showFlattenedNetFlag.get()
                         && localScaleZ != 0.
                         && tilt <= Math.PI*.5) // i.e. if xy plane is in front of rest of picture
                        {
                            drawFlattenedNet(mg3d, mesh, dualMesh, dualEdgeInitialCoords, nVerts, nEdges, dualEdgeColors);
                        }

                    } // if (drawDualDiagramFlag)

                } // for _iFacingPass

                if (drawDualDiagramFlag && showNetFlagValue)
                {
                    // Draw stuff to help algorithm visualization, AFTER the main diagram (iPass=1).
                    int thisPass = 1;
                    if (sweepVisualizationGraphics != null)
                    {
                        int nGraphics = sweepVisualizationGraphics.size();
                        FORI (iGraphic, nGraphics)
                        {
                            MyAlgorithmMaybe.Graphic graphic = sweepVisualizationGraphics.get(iGraphic);
                            if (graphic.iPass == thisPass)
                            {
                                mg3d.setColor(graphic.color);
                                double graphicVerts[][] = graphic.verts;
                                if (graphicVerts.length == 2)
                                {
                                    // a segment
                                    mg3d.drawLine(graphicVerts[0][0],
                                                  graphicVerts[0][1],
                                                  graphicVerts[1][0],
                                                  graphicVerts[1][1],
                                                  antiAliasingFlag);
                                }
                                else
                                {
                                    CHECK(false); // not sure what this is supposed to be
                                }
                            }
                        }
                    }
                }


                if (primalDualVisFlag.get()
                 && primalDualVisAngles != null
                 && primalDualVisPrimalVertInds != null
                 && primalDualVisDualVertInds != null)
                {
                    if (prevP != null)
                    {
                        // Highlight closest feature

                        // not sure prevP is the right thing to use when rotated but whatever
                        double ang = Math.atan2(prevP[1], prevP[0]);

                        // locate ang among primalDualVisAngles.
                        // could do binary search, but whatever.
                        int n = primalDualVisAngles.length;
                        while (ang > primalDualVisAngles[n-1])
                            ang -= 2*Math.PI;
                        while (ang < primalDualVisAngles[0])
                            ang += 2*Math.PI;
                        int i0 = 0;
                        while (i0+1 < n && primalDualVisAngles[i0+1] <= ang)
                            i0++;
                        int i1 = (i0+1) % n;
                        double ang0 = primalDualVisAngles[i0];
                        double ang1 = primalDualVisAngles[i1];
                        if (ang1 < ang0)
                            ang1 += 2*Math.PI; // wrap around
                        double frac = (ang-ang0)/(ang1-ang0);
                        try {
                            Mesh.Vertex p0vert = mesh.getVert(primalDualVisPrimalVertInds[i0]);
                            Mesh.Vertex p1vert = mesh.getVert(primalDualVisPrimalVertInds[i1]);
                            Mesh.Vertex d0vert = dualMesh.getVert(primalDualVisDualVertInds[i0]);
                            Mesh.Vertex d1vert = dualMesh.getVert(primalDualVisDualVertInds[i1]);
                            double p0[] = {p0vert.x(), p0vert.y(), p0vert.z()};
                            double p1[] = {p1vert.x(), p1vert.y(), p1vert.z()};
                            double d0[] = {d0vert.x(), d0vert.y(), d0vert.z()};
                            double d1[] = {d1vert.x(), d1vert.y(), d1vert.z()};
                            double p[] = VecMath.lerp(p0,p1,frac);
                            double d[] = VecMath.lerp(d0,d1,frac);

                            mg3d.setColor(java.awt.Color.WHITE);
                            mg3d.drawPoint(p[0], p[1], p[2], 7);
                            mg3d.setColor(lightBlue);
                            mg3d.drawPoint(d[0], d[1], d[2], 7);
                        } catch (IndexOutOfBoundsException e) {
                            System.out.println("Oops! primal-dual visualization apparently no longer valid, throwing it away");
                            primalDualVisAngles = null;
                            primalDualVisPrimalVertInds = null;
                            primalDualVisDualVertInds = null;
                        }
                    }

                    if (true)
                    {
                        // Show tri strip of whole thing
                        mg3d.setColor(new java.awt.Color(255,192,192)); // pink
                        FORI (i, primalDualVisAngles.length)
                        {
                            Mesh.Vertex p = mesh.getVert(primalDualVisPrimalVertInds[i]);
                            Mesh.Vertex d = dualMesh.getVert(primalDualVisDualVertInds[i]);
                            mg3d.drawLine(p.X(), p.Y(), p.Z(), p.W(),
                                        d.X(), d.Y(), d.Z(), d.W(),
                                        antiAliasingFlag);
                        }
                    }
                }

                // Draw primal-dual intersection.
                if (showPrimalDualIntersectionFlag.get())
                {
                    final int verboseLevel = 0;
                    Mesh[/*2*/] primalDualConvexHullAndIntersection = MeshUtils.MakePrimalDualConvexHullAndIntersection(mesh, dualMesh);
                    Mesh convexHullMesh = primalDualConvexHullAndIntersection[0];
                    Mesh intersectionMesh = primalDualConvexHullAndIntersection[1];
                    CHECK_EQ(convexHullMesh.edges.size(), intersectionMesh.edges.size());

                    Mesh[] meshesToDraw = {
                      //convexHullMesh,
                      intersectionMesh,
                    };

                    for (int iMeshToDraw = 0; iMeshToDraw < meshesToDraw.length; ++iMeshToDraw)
                    {
                        Mesh meshToDraw = meshesToDraw[iMeshToDraw];
                        FORIDOWN (iEdge, meshToDraw.edges.size())
                        {
                          {
                            // Decide whether we really are interested in this intersection edge.
                            // We're interested iff one of its incident faces is on the primal and the other is on the dual.
                            // I.e. we're interested if the corresponding edge on the convex hull joins a vertex on the primal with a vertex on the dual.
                            Mesh.Edge convexHullEdge = convexHullMesh.getEdge(iEdge);
                            Mesh.Vertex v0 = convexHullEdge.initialVertex();
                            Mesh.Vertex v1 = convexHullEdge.finalVertex();
                            CHECK(v0 != null && v1 != null);

                            if (v0.myIndex() >= mesh.verts.size() + dualMesh.verts.size()
                             || v1.myIndex() >= mesh.verts.size() + dualMesh.verts.size()) {
                              // It involves one of the synthetic verts that was added along a ray of dual--
                              // definitely not interested, unless debugging.
                              //continue;
                            }

                            // TODO: can we make this general so that we can share this code with the minkowski thing too?
                            boolean v0IsOnDual = v0.myIndex() >= mesh.verts.size();
                            boolean v1IsOnDual = v1.myIndex() >= mesh.verts.size();
                            boolean isInteresting = (v0IsOnDual != v1IsOnDual);

                            if (isInteresting) {
                              mg3d.setColor(java.awt.Color.RED);  // ?
                            } else {
                              mg3d.setColor(java.awt.Color.RED.darker().darker());  // ?
                            }
                          }

                          Mesh.Edge edge = meshToDraw.getEdge(iEdge);
                          CHECK_EQ(edge.myIndex(), iEdge);
                          if (edge.opposite().myIndex() < iEdge) continue;  // this edge isn't the canonical one
                          Mesh.Vertex v0 = edge.initialVertex();
                          Mesh.Vertex v1 = edge.finalVertex();
                          CHECK(v0 != null || v1 != null);  // wouldn't be able to locate it otherwise
                          double[] from = v0!=null ? new double[]{v0.X(), v0.Y(), v0.Z(), v0.W()}
                                          // TODO: do math in homo coords, from v1coords, not v1.x(),y(),z()
                                          : new double[]{v1.x() - edge.direction[0],
                                                         v1.y() - edge.direction[1],
                                                         v1.z() - edge.direction[2],
                                                         1.};
                          double[] to = v1!=null ? new double[]{v1.X(), v1.Y(), v1.Z(), v1.W()}
                                                 // TODO: do math in homo coords, from v1coords, not v1.x(),y(),z()
                                                 : new double[]{v0.x() + edge.direction[0],
                                                                v0.y() + edge.direction[1],
                                                                v0.z() + edge.direction[2],
                                                                1.};
                          mg3d.drawLine(from[0], from[1], from[2], from[3],
                                        to[0], to[1], to[2], to[3],
                                        antiAliasingFlag);
                        }
                        FORIDOWN (iVert, meshToDraw.verts.size())
                        {
                            Mesh.Vertex v = meshToDraw.getVert(iVert);
                            mg3d.drawPoint(v.X(), v.Y(), v.Z(), v.W(), 5);
                        }
                    }
                }

                // Draw minkowski average.
                if (showPrimalDualMinkowskiAverageFlag.get())
                {
                    final int verboseLevel = 0;
                    Mesh[] minkowskiAverageAndDual = MeshUtils.MakePrimalDualMinkowskiAverageAndDual(mesh, getDualMesh());
                    if (minkowskiAverageAndDual != null) {
                        Mesh minkowskiAverage = minkowskiAverageAndDual[0];
                        Mesh minkowskiAverageDual = minkowskiAverageAndDual[1];
                        Mesh[] meshesToDraw = {
                          //minkowskiAverage,
                          minkowskiAverageDual,
                        };

                        for (int iMeshToDraw = 0; iMeshToDraw < meshesToDraw.length; ++iMeshToDraw)
                        {
                            Mesh meshToDraw = meshesToDraw[iMeshToDraw];
                            FORIDOWN (iEdge, meshToDraw.edges.size())
                            {
                              Mesh.Edge edge = meshToDraw.getEdge(iEdge);
                              CHECK_EQ(edge.myIndex(), iEdge);
                              if (edge.opposite().myIndex() < iEdge) continue;  // this edge isn't the canonical one
                              Mesh.Vertex v0 = edge.initialVertex();
                              Mesh.Vertex v1 = edge.finalVertex();
                              CHECK(v0 != null || v1 != null);  // wouldn't be able to locate it otherwise
                              double[] from = v0!=null ? new double[]{v0.X(), v0.Y(), v0.Z(), v0.W()}
                                              // TODO: do math in homo coords, from v1coords, not v1.x(),y(),z()
                                              : new double[]{v1.x() - edge.direction[0],
                                                             v1.y() - edge.direction[1],
                                                             v1.z() - edge.direction[2],
                                                             1.};
                              double[] to = v1!=null ? new double[]{v1.X(), v1.Y(), v1.Z(), v1.W()}
                                                     // TODO: do math in homo coords, from v1coords, not v1.x(),y(),z()
                                                     : new double[]{v0.x() + edge.direction[0],
                                                                    v0.y() + edge.direction[1],
                                                                    v0.z() + edge.direction[2],
                                                                    1.};
                              mg3d.drawLine(from[0], from[1], from[2], from[3],
                                            to[0], to[1], to[2], to[3],
                                            antiAliasingFlag);
                            }
                            FORIDOWN (iVert, meshToDraw.verts.size())
                            {
                                Mesh.Vertex v = meshToDraw.getVert(iVert);
                                mg3d.drawPoint(v.X(), v.Y(), v.Z(), v.W(), 5);
                            }
                        }
                    }
                }

                //
                // Draw topological region.
                // Currently drawing this close to last, but should think about when to do it.
                //
                if (showTopologicalRegionWhenDraggingVertexFlag.get())
                {
                    final int verboseLevel = 0;
                    CHECK_LT(mostRecentlyBeingDraggedVertIndex, mesh.verts.size());
                    Mesh.Vertex v0 = beingDraggedVertIndex==-1 ? null : mesh.getVert(beingDraggedVertIndex);

                    if (false) { // set to true for debugging
                      // CBB: need additional debugging mode where it shows without v0 *and* with v0.  Hmm.
                      System.out.println("  (including being-dragged vert, for debugging)");
                      v0 = null;
                    }
                    java.util.ArrayList<double[][]> regionBoundaryArcSpecs = figureOutAllTopologicalRegions(mesh, dualMesh, v0);
                    if (regionBoundaryArcSpecs != null) {

                      IntArrayList counts = null;
                      if (true) {
                        // We're actually doing circles, not arcs.
                        // Combine duplicate circles into thicker circles, where thickness is multiplicity.
                        java.util.ArrayList<double[][]> merged = new java.util.ArrayList<double[][]>();
                        counts = new IntArrayList();
                        FuzzyPointHashTable<Integer> fuzzyTable = new FuzzyPointHashTable<Integer>(1e-12, 1e-10, 1/1024.);
                        int nArcs = regionBoundaryArcSpecs.size();
                        FORI (iArc, nArcs) {
                          double[/*2*/][] topoRegion = regionBoundaryArcSpecs.get(iArc);
                          double[/*4*/] triMomentAndArea = topoRegion[0];
                          double xa = triMomentAndArea[0];
                          double ya = triMomentAndArea[1];
                          double haa = triMomentAndArea[2];
                          double a = triMomentAndArea[3];
                          double x = xa/a;
                          double y = ya/a;
                          double h = haa/SQR(a);
                          double[] key = Arrays.append(VecMath.normalize(new double[]{xa,ya,a}),
                                                       haa/SQR(a)); // this part is unfortunate, I think it will actually be infinite, but that's unavoidable.  not sure how that will play into merging
                          Integer index = fuzzyTable.get(key);
                          if (index == null) {
                            index = Integer.valueOf(merged.size());
                            fuzzyTable.put(key, index);
                            merged.add(topoRegion);
                            counts.add(1);
                          } else {
                            counts.set(index.intValue(), counts.get(index.intValue())+1);
                          }
                        }
                        regionBoundaryArcSpecs = merged;
                      }

                      int nArcs = regionBoundaryArcSpecs.size();
                      if (verboseLevel >= 1) System.out.println("  drawing region of "+nArcs+" arcs");

                      FORI (iArc, nArcs) {
                        if (verboseLevel >= 2) System.out.println("      arc "+iArc+"/"+nArcs+":");
                        int count = counts.get(iArc);
                        double[/*2*/][] topoRegion = regionBoundaryArcSpecs.get(iArc);
                        double[/*4*/] triMomentAndArea = topoRegion[0];
                        if (verboseLevel >= 2) System.out.println("          triMomentAndArea = "+Arrays.toStringCompact(triMomentAndArea));
                        double xa = triMomentAndArea[0];
                        double ya = triMomentAndArea[1];
                        double haa = triMomentAndArea[2];
                        double a = triMomentAndArea[3];
                        if (verboseLevel >= 2) System.out.println("          h = "+haa/(a*a));

                        if (v0 != null)
                        {
                            // Adjust for v0's height, by pretending v0 is at 0 and everyone else got adjusted by minus its original height.
                            // CBB: this is disorienting; it seems like a bug because the picture changes when I release
                            // the vert being dragged.   But it makes sense, since, when not dragging,
                            // the only sensible thing to draw is the circles for a vertex at height 0.
                            haa += v0.h()*a*a;
                        }
                        if (haa <= 0) continue;

                        // radius is sqrt(h*2), so...
                        double curvature = a/Math.sqrt(haa*2); // XXX wait, what? can't haa be zero?  right, when radius is 0.  hmm.  but wait, can't h be zero even when a isn't?  yes, e.g. when all three face planes are pushed in so far that the vertex is below 0; then a new vertex can't even interact with it at all
                        if (verboseLevel >= 2) System.out.println("          curvature = "+curvature);


                        // What's the focus?
                        // Start with an arbitrary finite preFocus
                        // and expand outwards from center by radius - (dist from center to preFocus),
                        // except we must never express those explicitly since they may be infinite.

                        // Bleah!  Haven't figured out robust math that degrades gracefully when a goes to 0, so make that a special case.
                        double focusX;
                        double focusY;
                        double focusAngleRadians;
                        //if (ABS(a) < .1)  // works fine when all heights are zero (in fact when the arbitrarily chosen primal vert's height is zero), but doesn't degrade gracefully
                        if (a == 0)
                        {
                          // Fortunately, when a=0,
                          // perturbations in the contributing heights don't move the cline (generalized circle),
                          // so that means the cline passes through the primal vertex, so we can use that as the focus.
                          // CBB: this doesn't degrade gracefully, though.  It would be good to get something that degrades gracefully.
                          // CBB: hmm, I don't really know how to exercise this case
                          double[] primalVertCoords = topoRegion[1];
                          if (verboseLevel >= 2) System.out.println("          HEY!  Doing the a=0 case");
                          if (verboseLevel >= 2) System.out.println("          primalVertCoords = "+Arrays.toStringCompact(primalVertCoords));
                          focusX = primalVertCoords[0]/primalVertCoords[3];
                          focusY = primalVertCoords[1]/primalVertCoords[3];
                          focusAngleRadians = Math.atan2(focusY*a-ya,
                                                         focusX*a-xa);
                        }
                        else
                        {
                          double preFocusX = 0.;
                          double preFocusY = 0.;
                          focusAngleRadians = Math.atan2(preFocusX*a-ya,
                                                         preFocusY*a-xa);
                          if (verboseLevel >= 2) System.out.println("          focusAngleRadians = "+focusAngleRadians);

                          //double radius = 1./curvature;
                          //if (verboseLevel >= 2) System.out.println("          radius = "+radius);
                          //double centerX = xa/a;
                          //double centerY = ya/a;
                          //double expansion = radius - Math.hypot(centerX-preFocusX, centerY-preFocusY);
                          //double expansion = 1./(a/Math.sqrt(haa*2)) - Math.sqrt(SQR(centerX-preFocusX) + SQR(centerY-preFocusY));
                          //double expansion = Math.sqrt(haa*2)/a - Math.sqrt(SQR(xa/a-preFocusX) + SQR(ya/a-preFocusY));
                          double expansion = (Math.sqrt(haa*2) - Math.sqrt(SQR(xa-a*preFocusX) + SQR(ya-a*preFocusY))) / a;
                          // TODO: that wasn't robust.  Need something that works even if a is zero or close to it, i.e. center is at infinity and radius is infinite!
                          if (verboseLevel >= 2) System.out.println("          expansion = "+expansion);

                          focusX = preFocusX + expansion * Math.cos(focusAngleRadians);
                          focusY = preFocusY + expansion * Math.sin(focusAngleRadians);

                          if (false) {
                            mg3d.setColor(new java.awt.Color(255,0,0)); // red
                            mg3d.drawPoint(focusX, focusY, 0., 5);
                            //mg3d.setColor(new java.awt.Color(0,255,0)); // green
                            //mg3d.drawPoint(centerX, centerY, 0., 5);
                            mg3d.setColor(new java.awt.Color(0,255,255)); // cyan
                            mg3d.drawPoint(preFocusX, preFocusY, 0., 5);
                          }
                        }
                        if (verboseLevel >= 2) System.out.println("          focusX = "+focusX);
                        if (verboseLevel >= 2) System.out.println("          focusY = "+focusY);

                        mg3d.setColor(new java.awt.Color(128,128,128)); // gray
                        double thicknessInPixels = (double)count;
                        double start = -4.;  // CBB: be more principled
                        double end = 4.; // CBB: be more principled

                        if (true) {
                          // draw full circles instead of these arcs that I don't really know the full meaning of
                          start = -10.;
                          end = 10.;
                        }

                        if (verboseLevel >= 2) System.out.println("        calling smartDrawThickArc");
                        mg3d.smartDrawThickArc(
                            thicknessInPixels, // thicknessInPixels
                            focusX, focusY,   // a point on the arc
                            focusAngleRadians, // from center to focus
                            curvature,         // 1/radius
                            start, end, // arc goes from focusAngle+start to focusAngle+end in arc length
                            false); // antiAlias-- supposed to be always false according to function doc
                        if (verboseLevel >= 2) System.out.println("        returned from smartDrawThickArc");
                      }
                      if (verboseLevel >= 1) System.out.println("  done drawing region of "+nArcs+" arcs");
                    }
                }

                //
                // Draw the labels last...
                //
                if ((showPrimalVertsFlag.get()&&labelPrimalVertsFlag.get())
                 || (showPrimalEdgesFlag.get()&&labelPrimalEdgesFlag.get()))
                {
                    mg3d.setColor(java.awt.Color.WHITE);
                    drawLabels(mg3d, mesh, false, showInsideOutDualVertsFlag.get(),
                            showPrimalVertsFlag.get()&&labelPrimalVertsFlag.get(),
                            showPrimalEdgesFlag.get()&&labelPrimalEdgesFlag.get(),
                            null, // primal
                            whichPrimalEdgesGotDrawn);
                }
                if ((showDualVertsFlag.get()&&labelDualVertsFlag.get())
                 || (showDualEdgesFlag.get()&&labelDualEdgesFlag.get()))
                {
                    //mg3d.setColor(java.awt.Color.RED);
                    mg3d.setColor(dualColor);
                    drawLabels(mg3d, dualMesh, true, showInsideOutDualVertsFlag.get(),
                        showDualVertsFlag.get()&&labelDualVertsFlag.get(),
                        showDualEdgesFlag.get()&&labelDualEdgesFlag.get(),
                        dualEdgeInitialCoords, // dual
                        null);
                } // if (showLabelsFlag)

                if (showOriginFlag)
                {
                    // draw a subtle dot at the origin
                    mg3d.setColor(java.awt.Color.WHITE);
                    mg3d.drawPoint(0., 0., 0., 1);
                }
                // if showing an optimization path, display a message about it
                if (theOptimizationIndex != -1)
                {
                    mg3d.setColor(java.awt.Color.WHITE);
                    String message = "Optimization step "+theOptimizationIndex+"/"+(theOptimizationPath.length-1)+":  goodness = "+theOptimizationPathGoodnesses[theOptimizationIndex]
                        + " ([Shift] L/R arrow to advance/retreat )";
                    mg3d.drawString(message,
                                  -1., -1.,
                                  -1., 1.1);
                }


                // if showing a net and the net is complete, display a message about it
                // and a thermometer.
                if (showNetFlagValue
                 && theNet != null
                 && theNet.nUndecideds() == 0
                 && mesh.edges.size() > 0)
                {
                    int heights[] = VecMath.fillvec(nNonZeroLengthWholeEdges, 2);
                    int space = size.height+1;
                    int spaceUsed = nNonZeroLengthWholeEdges * 2;
                    if (thermometerIsLinear)
                    {
                        // roughly linear, distribute roundoff to lower part of screen
                        while (spaceUsed < space)
                            for (int i = 0; i < nNonZeroLengthWholeEdges && spaceUsed < space; ++i)
                            {
                                heights[i]++;
                                spaceUsed++;
                            }
                    }
                    else if (true)
                    {
                        // triangular numbers, larger at lower part of screen.
                        while (spaceUsed < space)
                            for (int i = 0; i < nNonZeroLengthWholeEdges && spaceUsed < space; i++)
                            {
                                for (int j = i; j >= 0 && spaceUsed < space; --j)
                                {
                                    heights[j]++;
                                    spaceUsed++;
                                }
                            }
                    }
                    else
                    {
                        // triangular numbers, larger at lower part of screen
                        for (int i = 0; spaceUsed < space; i = MIN(i+1, nNonZeroLengthWholeEdges-1))
                        {
                            for (int j = MIN(i,nNonZeroLengthWholeEdges-1); j >= 0 && spaceUsed < space; --j)
                            {
                                heights[j]++;
                                spaceUsed++;
                            }
                        }
                    }
                    // from bottom of screen (red) to top of screen (green)
                    int xIntervals[][] = {{0,thermometerWidth}, {size.width-thermometerWidth,size.width}};

                    g.setColor(java.awt.Color.BLACK);
                    FORI (iInterval, xIntervals.length)
                        g.fillRect(xIntervals[iInterval][0], 0,
                                   xIntervals[iInterval][1]-xIntervals[iInterval][0], size.height);

                    spaceUsed = 0;
                    g.setColor(java.awt.Color.RED);
                    FORI (iEdge, nNonZeroLengthWholeEdges)
                    {
                        if (iEdge == nNonZeroLengthOffBalanceCuts)
                            g.setColor(java.awt.Color.GREEN);
                        //int x0 = size.width-width;
                        int x0 = 0;
                        FORI (iInterval, xIntervals.length)
                            g.fillRect(xIntervals[iInterval][0],                         size.height-spaceUsed-heights[iEdge]+1,
                                       xIntervals[iInterval][1]-xIntervals[iInterval][0], heights[iEdge]-1);
                        spaceUsed += heights[iEdge];
                        if (spaceUsed >= space)
                            break;
                    }

                    mg3d.setColor(java.awt.Color.WHITE);
                    // BUG: I think number of off-balance cuts isn't right still-- doesn't match what "make good" is reporting.   But may be fixed now that I fixed some other bug?
                    mg3d.drawString(""+nNonZeroLengthOffBalanceCuts+" / "+(nNonZeroLengthWholeEdges/2)+" off-balance cuts",
                                  size.width/minSize,-size.height/minSize,
                                  1.2, 1.5,
                                  java.awt.Color.BLACK); // background

                } // thermometer


                //
                // Draw the rubber band last last
                //
                if (rubberBandingNewEdge)
                {
                    mg3d.setColor(java.awt.Color.WHITE);
                    Mesh.Vertex v0 = mesh.getVert(beingDraggedVertIndex);
                    double projectedPrevP[] = new double[3];
                    pickPointOnSurface(prevP, vertOffset(v0, wrapAroundSphereFlag.get()), projectedPrevP, mousePressWasBackFacing);
                    mg3d.drawLine(v0.x(), v0.y(), v0.z(),
                                  projectedPrevP[0], projectedPrevP[1], projectedPrevP[2],
                                  antiAliasingFlag);
                } // if (rubberBandingNewEdge)





                if (showPositiveOrthantnessVisualizationFlag)
                {
                    int nPoints = 5000;
                    int nLabels = 100;
                    double M[][] = new double[3][3];
                    {
                        // XXX should add a function to VecMath for random orthonormal matrix?
                        FORI (i, 2)
                        FORI (j, 3)
                            M[i][j] = 2*randomNumberGenerator.nextDouble() - 1.;
                        VecMath.normalize(M[0], M[0]);
                        VecMath.vpsxv(M[1],
                                      M[1],
                                      -VecMath.dot(M[0], M[1]),
                                      M[0]);
                        VecMath.normalize(M[1], M[1]);
                        VecMath.vxv3(M[2], M[0], M[1]);
                    }

                    double v[] = new double[3];
                    double Mv[] = new double[3];
                    FORI (iPoint, nLabels+nPoints)
                    {
                        VecMath.random(v);

                        if (iPoint == 0 || iPoint == nLabels+nPoints-1)
                            VecMath.fillvec(v, 1.);
                        else if (iPoint == 1 || iPoint == nLabels+nPoints-2)
                            VecMath.fillvec(v, -1);


                        VecMath.normalize(v, v);
                        VecMath.mxv(Mv, M, v);
                        if (Mv[2] < 0.)
                        {
                            VecMath.sxv(v, -1., v);
                            VecMath.sxv(Mv, -1., Mv);
                        }
                        double goodness = VecMath.positiveOrthantness(v, true); // true means use "synopsis"
                        //double incrDegrees = 10.;
                        double incrDegrees = 5.;
                        double dN = goodness * 180 / Math.PI / incrDegrees;
                        int iN = (int)Math.round(dN);
                        if (iPoint <= 1
                         || iPoint >= nLabels+nPoints-2
                         || ABS(iN-dN) < .01)
                        {
                            if (iN == 0)
                                mg3d.setColor(java.awt.Color.RED);
                            else if (iN % 2 == 0)
                                mg3d.setColor(java.awt.Color.GREEN);
                            else
                                mg3d.setColor(java.awt.Color.BLUE);

                            if (iPoint == 0
                             || iPoint == nLabels+nPoints-1)
                                mg3d.drawString(""+(dN*incrDegrees),
                                              Mv[0],Mv[1], -1., 1.);
                            else if (iPoint < nLabels)
                                mg3d.drawString(""+(int)Math.round(dN*incrDegrees),
                                              Mv[0],Mv[1], -1., 1.);
                            else
                                mg3d.drawPoint(Mv[0],Mv[1], 0., 1);
                        }
                        else
                            iPoint--; // cancel loop iteration
                    }
                }

                nPaints++;
                mg3d.setColor(java.awt.Color.WHITE);
                mg3d.drawString(""+nPaints+" paints", size.width/minSize,size.height/minSize,
                              1., -.5,
                              java.awt.Color.BLACK); // background


                if (g != frontBufferGraphics)
                {
                    if (showMagFlag.get())
                    FORI (iMag, 2) // twice, so we can mag the mag somewhat
                    {
                        // can we zoom part of the image onto itself?
                        // it seems yes! (at least with javac 1.3, runtime 1.6)
                        // XXX TODO: should really do it into a different buffer, we get artifacts this way when magging over the mag

                        int bbWidth = backBufferImage.getWidth(null);
                        int bbHeight = backBufferImage.getHeight(null);

                        // odd -> center pixel, even -> a little to lower right
                        int focusX = bbWidth/2;
                        int focusY = bbHeight/2;
                        if (prevP != null)
                        {
                            // lame way of figuring out where the mouse was most recently
                            double focus[] = new double[2];
                            mg3d.unpick(prevP[0], prevP[1], focus);
                            focusX = (int)Math.round(focus[0]-.5);
                            focusY = (int)Math.round(focus[1]-.5);
                        }



                        CHECK_EQ(magWidth % 2, 1);

                        int dx0 = bbWidth - (magFactor+1)*magWidth;
                        int dy0 = bbHeight - (magFactor+1)*magWidth;
                        int dx1 = bbWidth;
                        int dy1 = bbHeight;
                        int sx0 = focusX - (magWidth-1)/2;
                        int sy0 = focusY - (magWidth-1)/2;
                        int sx1 = focusX + (magWidth+1)/2;
                        int sy1 = focusY + (magWidth+1)/2;

                        {
                            // border around the real one (before copying,
                            // so it will get clobbered)
                            g.setColor(java.awt.Color.BLUE);
                            g.drawRect(focusX-(magWidth-1)/2 - 1,
                                       focusY-(magWidth-1)/2 - 1,
                                       magWidth+1,
                                       magWidth+1);
                        }


                        // TODO: can we do this using swing's back buffer as the back buffer image?
                        g.drawImage(backBufferImage,
                                    dx0,dy0,dx1,dy1,
                                    sx0,sy0,sx1,sy1,
                                    null);

                        //g.setColor(java.awt.Color.GRAY);
                        g.setColor(java.awt.Color.BLACK);
                        FORI (i, magWidth+1)
                        {
                            int x = bbWidth-1 - i*(magFactor+1);
                            int y = bbHeight-1 - i*(magFactor+1);
                            g.drawLine(x,dy0-1, x,dy1);
                            g.drawLine(dx0-1,y, dx1,y);
                        }

                        {
                            // slighly bolden the grid box around the center cell
                            int x0 = bbWidth - (magWidth+1)/2 * (magFactor+1) - 1;
                            int y0 = bbHeight - (magWidth+1)/2 * (magFactor+1) - 1;
                            int boldWidth = 3;
                            java.awt.Color colors[] = {java.awt.Color.BLACK, java.awt.Color.WHITE, java.awt.Color.BLACK};
                            FORI (i, boldWidth)
                            {
                                g.setColor(colors[i]);
                                g.drawRect(x0-i,y0-i, magFactor+1+2*i, magFactor+1+2*i);
                            }
                        }

                        {
                            // border around the magnified one
                            g.setColor(java.awt.Color.BLUE);
                            g.drawRect(dx0-1,dy0-1, dx1-dx0, dy1-dy0);
                        }

                        {

                            int[] pixels = new int[1];
                            java.awt.image.PixelGrabber pg = new java.awt.image.PixelGrabber(backBufferImage, focusX,focusY,1,1,pixels, 0, 1);
                            try
                            {
                                pg.grabPixels();
                            }
                            catch (InterruptedException e)
                            {
                                CHECK(false);
                            }
                            CHECK_EQ((pg.getStatus() & java.awt.image.ImageObserver.ABORT), 0);
                            int alpha = (pixels[0]>>24) & 0xff;
                            int red =   (pixels[0]>>16) & 0xff;
                            int green = (pixels[0]>> 8) & 0xff;
                            int blue =  (pixels[0]    ) & 0xff;

                            mg3d.setColor(java.awt.Color.WHITE);
                            mg3d.drawString(""+focusX+","+focusY+": "+red+","+green+","+blue+(alpha==255?"":" "+alpha),
                                          size.width/minSize,-size.height/minSize,
                                          1., 1.5,
                                          java.awt.Color.BLACK); // background
                        }
                    }

                    frontBufferGraphics.drawImage(backBufferImage,
                                                  0, 0,
                                                  getWidth(),  // of canvas, not back buffer
                                                  getHeight(), // of canvas, not back buffer
                                                  this);
                }

                if (showNetFlag.get() && showNetPolishFlag.get())
                {
                    // CBB: this is undoubtably the wrong place for this.
                    // Apply some fixage.
                    OUT("before: nFixagesSinceLastNoise = "+nFixagesSinceLastNoise);
                    OUT("Applying fixage!");
                    int quantum = showNetPolishQuantum.get(); // snapshot
                    boolean strictFlag = true; // TODO: put this in ui somehow? for now, most interested in strict since it may lead to a counterexample of the lame conjecture
                    boolean madeItGood = theNet.polish(strictFlag, quantum, randomNumberGenerator, showNetPolishFlag);
                    if (madeItGood)
                    {
                        if (showNetMakeBadAgainFlag.get())
                        {
                            OUT("making bad again!");
                            // Make Bad Again is checked, so whenever it was made good,
                            // create a different configuration and start making good again.
                            // CBB: never actually shows the good net!  Should show it for a frame.

                            //doJustNoiseThing(justNoiseN.get());
                            doConvexNoiseThing(convexNoiseN.get());

                            delaunayize(); // whether or not continuouslyDelaunayizeFlag.get()
                            if (true)
                            {
                                double truncationFrac = .9;
                                MeshUtils.maybeMakeMoreDifficultByTruncatingDual(mesh,
                                                                                 getDualMesh(),
                                                                                 truncationFrac,
                                                                                 randomNumberGenerator);
                                dirtyDualMesh();
                            }

                            nFixagesSinceLastNoise = 0;
                        }
                        else
                        {
                            showNetPolishFlag.set(false);
                        }
                    }
                    else
                    {
                        if (!showNetContinueAfterQuantumDoneFlag.get())
                        {
                            showNetPolishFlag.set(false);
                        }
                        nFixagesSinceLastNoise += quantum;
                    }

                    if (showNetPolishFlag.get() && showNetPolishVeryFastFlag.get())
                    {
                        repaint();
                    }
                    OUT("after: nFixagesSinceLastNoise = "+nFixagesSinceLastNoise); // CBB: this is just approximate since polish didn't return how many it did on success
                }

                if (eventVerbose >= 1) System.out.println("out paintComponent");
            } // paintComponent

            private void makeSureBackBufferIsRight()
            {
                if (homeGrownDoubleBufferFlag || showMagFlag.get())
                {
                    java.awt.Dimension size = getSize();
                    int shouldBeWidth = (int)Math.ceil((double)size.width);
                    int shouldBeHeight = (int)Math.ceil((double)size.height);
                    if (backBufferImage == null
                     || backBufferImage.getWidth(this) != shouldBeWidth
                     || backBufferImage.getHeight(this) != shouldBeHeight)
                    {
                        if (eventVerbose >= 1)
                        {
                            System.out.println("Creating back buffer " + shouldBeWidth + "x" + shouldBeHeight);
                        }
                        backBufferImage = createImage(shouldBeWidth,
                                                      shouldBeHeight);
                    }
                }
                else
                    backBufferImage = null;
            } // makeSureBackBufferIsRight
        } // class TheCanvas

            // Figure out the partitioning of the plane into "topological regions" for v0.
            // That is, the regions such that, if v0 moves around inside one of these regions,
            // it doesn't change the topology of the picture.
            // Q: does this make sense if not "keep delaunayized"?  Maybe just assume "keep delaunayized"?
            // The topological regions are bounded by circular arcs;
            // in fact the picture of all the regions can be formed by simply
            // drawing the circles where the primal face planes meet the hyperboloid.
            // So we return specs of those circles.
            // For a finite circle, the dual vertex of that primal face suffices:
            // its position is the circle center,
            // and  the circle curvature or radius is some function of its height and w.
            // For circles with infinite center and radius, we also need a reference point on the circle,
            // to disambiguate; for that case, we return an incident primal vert.
            private java.util.ArrayList<double[][]> figureOutAllTopologicalRegions(
                Mesh mesh,  // the primary mesh, i.e. the mostly triangulated white/yellow one that the user edits
                Mesh dualMesh,  // the dual mesh, i.e. the mostly trivalent blue one
                Mesh.Vertex vertexToIgnore)
            {
                Mesh meshToUse;
                Mesh dualMeshToUse;
                if (vertexToIgnore == null)
                {
                    meshToUse = mesh;
                    dualMeshToUse = dualMesh;
                }
                else
                {
                    // Make a dual mesh, out of the mesh with the vertex in question removed.
                    Mesh clone = new Mesh(mesh);
                    clone.deleteVertex(clone.getVert(vertexToIgnore.myIndex()), null, null);
                    clone = MeshUtils.delaunayized(clone,
                                                   wrapAroundSphereFlag.get(),
                                                   wrapSphereCurvature.get(),
                                                   centerSphereFlag.get(),
                                                   calcInsideOutDualVertsFlag.get(),
                                                   true);  // slightlyVerbose
                    dualMeshToUse = Mesh.makeDualMesh(clone,
                                                      false,  // includeNonArity3,
                                                      calcInsideOutDualVertsFlag.get(), // includeInsideOut
                                                      /*zeroVerts=*/false,
                                                      wrapAroundSphereFlag.get(),
                                                      centerSphereFlag.get(),
                                                      wrapSphereCurvature.get());
                    meshToUse = clone;
                }

                int nDualVerts = dualMeshToUse.verts.size();

                // For each dual vert, we also return one incident primal vert.
                // This is necessary for disambiguation in the case that the circle center
                // and radius are invinite.
                int[] dualVert2someIncidentPrimalVert = VecMath.fillvec(nDualVerts, -1);
                {
                  int nEdges = meshToUse.edges.size();
                  CHECK_EQ(nEdges, dualMeshToUse.edges.size());
                  for (int iEdge = 0; iEdge < nEdges; ++iEdge) {
                    Mesh.Edge primalEdge = meshToUse.getEdge(iEdge);
                    Mesh.Vertex primalVert0 = primalEdge.initialVertex();
                    Mesh.Vertex primalVert1 = primalEdge.finalVertex();
                    int iPrimalVert = primalVert0!=null ? primalVert0.myIndex() : primalVert1.myIndex();
                    Mesh.Edge dualEdge = dualMeshToUse.getEdge(iEdge);
                    Mesh.Vertex dualVert0 = dualEdge.initialVertex();
                    Mesh.Vertex dualVert1 = dualEdge.finalVertex();
                    if (dualVert0 != null) dualVert2someIncidentPrimalVert[dualVert0.myIndex()] = iPrimalVert;
                    if (dualVert1 != null) dualVert2someIncidentPrimalVert[dualVert1.myIndex()] = iPrimalVert;
                  }
                }

                java.util.ArrayList<double[][]> answer = new java.util.ArrayList<double[][]>();
                for (int iDualVert = 0; iDualVert < nDualVerts; ++iDualVert) {
                  Mesh.Vertex dualVert = dualMeshToUse.getVert(iDualVert);
                  // Can think of this as: {centerX*area, centerY*area, height*area^2, area}
                  double[/*4*/] center = {dualVert.X(), dualVert.Y(), dualVert.H(), dualVert.W()};
                  int someIncidentPrimalVertIndex = dualVert2someIncidentPrimalVert[iDualVert];
                  CHECK_NE(someIncidentPrimalVertIndex, -1);
                  Mesh.Vertex someIncidentPrimalVert = meshToUse.getVert(someIncidentPrimalVertIndex);
                  answer.add(new double[][] {
                      center,
                      {someIncidentPrimalVert.X(), someIncidentPrimalVert.Y(), someIncidentPrimalVert.H(), someIncidentPrimalVert.W()},
                  });
                }
                return answer;
            }  // figureOutAllTopologicalRegions

            private void delaunayize()
            {
                // ack! need to circumvent invalidation of selection
                // TODO: make this a little cleaner
                boolean wasValid = (meshOfSelectedTris == this.mesh);

                this.mesh = MeshUtils.delaunayized(this.mesh, wrapAroundSphereFlag.get(), wrapSphereCurvature.get(), centerSphereFlag.get(), calcInsideOutDualVertsFlag.get(),
                                                   true); // slightlyVerbose

                if (wasValid)
                    this.meshOfSelectedTris = this.mesh;
            }

            private void doCannedThingAlgorithm5Killer0()
            {
                if (true)
                {
                    double verts[][] = {
                        {0,0},     // 0
                        //{0,14,-1.5},    // 1
                        {0,10.5,-.8},    // 1
                        {7,7},     // 2
                        {-7,7},    // 3
                        {31,-5,10},   // 4
                        {-31,-5,10},  // 5
                        {28,-14},  // 6
                        {-28,-14}, // 7
                        {52,-26},  // 8
                        {-52,-26}, // 9
                    };
                    // XXX lame, we are scaling heights wrong... picked heights empirically for this wrongness
                    VecMath.mxs(verts, verts,
                                .02);
                    int faces[][] = {
                        {0,2,1},
                        {0,6,2},
                        {2,6,4},
                        {4,6,8},
                        {0,1,3},
                        {0,3,7},
                        {3,5,7},
                        {5,9,7},
                        {0,7,9,5,3,1,2,4,8,6},
                    };
                    mesh = new Mesh(verts, faces);
                }



                if (true)
                {
                    double scale = .05;

                    //double topTilt = DTOR(2.);
                    //double topTilt = DTOR(45.);
                    //double topTilt = Math.atan2(1,2);
                    //double topTilt = Math.atan2(1,2)/2;
                    double topTilt = Math.atan2(1,4);
                    double q = 250;
                    double qq = 300;
                    double verts[][] = {
                        {0,0},     // 0
                        {0,7+7*Math.tan(topTilt)}, // 1
                        {7,7},     // 2
                        {-7,7},    // 3
                        {14,0},  // 4
                        {-14,0}, // 5
                        {15,3},   // 6
                        {-15,3},  // 7
                        {14.5+q*Math.cos(DTOR(30.)), 1.5-q*Math.sin(DTOR(30.))},  // 8
                        {-14.5-q*Math.cos(DTOR(30.)), 1.5-q*Math.sin(DTOR(30.))},  // 9
#define DO_OUTER
#ifdef DO_OUTER
                        {14.5+qq*Math.cos(DTOR(30.)), 1.5-qq*Math.sin(DTOR(30.))},  // 10
                        {-14.5-qq*Math.cos(DTOR(30.)), 1.5-qq*Math.sin(DTOR(30.))},  // 11
                        {0,50}, // 12     (will be adjusted)
#endif // DO_OUTER
                    };
#ifdef DO_OUTER
                    verts[12][1] = verts[10][1] + Math.sqrt(3.)*verts[10][0];
#endif // DO_OUTER
                    int faces[][] = {
                        {1,0,2},
                        {0,1,3},
                        {2,0,4},
                        {0,3,5},
                        {2,4,6},
                        {5,3,7},
                        {6,4,8},
                        {5,7,9},

#ifndef DO_OUTER // if NOT doing outer
                        {0,5,9,7,3,1,2,6,8,4},
#endif // DO_OUTER

#ifdef DO_OUTER
                        {6,8,10},
                        {9,7,11},
                        {10,0,11},
                        {10,8,4},
                        {10,4,0},
                        {11,5,9},
                        {11,0,5},

                        //{10,11,5,3,1,2,4},
                        {12,11,7},
                        {12,7,3},
                        {12,3,1},
                        {12,1,2},
                        {12,2,6},
                        {12,6,10},
                        {12,10,11},
#endif // DO_OUTER
                    };
                    // corresponding to the triangular faces... (some of them)
                    double desiredDualVerts[][] = {
                        {1,3},
                        {-1,3},
                        {3,1},
                        {-3,1},
                        {9,7},
                        {-9,7},

                        //{12,6},
                        //{-12,6},

                        //{15,5},
                        //{-15,5},

                        {18,4},
                        {-18,4},

#ifdef DO_OUTER
                        {12+.5*Math.cos(RTOD(60.))/Math.sin(RTOD(60.)), 6.5}, // this one is only approximate, and will be adjusted below
                        {-12-.5*Math.cos(RTOD(60.))/Math.sin(RTOD(60.)), 6.5}, // this one is only approximate, and will be adjusted below
#endif // DO_OUTER
                    };
#ifdef DO_OUTER
                    PRINTVEC(desiredDualVerts[desiredDualVerts.length-2]);
                    PRINTVEC(desiredDualVerts[desiredDualVerts.length-1]);
                    double height = (desiredDualVerts[desiredDualVerts.length-5][1]
                                   - desiredDualVerts[desiredDualVerts.length-3][1])/2.;
                    double length = height / Math.sin(RTOD(60.));
                    desiredDualVerts[desiredDualVerts.length-1][1] =
                    desiredDualVerts[desiredDualVerts.length-2][1] =
                        desiredDualVerts[desiredDualVerts.length-3][1] + height;
                    desiredDualVerts[desiredDualVerts.length-1][0] =
                    -(desiredDualVerts[desiredDualVerts.length-2][0] =
                         desiredDualVerts[desiredDualVerts.length-4][0] + length * Math.cos(RTOD(60.)));
                    PRINTVEC(desiredDualVerts[desiredDualVerts.length-2]);
                    PRINTVEC(desiredDualVerts[desiredDualVerts.length-1]);

                    boolean doBackface = true;
                    if (doBackface)
                    {
                        verts = (double[][])Arrays.append(verts,
                                                          VecMath.bary(verts[verts.length-3],
                                                                       verts[verts.length-2], 1/3.,
                                                                       verts[verts.length-1], 1/3.));
                        verts[verts.length-1] = Arrays.append(verts[verts.length-1], -6./(scale*scale)); // shameless hardcoding
                        // Replace the last face with 3 faces
                        faces[faces.length-1] = new int[]{10,11,13};
                        faces = (int[][])Arrays.append(faces, new int[]{11,12,13});
                        faces = (int[][])Arrays.append(faces, new int[]{12,10,13});
                    }
#endif // DO_OUTER
                    // make room for heights in the array
                    FORI (iVert, verts.length)
                        if (verts[iVert].length == 2)
                            verts[iVert] = Arrays.append(verts[iVert], 0.);
                    // adjust heights to make the dual verts right
                    FORI (iVert, desiredDualVerts.length+2)
                    {
                        if (iVert == 0)
                            verts[iVert][2] = 0.;
                        else if (iVert == 1)
                        {
                            // Get the y coord of desiredDualVerts[0] right
                            double sampleResultVerts[][] = new double[2][3];
                            int iDualVert = 0;
                            double v0[] = verts[faces[iDualVert][0]];
                            double v1[] = verts[faces[iDualVert][1]];
                            double v2[] = verts[faces[iDualVert][2]];
                            FORI (iSample, 2)
                            {
                                verts[iVert][2] = (double)iSample; // 0. or 1.
                                GeomUtils.SolveForDualPoint(v0[0],v0[1],v0[2],
                                                            v1[0],v1[1],v1[2],
                                                            v2[0],v2[1],v2[2],
                                                            sampleResultVerts[iSample],
                                                            false, // wrapAroundSphereFlag
                                                            false, // centerSphereFlag
                                                            0.); // wrapSphereCurvature
                            }
                            double toDesired[] = VecMath.vmv(2, desiredDualVerts[iDualVert], sampleResultVerts[0]);
                            double toSample1[] = VecMath.vmv(2, sampleResultVerts[1], sampleResultVerts[0]);
                            double t = toDesired[1] / toSample1[1];
                            verts[iVert][2] = t;

                            // check...
                            double finalResultVert[] = new double[3];
                            GeomUtils.SolveForDualPoint(v0[0],v0[1],v0[2],
                                                        v1[0],v1[1],v1[2],
                                                        v2[0],v2[1],v2[2],
                                                        finalResultVert,
                                                        false, // wrapAroundSphereFlag
                                                        false, // centerSphereFlag
                                                        0.); // wrapSphereCurvature
                            //PRINTVEC(desiredDualVerts[iDualVert]);
                            //PRINTVEC(finalResultVert);
                            CHECK_ALMOST_EQ(desiredDualVerts[iDualVert][1], finalResultVert[1], 1e-6);
                        }
                        else
                        {
                            CHECK_EQ(faces[iVert-2][2], iVert);
                            double sampleResultVerts[][] = new double[2][3];
                            int iDualVert = iVert-2;
                            double v0[] = verts[faces[iDualVert][0]];
                            double v1[] = verts[faces[iDualVert][1]];
                            double v2[] = verts[faces[iDualVert][2]];
                            FORI (iSample, 2)
                            {
                                verts[iVert][2] = (double)iSample; // 0. or 1.
                                GeomUtils.SolveForDualPoint(v0[0],v0[1],v0[2],
                                                            v1[0],v1[1],v1[2],
                                                            v2[0],v2[1],v2[2],
                                                            sampleResultVerts[iSample],
                                                            false, // wrapAroundSphereFlag
                                                            false, // centerSphereFlag
                                                            0.); // wrapSphereCurvature
                            }
                            double toDesired[] = VecMath.vmv(2, desiredDualVerts[iDualVert], sampleResultVerts[0]);
                            double toSample1[] = VecMath.vmv(2, sampleResultVerts[1], sampleResultVerts[0]);
                            double t = VecMath.dot(2, toDesired,toSample1) / VecMath.dot(2, toSample1,toSample1);
                            verts[iVert][2] = t;

                            // check...
                            double finalResultVert[] = new double[3];
                            GeomUtils.SolveForDualPoint(v0[0],v0[1],v0[2],
                                                        v1[0],v1[1],v1[2],
                                                        v2[0],v2[1],v2[2],
                                                        finalResultVert,
                                                        false, // wrapAroundSphereFlag
                                                        false, // centerSphereFlag
                                                        0.); // wrapSphereCurvature
                            PRINTVEC(desiredDualVerts[iDualVert]);
                            PRINTVEC(finalResultVert);
                            CHECK_LE(VecMath.dist(desiredDualVerts[iDualVert], finalResultVert), 1e-6);  // XXX this fails, and I don't remember enough about what this whole thing is supposed to be to fix it
                        }
                    }
#ifdef DO_OUTER
                    // apex height is same as other outer heights
                    PRINT(verts[10][2]);
                    PRINT(verts[11][2]);
                    CHECK_ALMOST_EQ(verts[11][2], verts[10][2], 1e-6);
                    verts[12][2] = verts[11][2];
#endif
                    FORI (iVert, verts.length)
                    {
                        verts[iVert][0] *= scale;
                        verts[iVert][1] *= scale;
                        if (verts[iVert].length > 2)
                            verts[iVert][2] *= scale*scale;
                    }
                    mesh = new Mesh(verts, faces);
                }
            } // doCannedThingAlgorithm5Killer

            private void doCannedThingAlgorithm5Killer1()
            {
                if (true)
                {
                    double scale = 1/60000.;

                    double q = 30; // for working
                    //double q = 100; // the real thing
                    //double q = 60; // try not so extreme
                    double qq = 90;
                    //double qq = 300; // the real thing
                    //double qq = 180; // try not so extreme
                    double fudgeUp = 0; // fraction of big triangle height to move big triangle up
                    double verts[][] = {
                        {0,0},      // 0
                        {0,7},      // 1
                        {14,28},    // 2
                        {-14,28},   // 3

                        VecMath.lerp(new double[]{7,14},new double[]{392,-98},.8), // 4
                        VecMath.lerp(new double[]{-7,14},new double[]{-392,-98},.8), // 5



                        {392,-98},  // 6
                        {-392,-98}, // 7

                        {398,-68},  // 8
                        {-398,-68}, // 9

                        {q*395, -83},  // 10
                        {-q*395, -83}, // 11
                        {q*395, -83 + .25*q*395}, // 12
                        {-q*395, -83 + .25*q*395}, // 13

                        {q*395 + qq*395, -83 - qq*395}, // 14
                        {-q*395 - qq*395, -83 - qq*395}, // 15

                        {0, 1000}, // 16 -- will be adjusted
                    };
                    verts[16][1] = verts[14][1] + Math.sqrt(3.)*verts[14][0];
                    verts[14][1] += fudgeUp * verts[14][0];
                    verts[15][1] += fudgeUp * verts[14][0];
                    verts[16][1] += fudgeUp * verts[14][0];

                    int faces[][] = {
                        {1,0,2},
                        {0,1,3},
                        {1,2,3},

                        //{2,0,6},
                        {2,0,4},
                        {4,0,6},
                        {2,4,6},

                        {0,3,7},
                        //{0,3,5},
                        //{0,5,7},
                        //{5,3,7},

                        {2,6,8},
                        {7,3,9},
                        {8,6,10},
                        {7,9,11},

                        {8,10,12},
                        {11,9,13},

                        {6,0,14},
                        {0,7,15},


                        {2,12,16}, // moved up from below so can match with a desiredDualVert




                        {10,6,14},
                        {7,11,15},

                        {12,10,14},
                        {11,13,15},

                        {0,15,14},

                        {15,13,16},

                        {13,9,3},
                        {13,3,16},

                        {3,2,16},


                        {2,8,12},
                        //{2,12,16}, // moving this up

                        {12,14,16},
                        {14,15,16},
                    };
                    // corresponding to the triangular faces... (some of them)
                    double desiredDualVerts[][] = {
                        {3,0},
                        {-3,0},
                        {0,2},

                        //{5,-1},
                        {5,-1},
                        {4.75,-2},
                        {5.25,-.25},

                        {-5,-1},
                        //{-5,-1},
                        //{-4.75,-2},
                        //{-5.25,-.25},

                        {14,26},
                        {-14,26},
                        {19,25},
                        {-19,25},

                        {19,25.5},
                        {-19,25.5},

                        {4,-4},
                        {-4,-4},

                        //{14,46}, // approx
                        //{15,42}, // approx
                        {16,38}, // approx
                    };
                    VecMath.mxs(desiredDualVerts, desiredDualVerts,
                                80.);

                    boolean doBackface = true;
                    if (doBackface)
                    {
                        verts = (double[][])Arrays.append(verts,
                                                          VecMath.bary(verts[verts.length-3],
                                                                       verts[verts.length-2], 1/3.,
                                                                       verts[verts.length-1], 1/3.));
                        verts[verts.length-1] = Arrays.append(verts[verts.length-1], -.4/(scale*scale)); // shameless hardcoding
                        // Replace the last face with 3 faces
                        int oldLastFace[] = faces[faces.length-1];
                        faces[faces.length-1] = new int[]{oldLastFace[0],oldLastFace[1],verts.length-1};
                        faces = (int[][])Arrays.append(faces, new int[]{oldLastFace[1],oldLastFace[2],verts.length-1});
                        faces = (int[][])Arrays.append(faces, new int[]{oldLastFace[2],oldLastFace[0],verts.length-1});
                    }

                    // make room for heights in the array
                    FORI (iVert, verts.length)
                        if (verts[iVert].length == 2)
                            verts[iVert] = Arrays.append(verts[iVert], 0.);
                    // adjust heights to make the dual verts right
                    verts[0][2] = 0.;
                    {
                        int iVert = 1;
                        int iDualVert = 0;
                        // Get the y coord of desiredDualVerts[0] right
                        double sampleResultVerts[][] = new double[2][3];
                        double v0[] = verts[faces[iDualVert][0]];
                        double v1[] = verts[faces[iDualVert][1]];
                        double v2[] = verts[faces[iDualVert][2]];
                        FORI (iSample, 2)
                        {
                            verts[iVert][2] = (double)iSample; // 0. or 1.
                            GeomUtils.SolveForDualPoint(v0[0],v0[1],v0[2],
                                                        v1[0],v1[1],v1[2],
                                                        v2[0],v2[1],v2[2],
                                                        sampleResultVerts[iSample],
                                                        false, // wrapAroundSphereFlag
                                                        false, // centerSphereFlag
                                                        0.); // wrapSphereCurvature
                        }
                        double toDesired[] = VecMath.vmv(2, desiredDualVerts[iDualVert], sampleResultVerts[0]);
                        double toSample1[] = VecMath.vmv(2, sampleResultVerts[1], sampleResultVerts[0]);
                        double t = toDesired[1] / toSample1[1];
                        verts[iVert][2] = t;

                        // check...
                        double finalResultVert[] = new double[3];
                        GeomUtils.SolveForDualPoint(v0[0],v0[1],v0[2],
                                                    v1[0],v1[1],v1[2],
                                                    v2[0],v2[1],v2[2],
                                                    finalResultVert,
                                                    false, // wrapAroundSphereFlag
                                                    false, // centerSphereFlag
                                                    0.); // wrapSphereCurvature
                        //PRINTVEC(desiredDualVerts[iDualVert]);
                        //PRINTVEC(finalResultVert);
                        CHECK_ALMOST_EQ(desiredDualVerts[iDualVert][1], finalResultVert[1], 1e-6);
                    }

                    FORI (iDualVert, desiredDualVerts.length)
                    {
                        int iVert = faces[iDualVert][2];
                        double sampleResultVerts[][] = new double[2][3];
                        double v0[] = verts[faces[iDualVert][0]];
                        double v1[] = verts[faces[iDualVert][1]];
                        double v2[] = verts[faces[iDualVert][2]];
                        FORI (iSample, 2)
                        {
                            verts[iVert][2] = (double)iSample; // 0. or 1.
                            GeomUtils.SolveForDualPoint(v0[0],v0[1],v0[2],
                                                        v1[0],v1[1],v1[2],
                                                        v2[0],v2[1],v2[2],
                                                        sampleResultVerts[iSample],
                                                        false, // wrapAroundSphereFlag
                                                        false, // centerSphereFlag
                                                        0.); // wrapSphereCurvature
                        }
                        double toDesired[] = VecMath.vmv(2, desiredDualVerts[iDualVert], sampleResultVerts[0]);
                        double toSample1[] = VecMath.vmv(2, sampleResultVerts[1], sampleResultVerts[0]);
                        double t = VecMath.dot(2, toDesired,toSample1) / VecMath.dot(2, toSample1,toSample1);
                        verts[iVert][2] = t;

                        // check...
                        double finalResultVert[] = new double[3];
                        GeomUtils.SolveForDualPoint(v0[0],v0[1],v0[2],
                                                    v1[0],v1[1],v1[2],
                                                    v2[0],v2[1],v2[2],
                                                    finalResultVert,
                                                    false, // wrapAroundSphereFlag
                                                    false, // centerSphereFlag
                                                    0.); // wrapSphereCurvature
                        PRINTVEC(desiredDualVerts[iDualVert]);
                        PRINTVEC(finalResultVert);
                        //CHECK_LE(VecMath.dist(desiredDualVerts[iDualVert], finalResultVert), 1e-6);
                    }

                    FORI (iVert, verts.length)
                    {
                        verts[iVert][0] *= scale;
                        verts[iVert][1] *= scale;
                        if (verts[iVert].length > 2)
                            verts[iVert][2] *= scale*scale;
                    }
                    mesh = new Mesh(verts, faces);
                }
            } // doCannedThingAlgorithm5Killer

            private void doBlueNoiseThing(int n)
            {
                double stubbornness = 100;
                //double overlappingDiskRadiusX = .02;
                //double overlappingDiskRadiusY = .02;
                //double overlappingDiskRadiusX = .05;
                //double overlappingDiskRadiusY = .05;
                //double overlappingDiskRadiusX = .2;
                //double overlappingDiskRadiusY = .2;
                // heuristic to get same number of points as nxn square grid
                // TODO: what was I thinking? redo this using http://mathoverflow.net/questions/238661/formula-for-density-of-maximal-poisson-disk-sampling-of-radius-1
                // overlapping radius 1 -> density 0.6965[45] ± .00002
                // therefore density is .696545 / overlappingRadius^2
                // overlappingRadius = sqrt(.696545 / density)

                /*
                double magic = 1.6165;
                double overlappingDiskRadiusX = magic/Math.sqrt(n);
                double overlappingDiskRadiusY = magic/Math.sqrt(n);
                */

                double magic = .696545;
                magic *= 4; // FUDGE-- I don't understand yet.  the mathoverflow question does talk in terms of overlapping disks, right???
                double overlappingDiskRadiusX = Math.sqrt(magic / n);
                double overlappingDiskRadiusY = Math.sqrt(magic / n);

                double verts[][];
                if (wrapAroundSphereFlag.get())
                {
                    verts = generateBlueNoiseOnUnitSphere(stubbornness,
                                                          overlappingDiskRadiusX,
                                                          randomNumberGenerator);
                    if (!centerSphereFlag.get())
                        VecMath.mmv(verts, verts, new double[]{0,0,1./wrapSphereCurvature.get()});
                    FORI (iVert, verts.length)
                        verts[iVert] = Arrays.append(verts[iVert], 1.); // X,Y,Z,W, not x,y,h
                }
                else
                {
                    verts = generateBlueNoiseOnUnitSquare(stubbornness,
                                                          overlappingDiskRadiusX,
                                                          overlappingDiskRadiusY,
                                                          randomNumberGenerator);
                    VecMath.mmv(verts, verts, new double[]{.5,.5});
                    FORI (iVert, verts.length)
                        verts[iVert] = Arrays.append(verts[iVert], 0.); // make room for heights
                }
                PRINT(verts.length);
                mesh = new Mesh(verts, new int[][]{});
            } // doBlueNoiseThing

            // TODO: change this n to mean number of points, here and everywhere except maybe grid
            private void doJustNoiseThing(int n)
            {
                double verts[][] = new double[n][3];
                if (wrapAroundSphereFlag.get())
                {
                    FORI (iVert, verts.length)
                    {
                        while (true)
                        {
                            verts[iVert][0] = randomNumberGenerator.nextDouble()*2.-1.;
                            verts[iVert][1] = randomNumberGenerator.nextDouble()*2.-1.;
                            verts[iVert][2] = randomNumberGenerator.nextDouble()*2.-1.;
                            double length2 = VecMath.normsqrd(verts[iVert]);
                            if (length2 <= 1. && length2 >= SQR(1e-6))
                                break;
                        }
                        VecMath.normalize(verts[iVert], verts[iVert]);
                    }
                    if (!centerSphereFlag.get())
                        VecMath.mmv(verts, verts, new double[]{0,0,1./wrapSphereCurvature.get()});
                    FORI (iVert, verts.length)
                        verts[iVert] = Arrays.append(verts[iVert], 1.); // X,Y,Z,W, not x,y,h
                }
                else
                {
                    FORI (iVert, verts.length)
                    {
                        verts[iVert][0] = randomNumberGenerator.nextDouble() - .5;
                        verts[iVert][1] = randomNumberGenerator.nextDouble() - .5;
                        verts[iVert][2] = 0.;
                    }
                }
                mesh = new Mesh(verts, new int[][]{});
                nFixagesSinceLastNoise = 0;
            } // doJustNoiseThing

            private void doConvexNoiseThing(int nVerts)
            {
                int verboseLevel = 2; // 0: nothing, 1: function entry/exit, 2: '.' on each vertex, 3: heavy-duty debugging
                if (verboseLevel >= 1) OUT("    in doConvexNoiseThing");
                long t0millis = System.currentTimeMillis();
                if (wrapAroundSphereFlag.get())
                {
                    unimplemented(); // TODO: implement me!
                }
                else
                {
                    if (false) // set to true for deterministic convex noise
                    {
                        OUT("SEEDING 0");
                        randomNumberGenerator.setSeed(0);
                    }

                    int nInitialVerts = 3; // must be 3 or 4
                    ConvexNoiseMaker convexNoiseMaker = new ConvexNoiseMaker(nInitialVerts, nVerts);
                    for (int iVert = nInitialVerts; iVert < nVerts; ++iVert)
                    {
                        convexNoiseMaker.pushRandomVertex(randomNumberGenerator, verboseLevel);
                    }
                    this.mesh = convexNoiseMaker.getInternalMesh();
                } // !wrapAroundSphereFlag.get()

                if (false) // XXX false for now, for debugging
                {
                    // have to delaunayize again with calcInsideOutDualVertsFlag=false, otherwise 2nd sheet will get drawn, and weirdly
                    // XXX not sure what I was talking about.  is that only if nInitialVerts==4? does it still happen? confused
                    if (verboseLevel >= 1) OUT("      delaunayizing...");
                    this.mesh = MeshUtils.delaunayized(this.mesh,
                                                       false,
                                                       1.,
                                                       true,
                                                       false, // calcInsideOutDualVertsFlag=false this time
                                                       false);
                    // TODO: salvage assertions from when delaunayizing all the time
                    if (verboseLevel >= 1) OUT("      done.");
                }
                CHECK_EQ(this.mesh.verts.size(), nVerts);
                this.nFixagesSinceLastNoise = 0;
                long t1millis = System.currentTimeMillis();
                if (verboseLevel >= 1) OUT("    out doConvexNoiseThing ("+(t1millis-t0millis)*1e-3+" secs)");
            } // doConvexNoiseThing

            private void doUniformGridThing(int nX, double rotDegrees, boolean augment_existing_mesh)
            {
                double[][] verts;

                if (nX <= 0)
                    verts = new double[0][3];
                else if (nX == 1)
                    verts = new double[][] {{0.,0.,0.}};
                else if (pRotationalSymmetry.get() % 3 == 0)
                {
                    // do regular tri grid, verts of {3,6}
                    double r = 1.;
                    int nRots = 6;
                    int nVerts = nX*(nX-1)/2 * nRots + 1;
                    verts = new double[nVerts][3]; // zeros initially, heights stay zero
                    int iVert = 0;
                    verts[iVert][0] = 0; verts[iVert][1] = 0; iVert++;
                    FORI (iRot, nRots)
                    {
                        double c = ExactTrig.cosPiTimes(iRot, 3);
                        double s = ExactTrig.sinPiTimes(iRot, 3);
                        double m[][] = {{c,s},{-s,c}};
                        FORI (iY, nX-1)
                            FORI (iX, nX-iY-1)
                            {
                                double x = ((iX+1.)/(nX-1.) + iY/2./(nX-1.)) * r;
                                double y = (Math.sqrt(3.)/2. * iY / (nX-1.)) * r;
                                VecMath.sxvpsxv(verts[iVert++], x, m[0], y, m[1]);
                            }
                    }
                    //PRINT(iVert);
                    //PRINT(verts.length);
                    CHECK_EQ(iVert, verts.length);
                }
                else
                {
                    // do regular square grid, verts of {4,4}
                    int nY = nX;
                    verts = new double[nX*nY][3]; // zeros initially, heights stay zero
                    int iVert = 0;
                    FORI (iY, nY)
                        FORI (iX, nX)
                        {
                            double x = LERP(-.5, .5, iX/(nX-1.));
                            double y = LERP(-.5, .5, iY/(nY-1.));
                            verts[iVert][0] = x;
                            verts[iVert][1] = y;
                            iVert++;
                        }
                    CHECK_EQ(iVert, verts.length);
                }

                if (rotDegrees != 0.) {
                    double c = Math.cos(DTOR(rotDegrees));
                    double s = Math.sin(DTOR(rotDegrees));
                    verts = VecMath.mxm(verts, new double[][] {{c,s,0},{-s,c,0},{0,0,1}});
                }

                if (augment_existing_mesh)
                {
                    if (false) {
                        // this works but throws away existing mesh
                        verts = (double[][])Arrays.concat(MeshUtils.getMeshVertsXYZW(mesh), verts);
                    } else {
                        FORI (i, verts.length) {
                            this.mesh.newVertex(/*x=*/verts[i][0],
                                                /*y=*/verts[i][1],
                                                /*h=*/verts[i][2]);
                        }
                    }
                } else {
                    this.mesh = new Mesh(verts, new int[][]{});
                }

                if (true)
                {
                    // Randomly homogeneous scale half the verts by 2.
                    // This shouldn't change anything,
                    // but it may root out some xform stuff that's too naive.
                    System.out.println("randomly homogeneous scaling about half the grid verts by 2");
                    int nVerts = this.mesh.verts.size();
                    FORI (iVert, nVerts)
                    {
                        Mesh.Vertex vert = this.mesh.getVert(iVert);
                        if (randomNumberGenerator.nextDouble() > .5)
                            vert.setXYZW(vert.X()*2.,
                                         vert.Y()*2.,
                                         vert.Z()*2.,
                                         vert.W()*2.);
                    }
                }


            } // doUniformGridThing

            //
            // (If you want to follow this, hit Far Lagoon Killer 1 and then 'W')
            // Farthest-from-center lagoon exiting goes into an endless loop:
            //     A is the upper-left almost-horizontal edge
            //     B is the lower-right edge
            //     C is the edge halfway between them
            // Only bad exit A -> farthest good exit B
            // Only bad exit C -> farthest good exit A
            // Only bad exit B -> farthest good exit C
            // and we're back to the beginning.
            //
            private void doCannedThingFarthestLagoonExitKiller()
            {
                /*
                // really simple verts, no hand-crafting-- see what happens.  hmm this sucks, it doesn't get there!
                double verts[][] = {
                    {.1, .3, 0},
                    {-.1, .1, 0},
                    {-.1, .5, 0},
                    {.1, -.1, 0},
                    {-.1, -.3, 0},
                    {.1, -.5, 0},
                };
                */

                /*
                // original hand-crafted verts: violated farthest-exit constraint for top 2-vertex lagoon
                double verts[][] = {
                    {0.254632748975815, 0.6613110539845769, 0.0},
                    {0.001985463846777679, 0.40848329048843174, 0.0050},
                    {-0.0016100400996860165, 0.8262841442469365, -0.0705},
                    {0.15968401023145556, 0.09537275064267343, -0.0050},
                    {0.053309106411296145, 0.1762210796915167, -0.01},
                    {-0.4317114578915699, -0.6837916370249981, -0.5450000000000002},
                };
                */

                /*
                // optimized 10 passes: goodness = .017256350831721664 (using VecMath.synopsis which I'm not thrilled with any more)
                double verts[][] = {
                    {0.1800525435129707, 0.4676175307461174, 0.0},
                    {0.13567357880860711, 0.42320686396714136, 0.0025000000000000022},
                    {-0.041882330900956, 0.7515699545002962, -0.03525000000000006},
                    {0.29423490241724615, -0.015297283324235564, -0.024256623978102798},
                    {0.2657663454311589, 0.0032808826682159285, -0.02535592252632536},
                    {0.027482624239009528, -0.5713757012317203, -0.09458036525466695},
                };
                */

                // optimized 50 passes: goodness = .019362280324644425 (using VecMath.synopsis which I'm not thrilled with any more)
                double verts[][] = {
                    {0.1800525435129707, 0.4676175307461174, 0.0},
                    {0.1093067590185278, 0.3968212090624114, 0.0025000000000000022},
                    {-0.3578608151777813, 1.1748461992103727, -0.03525000000000006},
                    {0.6348756548188554, -0.5552758689949323, 0.1838002721879618},
                    {0.5790169179568446, -0.523270452612108, 0.14986341969960895},
                    {0.20759453708056247, -1.6232499556679696, 0.4089344906614831},
                };


                int faces[][] = {
                    {1, 3, 0},
                    {3, 1, 4},
                    {0, 3, 5, 4, 1, 2},
                    {1, 0, 2},
                    {3, 4, 5},
                };
                mesh = new Mesh(verts, faces);

            } // doCannedThingFarthestLagoonExitKiller

            //
            // (If you want to follow this, hit Far Lagoon Killer 2 and then then 'W')
            // Farthest-from-center lagoon exiting goes into an endless loop:
            //     A is the upper-left almost-vertical edge
            //     B is the upper-right edge
            //     C is the edge halfway between them
            // Only bad exit A -> farthest good exit B
            // Only bad exit C -> farthest good exit A
            // Only bad exit B -> farthest good exit C
            // and we're back to the beginning.
            //
            private void doCannedThingFarthestLagoonExitKillerAltB()
            {
/*
100 passes from original hand-crafted: simple synopsis = 0.0632903084802694
OFF
6 5 0
0.1273163744879075 0.3306555269922885 -1.3877787807814457E-17
0.007466950664434855 0.21072048883775582 0.0012499999999999976
0.063927946972354 0.45166494195664725 -0.01762500000000003
0.07725274705168253 0.017764193145660596 0.039682919717938775
0.019644371916512516 0.019129114462716725 0.013473915969745336
-0.2059752055364354 -0.6388679646686696 -0.06303872265462748
3  1 3 0
3  3 1 4
6  0 3 5 4 1 2
3  1 0 2
3  3 4 5

100 passed from 50 passes on original structure: simple synopsis = 0.08830543355804742
OFF
6 5 0
0.1800525435129707 0.4676175307461174 0.0
0.08303579636398613 0.37053147976867984 0.0025000000000000022
-0.1743207145354405 1.207926317312154 -0.03525000000000006
0.5935025616828306 -0.4786092404430522 0.20709150548025163
0.5086599164177077 -0.50309546392274 0.1310302693859244
0.5788838237668292 -1.7863394875007428 0.19118475261903686
3  1 3 0
3  3 1 4
6  0 3 5 4 1 2
3  1 0 2
3  3 4 5
*/
/*
                //100 passed from 50 passes on original structure: simple synopsis = 0.08830543355804742
                double verts[][] = {
                    {0.1800525435129707, 0.4676175307461174, 0.0},
                    {0.08303579636398613, 0.37053147976867984, 0.0025000000000000022},
                    {-0.1743207145354405, 1.207926317312154, -0.03525000000000006},
                    {0.5935025616828306, -0.4786092404430522, 0.20709150548025163},
                    {0.5086599164177077, -0.50309546392274, 0.1310302693859244},
                    {0.5788838237668292, -1.7863394875007428, 0.19118475261903686},
                };
                int faces[][] = {
                    {1, 3, 0},
                    {3, 1, 4},
                    {0, 3, 5, 4, 1, 2},
                    {1, 0, 2},
                    {3, 4, 5},
                };
*/

                // and then diagonally flipped and hand neatened
                double verts[][] = {
                    {-0.4375, 0.0625, 0},
                    {-0.375, 0.125, 0},
                    {-0.78125, 0.125, 0.0812},
                    {0.125, -0.125, 0.0518},
                    {0.140625, -0.078125, 0.0328},
                    {0.9375, -0.125, 0.0478},
                };
                int faces[][] = {
                    {0, 3, 1},
                    {4, 1, 3},
                    {2, 1, 4, 5, 3, 0},
                    {2, 0, 1},
                    {5, 4, 3},
                };

                mesh = new Mesh(verts, faces);

            } // doCannedThingFarthestLagoonExitKillerAltB

            private void doCannedThingFarthestLagoonExitKillerOptimized()
            {
                doCannedThingFarthestLagoonExitKiller();
                optimizeFarthestLagoonExitKiller();
            }
            private void optimizeFarthestLagoonExitKiller()
            {
                int fromsAndTos[][/*2*/][][/*3*/] = {
                    {{{0,2,1}}, {{0,2,1},{0,1,3},{1,4,3},{3,4,5}}}, // edge A must be a bad exit of everything
                    {{{0,1,3}}, {{0,1,3},{1,4,3},{3,4,5}}}, // upper inner edge must be good exit of 3-vert lagoon under it
                    {{{1,4,3}}, {{1,4,3},{3,4,5}}}, // edge C (center) must be a good exit for 2-vert lagoon under it
                    {{{3,4,5}}, {{0,2,1},{0,1,3},{1,4,3},{3,4,5}}}, // edge B must be a good exit of whole thing
                    {{{3,4,5}}, {{0,2,1},{0,1,3},{1,4,3},{3,4,5}}}, // edge B's evil twin must be a bad exit of whole thing

                    {{{0,1,3}}, {{0,2,1},{0,1,3}}}, // edge C (center) must be bad for upper 2-vert lagoon
                    {{{0,2,1}}, {{0,2,1},{0,1,3}}}, // edge A must be good for upper 2-vert lagoon
                    {{{0,2,1}}, {{0,2,1},{0,1,3}}}, // edge A's evil twin must be bad for upper 2-vert lagoon

                    {{{3,4,5}}, {{1,4,3},{3,4,5}}}, // edge B must be bad for lower 2-vert lagoon
                    {{{1,4,3}}, {{1,4,3},{3,4,5}}}, // edge C must be good for lower 2-vert lagoon
                    {{{1,4,3}}, {{1,4,3},{3,4,5}}}, // west edge must be bad for lower 2-vert lagoon
                };

                /*
                // ORIGINAL
                int toLeftOfEdgeEndIndices[][] = {
                    {1,2}, // edge A must be a bad exit of whole thing
                    {0,1}, // upper inner edge must be good exit of 3-vert lagoon under it
                    {3,1}, // edge C (center) must be a good exit for 2-vert lagoon under it
                    {5,3}, // edge B must be a good exit of whole thing
                    {5,4}, // edge B's evil twin must be a bad exit of whole thing

                    {3,1}, // edge C (center) must be bad for upper 2-vert lagoon
                    {2,1}, // edge A must be good for upper 2-vert lagoon
                    {2,0}, // edge A's evil twin must be bad for upper 2-vert lagoon

                    {3,5}, // edge B must be bad for lower 2-vert lagoon
                    {3,1}, // edge C must be good for lower 2-vert lagoon
                    {4,1}, // west edge must be bad for lower 2-vert lagoon
                };
                */


                // ALTERNATE B-- make B be the lower-left instead of lower-right
                int toLeftOfEdgeEndIndices[][] = {
                    {1,2}, // edge A must be a bad exit of whole thing
                    {0,1}, // upper inner edge must be good exit of 3-vert lagoon under it
                    {3,1}, // edge C (center) must be a good exit for 2-vert lagoon under it
                    {4,5}, // edge B must be a good exit of whole thing
                    {3,5}, // edge B's evil twin must be a bad exit of whole thing

                    {3,1}, // edge C (center) must be bad for upper 2-vert lagoon
                    {2,1}, // edge A must be good for upper 2-vert lagoon
                    {2,0}, // edge A's evil twin must be bad for upper 2-vert lagoon

                    {5,4}, // edge B must be bad for lower 2-vert lagoon
                    {3,1}, // edge C must be good for lower 2-vert lagoon
                    {4,1}, // west edge must be bad for lower 2-vert lagoon
                };

                /*
                // ALTERNATE AB-- make B be the lower-left instead of lower-right,
                //                make A be the upper-right instead of upper-left
                // (doesn't work :-( )
                int toLeftOfEdgeEndIndices[][] = {
                    {2,0}, // edge A must be a bad exit of whole thing
                    {0,1}, // upper inner edge must be good exit of 3-vert lagoon under it
                    {3,1}, // edge C (center) must be a good exit for 2-vert lagoon under it
                    {4,5}, // edge B must be a good exit of whole thing
                    {3,5}, // edge B's evil twin must be a bad exit of whole thing

                    {3,1}, // edge C (center) must be bad for upper 2-vert lagoon
                    {0,2}, // edge A must be good for upper 2-vert lagoon
                    {1,2}, // edge A's evil twin must be bad for upper 2-vert lagoon

                    {5,4}, // edge B must be bad for lower 2-vert lagoon
                    {3,1}, // edge C must be good for lower 2-vert lagoon
                    {4,1}, // west edge must be bad for lower 2-vert lagoon
                };
                */

                /*
                // ALTERNATE A-- make A be the upper-right instead of upper-left
                //               B is still lower-right
                // (doesn't work :-( )
                int toLeftOfEdgeEndIndices[][] = {
                    {2,0}, // edge A must be a bad exit of whole thing
                    {0,1}, // upper inner edge must be good exit of 3-vert lagoon under it
                    {3,1}, // edge C (center) must be a good exit for 2-vert lagoon under it
                    {5,3}, // edge B must be a good exit of whole thing
                    {5,4}, // edge B's evil twin must be a bad exit of whole thing

                    {3,1}, // edge C (center) must be bad for upper 2-vert lagoon
                    {0,2}, // edge A must be good for upper 2-vert lagoon
                    {1,2}, // edge A's evil twin must be bad for upper 2-vert lagoon

                    {3,5}, // edge B must be bad for lower 2-vert lagoon
                    {3,1}, // edge C must be good for lower 2-vert lagoon
                    {4,1}, // west edge must be bad for lower 2-vert lagoon
                };
                */

                boolean mustBeFarthestExit[] = {
                    false,
                    false,
                    false,
                    true,
                    false,

                    false,
                    true,
                    false,

                    false,
                    true,
                    false,
                };


                /*
                nice spec might look something like:
                    CCW lagoon boundary (can be in multiple pieces),   bad exits,    good exits, farthest exits

                    {{{0,2,1,4,5,3}}, {{2,1},{4,5}}, {{5,3}}, {{5,3}} }, // whole thing: A bad, B's evil twin bad, B good,  B farthest good from cg
                    {{{0,1,4,5,3}},   {},            {{0,1}}, {} }, // lower 3 vertices: upper inner edge good
                    {{{1,4,5,3}},     {{5,3},{1,4}}, {{3,1}}, {{3,1}} }, // lower 2 vertices: B bad, west edge bad, C good,  C farthest good from cg
                    {{{0,2,1,3}},     {{1,3},{0,2}}, {{2,1}}, {{2,1}} }, // upper 2 vertices: C bad, A's evil twin bad, A good,  A farthest good from cg


                */


                // doesn't seem to ever help much to consider edge lengths... weird.  also it's the 1-edgelength thing that hurts,  edgelength itself doesn't.  But, isn't that necessary to prevent it growing without bound?? dammit.
                boolean considerEdgeLengths = false;

                int nPasses = 2;
                //int maxCallsPerPass = 10*1000;
                //int maxCallsPerPass = 1*1000;
                //int maxCallsPerPass = 500;
                //int maxCallsPerPass = 255;
                //int maxCallsPerPass = 100;
                //int maxCallsPerPass = 53;
                //int maxCallsPerPass = 10;
                int maxCallsPerPass = 1;
                double initialDelta = .0001;

                Object optimizationPathVertsAndGoodnesses[/*2*/] = GeneralOptimizationStuff.optimizeVerts(mesh,
                    fromsAndTos,
                    toLeftOfEdgeEndIndices,
                    mustBeFarthestExit,
                    considerEdgeLengths,
                    nPasses,
                    maxCallsPerPass,
                    initialDelta,
                    false, // wrapAroundSphereFlagValue
                    false, // centerSphereFlag
                    0., // wrapSphereCurvature
                    randomNumberGenerator);
                double optimizationPathVerts[][][] = (double[][][])optimizationPathVertsAndGoodnesses[0];
                double optimizationPathGoodnesses[] = (double[])optimizationPathVertsAndGoodnesses[1];

                PRINT(optimizationPathVerts.length);
                double verts[][] = optimizationPathVerts[optimizationPathVerts.length-1];
                CHECK_EQ(verts.length, 6);
                FORI (iVert, verts.length)
                {
                    Mesh.Vertex v = mesh.getVert(iVert);
                    v.setXYHnaive(verts[iVert][0],
                             verts[iVert][1],
                             verts[iVert][2]);
                }

                PRINT(optimizationPathVerts.length);
                //PRINTARRAY(optimizationPathGoodnesses);

                this.theOptimizationPath = optimizationPathVerts;
                this.theOptimizationPathGoodnesses = optimizationPathGoodnesses;
                this.theOptimizationIndex = optimizationPathVerts.length-1;
            } // optimizeFarthestLagoonExitKiller




            private void doCannedThingRefinementKiller()
            {
                // The story here is:
                // What if we start out without the middle vertex in the primal.
                // The dual verts are:
                //    A B  C  D
                //         E
                //        F
                //       G
                //           H
                //          I
                // Initial good net:
                //      B->F
                //      G->F
                //      F->E
                //      E->C
                //      C->D
                //      D->infinity
                // Now add back the middle dual vertex, which truncates E.
                // Call the new verts C', F', H'.
                // Then there's no good single-trunc refinement.
                //
                // Note this assumes there were 2 net edges at E.
                // I think (but haven't worked it out completely)
                // that a 3-net-edges case can be formed by
                // adding a 3rd edge but to a very lightweight vertex
                // so that it doesn't really change anything.
                // And for a 1-net-edge case:
                //     - single-truncation can always be done
                //     - compound truncation sometimes fails
                //       (sweepkiller8), although failure seems to imply
                //       non-regularity.
                double verts[][] = {
                    {0.9889267138688066, -0.5709571044609676, 0.0},
                    {0.0, 1.1419142089219352, 0.52},
                    {-0.9889267138688066, -0.5709571044609676, 0.4885},
                    {0.0, -0.092134895389832, 0.0},
                    {0.07979115998261628, 0.046067447694916004, 0.0},
                    {-0.07979115998261628, 0.046067447694916004, 0.0},
                    {-0.20111846493253296, -0.03622735790131169, 0.0},
                    {0,0,0},
                };
                this.mesh = new Mesh(verts, new int[0][]);
                delaunayize();
            } // doCannedThingRefinementKiller

            private void doCannedThingNetless8()
            {
                double Eps = .04;
                double slope = 1./16; // started with 1./100, 1/10 works but starts pushing outer point far away
                //     3   2
                //       1
                //      5 4
                //       0
                double verts[][] = {
                    {0*Eps, -7*Eps, 0},  // the "lowest" face, bottom point of dual
                    {0*Eps, 7*Eps, 1.64*Eps*Eps}, // empirical
                    {2*Eps, 9*Eps, 0},
                    {-2*Eps, 9*Eps, 0},
                    {7*slope*Eps, 0,  -23*Eps*Eps},
                    {-7*slope*Eps, 0, -23*Eps*Eps},
                };

                int faces[][] = {
                    {5,4,1},
                    {0,4,5},
                    {4,2,1},
                    {5,1,3},
                    {5,3,0},
                    {2,4,0},
                    {1,2,3},
                    {0,3,2},
                };

                mesh = new Mesh(verts, faces);
            } // doCannedThingNetless8


            // Counterexample to entire class of sweep algorithms
            // that cut each vertex to a higher vertex.
            // It contains two netless8's.
            private void doCannedThingSweepKiller0()
            {
                // cheap way of getting verts of netless8
                doCannedThingNetless8();
                double netless8Verts[][] = new double[mesh.verts.size()][3];
                FORI (i, netless8Verts.length)
                {
                    Mesh.Vertex vertex = mesh.getVert(i);
                    netless8Verts[i][0] = vertex.Xnaive();
                    netless8Verts[i][1] = vertex.Ynaive();
                    netless8Verts[i][2] = vertex.Hnaive();
                }

                double separation = 2;
                double verts[][] = new double[2*netless8Verts.length][3];
                FORI (i, netless8Verts.length)
                {
                    VecMath.copyvec(verts[i], netless8Verts[i]);
                    verts[i][0] -= separation/2;
                    VecMath.copyvec(verts[netless8Verts.length+i], netless8Verts[i]);
                    verts[netless8Verts.length+i][0] += separation/2;
                }

                double netless8TriHeight = verts[2][1] - verts[0][1];
                double y = verts[0][1] - netless8TriHeight;
                double Eps = .04; // same as netless8
                double h = -110*Eps*Eps; // not strictly necessary, but makes it easier to think about

                verts = (double[][])Arrays.append(verts, new double[]{verts[3][0],
                                                  y,
                                                  h});
                verts = (double[][])Arrays.append(verts, new double[]{verts[2][0],
                                                  y,
                                                  h});
                verts = (double[][])Arrays.append(verts, new double[]{verts[9][0],
                                                  y,
                                                  h});
                verts = (double[][])Arrays.append(verts, new double[]{verts[8][0],
                                                  y,
                                                  h});
                y -= (verts[2][0]-verts[3][0])*3/4;
                verts = (double[][])Arrays.append(verts, new double[]{0,
                                                  y,
                                                  0});
                verts = (double[][])Arrays.append(verts, new double[]{verts[1][0],
                                                  y,
                                                  h});
                verts = (double[][])Arrays.append(verts, new double[]{verts[7][0],
                                                  y,
                                                  h});
                y += (verts[2][0]-verts[3][0])*3/4;
                y -= netless8TriHeight;
                verts = (double[][])Arrays.append(verts, new double[]{verts[3][0]-2*(verts[2][0]-verts[3][0]),
                                                                      y,
                                                                      0});
                verts = (double[][])Arrays.append(verts, new double[]{-verts[verts.length-1][0],
                                                                      y,
                                                                      0});

                int faces[][] = new int[0][0];
                mesh = new Mesh(verts, faces);

                // temporarily fudge to prevent degenerate edges on boundary
                mesh.getVert(3).setYnaive(mesh.getVert(3).Ynaive() - 1/4096.);
                mesh.getVert(8).setYnaive(mesh.getVert(8).Ynaive() - 1/4096.);
                delaunayize();

                if (false)
                {
                    // TODO: hmm, doing this makes the 3 vertical dual edges disappear-- should figure out why
                    mesh.getVert(3).setYnaive(mesh.getVert(3).Ynaive() + 1/4096.);
                    mesh.getVert(8).setYnaive(mesh.getVert(8).Ynaive() + 1/4096.);
                }
                // TODO: huh, Ynaive() works here, why doesn't it work during an 'f' afterwards?

                rescale(.25, .25);
            } // doCannedThingSweepKiller0

            // simple interesting example
            private void doCannedThingSimpleOutwardSweepKiller()
            {
                double verts[][] = {
                    {0.0, 0.0, 0.00125},
                    {-0.02657501261826368, 0.01647072793338322, 0},
                    {0.02755157511826369, 0.014779272066616748, 0},
                    {-9.765625E-4, -0.03125, 0},
                    {0.21650635094610934, -0.125, 0},
                    {-0.21650635094610934, -0.125, 0},
                    {0.0, 0.25, 0},
                    {-1.7320508075688772, 1, 1.48},
                    {1.7320508075688772, 1, 1.48},
                    {0.0, -2, 1.48},
                    {-0.02755157511826369, 0.014779272066616748, 0},
                    {0.02657501261826368, 0.01647072793338322, 0},
                    {9.765625E-4, -0.03125, 0},
                };
                mesh = new Mesh(verts, new int[][]{});
                delaunayize();
            } // doCannedThingSimpleOutwardSweepKiller

            // Counterexample to entire class of sweep algorithms
            // that cut each vertex to a higher vertex.
            // Slightly simpler than SweepKiller0.
            private void doCannedThingSweepKiller1()
            {
                double verts[][] = {
                    {0,0,0},
                    {9,-9,0},
                    {6,-3,0},
                    {7,24,0},
                    {-7,24,0},
                    {-6,-3,0},
                    {-9,-9,0},

                    {7,-6,0},
                    {3,-2,0},

                    {-3,-2,0},
                    {-7,-6,0},
                };
                int faces[][] = {
                    //{0,1,2},
                    {0,1,8},
                    {1,7,8},
                    {1,2,7},
                    {2,0,8},
                    {2,8,7},

                    //{6,0,5},
                    {0,5,9},
                    {0,9,6},
                    {5,10,9},
                    {5,6,10},
                    {9,10,6},

                    {1,3,2},
                    {2,3,0},
                    {0,3,4},
                    {0,4,5},
                    {4,6,5},
                    {0,6,1},
                    {1,6,4,3},
                };
                // argh, requires panning the whole picture around randomly a bit in order for it to come out symmetric...
                VecMath.mpv(verts, verts, new double[]{.1,.1,0});
                mesh = new Mesh(verts, faces);
                mesh.findAndApplyOptimalVertexHeights(Mesh.OPTIMIZE_LENGTHS_INFINITY_NORM);
                // XXX argh, still requires use to set Mesh.OPTIMIZE_LENGTHS_INFINITY_NORM and turn on and off Optimize, otherwise the dual picture is tiny... why??

                rescale(1./Math.sqrt(2.), 1./Math.sqrt(2.));

            } // doCannedThingSweepKiller1

            // SweepKiller1 separated into finite, eps, eps^, ...
            // This is where polynomials in infinitesimals would help.
            // And with target angles.
            //     alpha = smallest incident angle
            //     beta = "safety" past perpendicular for the bad cut
            //     spread = 3*alpha + beta
            // assuming eps is negligible,
            // on the RHS of the figure:
            //     the downward angle:
            //         -45 + alpha*3/2 + beta/2
            //     the upward angles:
            //          45 - alpha*3/2 + beta/2    (shallowest)
            //          45 - alpha/2   - beta/2    (medium)
            //          45 + alpha/2   - beta/2    (steepest)
            //
            // Dual verts:
            //     4         3
            //
            //          0
            //        57 86
            //       9     10
            //
            //    2           1
            private void doCannedThingSweepKiller1eps()
            {
                double eps = 1./16; // making very small doesn't hurt dual pic but makes primal pic more and more difficult to deal with
                // I did it with alpha,beta = 20 and 10.  20 makes pic nicer; can theoretically make it very small and slopes will approach 45 degrees.
                double alpha = DTOR(15.);
                double beta = DTOR(15.);
                double verts[][] = {
                    /* 0 */ {0, 0, 0},

                    // medium of 3 upward slopes
                    /* 1 */ { Math.tan(DTOR(45.)-alpha*3/2+beta/2), -1, 0},
                    /* 2 */ {-Math.tan(DTOR(45.)-alpha*3/2+beta/2), -1, 0},

                    // the downward slope
                    /* 3 */ { eps*Math.tan(DTOR(45.)-alpha/2-beta/2), eps, 0},
                    /* 4 */ {-eps*Math.tan(DTOR(45.)-alpha/2-beta/2), eps, 0},

                    // steepest of 3 upward slopes
                    /* 5 */ {-eps*eps*Math.tan(DTOR(45.)+alpha/2-beta/2) - eps*eps*eps, -eps*eps, Double.NaN},
                    /* 6 */ { eps*eps*Math.tan(DTOR(45.)+alpha/2-beta/2) + eps*eps*eps, -eps*eps, Double.NaN},

                    /* 7 */ {-eps*eps*Math.tan(DTOR(45.)+alpha/2-beta/2), -eps*eps, Double.NaN},
                    /* 8 */ { eps*eps*Math.tan(DTOR(45.)+alpha/2-beta/2), -eps*eps, Double.NaN},

                    // 7,8 + shallowest of 3 upward slopes
                    /* 9 */ {-eps*eps*Math.tan(DTOR(45.)+alpha/2-beta/2) - eps*eps*Math.tan(DTOR(45.)-alpha*3/2+beta/2) + eps*eps*eps, -eps*eps*2, Double.NaN},
                    /* 10 */ { eps*eps*Math.tan(DTOR(45.)+alpha/2-beta/2) + eps*eps*Math.tan(DTOR(45.)-alpha*3/2+beta/2) - eps*eps*eps, -eps*eps*2, Double.NaN},
                };
                // I just did it with various eps,alpha,beta and then tweaked heights til it worked.  not scientific.
                if (eps == 1./16 && alpha == DTOR(10.) && beta == DTOR(10.))
                {
                    verts[5][2] = verts[6][2] = -0.0031936645507812324;
                    verts[7][2] = verts[8][2] = -0.003109522123682717;
                    verts[9][2] = verts[10][2] = -0.005822657649931442;
                }
                else if (eps == 1./16 && alpha == DTOR(15.) && beta == DTOR(15.))
                {
                    verts[5][2] = verts[6][2] = -0.002963195800781224;
                    verts[7][2] = verts[8][2] = -0.0028790533736827166;
                    verts[9][2] = verts[10][2] = -0.005275782649931436;
                }
                else if (eps == 1./16 && alpha == DTOR(20.) && beta == DTOR(20.))
                {
                    verts[5][2] = verts[6][2] = -0.002822570800781228;
                    verts[7][2] = verts[8][2] = -0.002734522123682715;
                    verts[9][2] = verts[10][2] = -0.004916407649931435;
                }
                else if (eps == 1./17 && alpha == DTOR(15.) && beta == DTOR(15.)) // same heights as for 1/16, not as pretty but just wanted to test something
                {
                    verts[5][2] = verts[6][2] = -0.002822570800781228;
                    verts[7][2] = verts[8][2] = -0.002734522123682715;
                    verts[9][2] = verts[10][2] = -0.004916407649931435;
                }
                else
                {
                    CHECK(false);
                }
                int faces[][] = {
                    {0,3,4}, {3,0,6}, {4,3,1,2}, {0,4,5}, {1,0,2}, {0,1,10}, {2,0,9}, {6,1,3}, {1,6,10},
                    {5,4,2}, {5,2,9}, {0,5,7}, {5,9,7}, {10,6,8}, {6,0,8}, {0,10,8}, {7,9,0},
                };
                wrapAroundSphereFlagIntent.set(false);
                mesh = new Mesh(verts, faces);
            } // doCannedThingSweepKiller1eps



            // attempt to put lots of sweep killer 1's in a single picture.
            private void doCannedThingSweepKiller1epsMultiple(int nRows, int nCols, boolean willBeUsedForWrapLeftRight)
            {
                doCannedThingSweepKiller1eps();
                double verts0[][] = MeshUtils.getMeshVertsXYH(mesh);
                int nVerts0 = verts0.length;
                int faces0[][] = MeshUtils.getMeshFaces(mesh, true);
                double verticalPeriod = verts0[3][1] - verts0[1][1]; // on average
                double horizontalPeriod = verts0[1][0] + verts0[3][0];  // on average

                boolean staggerVertically = false; // TODO: probably just get rid of this

                verticalPeriod *= 1.5;

                if (staggerVertically)
                    horizontalPeriod *= 4;
                else
                    horizontalPeriod *= 3;

                double verts[][] = new double[nRows*nCols*(nVerts0+2)][]; // upper bound
                int nVerts = 0; // and counting
                FORI (iRow, nRows)
                FORI (iCol, nCols)
                {
                    FORI (iVert0, nVerts0)
                    {
                        verts[nVerts++] = new double[] {
                            verts0[iVert0][0] + (-nCols*.5 + (iCol+.5)) * horizontalPeriod,
                            verts0[iVert0][1] + (-nRows*.5 + (iRow+.5)) * verticalPeriod   + (staggerVertically ? ((iCol%2) * (verticalPeriod/2.)) : 0),
                            verts0[iVert0][2],
                        };
                    }
                }
                if (true) // use this even if staggering horizontally
                {
                    FORI (iRow, nRows-1)
                    FORI (iCol, nCols)
                        verts[nVerts++] = new double[] {
                            0. + (-nCols*.5 + (iCol+.5)) * horizontalPeriod,

                            //2*verts0[3][1] + (-nRows*.5 + (iRow+.5)) * verticalPeriod + (staggerVertically ? ((iCol%2) * (verticalPeriod/2.)) : 0),
                            3.5*verts0[3][1] + (-nRows*.5 + (iRow+.5)) * verticalPeriod + (staggerVertically ? ((iCol%2) * (verticalPeriod/2.)) : 0),
                            // note the 3.5 is fudge, to somewhat equalize lengths of vertical segments. might work only for current settings: alpha=beta=15 degrees, eps=1/16

                            0.,
                        };
                }
                if (!staggerVertically)
                {
                    FORI (iRow, nRows-1)
                    FORI (iCol, willBeUsedForWrapLeftRight ? nCols : nCols-1)
                        verts[nVerts++] = new double[] {
                            horizontalPeriod/2. + (-nCols*.5 + (iCol+.5)) * horizontalPeriod,
                            verts0[1][1]+verticalPeriod + (-nRows*.5 + (iRow+.5)) * verticalPeriod,
                            0.,
                        };
                }

                verts = (double[][])Arrays.subarray(verts, 0, nVerts);
                wrapAroundSphereFlagIntent.set(false);
                mesh = new Mesh(verts, faces0); // actually faces0 not necessary
                delaunayize();
            } // doCannedThingSweepKiller1epsMultiple()

            private void doCannedThingSweepKiller1epsMultiplePolar(int nRings, int ringSize)
            {
                // CBB: it delaunayizes, don't need to do that
                doCannedThingSweepKiller1epsMultiple(nRings,   // nRows
                                                     ringSize, // nCols
                                                     true);    // willBeUsedForWrapLeftRight

                int nVerts = mesh.verts.size();

                // hack to figure out x period... we know verts[11] is the origin offset by horizontalPeriod
                CHECK_GE(ringSize, 2);
                CHECK_EQ(mesh.getVert(11).y(), mesh.getVert(0).y());
                double xFullPeriod = (mesh.getVert(11).x() - mesh.getVert(0).x()) * ringSize;

                //Complex translateAtEnd = new Complex(0., -1.); // could make this a parameter
                Complex translateAtEnd = new Complex(0., 0.); // could make this a parameter

                FORI (iVert, nVerts)
                {
                    Mesh.Vertex vert = mesh.getVert(iVert);
                    double x = vert.x();
                    double y = vert.y();
                    double h = vert.h();
                    // The transformation is, in complex plane:
                    //     multiply by 2pi/xFullPeriod
                    //     multiply by -i
                    //     exponentiate
                    //     multiply by i
                    //     if ringSize is even, rotate by (pi/ringSize)
                    //     translate by -i
                    double fudgeAngle = Math.PI / ringSize;
                    Complex z = new Complex(x, y);
                    z
                     .timesEquals(2*Math.PI/xFullPeriod)
                     .timesEquals(Complex.MINUS_I)
                     .expEquals()
                     .timesEquals(Complex.I);
                    if (ringSize % 2 == 0)
                        z.timesEquals(Math.cos(fudgeAngle), Math.sin(fudgeAngle));
                    double magnitudeAfterExponentiating = z.abs();
                    z.plusEquals(translateAtEnd);
                    x = z.x;
                    y = z.y;

                    // Gotta do something to h to make it sort of equivalent.
                    // Just futzed around til it worked.

                    h *= SQR(2*Math.PI/xFullPeriod);
                    h *= SQR(magnitudeAfterExponentiating); // acts like consistently < 1 afterwards (all magenta)

                    // wtf? why am I needing this fudge?? found it by binary search.
                    // oh, I think maybe it's because of the difference between the primal and dual. hmm.

                    h /= 1.066666667; // = 16/15. not sure whether that has any significance.  note that eps is 1/16 ? hmm.  oh, and this starts working only when n=15 (and accidentally during alternate way) or n=16 (barely)... starts looking good by n=19.

                    //h /= 1.075; // sorta good. different shape. hmm. that's 43/40 or so. bleah, magic.  note that eps is 1/17 in this case. hmm.

                    vert.setxyh(x, y, h);
                }
                mesh.addIsolatedVertex(translateAtEnd.x, translateAtEnd.y, 0.);
                delaunayize();
            } // doCannedThingSweepKiller1epsMultiplePolar

            // Counterexample to the class of face sweep algorithms
            // in which each new face attaches to a previous one.
            private void doCannedThingFaceSweepKiller()
            {
                double verts[][] = {
                    {0.0, 0.0, -0.00852081528017131},
                    {-0.03125, -0.0625, -0.001011263580012437},
                    {0.03125, -0.0625, -0.001011263580012437},
                    {0.125, 0.25, -0.016180217280198993},
                    {-0.125, 0.25, -0.016180217280198993},
                    {0.5355693512828954, 0.3073584546624453, -0.07897059225184244},
                    {-0.5355693512828954, 0.3073584546624453, -0.07897059225184244},
                    {0.8069686188220531, 0.28509336823378756, -0.05025679343442235},
                    {-0.8069686188220531, 0.28509336823378756, -0.05025679343442235},
                    {0.0, 0.78125, 0.165},
                };
                mesh = new Mesh(verts, new int[][]{});
                delaunayize();
            } // doCannedThingFaceSweepKiller

            // Simpler counterexample to the class of face sweep algorithms
            // in which each new face attaches to a previous one.
            private void doCannedThingSimplerFaceSweepKiller()
            {
                double verts[][] = {
                    {0.0, 0.0, 0.0},
                    {-0.125, -0.5, 0.0},
                    {0.125, -0.5, 0.0},
                    {0.5, 0.25, 0.0},
                    {-0.5, 0.25, 0.0},
                    {0.59375, 0.2421875, 0},
                    {-0.59375, 0.2421875, 0},
                };
                mesh = new Mesh(verts, new int[][]{});
                delaunayize();
            } // doCannedThingFaceSweepKiller

            // Same, but with 2 extra vertices-- this one *does* have a good vertex sweep oriented unfolding.
            private void doCannedThingSimplerFaceSweepKillerNotVertexSweepKiller()
            {
                double verts[][] = {
                    {0.0, 0.0, 0.0},
                    {-0.125, -0.5, 0.0},
                    {0.125, -0.5, 0.0},
                    {0.5, 0.25, 0.0},
                    {-0.5, 0.25, 0.0},
                    {0.59375, 0.2421875, 0},
                    {-0.59375, 0.2421875, 0},
                    {0.6341760000748309, 0.24615384615384617, 0.0},
                    {-0.6341760000748309, 0.24615384615384617, 0.0},
                };
                mesh = new Mesh(verts, new int[][]{});
                delaunayize();
            }

            // This one forces a downward slope of -2 (and can be easily modified
            // to any steepness)
            private void doCannedThingSteepKiller()
            {
                double verts[][] = {
                    {0.,0.},
                    {1.,-4.},
                    {-1.,-4.},
                    {27.,9.},
                    {-27.,9.},
                };
                VecMath.mxs(verts, verts, 1./64);
                mesh = new Mesh(verts, new int[][]{});
                delaunayize();
            } // doCannedThingSteepKiller

            // Stress outward sweep, in slightly spiral way.
            private void doCannedThingOutStressorSpiral(int nVertsWanted)
            {
                //double heightScaleFactor4 = 3; // too big, changes topology
                //double heightScaleFactor4 = 2.25; // pretty good
                //double heightScaleFactor4 = 2.2;
                double heightScaleFactor4 = 2.15;
                //double heightScaleFactor4 = 2.1;
                //double heightScaleFactor4 = 2.01; // anything above 2 works

                double verts[][] = new double[nVertsWanted][];
                int nVerts = 0;

                if (nVerts < verts.length) verts[nVerts++] = new double[]{0,0,-0.1534374,1.}; // nice for heightScaleFactor4=2.15 because all 8 inner edges are tangent to sphere at some time, and inner 8 verts are clearly closest to origin

                if (nVerts < verts.length) verts[nVerts++] = new double[]{1,0,-1.,1.};
                if (nVerts < verts.length) verts[nVerts++] = new double[]{-1,-1,-Math.pow(heightScaleFactor4, .5),1.};
                while (nVerts < verts.length)
                {
                    verts[nVerts] = new double[] {
                        verts[nVerts-2][1] * -2,
                        verts[nVerts-2][0] * 2,
                        verts[nVerts-2][2] * heightScaleFactor4,
                        1.,
                    };
                    nVerts++;
                }
                CHECK_EQ(nVerts, verts.length);
                mesh = new Mesh(verts, new int[][]{});
                delaunayize();

                if (true)
                {
                    rescalePrimalOnly(4./Math.pow(2., nVertsWanted*.5));
                    rescaleDualOnly(1./8);
                }
            }

            // Stress outward sweep.
            // Heights were figured out empirically.
            private void doCannedThingOutStressor(int nLevels)
            {
                //double dualScaleFactor4 = 4; // this gives what I drew on graph paper
                //double dualScaleFactor4 = 3.5;
                double dualScaleFactor4 = 3.25;
                //double dualScaleFactor4 = 3; // this gives more tightly spaced rings in dual
                //double dualScaleFactor4 = 2.9; // very tight
                //double dualScaleFactor4 = 2.85; // ridiculously tight
                //double dualScaleFactor4 = 2.84; // even tighter
                //double dualScaleFactor4 = 2.83; // even tighter
                //double dualScaleFactor4 = 2.829; // even tighter
                //double dualScaleFactor4 = 2.8285; // superdupertight
                //double dualScaleFactor4 = 2.82845; // even tighter
                //double dualScaleFactor4 = 2.82843; // even tighter
                //double dualScaleFactor4 = 2.828428; // even tighter
                //double dualScaleFactor4 = 2.8284275; // even tighter-- 40 zooms to get full screen
                //double dualScaleFactor4 = 2.8284272; // 45 zooms
                //double dualScaleFactor4 = 2.82842715; // 48 zooms
                //double dualScaleFactor4 = 2.82842713; // 53 zooms
                //double dualScaleFactor4 = 2.828427125; // 61 zooms and getting confused about backfaces
                //double dualScaleFactor4 = 2.8284271248; // 66 zooms
                //double dualScaleFactor4 = 2.82842712475; // 73 zooms
                //double dualScaleFactor4 = 2.828427124747;
                //double dualScaleFactor4 = 2.8284271247465;
                //double dualScaleFactor4 = 2.8284271247462;
                //double dualScaleFactor4 = 2.828427124746195; // 93 zooms
                //double dualScaleFactor4 = 2.828427124746192;
                //double dualScaleFactor4 = 2.828427124746191;
                //double dualScaleFactor4 = 2.8284271247461907;
                //double dualScaleFactor4 = 2.8284271247461906;
                //double dualScaleFactor4 = 2.82842712474619055;
                //double dualScaleFactor4 = 2.82842712474619052; // 99 or so zooms
                //double dualScaleFactor4 = 2.828427124746190515; // 99 or so zooms
                CHECK_EQ(2.828427124746190515, 2.82842712474619052); // oh! it's sqrt(8)
                CHECK_EQ(2.8284271247461905, 2.82842712474619051);
                //double dualScaleFactor4 = 2.82842712474619051; // too small
                //double dualScaleFactor4 = 2.8284271247461905; // too small
                //double dualScaleFactor4 = 2.82842712474619; // too small
                //double dualScaleFactor4 = 2.82842712474618; // too small
                //double dualScaleFactor4 = 2.82842712474617; // too small
                //double dualScaleFactor4 = 2.82842712474615; // too small
                //double dualScaleFactor4 = 2.8284271247461; // too small
                //double dualScaleFactor4 = 2.828427124746; // too small
                //double dualScaleFactor4 = 2.828427124745; // too small
                //double dualScaleFactor4 = 2.82842712474; // too small
                //double dualScaleFactor4 = 2.82842712473; // too small
                //double dualScaleFactor4 = 2.82842712472; // too small
                //double dualScaleFactor4 = 2.8284271247; // too small
                //double dualScaleFactor4 = 2.8284271245; // too small
                //double dualScaleFactor4 = 2.828427124; // too small
                //double dualScaleFactor4 = 2.828427123; // too small
                //double dualScaleFactor4 = 2.828427122; // too small
                //double dualScaleFactor4 = 2.82842712; // too small
                //double dualScaleFactor4 = 2.8284271; // too small
                //double dualScaleFactor4 = 2.828427; // too small
                //double dualScaleFactor4 = 2.828425; // too small
                //double dualScaleFactor4 = 2.82842; // too small
                //double dualScaleFactor4 = 2.8284; // too small
                //double dualScaleFactor4 = 2.828; // too small
                //double dualScaleFactor4 = 2.8275; // too small
                //double dualScaleFactor4 = 2.825; // too small
                //double dualScaleFactor4 = 2.82; // too small
                //double dualScaleFactor4 = 2.8;
                //double dualScaleFactor4 = 2.75;
                //double dualScaleFactor4 = 2.5; too small

                double verts[][] = new double[1+nLevels*4][];
                int nVerts = 0;

                // TODO: this isn't quite right for adjusted dualScaleFactor4 (isn't even right for =4)
                // I think what I want is the smallest hexagon to be same shape as all the others.

                // Tuning for dualScaleFactor4=4...
                //verts[nVerts++] = new double[]{0,0,3/8.,1}; // edge length too big
                //verts[nVerts++] = new double[]{0,0,.3,1}; // little too big
                //verts[nVerts++] = new double[]{0,0,.275,1}; // little too big
                //verts[nVerts++] = new double[]{0,0,.27,1}; // pretty good

                // Tuning for dualScaleFactor4=3.25...
                //verts[nVerts++] = new double[]{0,0,.1,1.}; // edge length too big
                verts[nVerts++] = new double[]{0,0,.075,1.};  // edge length pretty good
                //verts[nVerts++] = new double[]{0,0,.05,1.}; // edge length too small
                //verts[nVerts++] = new double[]{0,0,0,1}; // edge length too small

                FORI (iLevel, nLevels)
                {
                    if (iLevel == 0)
                    {
                        verts[nVerts++] = new double[]{1,0,-3/4.,1.};
                        verts[nVerts++] = new double[]{0,1,-3/4.,1.};
                        verts[nVerts++] = new double[]{-1,0,-3/4.,1.};
                        verts[nVerts++] = new double[]{0,-1,-3/4.,1.};
                    }
                    else if (iLevel == 1)
                    {
                        verts[nVerts++] = new double[]{2,2,-3/4.*dualScaleFactor4,1.};
                        verts[nVerts++] = new double[]{-2,2,-3/4.*dualScaleFactor4,1.};
                        verts[nVerts++] = new double[]{-2,-2,-3/4.*dualScaleFactor4,1.};
                        verts[nVerts++] = new double[]{2,-2,-3/4.*dualScaleFactor4,1.};
                    }
                    else
                    {
                        FORI (i, 4)
                        {
                            verts[nVerts] = new double[] {
                                verts[nVerts-8][0] * 8,
                                verts[nVerts-8][1] * 8,
                                verts[nVerts-4][2] * dualScaleFactor4,
                                1.,
                            };
                            nVerts++;
                        }
                    }
                }
                CHECK_EQ(nVerts, verts.length);

                mesh = new Mesh(verts, new int[][]{});
                delaunayize();

                if (true)
                {
                    // Hmm, primal is WAY bigger than dual, and that makes the outermost quill tiny (actually sloped way down), the way it's currently calculated.
                    // Let's adjust (empirically) so it's all more reasonable.

                    // Unfortunately delaunayize messes up when things are that tiny,
                    // so do this after the delaunayize.
                    // TODO: find out why that happens!  I thought I was using tol=0 for convex hull which means it should be accurate near 0? or maybe I'm doing some ill-concieved bounding box translation down inside it
                    rescalePrimalOnly(64./Math.pow(2., nLevels*1.5));
                    //rescaleDualOnly(4./Math.pow(2., nLevels*.5));
                    //rescaleDualOnly(.25);
                    //rescaleDualOnly(.5);
                    rescaleDualOnly(.6);
                }

            } // doCannedThingOutStressor

            // Counterexample to entire class of sweep algorithms
            // that cut each vertex to a higher vertex.
            // Slightly simpler than SweepKiller1.
            // XXX but does it really work? Looking at it again, it seems to me it doesn't force the side vert out, so it doesn't work.
            // XXX and in fact it looks like it can't be fixe by adjusting heights, since the center of the whole cluster
            // XXX is always in line with the exit we'd need to make bad.
            private void doCannedThingSweepKiller2()
            {
                double verts[][] = {
                    {0,0,0},
                    {9,-9,0},
                    {6,-3,0},
                    {7,24,0},
                    {-7,24,0},
                    {-6,-3,0},
                    {-9,-9,0},
                    {3,-2,0},
                    {-3,-2,0},
                };

                int faces[][] = {
                    {0,1,7},
                    {1,2,7},
                    {2,0,7},

                    {0,5,8},
                    {0,8,6},
                    {5,6,8},

                    {1,3,2},
                    {2,3,0},
                    {0,3,4},
                    {0,4,5},
                    {4,6,5},
                    {0,6,1},
                    {1,6,4,3},
                };
                // argh, requires panning the whole picture around randomly a bit in order for it to come out symmetric...
                VecMath.mpv(verts, verts, new double[]{.1,.1,0});
                mesh = new Mesh(verts, faces);
                mesh.findAndApplyOptimalVertexHeights(Mesh.OPTIMIZE_LENGTHS_INFINITY_NORM);
                // XXX argh, still requires use to set Mesh.OPTIMIZE_LENGTHS_INFINITY_NORM and turn on and off Optimize, otherwise the dual picture is tiny... why??

                rescale(Math.sqrt(.5)*.5, Math.sqrt(.5)*.5);

            } // doCannedThingSweepKiller2


            // VecMath.synopsis might be brain damaged, not sure... try simpler way
            static double simpleSynopsis(int n, double v[])
            {
                FORI (i, n)
                    if (v[i] <= 0) // non-strict so we do it this way if on the boundary of the positive orthant
                    {
                        //
                        // Outside the positive orthant,
                        // return minus the euclidean distance
                        // to the positive orthant.
                        //
                        double sum = 0.;
                        for (; i < n; i++)
                            if (v[i] < 0.)
                                sum += v[i]*v[i];
                        return -Math.sqrt(sum);
                    }
                //
                // Inside the positive orthant, return the min.
                //
                return VecMath.min(n, v);
            } // simpleSynopsis

            // XXX should put this into VecMath, I think?
            // For two vars, the graph should look like this
            // (the diagonals are actually quarter-circles):
            //   | | | | | |               //
            //   | | | | | +               //
            //   | | | | |  \              //
            //   | | | | |   \             //
            //   | | | | |    \            //
            //   | | | | +     \           //
            //   | | | |  \     \          //
            //   | | | |   \     +-        //
            //   | | | |    \              //
            //   | | | +     +-----        //
            //   | | |  \                  //
            //   | | |   +---------        //
            //   | | |                     //
            //   + + +-------------        //
            //    \ \                      //
            //     \ +-------------        //
            //      \                      //
            //       +-------------        //
            // It's differentiable everywhere except at 0.
            // (non-differentiability at 0 is unavoidable
            // if we want scale-invariance).
            // XXX DOESN'T WORK-- see bottom of function body
            static double synopsis(int n, double v[])
            {
                double min = Double.POSITIVE_INFINITY;
                FORI (i, n)
                {
                    double x = v[i];
                    if (x <= 0) // non-strict so we do it this way if on the boundary of the positive orthant
                    {
                        //
                        // Outside the positive orthant,
                        // return minus the euclidean distance
                        // to the positive orthant.
                        //
                        double sum2 = 0.;
                        for (; i < n; i++)
                            if (v[i] < 0.)
                                sum2 += v[i]*v[i];
                        return -Math.sqrt(sum2);
                    }
                    min = MIN(min, x);
                }

                // All are positive.
                // The ones that participate are those that are < twice the smallest.
                // Call those x0,x1,...
                // We want to solve:
                //     (2*q-x0)^2 + (2*q-x1)^2 + (2*q-x2)^2 + ... = q^2
                //     n*4*q^2 - 4*q*(x0 + x1 + ...) + (x0^2 + x1^2 + ...) = q^2
                //     (4*n-1)*q^2 - 4*q*(x0 + x1 + ...) + (x0^2 + x1^2 + ...) = 0
                // Using the quadratic formula with:
                //       a = 4*n-1
                //       b = -4*(x0+x1+...)
                //       c = x0^2 + x1^2 + ...
                // The solution is
                // (we want the bigger of the two possibilities, so + rather than -):
                //       q = (-b + sqrt(b^2 - 4*a*c) / (2*a)
                //         = (4*(x0+...) + sqrt((4*(x0+...))^2 - 4*(4*n-1)*(x0^2+...)) / (2*(4*n-1))
                //         = (2*(x0+...) + sqrt((2*(x0+...))^2 - (4*n-1)*(x0^2+...)) / (4*n-1)
                // check, if just one var (n=1), q should be x0:
                //       q = (2*x0 + sqrt(4*x0^2 - 3*x0^2)) / 3
                //         = (2*x0 + x0) / 3
                //         = x0  check.
                int nParticipants = 0;
                double sum1 = 0.;
                double sum2 = 0.;
                FORI (i, n)
                {
                    double x = v[i];
                    if (x < 2*min)
                    {
                        PRINT(x);
                        nParticipants++;
                        sum1 += x;
                        sum2 += x*x;
                    }
                }
                if (nParticipants == 1)
                    return min;
                double discr = SQR(2*sum1) - (4*nParticipants-1)*sum2;
                PRINTVEC((double[])Arrays.subarray(v,0,n));
                PRINT(min);
                PRINT(sum1);
                PRINT(sum2);
                PRINT(discr);
                PRINT(nParticipants);
                //CHECK_GE(discr, 0.); // should be safely so (should be at least sum2)... can we reformulate to make that obvious?  no wait, that's not even right :-(  may need to go back to the drawing board on this whole thing
                //CHECK(GEQ(discr, 0., 5.549966375204551E-4)); // TODO: use or write an assert variation
                //CHECK(GEQ(discr, 0., 5.549966375204551E-4)); // TODO: use or write an assert variation
                //CHECK(GEQ(discr, 0., 0.004241588576413768)); // TODO: use or write an assert variation
                CHECK(GEQ(discr, 0., 0.007445722649008779)); // TODO: use or write an assert variation
                if (discr < 0.) discr = 0.; // FUDGE

                double q = (2*sum1 + Math.sqrt(discr)) / (4*nParticipants-1);
                return q;
            } // synopsis









            // General optimization:
            // maximize the minimum over:
            //     - length of each primal edge
            //     - length of each finite dual edge
            //     - 1-length of each primal edge
            //     - 1-length of each finite dual edge
            //     - a set of specified goodness-of-balances
            //
            // can constrain three vertex heights to be zero, I think, and one vertex position
            // (and maybe one coord of a second vertex's position)
            //
            private static class GeneralOptimizationStuff
            {
                private static void getMeshVertCoords(Mesh mesh, double coords[/*nVerts*/][/*3*/])
                {
                    FORI (iVert, coords.length)
                    {
                        Mesh.Vertex v = mesh.getVert(iVert);
                        coords[iVert][0] = v.Xnaive();
                        coords[iVert][1] = v.Ynaive();
                        coords[iVert][2] = v.Hnaive();
                    }
                }

                private static void vertsToDualMomentsAndAreas(double primalCoords[/*nVerts*/][/*3*/],
                                                               int tris[/*nDualVerts*/][/*3*/],
                                                               double dualMomentsAndAreas[/*nDualVerts*/][/*3*/],
                                                               boolean wrapAroundSphereFlagValue,
                                                               boolean centerSphereFlagValue,
                                                               double wrapSphereCurvatureValue)
                {
                    FORI (iDualVert, dualMomentsAndAreas.length)
                    {
                        int tri[] = tris[iDualVert];
                        double A[] = primalCoords[tri[0]];
                        double B[] = primalCoords[tri[1]];
                        double C[] = primalCoords[tri[2]];
                        GeomUtils.SolveForDualMomentAndArea(A[0],A[1],A[2],
                                                            B[0],B[1],B[2],
                                                            C[0],C[1],C[2],
                                                            dualMomentsAndAreas[iDualVert],
                                                            wrapAroundSphereFlagValue,
                                                            centerSphereFlagValue,
                                                            wrapSphereCurvatureValue);
                    }
                }

                private static void momentsAndAreasToCoords(double momentsAndAreas[][/*3*/],
                                                            double coordss[][/*2*/])
                {
                    FORI(i, momentsAndAreas.length)
                    {
                        double momentAndArea[/*3*/] = momentsAndAreas[i];
                        double coords[/*2*/] = coordss[i];
                        double A = momentAndArea[2];
                        if (A == 0.)
                        {
                            coords[0] = 0.;
                            coords[1] = 0.;
                        }
                        else
                        {
                            coords[0] = momentAndArea[0] / A;
                            coords[1] = momentAndArea[1] / A;
                        }
                    }
                }

                // params are:
                //     dist from x0,y0 to x1,y1
                //     x2
                //     y2
                //     x3,y3,h3
                //     x4,y4,h4
                //     ...
                // fixed:
                //     x0
                //     y0
                //     h0
                //     direction from x0,y0 to x1,y1
                //     h1
                //     h2
                private static double[] vertsToParams(double verts[][/*3*/])
                {
                    double params[] = new double[verts.length*3 - 6];
                    // verts to params...
                    int iParam = 0;
                    double x0, y0, h0, x1, y1, h1, h2; // XXX could store these so paramsToVerts doesn't have to keep looking them up
                    FORI (iVert, verts.length)
                    {
                        double v[] = verts[iVert];
                        if (iVert == 0)
                        {
                            x0 = v[0];
                            y0 = v[1];
                            h0 = v[2];
                        }
                        else if (iVert == 1)
                        {
                            params[iParam++] = MyMath.hypot(v[0]-verts[0][0], v[1]-verts[0][1]);
                            x1 = v[0];
                            y1 = v[1];
                            h1 = v[2];
                        }
                        else if (iVert == 2)
                        {
                            params[iParam++] = v[0];
                            params[iParam++] = v[1];
                            h2 = v[2];
                        }
                        else
                        {
                            params[iParam++] = v[0];
                            params[iParam++] = v[1];
                            params[iParam++] = v[2];
                        }
                    }
                    PRINT(params.length);
                    PRINT(iParam);
                    CHECK_EQ(iParam, params.length);
                    return params;
                }


                // needs to be fast-- no memory allocations
                private static void paramsToVerts(Mesh primal, // for verts that are fixed
                                                  double params[], double verts[][])
                {
                    PRINT(verts.length);
                    PRINT(params.length);
                    CHECK_EQ(params.length, verts.length*3 - 6);
                    int iParam = 0;

                    Mesh.Vertex v0 = primal.getVert(0);
                    Mesh.Vertex v1 = primal.getVert(1);
                    Mesh.Vertex v2 = primal.getVert(2);

                    verts[0][0] = v0.Xnaive();
                    verts[0][1] = v0.Ynaive();
                    verts[0][2] = v0.Hnaive();
                    double origDist01 = MyMath.hypot(v1.Xnaive()-v0.Xnaive(), v1.Ynaive()-v0.Ynaive());
                    verts[1][0] = v0.Xnaive() + (v1.Xnaive()-v0.Xnaive())/origDist01 * params[iParam];
                    verts[1][1] = v0.Ynaive() + (v1.Ynaive()-v0.Ynaive())/origDist01 * params[iParam];
                    iParam++;
                    verts[1][2] = v1.Hnaive();

                    verts[2][0] = params[iParam++];
                    verts[2][1] = params[iParam++];
                    verts[2][2] = v2.Hnaive();

                    for (int iVert = 3; iVert < verts.length; ++iVert)
                    {
                        verts[iVert][0] = params[iParam++];
                        verts[iVert][1] = params[iParam++];
                        verts[iVert][2] = params[iParam++];
                    }
                    CHECK_EQ(iParam, params.length);
                } // paramsToVerts

                private static String[] getParamNames(int nVerts)
                {
                    int iParam = 0;
                    String paramNames[] = new String[nVerts * 3 - 6];
                    paramNames[iParam++] = "dist01";
                    paramNames[iParam++] = "x2";
                    paramNames[iParam++] = "y2";
                    for (int iVert = 3; iVert < nVerts; ++iVert)
                    {
                        paramNames[iParam++] = "x"+iVert;
                        paramNames[iParam++] = "y"+iVert;
                        paramNames[iParam++] = "h"+iVert;
                    }
                    CHECK_EQ(iParam, paramNames.length);
                    return paramNames;
                } // getParamNames




                // Returns the optimization path, better and better verts,
                // and the associated goodnesses.
                public static Object[/*2*/] optimizeVerts(
                    final Mesh primal,
                    final int fromsAndTosTris[][/*2*/][][/*3*/],
                    final int toLeftOfEdgeEndIndices[][/*2*/],
                    final boolean mustBeFarthestExit[],
                    final boolean considerEdgeLengths, // XXX we don't handle this correctly-- we hard-code ignoring the 1-edgelength thing. need to figure out why, I thought that was necessary to prevent edge lengths from growing without bound???
                    final int nPasses,
                    final int maxCallsPerPass,
                    final double initialDelta,
                    final boolean wrapAroundSphereFlagValue,
                    final boolean centerSphereFlagValue,
                    final double wrapSphereCurvatureValue,
                    java.util.Random randomNumberGenerator)
                {
                    CHECK_EQ(fromsAndTosTris.length, toLeftOfEdgeEndIndices.length);
                    CHECK_EQ(mustBeFarthestExit.length, toLeftOfEdgeEndIndices.length);

                    final Mesh dual = Mesh.makeDualMesh(primal,
                                                        false, // includeNonArity3
                                                        false, // includeInsideOut
                                                        /*zeroVerts=*/false,
                                                        wrapAroundSphereFlagValue,
                                                        centerSphereFlagValue,
                                                        wrapSphereCurvatureValue);
                    final int nVerts = primal.verts.size();
                    final int nDualVerts = dual.verts.size();
                    final int nEdges = primal.edges.size();
                    CHECK_EQ(nEdges, dual.edges.size());

                    final int tris[][/*3*/] = new int[nDualVerts][3];
                    {
                        FORI (iEdge, nEdges)
                        {
                            Mesh.Edge dualEdge = dual.getEdge(iEdge);
                            Mesh.Vertex dualVert = dualEdge.finalVertex();
                            if (dualVert != null)
                            {
                                int iDualVert = dualVert.myIndex();

                                // Only do it if initial vertex is smallest indexed on the triangle.
                                // This avoids calculating the same vertex 3 times,
                                // and it also guarantees that the triangle will be in canonical order
                                // (smallest index first).
                                Mesh.Edge primalEdge = primal.getEdge(iEdge);
                                int i = primalEdge.initialVertex().myIndex();
                                int j = primalEdge.next().initialVertex().myIndex();
                                int k = primalEdge.prev().initialVertex().myIndex();
                                if (i < j && i < k)
                                {
                                    int tri[] = tris[iDualVert];
                                    CHECK_EQ(tri[0], 0);
                                    CHECK_EQ(tri[1], 0);
                                    CHECK_EQ(tri[2], 0);
                                    tri[0] = i;
                                    tri[1] = j;
                                    tri[2] = k;
                                }
                            }
                        }
                        FORI (iTri, tris.length)
                            CHECK_NE_NE(tris[iTri][1], 0, tris[iTri][2]);
                    }

                    java.util.HashMap<String,Integer> triToIndex = new java.util.HashMap<String,Integer>();
                    FORI (iTri, tris.length)
                    {
                        int tri[] = tris[iTri];
                        // really only first two are necessary, but third is sanity check
                        triToIndex.put(""+tri[0]+" "+tri[1]+" "+tri[2], iTri);
                    }

                    final int fromsAndTosInds[][/*2*/][] = new int[fromsAndTosTris.length][2][];
                    FORI (iFromAndTo, fromsAndTosTris.length)
                        FORI (iFromOrTo, 2)
                        {
                            int fromOrToTris[][] = fromsAndTosTris[iFromAndTo][iFromOrTo];
                            int fromOrToInds[] = new int[fromOrToTris.length];
                            FORI(iTri, fromOrToTris.length)
                            {
                                int tri[] = fromOrToTris[iTri];
                                Integer ind = triToIndex.get(""+tri[0]+" "+tri[1]+" "+tri[2]);
                                CHECK_NE(ind, null);
                                fromOrToInds[iTri] = ind.intValue();
                            }
                            fromsAndTosInds[iFromAndTo][iFromOrTo] = fromOrToInds;
                        }


                    final double scratchVerts[][] = new double[nVerts][3];
                    final double scratchDualMomentsAndAreas[][] = new double[nDualVerts][3]; // x*A,y*A,A
                    final double scratchDualVerts[][] = new double[nDualVerts][2]; // x,y

                    getMeshVertCoords(primal, scratchVerts);
                    vertsToDualMomentsAndAreas(scratchVerts, tris, scratchDualMomentsAndAreas, wrapAroundSphereFlagValue, centerSphereFlagValue, wrapSphereCurvatureValue);


                    double initialGuessParams[] = vertsToParams(scratchVerts);
                    int nParams = initialGuessParams.length;

                    {
                        // Sanity check-- convert back to verts, should get original verts again
                        double shouldBeScratchVerts[][] = new double[nVerts][3];
                        paramsToVerts(primal, initialGuessParams, shouldBeScratchVerts);
                        PRINTMAT(scratchVerts);
                        PRINTVEC(initialGuessParams);
                        PRINTMAT(shouldBeScratchVerts);
                        PRINTMAT(VecMath.mmm(shouldBeScratchVerts, scratchVerts));
                        CHECK(VecMath.equals(shouldBeScratchVerts, scratchVerts, 1e-6));
                    }

                    final double saveBestParams[] = new double[nParams];
                    final double saveBestValue[] = {Double.POSITIVE_INFINITY};
                    final java.util.ArrayList<double[][]> optimizationPathList = new java.util.ArrayList<double[][]>();
                    final DoubleArrayList optimizationPathGoodnessesList = new DoubleArrayList();
                    final int iPassFinal[] = new int[1]; // just so fun can see iPass

                    Minimizer.VectorFunction fun = new Minimizer.VectorFunction() {
                        // VectorFunction interface
                        public double apply(double params[])
                        {
                            System.out.println("    in apply()");
                            System.out.println("        iPass="+iPassFinal[0]+"/"+nPasses);
                            paramsToVerts(primal, params, scratchVerts);
                            vertsToDualMomentsAndAreas(scratchVerts, tris, scratchDualMomentsAndAreas, wrapAroundSphereFlagValue, centerSphereFlagValue, wrapSphereCurvatureValue);
                            momentsAndAreasToCoords(scratchDualMomentsAndAreas, scratchDualVerts);


                            int nGoodness = 2*primal.edges.size()
                                          + 2*primal.edges.size() // at most this many dual edge constraints
                                          + fromsAndTosTris.length;
                            double goodnessVector[] = new double[nGoodness];
                            int iGoodness = 0;

                            System.out.println("    -----------------------");

                            if (considerEdgeLengths) // considering edge lengths seems to prevent some nice optimization paths.  hmm.  (it might be just the 1-edgelength component though)
                            {
                                // Edge lengths...
                                FORI (iEdge, nEdges)
                                {
                                    Mesh.Edge edge = primal.getEdge(iEdge);
                                    int i0 = edge.initialVertex().myIndex();
                                    int i1 = edge.finalVertex().myIndex();
                                    if (i0 < i1) // canonical order only
                                    {
                                        double edgeLength = MyMath.hypot(scratchVerts[i1][0]-scratchVerts[i0][0],
                                                                         scratchVerts[i1][1]-scratchVerts[i0][1]);
                                        System.out.println("        primal edge "+i0+"->"+i1+": "+edgeLength+"");
                                        goodnessVector[iGoodness++] = edgeLength;
                                        //goodnessVector[iGoodness++] = 1. - edgeLength; // XXX needs to be a legit parameter
                                    }
                                }
                            }

                            if (true)
                            {
                                // Dual edge lengths...
                                FORI (iEdge, nEdges)
                                {
                                    Mesh.Edge dualEdge = dual.getEdge(iEdge);
                                    Mesh.Vertex dv0 = dualEdge.initialVertex();
                                    Mesh.Vertex dv1 = dualEdge.finalVertex();
                                    if (dv0 == null || dv1 == null)
                                        continue; // not a finite edge
                                    int dv0i = dv0.myIndex();
                                    int dv1i = dv1.myIndex();
                                    if (dv1i < dv0i)
                                        continue; // not in canonical order
                                    double dualEdgeVecX = scratchDualVerts[dv1i][0] - scratchDualVerts[dv0i][0];
                                    double dualEdgeVecY = scratchDualVerts[dv1i][1] - scratchDualVerts[dv0i][1];


                                    Mesh.Edge primalEdge = primal.getEdge(iEdge);
                                    int pv0i = primalEdge.initialVertex().myIndex();
                                    int pv1i = primalEdge.finalVertex().myIndex();
                                    double edgeDirX = scratchVerts[pv1i][0] - scratchVerts[pv0i][0];
                                    double edgeDirY = scratchVerts[pv1i][1] - scratchVerts[pv0i][1];
                                    double edgeLength = MyMath.hypot(edgeDirX, edgeDirY);
                                    CHECK_NE(edgeLength, 0.);
                                    double invEdgeLength = 1./edgeLength;
                                    edgeDirX *= invEdgeLength;
                                    edgeDirY *= invEdgeLength;
                                    double dualEdgeDirX = -edgeDirY;
                                    double dualEdgeDirY =  edgeDirX;

                                    double dualEdgeLength = dualEdgeVecX*dualEdgeDirX
                                                          + dualEdgeVecY*dualEdgeDirY;

                                    System.out.println("        dual edge "+pv0i+"->"+pv1i+": "+dualEdgeLength+"");
                                    double dualEdgeMinLength = .05; // setting to > 0 keeps dual edge length constraints from jamming into corner with other constraints
                                    goodnessVector[iGoodness++] = dualEdgeLength - dualEdgeMinLength;
                                    goodnessVector[iGoodness++] = 1. - dualEdgeLength;
                                }
                            }

                            if (true)
                            {
                                // General froms and tos...

                                FORI (iFromAndTo, fromsAndTosTris.length)
                                {
                                    int fromAndTo[/*2*/][] = fromsAndTosInds[iFromAndTo];

                                    double v0[] = scratchVerts[toLeftOfEdgeEndIndices[iFromAndTo][0]];
                                    double v1[] = scratchVerts[toLeftOfEdgeEndIndices[iFromAndTo][1]];
                                    double edgeDirX = v1[0] - v0[0];
                                    double edgeDirY = v1[1] - v0[1];
                                    double edgeLength = MyMath.hypot(edgeDirX, edgeDirY);
                                    CHECK_NE(edgeLength, 0.);
                                    double invEdgeLength = 1./edgeLength;
                                    edgeDirX *= invEdgeLength;
                                    edgeDirY *= invEdgeLength;
                                    double dualEdgeDirX = -edgeDirY;
                                    double dualEdgeDirY =  edgeDirX;


                                    double fromCenterX = 0.;
                                    double fromCenterY = 0.;
                                    double toCenterX = 0.;
                                    double toCenterY = 0.;
                                    FORI (iFromOrTo, 2)
                                    {
                                        int fromOrTo[] = fromAndTo[iFromOrTo];
                                        double totalMomentX = 0.;
                                        double totalMomentY = 0.;
                                        double totalArea = 0.;
                                        FORI (i, fromOrTo.length)
                                        {
                                            double dualVertMomentAndArea[/*3*/] = scratchDualMomentsAndAreas[fromOrTo[i]];
                                            totalMomentX += dualVertMomentAndArea[0];
                                            totalMomentY += dualVertMomentAndArea[1];
                                            totalArea += dualVertMomentAndArea[2];
                                        }
                                        if (iFromOrTo == 0)
                                        {
                                            fromCenterX = totalMomentX / totalArea;
                                            fromCenterY = totalMomentY / totalArea;
                                        }
                                        else
                                        {
                                            toCenterX = totalMomentX / totalArea;
                                            toCenterY = totalMomentY / totalArea;
                                        }
                                    }
                                    double goodness = (toCenterX-fromCenterX)*dualEdgeDirX
                                                    + (toCenterY-fromCenterY)*dualEdgeDirY;
                                    System.out.println("        another goodness: "+goodness);
                                    goodnessVector[iGoodness++] = goodness;

                                    if (true)
                                    {
                                        if (mustBeFarthestExit[iFromAndTo])
                                        {
                                            int from[] = fromAndTo[0];
                                            CHECK_EQ(from.length, 1);
                                            int desiredFarthestDualVertIndex = from[0];

                                            double thisDist2fromCenter = -1.;
                                            double largestOtherDist2fromCenter = -1.;
                                            int to[] = fromAndTo[1];
                                            FORI (iTo, to.length)
                                            {
                                                int iDualVert = to[iTo];
                                                double dualVert[] = scratchDualVerts[iDualVert];
                                                double dist2fromCenter = SQR(dualVert[0]-toCenterX)
                                                                       + SQR(dualVert[1]-toCenterY);
                                                if (iDualVert == desiredFarthestDualVertIndex)
                                                    thisDist2fromCenter = dist2fromCenter;
                                                else
                                                    largestOtherDist2fromCenter = MAX(largestOtherDist2fromCenter, dist2fromCenter);
                                            }
                                            CHECK_GE(thisDist2fromCenter, 0.);
                                            CHECK_GE(largestOtherDist2fromCenter, 0.); // i.e. lagoon size must be >= 2
                                            goodness = Math.sqrt(thisDist2fromCenter) - Math.sqrt(largestOtherDist2fromCenter);
                                            System.out.println("        yet another goodness: "+goodness);
                                            goodnessVector[iGoodness++] = goodness;
                                        }
                                    }
                                }
                            }


                            PRINT(nGoodness);
                            PRINT(iGoodness);
                            //double synopsis = VecMath.synopsis(iGoodness, goodnessVector);
                            double synopsis = simpleSynopsis(iGoodness, goodnessVector);
                            //double synopsis = synopsis(iGoodness, goodnessVector);
                            System.out.println("        synopsis = "+synopsis);
                            double answer = -synopsis; // trying to maximize synopsis, trying to minimize answer

                            if (answer < saveBestValue[0])
                            {
                                System.out.println("            improvement!");
                                saveBestValue[0] = answer;
                                optimizationPathList.add((double[][])Arrays.copy(scratchVerts, 2));
                                optimizationPathGoodnessesList.add(synopsis);
                            }
                            else
                            {
                                System.out.println("            (not an improvement, best is still "+-saveBestValue[0]+")");
                            }
                            System.out.println("    -----------------------");
                            System.out.println("    out apply()");
                            return answer;
                        }
                    }; // fun

                    PRINT(fun.apply(initialGuessParams));
                    String paramNames[] = getParamNames(primal.verts.size());
                    FORI (iPass, nPasses)
                    {
                        iPassFinal[0] = iPass;

                        System.out.println("-------------------------------------");
                        PRINT(iPass);

                        double answerParams[] = Minimizer.minimize(fun,
                                                                   initialGuessParams,
                                                                   initialDelta,
                                                                   maxCallsPerPass,
                                                                   true, // returnNullOnMaxCallsReached
                                                                   paramNames);
                        if (true)
                        {
                            // See if we can get better by randomly jumping out of
                            // where we've wedged into
                            double bestParams[] = vertsToParams(optimizationPathList.get(optimizationPathList.size()-1));
                            double bestGoodness = optimizationPathGoodnessesList.get(optimizationPathList.size()-1);
                            double params0[] = VecMath.copyvec(bestParams);
                            double scratchParams[] = new double[bestParams.length];
                            FORI (iJump, 100)
                            {
                                // pick a random (infinity norm) distance between 1e-17 and 1
                                double a = Math.log(1e-17);
                                double b = Math.log(1);
                                double distance = randomNumberGenerator.nextDouble();
                                distance = LERP(a,b,distance);
                                distance = Math.exp(distance);
                                PRINT(distance);
                                FORI (iParam, scratchParams.length)
                                {
                                    scratchParams[iParam] = params0[iParam] + (randomNumberGenerator.nextDouble()*2-1)*distance;
                                }
                                double thisGoodness = -fun.apply(scratchParams);
                                // automatically appended to optimizationPathList if it's better
                                if (thisGoodness > bestGoodness)
                                {
                                    bestGoodness = thisGoodness;
                                    VecMath.copyvec(bestParams, scratchParams);
                                    System.out.println("    BETTER!");
                                }
                                else
                                {
                                    System.out.println("    not better");
                                }
                            }
                        }

                        // we don't really use answerParams
                        initialGuessParams = vertsToParams(optimizationPathList.get(optimizationPathList.size()-1));

                        PRINT(optimizationPathList.size());
                        //PRINTARRAY(optimizationPathGoodnessesList);
                        PRINT(iPass);
                        System.out.println("-------------------------------------");
                    }
                    double optimizationPath[][][] = new double[optimizationPathList.size()][][];
                    optimizationPathList.toArray(optimizationPath);
                    double optimizationPathGoodnesses[] = new double[optimizationPathGoodnessesList.size()];
                    optimizationPathGoodnessesList.toArray(optimizationPathGoodnesses);
                    PRINT(optimizationPath.length);
                    System.out.println("    out optimizeVerts");
                    return new Object[] {optimizationPath, optimizationPathGoodnesses};
                } // GeneralOptimizationStuff.optimizeVerts
            } // class GeneralOptimizationStuff


            // Solid example symmetric:
            //           n=36 after=12 before=12 slope=1/2
            //           n=36 after=12 before=12 slope=1/1
            //           n=36 after=12 before=12 slope=5/4
            // Solid examples of cc having y<0:
            //           n=27.6 after=0 before=20 slope=1/3 (looks same synth and not, so reliable)
            //           n=13.8 after=0 before=10 slope=1/3 (looks same synth and not, so reliable)
            //           n=13.7 after=0 before=10 slope=1/4 (looks same synth and not, so reliable... woops no it doesn't)
            //           n=10.9 after=0 before=8 slope=1/4 (looks *almost* same synth and not)
            // Example where apex does NOT suffice:
            //  n=32  pointApexUp=yes
            //  nAfter=0 nBefore=13     quill slope: 1/10
            //  nAAfter=3 nBBefore=3    quill slope: 1.414213
            private void doCannedThingSingleExitLagoonPolygon(double nVirtual,

                                                              int nBeforeApex,
                                                              int nAfterApex,
                                                              double quillSlopeNumerator,
                                                              double quillSlopeDenominator,
                                                              int nBeforeBeforeApex,
                                                              int nAfterAfterApex,
                                                              double quillSlopeNumeratorNumerator,
                                                              double quillSlopeDenominatorDenominator,
                                                              boolean pointApexUpFlag,

                                                              boolean synthesizeExactDualFlag,
                                                              boolean fudgeWeightsSoApexIsFarthestFromCurvatureCenterFlag)
            {
                int n = nBeforeBeforeApex + nBeforeApex + 1 + nAfterApex + nAfterAfterApex;
                // convert quill slope to angle in range [0,pi/2]
                // and then rescale to range [(2pi/n)/2, pi/2 - (2pi/n)/2]
                // and then subtract pi/2 - (2pi/n)/2...
                // i.e. scale to [0, pi/2 - 2pi/n].
                double quillLiftAngle = Math.atan2(quillSlopeNumerator,
                                                   quillSlopeDenominator)
                                      * (Math.PI/2-2*Math.PI/nVirtual)/(Math.PI/2);
                PRINT(quillLiftAngle);
                double quillLiftAngle0 = Math.atan2(quillSlopeNumeratorNumerator,
                                                    quillSlopeDenominatorDenominator)
                                      * (Math.PI/2-2*Math.PI/nVirtual)/(Math.PI/2);
                PRINT(quillLiftAngle0);
                double quillLiftAngles[] = new double[n];
                PRINT(nBeforeBeforeApex);
                PRINT(nBeforeApex);
                PRINT(nAfterApex);
                PRINT(nAfterAfterApex);
                FORI (i, nBeforeBeforeApex)
                    quillLiftAngles[i] = quillLiftAngle0;
                FORI (i, nBeforeApex)
                    quillLiftAngles[nBeforeBeforeApex+i] = quillLiftAngle;
                // skip apex
                FORI (i, nAfterApex)
                    quillLiftAngles[nBeforeBeforeApex+nBeforeApex+1+i] = quillLiftAngle;
                FORI (i, nAfterAfterApex)
                    quillLiftAngles[nBeforeBeforeApex+nBeforeApex+1+nAfterApex+i] = quillLiftAngle0;


                double allButApexTurn = 2*Math.PI/nVirtual;
                double apexTurn = 2*Math.PI - (n-1)*allButApexTurn;
                double vertTurns[] = VecMath.fillvec(n, allButApexTurn);
                vertTurns[nBeforeBeforeApex+nBeforeApex] = apexTurn;
                if (nBeforeApex >= 1)
                {
                    vertTurns[nBeforeBeforeApex] += quillLiftAngle0 - quillLiftAngle; // worked out on paper
                    vertTurns[nBeforeBeforeApex+nBeforeApex] -= quillLiftAngle0 - quillLiftAngle;
                }
                if (nAfterApex >= 1)
                {
                    vertTurns[n-1-nAfterAfterApex] += quillLiftAngle0 - quillLiftAngle; // worked out on paper
                    vertTurns[nBeforeBeforeApex+nBeforeApex] -= quillLiftAngle0 - quillLiftAngle;
                }





                double answer[][][] = SingleExitLagoonPolygonOptimizationStuff.constructSingleExitLagoonPolygon(nBeforeBeforeApex+nBeforeApex, quillLiftAngles, vertTurns);
                double polyVerts[][] = answer[0];
                double trisVerts[][] = answer[1];
                double quillDirs[][] = answer[2];
                /*
                PRINT(radiusScaleQuantum);
                PRINTVEC(polyVerts[0]);
                PRINTVEC(polyVerts[2]);
                PRINTVEC(trisVerts[2]);
                PRINTVEC(trisVerts[3]);
                */
                if (true)
                {
                    // worked this out on paper
                    double predictedScale = Math.cos(quillLiftAngle)/Math.cos(2*Math.PI/nVirtual + quillLiftAngle);
                    PRINT(predictedScale);
                    // analagous thing for tris diagram should just be the mirror image of that
                    // XXX TODO: argh, this is wrong for some reason
                    double predictedTrisScale = Math.cos(Math.PI/4-(Math.PI/4-quillLiftAngle))
                                              / Math.cos(2*Math.PI/nVirtual + Math.PI/4-(Math.PI/4-quillLiftAngle));
                    PRINT(predictedTrisScale);
                }
                PRINT(VecMath.norm(2,polyVerts[1])/VecMath.norm(2,polyVerts[0]));
                PRINT(VecMath.norm(2,trisVerts[3])/VecMath.norm(2,trisVerts[2]));
                PRINT(Math.log(VecMath.norm(2,polyVerts[1])/VecMath.norm(2,polyVerts[0]))/(2*Math.PI/nVirtual));
                PRINT(Math.log(VecMath.norm(2,trisVerts[3])/VecMath.norm(2,trisVerts[2]))/(2*Math.PI/nVirtual));

                if (pointApexUpFlag)
                {
                    CHECK_EQ(polyVerts[0].length, 2);
                    CHECK_EQ(trisVerts[0].length, 3);
                    CHECK_EQ(quillDirs[0].length, 2);
                    int apex = nBeforeBeforeApex+nBeforeApex;
                    double apexDir[] = VecMath.vpv(
                                         VecMath.normalize(VecMath.vmv(polyVerts[apex],polyVerts[MOD(apex-1,n)])),
                                         VecMath.normalize(VecMath.vmv(polyVerts[apex],polyVerts[(apex+1)%n])));
                    VecMath.normalize(apexDir, apexDir);
                    apexDir = Arrays.append(apexDir, 0.);
                    double m33[][] = GeomUtils.parallelTransport(apexDir, new double[] {0,1,0});
                    double m22[][] = {{m33[0][0],m33[0][1]},
                                      {m33[1][0],m33[1][1]}};
                    polyVerts = VecMath.mxm(polyVerts, m22);
                    trisVerts = VecMath.mxm(trisVerts, m33);
                    quillDirs = VecMath.mxm(quillDirs, m22);
                }


                if (true)
                {
                    // scale by a power of 2 til y range of primal fits in the window
                    double scale = 1.;
                    double maxY = 0.;
                    FORI (i, polyVerts.length)
                        maxY = MAX(maxY, ABS(polyVerts[i][1]));
                    //PRINT(maxY);
                    if (maxY != 0. && maxY != Double.POSITIVE_INFINITY)
                    {
                        while (scale*maxY <= .5)
                            scale *= 2;
                        while (scale*maxY > 1.)
                            scale *= .5;
                        //PRINT(scale);
                        VecMath.mxs(polyVerts, polyVerts, scale);
                        VecMath.mxs(trisVerts, trisVerts, scale);
                        FORI (i, trisVerts.length)
                            trisVerts[i][2] *= scale; // so that h gets scaled by scale*scale
                    }
                }


                int tris[][];
                if (true)
                {
                    //
                    // See if I got the tris right.
                    //
                    tris = new int[n+1][];
                    FORI (i, n)
                        tris[i] = new int[] {0, i+1, (i+1)%n+1};
                    tris[n] = new int[n];
                    FORI (i, n)
                        tris[n][i] = (n-1-i)+1;
                    //PRINTARRAY(trisVerts);
                    //PRINTARRAY(tris);
                    mesh = new Mesh(trisVerts, tris);
                }
                if (synthesizeExactDualFlag)
                {
                    // see if I got the polygon right.
                    // force our idea of what the polygon should look like
                    // into the dual.
                    // NOTE, if experimenting with liftAngle=0, this is necessary-- dual becomes infinite!
                    double finalVerts[][] = new double[2*n][];
                    int finalFaces[][] = {new int[3*n], new int[n]};
                    FORI (i, n)
                    {
                        finalVerts[2*i] = polyVerts[i];
                        finalVerts[2*i+1] = VecMath.vpv(polyVerts[i], quillDirs[i]);
                        finalFaces[0][3*i+0] = 2*i;
                        finalFaces[0][3*i+1] = 2*i+1;
                        finalFaces[0][3*i+2] = 2*i;
                        finalFaces[1][i] = 2*(n-1-i);
                    }

                    // if we just pass in the x,y's,
                    // they will get interpreted as h=0,
                    // i.e. projected onto paraboloid, which isn't what we want;
                    // we want the polygon to lie completely in the xy (z=0) plane.
                    // so change to X,Y,Z,W representation.
                    // Note that the quill ends won't be right
                    // (they shouldn't be in the xy plane) but whatever...
                    // that's actually a good thing since the whole reason for doing this
                    // is for the case when curvatures are growing too quickly
                    // or infinitely, in which case all the quills will point straight down anyway so that's not interesting.
                    FORI (iDualVert, finalVerts.length)
                    {
                        if (iDualVert % 2 == 0)
                        {
                            int i = iDualVert / 2;
                            int tri[] = tris[i];
                            double area = .5*GeomUtils.twiceTriangleArea(
                                trisVerts[tri[0]][0], trisVerts[tri[0]][1],
                                trisVerts[tri[1]][0], trisVerts[tri[1]][1],
                                trisVerts[tri[2]][0], trisVerts[tri[2]][1]);
                            finalVerts[iDualVert] = new double[] {finalVerts[iDualVert][0]*area,
                                                                  finalVerts[iDualVert][1]*area,
                                                                  0.*area,
                                                                  1.*area};
                        }
                        else
                        {
                            finalVerts[iDualVert] = new double[] {finalVerts[iDualVert][0],
                                                                  finalVerts[iDualVert][1],
                                                                  0.,
                                                                  1.};
                        }
                    }

                    //PRINTARRAY(finalVerts);
                    //PRINTARRAY(finalFaces);

                    _dualMesh = new Mesh(finalVerts, finalFaces);

                    FORI (iDualVert, finalVerts.length)
                    {
                        // try to hack the dual vertex into something that looks as legit as possible.
                        Mesh.Vertex dualVert = _dualMesh.getVert(iDualVert);
                        CHECK_EQ(dualVert.weight, 1.);
                        CHECK_EQ(dualVert.momentAndArea, null);
                        if (iDualVert % 2 == 0)
                        {
                            dualVert.momentAndArea = VecMath.copyvec(finalVerts[iDualVert]);
                        }
                        else
                        {
                            dualVert.weight = 0.;
                            dualVert.momentAndArea = new double[] {0., 0., 0., 0.};
                        }
                    }

                    _primalMeshOfDualMesh = mesh; // counter-counter-espionage, prevents dual from thinking it's dirty
                }
                if (fudgeWeightsSoApexIsFarthestFromCurvatureCenterFlag)
                {
                    final Mesh dualMesh = getDualMesh();
                    int nDualVerts = dualMesh.verts.size();

                    // Could do this in linear time, but don't bother
                    int inds[] = VecMath.identityperm(nDualVerts);
                    SortStuff.sort(inds, new SortStuff.IntComparator() {
                        @Override public int compare(int a, int b)
                        {
                            double ay = dualMesh.getVert(a).y();
                            double by = dualMesh.getVert(b).y();
                            return ay < by ? -1 :
                                   ay > by ? 1 : 0;
                        }
                    });
                    for (int i = 0; i < 2; ++i)
                    {
                        Mesh.Vertex dualVert = dualMesh.getVert(inds[i]);
                        double targetWeight = 1e2; // TODO: get more principled. this works for the default single-exit lagoon, currently.
                        VecMath.vxs(dualVert.momentAndArea, dualVert.momentAndArea, targetWeight/ABS(dualVert.momentAndArea[3]));
                        dualVert.weight = .5 * dualVert.momentAndArea[3];
                    }
                }

                if (true)
                {
                    // Figure out visualization of primal-dual correspondence.
                    // This will be a map from angle
                    // to a point on primal and point on dual.
                    // What we store is a list of tiepoints:
                    // angles, and corresponding indices into primal verts and dual verts.
                    primalDualVisAngles = new double[2*n];
                    primalDualVisPrimalVertInds = new int[2*n];
                    primalDualVisDualVertInds = new int[2*n];

                    Mesh dualMesh = getDualMesh();
                    // First, get our bearings in the dual mesh--
                    // we're going to walk CCW around the big polygon.
                    // Find an edge of that polygon.
                    // Note however that, in the dual mesh, edges walk CW instead of CCW,
                    // so we'll be following prev instead of next.
                    Mesh.Edge dualEdge;
                    {
                        int nEdges = dualMesh.edges.size();
                        int iDualEdge = 0;
                        dualEdge = dualMesh.getEdge(iDualEdge);
                        while (dualEdge.next().next().next() == dualEdge)
                        {
                            iDualEdge++;
                            dualEdge = dualMesh.getEdge(iDualEdge);
                        }
                        //PRINT(iDualEdge);
                    }

                    Mesh.Edge primalEdge = mesh.getEdge(dualEdge.myIndex());

                    FORI (i, n)
                    {
                        // emit dualEdge.initialVertex(), primalEdge.initialVertex()

                        primalDualVisAngles[2*i+0] = 2*Math.PI/(2*n) * (.5+2*i+0) - Math.PI/2;
                        primalDualVisDualVertInds[2*i+0] = dualEdge.initialVertex().myIndex(); // the CW-most of the two verts of dualEdge
                        primalDualVisPrimalVertInds[2*i+0] = primalEdge.initialVertex().myIndex();

                        // advance dualEdge and primalEdge
                        dualEdge = dualEdge.prev();
                        primalEdge = mesh.getEdge(dualEdge.myIndex());

                        // emit dualEdge.finalVertex() (same as previous dualEdge.initialVertex()),
                        // primalEdge.initialVertex()

                        primalDualVisAngles[2*i+1] = 2*Math.PI/(2*n) * (.5+2*i+1) - Math.PI/2;
                        primalDualVisDualVertInds[2*i+1] = dualEdge.finalVertex().myIndex();
                        primalDualVisPrimalVertInds[2*i+1] = primalEdge.initialVertex().myIndex();
                    }
                    //PRINTVEC(primalDualVisAngles);
                    //PRINTVEC(primalDualVisDualVertInds);
                    //PRINTVEC(primalDualVisPrimalVertInds);
                }
            } // doCannedThingSingleExitLagoonPolygon

            private static class SingleExitLagoonPolygonOptimizationStuff {

                // answer[0] is the vertex positions
                // answer[1] is trisVerts
                // answer[2] is the quill directions (unit vectors)
                public static double[/*2*/][][] constructSingleExitLagoonPolygon(int nBeforeApex, // callers beforeBefore+before
                                                                                 double quillLiftAngles[],
                                                                                 double vertTurns[]) // should sum to 2*pi, with each turn (other than apex) < pi/2.
                {
                    System.out.println("    in constructSingleExitLagoonPolygon");
                    int n = vertTurns.length;
                    int nAfterApex = n-1-nBeforeApex;
                    int apex = nBeforeApex;

                    PRINT(n);
                    PRINT(apex);
                    //PRINTARRAY(quillLiftAngles);
                    //PRINTARRAY(vertTurns);

                    double origin[] = {0,0};

                    double answerVerts[][] = new double[n][2];
                    double answerQuillDirs[][] = new double[n][2]; // we'll expand to [3] at end
                    double answerTriVerts[][] = new double[n+1][2]; // actually becomes primal... confusing

                    answerTriVerts[0][0] = 0.;
                    answerTriVerts[0][1] = 0.;
                    answerTriVerts[1][0] = 0.;
                    answerTriVerts[1][1] = -1.;

                    double beforeApexToApexDir[];
                    {
                        // compute the verts and quill dirs before the apex
                        double prevEdgeDirAng = 0.;
                        double prevEdgeDir[] = {1.,0.};
                        double prevVert[] = {-1.,-1.}; // fake
                        FORI (iVert, apex)
                        {
                            double nextEdgeDirAng = prevEdgeDirAng + vertTurns[iVert];
                            double nextEdgeDir[] = {Math.cos(nextEdgeDirAng),Math.sin(nextEdgeDirAng)};
                            double quillDirAng = nextEdgeDirAng - Math.PI + quillLiftAngles[iVert];
                            answerQuillDirs[iVert][0] = Math.cos(quillDirAng);
                            answerQuillDirs[iVert][1] = Math.sin(quillDirAng);
                            double originToVertDirAng = quillDirAng + Math.PI/2;
                            double originToVertDir[] = {Math.cos(originToVertDirAng),Math.sin(originToVertDirAng)};

                            // want to intersect the line from origin to vert
                            // with the previous edge line.
                            GeomUtils.intersectLines(answerVerts[iVert],
                                                     prevVert, prevEdgeDir,
                                                     origin, originToVertDir);


                            double originToDualVertDir[] = VecMath.xv2(nextEdgeDir); // actually reversed, but it doesn't matter
                            double dualEdgeDir[] = VecMath.xv2(answerQuillDirs[iVert]); // actually reversed, but it doesn't matter
                            GeomUtils.intersectLines(answerTriVerts[iVert+2],
                                                     answerTriVerts[iVert+1], dualEdgeDir,
                                                     origin, originToDualVertDir);


                            // prepare for next iteration
                            prevVert = answerVerts[iVert];
                            prevEdgeDirAng = nextEdgeDirAng;
                            prevEdgeDir = nextEdgeDir;
                        }
                        beforeApexToApexDir = prevEdgeDir;
                    }

                    double afterApexToApexDir[];
                    {
                        // compute the verts after the apex.
                        // do it using left-right-flipped angles,
                        // so that in the case of mirror symmetry we'll get *exactly*
                        // mirror images on left and right.
                        // (this actually matters for nice display,
                        // since if the top triangle edge is ever so slightly non-horizontal,
                        // its dual vertex can be ever-so-slightly negative,
                        // which, if canvas size is odd,
                        // can end up to left of center line while grid y axis
                        // is to right of center line.

                        double prevEdgeDirAngBackwards = 0.;
                        double prevEdgeDir[] = {-1.,0.};
                        double prevVert[] = {1.,-1.}; // fake
                        for (int iVert = n-1; iVert > apex; --iVert)
                        {
                            double nextEdgeDirAngBackwards = prevEdgeDirAngBackwards + vertTurns[iVert]; // + instead of -, since backwards
                            double nextEdgeDir[] = {-Math.cos(nextEdgeDirAngBackwards),Math.sin(nextEdgeDirAngBackwards)};
                            double quillDirAngBackwards = nextEdgeDirAngBackwards - Math.PI + quillLiftAngles[iVert];
                            answerQuillDirs[iVert][0] = -Math.cos(quillDirAngBackwards);
                            answerQuillDirs[iVert][1] = Math.sin(quillDirAngBackwards);
                            double originToVertDirAngBackwards = quillDirAngBackwards + Math.PI/2;
                            double originToVertDir[] = {-Math.cos(originToVertDirAngBackwards),Math.sin(originToVertDirAngBackwards)};

                            GeomUtils.intersectLines(answerVerts[iVert],
                                                     prevVert, prevEdgeDir,
                                                     origin, originToVertDir);


                            double originToDualVertDir[] = VecMath.xv2(nextEdgeDir);
                            double dualEdgeDir[] = VecMath.xv2(answerQuillDirs[iVert]); // actually reversed, but it doesn't matter, we use it only for intersection
                            GeomUtils.intersectLines(answerTriVerts[iVert+1],
                                                     answerTriVerts[((iVert+2)-1)%n+1], dualEdgeDir,
                                                     origin, originToDualVertDir);

                            // prepare for next iteration
                            prevVert = answerVerts[iVert];
                            prevEdgeDirAngBackwards = nextEdgeDirAngBackwards;
                            prevEdgeDir = nextEdgeDir;
                        }
                        afterApexToApexDir = prevEdgeDir;
                    }

                    // compute the apex
                    GeomUtils.intersectLines(answerVerts[apex],
                                             answerVerts[MOD(apex-1,n)],beforeApexToApexDir,
                                             answerVerts[(apex+1)%n],afterApexToApexDir);

                    // Since we have the dual,
                    // we can now compute the apex quill direction
                    // as the perpendicular of the final dual edge.
                    if (quillLiftAngles[0] != 0. || quillLiftAngles[quillLiftAngles.length-1] != 0.) // TODO: not sure this is quite right
                    {
                        answerQuillDirs[apex] = VecMath.normalize(VecMath.xv2(VecMath.vmv(answerTriVerts[apex+1], answerTriVerts[((apex+2)-1)%n+1])));
                    }
                    else
                    {
                        // dual is degenerate and useless,
                        // but in this case we can just pull the answer out of our hat.
                        if (nBeforeApex > nAfterApex)
                            answerQuillDirs[apex] = beforeApexToApexDir;
                        else if (nAfterApex > nBeforeApex)
                            answerQuillDirs[apex] = afterApexToApexDir;
                        else // nBeforeApex == nAfterApex
                            answerQuillDirs[apex] = new double[] {0,1}; // straight up
                    }


                    //
                    // Now reverse-engineer the heights of the tri verts
                    // (other than [0]),
                    // to give exactly the polygon verts.
                    //
                    if (true)
                    {
                        answerTriVerts[0] = Arrays.append(answerTriVerts[0], 0.);
                        answerTriVerts[1] = Arrays.append(answerTriVerts[1], -.5); // magic value to make edge lie on the horizontal line y=-1
                        FORI (iTriVertOrder, answerTriVerts.length-2) // == n-1
                        {
                            int iVert,iTriVert,jTriVert,kTriVert;
                            if (iTriVertOrder < apex)
                            {
                                iVert = iTriVertOrder;
                                iTriVert = 2+iTriVertOrder;
                                jTriVert = 0;
                                kTriVert = 1+iTriVertOrder;
                            }
                            else
                            {
                                iVert = n-1 - (iTriVertOrder-apex);
                                iTriVert = n - (iTriVertOrder-apex);
                                jTriVert = ((iTriVert+1)-1)%n+1;
                                kTriVert = 0;
                            }
                            CHECK_EQ(answerTriVerts[iTriVert].length, 2); // not calculated yet
                            CHECK_EQ(answerTriVerts[jTriVert].length, 3); // calculated already
                            CHECK_EQ(answerTriVerts[kTriVert].length, 3); // calculated already

                            // given:
                            //     tri verts i,j,k (j,k already with heights assigned)
                            //     target vert position v
                            // figure out the proper height to give tri vert i.
                            double v[] = answerVerts[iVert];

                            double v0[] = new double[2];
                            double v1[] = new double[2];
                            double xi = answerTriVerts[iTriVert][0];
                            double yi = answerTriVerts[iTriVert][1];
                            double xj = answerTriVerts[jTriVert][0];
                            double yj = answerTriVerts[jTriVert][1];
                            double hj = answerTriVerts[jTriVert][2];
                            double xk = answerTriVerts[kTriVert][0];
                            double yk = answerTriVerts[kTriVert][1];
                            double hk = answerTriVerts[kTriVert][2];
                            GeomUtils.SolveForDualPoint(xi,yi,0.,
                                                        xj,yj,hj,
                                                        xk,yk,hk,
                                                        v0, // put answer here
                                                        false, // wrapAroundSphereFlag
                                                        false, // centerSphereFlag
                                                        0.); // wrapSphereCurvature
                            GeomUtils.SolveForDualPoint(xi,yi,1.,
                                                        xj,yj,hj,
                                                        xk,yk,hk,
                                                        v1, // put answer here
                                                        false, // wrapAroundSphereFlag
                                                        false, // centerSphereFlag
                                                        0.); // wrapSphereCurvature
                            double dv_dh[] = VecMath.vmv(2,v1,v0);
                            double dv[] = VecMath.vmv(v,v0);
                            double h = VecMath.dot(dv,   dv_dh)
                                     / VecMath.dot(dv_dh,dv_dh);
                            //PRINT(h);

                            // If h is very far from 0, then it probably sucks.
                            // try again, using h instead of 1.
                            // This actually improves things a lot!
                            if (ABS(h) >= 2.)
                            {
                                FORI (iPass, 10) // probably severe overkill but whatever, this code doesn't need to be fast
                                {
                                    // re-estimate dv_dh based on bigger finite difference
                                    double shouldBeV[] = new double[2];
                                    GeomUtils.SolveForDualPoint(xi,yi,h,
                                                                xj,yj,hj,
                                                                xk,yk,hk,
                                                                shouldBeV, // put answer here
                                                                false, // wrapAroundSphereFlag
                                                                false, // centerSphereFlag
                                                                0.); // wrapSphereCurvature
                                    double dv_dh_again[] = VecMath.vmv(2,shouldBeV,v0); // and divide by h...
                                        VecMath.vxs(dv_dh_again, dv_dh_again, 1./h);
                                    double h_again = VecMath.dot(dv,          dv_dh_again)
                                                   / VecMath.dot(dv_dh_again, dv_dh_again);
                                    //PRINT(h_again);
                                    h = h_again;
                                }
                            }
                            answerTriVerts[iTriVert] = Arrays.append(answerTriVerts[iTriVert], h);
                        }
                    }


                    System.out.println("    out constructSingleExitLagoonPolygon");
                    return new double[][][] {answerVerts, answerTriVerts, answerQuillDirs};
                }
            } // SingleExitLagoonPolygonOptimizationStuff

            // Try to answer the question: what's the steepest slope possible for the legs of netless8?
            private static class Netless8SlopeOptimizationStuff
            {
                // Returns the optimization path, better and better verts
                public static Object[/*2*/] optimize(Mesh initialGuessMesh)
                {
                    System.out.println("    in Netless8SlopeOptimizationStuff.optimize");

                    // I guess I'm doing some sort of annealing thing.

                    final java.util.ArrayList<double[][]> optimizationPathList = new java.util.ArrayList<double[][]>();
                    final DoubleArrayList optimizationPathGoodnessesList = new DoubleArrayList();

                    int i[] = new int[4]; // scratch for loop
                    double params[] = new double[4]; // scratch for loop
                    double verts[][] = new double[6][3]; // scratch for loop
                    double dualVerts[][] = new double[7][3]; // scratch for loop
                    double bestParams[] = new double[4];

                    double paramsCenter[] = {.5, .5, .5, .5};
                    double radius = .5;

                    if (false)
                    {
                        // Optional: make sure we start at something sane.
                        // Note, if we *don't* do this, the very first entry in the optimization path
                        // will not be feasible, resulting in scrambled looking dual verts.
                        double one = initialGuessMesh.getVert(2).Ynaive()-initialGuessMesh.getVert(0).Ynaive();
                        double x2 = initialGuessMesh.getVert(2).Xnaive() / one;
                        PRINT(x2);
                        double y1 = (initialGuessMesh.getVert(1).Ynaive()-initialGuessMesh.getVert(0).Ynaive()) / one;
                        PRINT(y1);
                        double y4 = (initialGuessMesh.getVert(4).Ynaive()-initialGuessMesh.getVert(0).Ynaive()) / one;
                        PRINT(y4);
                        double x4 = initialGuessMesh.getVert(4).Xnaive() / one;
                        PRINT(x4);
                        paramsCenter[0] = x2;
                        paramsCenter[1] = y1;
                        paramsCenter[2] = y4/y1;
                        paramsCenter[3] = x4/(y4*x2);
                    }

                    /*
                        Ok what's the problem here?
                        Seems like if I choose target middleDualEdgeLength=0 and goodness=0
                        Then it just makes all dual verts coincidental, which sucks!
                        So the moral is...
                        can't make them both 0.
                        But maybe can make them tiny.
                    */

                    // Best results (always blows up though):
                    //     n=25 targetMiddleDualEdgeLength=0 targetGoodness=1e-4 -> 0.3533521112275946 at iter=15 (slow)
                    //     n=21 targetMiddleDualEdgeLength=0 targetGoodness=1e-4 -> 0.3530897955767722 at iter=16 (sorta slow)
                    //     n=19 targetMiddleDualEdgeLength=0 targetGoodness=1e-4 -> 0.35324928375054376 at iter=18 (reasonably fast)
                    //     n=18 targetMiddleDualEdgeLength=0 targetGoodness=1e-4 -> 0.3534435678635619 at iter=21 (reasonably faster)  <--
                    //                  same if reverse targets! hmm!
                    //                  or even for 1e-4,1e-4
                    //     n=10 targetMiddleDualEdgeLength=0 targetGoodness=1e-4 -> 0.35245685072690114 at iter=20 (fast)
                    //     n=5 targetMiddleDualEdgeLength=0 targetGoodness=1e-4 -> 0.34977091847631414 at iter=23 radius=1.66e-6
                    //
                    //     n=19 1e-5,1e-5 -> 0.35324928375054376 at iter=18
                    //     n=18 1e-5,1e-5 -> 0.35344427943017076 at iter=23  <-- best!
                    //
                    //     n=19 1e-6,1e-6 -> 0.35324928375054376 at iter=21
                    //     n=18 1e-6,1e-6 -> 0.35344427943017076 at iter=23
                    //
                    // Weird though; fewer subdivs means consistently worse results (though much faster)... not sure why that would be so.
                    //
                    // Conclusion: max slope is approx 0.35344427943017076, i.e. 19.46566 degrees or so.
                    // So the 3 angles of dual at closest-to-regular are: 109.46566345804531 109.46566345804531 141.06867308390937
                    // And 3 angles of primal at closest-to-regular are: 70.53433654195469 70.53433654195469 38.93132691609062
                    //
                    // So what gonality is 141.06867308390937 ?
                    //     ang = 180*(p-2)/p
                    //     p = 360/(180-ang) = 1/(2-ang/360))
                    //       = 9.247051886413077
                    //
                    //int n = 25; // 25**4 = 390625 samples per pass, and odd so we always put one in the center
                    //int n = 21;
                    //int n = 20;  // fails immediately!? with el=0 g=1e-4, or 1e-5,1e-5
                    //int n = 19;
                    int n = 18;
                    //int n = 10;
                    //int n = 5;
                    int maxPathSize = 100; // never gets nearly this far


                    while (true)
                    {
                        // doesn't work: makes all dual verts coincidental
                        //double targetMiddleDualEdgeLength = 0;
                        //double targetGoodness = 0;

                        double targetMiddleDualEdgeLength = 1e-2;
                        double targetGoodness = 0;

                        //double targetMiddleDualEdgeLength = 0;
                        //double targetGoodness = 1e-4;

                        //double targetMiddleDualEdgeLength = 1e-4;
                        //double targetGoodness = 0;

                        //double targetMiddleDualEdgeLength = 1e-4;
                        //double targetGoodness = 1e-4;

                        //double targetMiddleDualEdgeLength = 1e-5;
                        //double targetGoodness = 1e-5;

                        //double targetMiddleDualEdgeLength = 1e-6;
                        //double targetGoodness = 1e-6;

                        paramsToVertsAndDualVerts(paramsCenter, targetMiddleDualEdgeLength, targetGoodness, verts, dualVerts);
                        System.out.println("    iter="+optimizationPathList.size()+": "+verts[2][0]);
                        PRINTARRAY_NONCOMPACT(dualVerts);
                        optimizationPathList.add(VecMath.copymat(verts));
                        optimizationPathGoodnessesList.add(paramsCenter[0]);

                        if (radius == 0. || optimizationPathList.size() >= maxPathSize)
                            break;

                        bestParams[0] = -1.; // so it's guaranteed to get set on first feasible point

                        try {
                            for (i[0] = 0; i[0] <= n; ++i[0])
                            for (i[1] = 0; i[1] <= n; ++i[1])
                            for (i[2] = 0; i[2] <= n; ++i[2])
                            for (i[3] = 0; i[3] <= n; ++i[3])
                            {
                                for (int j = 0; j < 4; ++j)
                                    params[j] = LERP(paramsCenter[j]-radius, paramsCenter[j]+radius, (i[j]+.5)/n);
                                paramsToVertsAndDualVerts(params, targetMiddleDualEdgeLength, targetGoodness, verts, dualVerts);
                                if (dualVertsAreFeasible(verts, dualVerts)) {
                                    if (params[0] > bestParams[0]) // goal is to maximize x2=params[0]
                                    {
                                        VecMath.copyvec(bestParams, params);
                                    }
                                }
                            }
                        } catch (Error e) {
                            System.out.println("Oh no! "+e);
                            // Just end the iteration and return the current optimization list.
                            break;
                        }
                        // Had to find at least one good set of params
                        CHECK_GE(bestParams[0], 0.);

                        // Re-center around new best params.
                        // Adjust radii: if landed in paramsCenter, divide by 2.
                        // If landed at edge, stay the same.
                        // Otherwise, geometrically interpolate between the two.
                        double t = MAX4(ABS((bestParams[0]-paramsCenter[0])/(2*radius)),
                                        ABS((bestParams[1]-paramsCenter[1])/(2*radius)),
                                        ABS((bestParams[2]-paramsCenter[2])/(2*radius)),
                                        ABS((bestParams[3]-paramsCenter[3])/(2*radius)));
                        double scale = Math.pow(.5, 1-t) * Math.pow(1., t);
                        radius *= scale;
                        System.out.println("        t="+t+" -> scale="+scale+" -> radius="+radius);
                        VecMath.copyvec(paramsCenter, bestParams);
                        PRINTVEC(paramsCenter);
                    }
                    System.out.println("    out Netless8SlopeOptimizationStuff.optimize");
                    double optimizationPath[][][] = new double[optimizationPathList.size()][][];
                    optimizationPathList.toArray(optimizationPath);
                    double optimizationPathGoodnesses[] = new double[optimizationPathGoodnessesList.size()];
                    optimizationPathGoodnessesList.toArray(optimizationPathGoodnesses);
                    System.out.println("    out optimizeNetless8Verts");
                    return new Object[] {optimizationPath, optimizationPathGoodnesses};
                } // optimize

                private static void paramsToVertsAndDualVerts(double params[/*4*/],
                                                              double targetMiddleDualEdgeLength,
                                                              double targetGoodness,
                                                              double verts[/*6*/][/*3*/], double dualVerts[/*7*/][/*3*/])
                {
                    double x2 = params[0];
                    double y1 = params[1];
                    double y4_over_y1 = params[2];
                    double x4_over_y4x2 = params[3];
                    double y4 = y4_over_y1*y1;
                    double x4 = x4_over_y4x2 * (y4*x2);

                    //   3       2
                    //       1
                    //      5 4
                    //       0
                    verts[0][0] = 0;
                    verts[0][1] = 0;
                    verts[0][2] = 0;

                    verts[1][0] = 0;
                    verts[1][1] = y1;
                    verts[1][2] = 0; // h1, to be figured out

                    verts[2][0] = x2;
                    verts[2][1] = 1;
                    verts[2][2] = 0;

                    verts[3][0] = -verts[2][0];
                    verts[3][1] = verts[2][1];
                    verts[3][2] = 0;

                    verts[4][0] = x4;
                    verts[4][1] = y4;
                    verts[4][2] = 0; // h4, to be figured out

                    verts[5][0] = -verts[4][0];
                    verts[5][1] = verts[4][1];
                    verts[5][2] = 0; // h4, to be figured out

                    // Now figure out the two heights.
                    // The thing to take advantage of here is:
                    // changing the heights don't change any weights (tri areas),
                    // and it moves every dual vert in a linear fashion.
                    // Therefore the dot product in question
                    // is also changed linearly... I think.

                    vertsToDualVertsInNetless8(verts, dualVerts);
                    double middleDualEdgeLength00 = calcMiddleDualEdgeLength(dualVerts);
                    double goodness00 = calcGoodness(verts, dualVerts);

                    verts[1][2] = 1;
                    vertsToDualVertsInNetless8(verts, dualVerts);
                    double middleDualEdgeLength10 = calcMiddleDualEdgeLength(dualVerts);
                    double goodness10 = calcGoodness(verts, dualVerts);
                    verts[1][2] = 0;

                    //double tol = 1e-6;
                    double tol = 1e-5;
                    if (true)
                    {
                        // optional sanity check
                        verts[1][2] = 2;
                        vertsToDualVertsInNetless8(verts, dualVerts);
                        double middleDualEdgeLength20 = calcMiddleDualEdgeLength(dualVerts);
                        double goodness20 = calcGoodness(verts, dualVerts);
                        verts[1][2] = 0;
                        CHECK_ALMOST_EQ(goodness10-goodness00, goodness20-goodness10, tol);
                    }

                    verts[5][2] = verts[4][2] = 1;
                    vertsToDualVertsInNetless8(verts, dualVerts);
                    double middleDualEdgeLength01 = calcMiddleDualEdgeLength(dualVerts);
                    double goodness01 = calcGoodness(verts,dualVerts);
                    verts[5][2] = verts[4][2] = 0;

                    if (true)
                    {
                        // optional sanity check
                        verts[5][2] = verts[4][2] = 2;
                        vertsToDualVertsInNetless8(verts, dualVerts);
                        double middleDualEdgeLength02 = calcMiddleDualEdgeLength(dualVerts);
                        double goodness02 = calcGoodness(verts,dualVerts);
                        verts[5][2] = verts[4][2] = 0;
                        CHECK_ALMOST_EQ(goodness01-goodness00, goodness02-goodness01, tol);
                    }

                    // We want values of h1 and h4 that make
                    // middleDualEdgeLength and goodness both 0.
                    double h1effect[] = {middleDualEdgeLength10 - middleDualEdgeLength00,
                                         goodness10 - goodness00};
                    double h4effect[] = {middleDualEdgeLength01 - middleDualEdgeLength00,
                                         goodness01 - goodness00};
                    double M[][] = {h1effect, h4effect};
                    // So we have M such that
                    // <1,0> * M == h1effect and
                    // <0,1> * M == h4effect,
                    // i.e. <h1,h4> * M == effect.

                    double targetEffect[] = {targetMiddleDualEdgeLength - middleDualEdgeLength00,
                                             targetGoodness - goodness00};
                    double h1h4[] = VecMath.vxinvm(targetEffect, M);
                    double h1 = h1h4[0];
                    double h4 = h1h4[1];

                    verts[1][2] = h1;
                    verts[5][2] = verts[4][2] = h4;

                    vertsToDualVertsInNetless8(verts, dualVerts);
                    double shouldBeTargetMiddleDualEdgeLength = calcMiddleDualEdgeLength(dualVerts);
                    double shouldBeTargetGoodness = calcGoodness(verts, dualVerts);
                    if (!EQ(shouldBeTargetMiddleDualEdgeLength, targetMiddleDualEdgeLength, tol))
                    {
                        PRINT(targetMiddleDualEdgeLength);
                        PRINT(shouldBeTargetMiddleDualEdgeLength);
                    }
                    CHECK_ALMOST_EQ(shouldBeTargetMiddleDualEdgeLength, targetMiddleDualEdgeLength, tol);
                    CHECK_ALMOST_EQ(shouldBeTargetGoodness, targetGoodness, tol);
                } // paramsToVertsAndDualVerts

                private static int primalEdgeAndLeftwardDualEdge[][][];
                private static boolean dualVertsAreFeasible(double verts[/*6*/][/*3*/], double dualVerts[/*7*/][/*3*/])
                {
                    if (primalEdgeAndLeftwardDualEdge == null)
                    {
                        // Initialize primalEdgeAndLefwardDualEdge
                        primalEdgeAndLeftwardDualEdge = new int[9][/*2*/][/*2*/];
                        int n = 0;
                        java.util.HashMap<String,Integer> unmatchedEdgeToTri = new java.util.HashMap<String,Integer>();
                        FORI (iTri, tris.length)
                        FORI (iVertThisTri, 3)
                        {
                            int v0 = tris[iTri][iVertThisTri];
                            int v1 = tris[iTri][(iVertThisTri+1)%3];
                            String v0_v1 = ""+v0+"_"+v1;
                            String v1_v0 = ""+v1+"_"+v0;
                            CHECK(!unmatchedEdgeToTri.containsKey(v0_v1));
                            Integer match = unmatchedEdgeToTri.remove(v1_v0);
                            if (match == null)
                                unmatchedEdgeToTri.put(v0_v1, iTri);
                            else
                            {
                                int jTri = match.intValue();
                                primalEdgeAndLeftwardDualEdge[n++] = new int[][] {{v0,v1},{jTri,iTri}};
                            }
                        }
                        CHECK_EQ(unmatchedEdgeToTri.size(), 3);
                        CHECK_EQ(n, primalEdgeAndLeftwardDualEdge.length);
                    }
                    FORI (i, primalEdgeAndLeftwardDualEdge.length)
                    {
                        int pv0 = primalEdgeAndLeftwardDualEdge[i][0][0];
                        int pv1 = primalEdgeAndLeftwardDualEdge[i][0][1];
                        int dv0 = primalEdgeAndLeftwardDualEdge[i][1][0];
                        int dv1 = primalEdgeAndLeftwardDualEdge[i][1][1];
                        if ((pv0==4&&pv1==5)||(pv0==5&&pv1==4))
                        {
                            // special case-- this one is constrained to have length 0,
                            // so don't check it since it might be slightly negative due to roundoff error.
                            continue;
                        }
                        if (VecMath.vxv2(VecMath.vmv(verts[pv0],verts[pv1]),
                                         VecMath.vmv(dualVerts[dv0],dualVerts[dv1])) < 0.)
                        {
                            return false;
                        }
                    }
                    return true;
                }

                private static int tris[][] = {
                    {0,2,4}, // 0: right
                    {4,2,1}, // 1: the vertex with the angle we care about
                    {5,4,1}, // 2: top of seg we care about
                    {0,4,5}, // 3: bottom of seg we care about
                    {1,2,3}, // 4: top
                    {0,5,3}, // 5: left
                    {5,1,3}, // 6: top left
                };
                private static double calcMiddleDualEdgeLength(double dualVerts[][])
                {
                    return dualVerts[2][1] - dualVerts[3][1]; // (top of seg we care about) - (bottom of seg we care about)
                }
                private static double calcGoodness(double verts[][], double dualVerts[][])
                {
                    // CBB: note that there's a lot of redundant calculation here... this gets called 4 (or 6 for sanity)
                    // times using the same primal verts, so could precompute weights (tri areas), for all of those calls.
                    int dualVertsBeingAveraged[] = {0, 2, 3};
                    double totalArea = 0.;
                    double center[] = {0.,0.};
                    FORI (i, dualVertsBeingAveraged.length)
                    {
                        double area = GeomUtils.twiceTriangleArea(
                            verts[tris[dualVertsBeingAveraged[i]][0]],
                            verts[tris[dualVertsBeingAveraged[i]][1]],
                            verts[tris[dualVertsBeingAveraged[i]][2]]);
                        // Don't worry if an area is negative... this is for linear interpolation, it will do the right thing
                        //PRINTSUB(dualVertsBeingAveraged,i);
                        //PRINT(area);
                        totalArea += area;
                        // accumulate moment
                        VecMath.vpsxv(center,
                                      center, area, dualVerts[dualVertsBeingAveraged[i]]);
                    }
                    // divide moment by total area, to get actual center
                    VecMath.vxs(center, center, 1./totalArea);

                    // Dual edge direction can't be reliably computed by subtracting dual verts,
                    // but it *can* be reliably computed as the perpdot of the primal edge.
                    double goodnessDir[] = VecMath.xv2(VecMath.vmv(2, verts[2], verts[1]));
                    VecMath.normalize(goodnessDir, goodnessDir);
                    double height = VecMath.dot(
                        goodnessDir,
                        VecMath.vmv(2, center, dualVerts[1]));
                    return height;
                } // calcGoodness

                private static double[][] vertsToDualVertsInNetless8(double verts[/*6*/][/*3*/], double dualVerts[/*7*/][/*3*/])
                {
                    // Could optimize the hell out of this,
                    // by caching the linear transform
                    CHECK_EQ(tris.length, 7);
                    FORI (iDualVert, dualVerts.length)
                    {
                        int tri[] = tris[iDualVert];
                        double x0 = verts[tri[0]][0];
                        double y0 = verts[tri[0]][1];
                        double h0 = verts[tri[0]][2];
                        double x1 = verts[tri[1]][0];
                        double y1 = verts[tri[1]][1];
                        double h1 = verts[tri[1]][2];
                        double x2 = verts[tri[2]][0];
                        double y2 = verts[tri[2]][1];
                        double h2 = verts[tri[2]][2];
                        GeomUtils.SolveForDualPoint(x0,y0,h0,
                                                    x1,y1,h1,
                                                    x2,y2,h2,
                                                    dualVerts[iDualVert],
                                                    false, // wrapAroundSphereFlag
                                                    false, // centerSphereFlag
                                                    0.); // wrapSphereCurvature
                    }
                    return dualVerts;
                } // vertsToDualVertsInNetless8

            } // Netless8SlopeOptimizationStuff


            private static class Netless8OptimizationStuff
            {
                // Returns the optimization path, better and better verts
                public static Object[/*2*/] optimizeNetless8Verts(
                    double initialGuessVerts[][])
                {
                    System.out.println("    in optimizeNetless8Verts");

                    double initialGuessParams[] = vertsToParams(initialGuessVerts);
                    PRINTARRAY(initialGuessVerts);
                    PRINTVEC(initialGuessVerts[4]);
                    PRINTARRAY(initialGuessParams);
                    PRINTARRAY(paramsToVerts(initialGuessParams));
                    PRINTARRAY(VecMath.mmm(paramsToVerts(initialGuessParams),initialGuessVerts));

                    // TODO: explain this.
                    // Why isn't h4 a param?
                    //    I think the answer is: h4 is chosen (by paramsToVerts)
                    //    such that the dual size (specifically max x) is 1.
                    // And why are x2,y2 both params? Doesn't that mean
                    // the whole figure can grow without bound?
                    final String paramNames[] = {
                        "y1",
                        "h1",
                        "x2",
                        "y2",
                        "x4",
                        "y4",
                    };

                    final double saveBestParams[] = new double[5];
                    final double saveBestValue[] = {Double.POSITIVE_INFINITY};
                    final java.util.ArrayList<double[][]> optimizationPathList = new java.util.ArrayList<double[][]>();
                    final DoubleArrayList optimizationPathGoodnessesList = new DoubleArrayList();

                    Minimizer.VectorFunction fun = new Minimizer.VectorFunction() {
                        // VectorFunction interface
                        public double apply(double params[])
                        {
                            double verts[][] = paramsToVerts(params);
                            double leftDualVerts[][] = vertsToDualVertsInNetless8(verts);
                            double dualEdgeLengths[] = vertsAndDualVertsToDualEdgeLengths(verts, leftDualVerts);

                            double dualEdgeLengthExponent = 2.;
                            double triAreaExponent = 1.;
                            double angleExponent = 2.;


                            double answer = 0.;
                            // penalties for dual edges being too small (i.e. too small dihedral)
                            FORI (iDualEdge, dualEdgeLengths.length)
                            {
                                if (dualEdgeLengths[iDualEdge] <= 0.)
                                    return Double.POSITIVE_INFINITY;
                                answer += 1./Math.pow(dualEdgeLengths[iDualEdge], dualEdgeLengthExponent);
                            }

                            // penalties for tri areas being too small (not sure why though)
                            FORI (iTri, tris.length)
                            {
                                double area = GeomUtils.twiceTriangleArea(
                                    verts[tris[iTri][0]],
                                    verts[tris[iTri][1]],
                                    verts[tris[iTri][2]]);
                                if (area <= 0.)
                                    return Double.POSITIVE_INFINITY;
                                answer += 1./Math.pow(area, triAreaExponent);
                            }

                            // Also add in a penalty for being too close
                            // to violating the alpha-beta thing
                            if (true)
                            {
                                int dualVertsBeingAveraged[] = {0, 2, 3};
                                double totalArea = 0.;
                                double center[] = {0.,0.};
                                FORI (i, 3)
                                {
                                    double area = GeomUtils.twiceTriangleArea(
                                        verts[tris[dualVertsBeingAveraged[i]][0]],
                                        verts[tris[dualVertsBeingAveraged[i]][1]],
                                        verts[tris[dualVertsBeingAveraged[i]][2]]);
                                    PRINTSUB(dualVertsBeingAveraged,i);
                                    PRINT(area);
                                    if (area <= 0.)
                                        return Double.POSITIVE_INFINITY; // very bad
                                    totalArea += area;
                                    VecMath.vpsxv(center,
                                                  center, area, leftDualVerts[dualVertsBeingAveraged[i]]);
                                }
                                VecMath.vxs(center, center, 1./totalArea);

                                double height = VecMath.dot(
                                    2,
                                    VecMath.normalize(VecMath.vmv(leftDualVerts[4],
                                                                  leftDualVerts[1])),
                                    VecMath.vmv(center, leftDualVerts[1]));
                                if (height <= 0.)
                                    return Double.POSITIVE_INFINITY; // very bad
                                answer += 1./Math.pow(height, angleExponent); // add some badness
                            }

                            if (answer < saveBestValue[0])
                            {
                                saveBestValue[0] = answer;
                                optimizationPathList.add(paramsToVerts(params)); // XXX TODO: um, why aren't we just adding verts?
                                optimizationPathGoodnessesList.add(-answer); // answer is thing we're trying to minimize, so goodness is in the opposite direction
                            }
                            return answer;
                        }
                    }; // fun

                    double initialDelta = .0001;
                    //int maxCalls = 10*1000;
                    int maxCalls = 1*1000;
                    //int maxCalls = 500;
                    //int maxCalls = 100;
                    //int maxCalls = 53;
                    PRINT(fun.apply(initialGuessParams));
                    double answerParams[] = Minimizer.minimize(fun,
                                                               initialGuessParams,
                                                               initialDelta,
                                                               maxCalls,
                                                               true, // returnNullOnMaxCallsReached
                                                               paramNames);
                    // we don't really use that
                    double optimizationPath[][][] = new double[optimizationPathList.size()][][];
                    optimizationPathList.toArray(optimizationPath);
                    double optimizationPathGoodnesses[] = new double[optimizationPathGoodnessesList.size()];
                    optimizationPathGoodnessesList.toArray(optimizationPathGoodnesses);
                    System.out.println("    out optimizeNetless8Verts");
                    return new Object[] {optimizationPath, optimizationPathGoodnesses};
                } // optimizeNetless8Verts

                private static double[] vertsToParams(double verts[][])
                {
                    double params[] = new double[6];
                    params[0] = verts[1][1]; // y1
                    params[1] = verts[1][2]; // h1
                    params[2] = verts[2][0]; // x2
                    params[3] = verts[2][1]; // y2
                    params[4] = verts[4][0]; // x4
                    params[5] = verts[4][1]; // y4
                    return params;
                } // vertsToParams

                private static double[][] paramsToVerts(double params[])
                {
                    //System.out.println("            in paramsToVerts");
                    //PRINTVEC(params);
                    double tol = 1e-6;
                    double verts[][] = new double[6][3];

                    //     3   2
                    //       1
                    //      5 4
                    //       0
                    verts[0][0] = 0;
                    verts[0][1] = 0;
                    verts[0][2] = 0;

                    verts[1][0] = 0;
                    verts[1][1] = params[0]; // y1
                    verts[1][2] = params[1]; // h1

                    verts[2][0] = params[2]; // x2
                    verts[2][1] = params[3]; // y2
                    verts[2][2] = 0;

                    verts[3][0] = -verts[2][0];
                    verts[3][1] = verts[2][1];
                    verts[3][2] = 0;

                    verts[4][0] = params[4]; // x4
                    verts[4][1] = params[5]; // y4
                    // verts[4][2] filled in below

                    verts[5][0] = -verts[4][0];
                    verts[5][1] = verts[4][1];
                    // verts[5][2] = verts[4][2] whenever we set it

                    verts[5][2] = verts[4][2] = 0;
                    double xradius0 = vertsToDualVertsInNetless8(verts)[0][0];
                    verts[5][2] = verts[4][2] = 1;
                    double xradius1 = vertsToDualVertsInNetless8(verts)[0][0];
                    verts[5][2] = verts[4][2] = (1.-xradius0)/(xradius1-xradius0);
                    CHECK_LT(Math.abs(vertsToDualVertsInNetless8(verts)[0][0]-1.), tol);

                    //System.out.println("            out paramsToVerts");
                    return verts;
                } // paramsToVerts

                private static int tris[][] = {
                    {0,2,4}, // 0: right
                    {4,2,1}, // 1: the vertex with the angle we care about
                    {5,4,1}, // 2: top of seg we care about
                    {0,4,5}, // 3: bottom of seg we care about
                    {1,2,3}, // 4: top
                    {0,5,3}, // 5: left
                    {5,1,3}, // 6: top left
                };
                private static double[][] vertsToDualVertsInNetless8(double verts[][])
                {
                    // Could optimize the hell out of this,
                    // by caching the linear transform
                    double leftDualVerts[][] = new double[tris.length][3];
                    FORI (iDualVert, leftDualVerts.length)
                    {
                        int tri[] = tris[iDualVert];
                        double x0 = verts[tri[0]][0];
                        double y0 = verts[tri[0]][1];
                        double h0 = verts[tri[0]][2];
                        double x1 = verts[tri[1]][0];
                        double y1 = verts[tri[1]][1];
                        double h1 = verts[tri[1]][2];
                        double x2 = verts[tri[2]][0];
                        double y2 = verts[tri[2]][1];
                        double h2 = verts[tri[2]][2];
                        GeomUtils.SolveForDualPoint(x0,y0,h0,
                                                    x1,y1,h1,
                                                    x2,y2,h2,
                                                    leftDualVerts[iDualVert],
                                                    false, // wrapAroundSphereFlag
                                                    false, // centerSphereFlag
                                                    0.); // wrapSphereCurvature
                    }
                    return leftDualVerts;
                } // vertsToDualVertsInNetless8


                private static int edge2verts[/*9*/][/*2*/] = null; // from, to
                private static int edge2tris[/*9*/][/*2*/] = null; // left, right

                private static double[] vertsAndDualVertsToDualEdgeLengths(double verts[][], double leftDualVerts[][])
                {
                    if (edge2verts == null)
                    {
                        edge2verts = new int[9][2]; // from, to
                        edge2tris = new int[9][2]; // left, right
                        {
                            int nEdges = 0;
                            FORI (iTri, tris.length)
                                FORI (jTri, iTri)
                                {
                                    // If they have two things in common...
                                    FORI (ii, 3)
                                        FORI (jj, 3)
                                            if (tris[iTri][ii] == tris[jTri][jj]
                                             && tris[iTri][(ii+1)%3] == tris[jTri][MOD(jj-1,3)])
                                            {
                                                edge2verts[nEdges][0] = tris[iTri][ii]; // from
                                                edge2verts[nEdges][1] = tris[iTri][(ii+1)%3]; // to
                                                edge2tris[nEdges][0] = iTri; // left
                                                edge2tris[nEdges][1] = jTri; // right
                                                nEdges++;
                                            }
                                }
                            PRINT(nEdges);
                            CHECK_EQ(nEdges, edge2verts.length);
                            CHECK_EQ(nEdges, edge2tris.length);
                            PRINTARRAY(edge2verts);
                            PRINTARRAY(edge2tris);
                        }
                    }

                    double dualEdgeLengths[] = new double[9];
                    FORI (iEdge, 9)
                    {
                        double fromVert[] = verts[edge2verts[iEdge][0]];
                        double toVert[] = verts[edge2verts[iEdge][1]];
                        double leftDualVert[] = leftDualVerts[edge2tris[iEdge][0]];
                        double rightDualVert[] = leftDualVerts[edge2tris[iEdge][1]];
                        CHECK_NE(fromVert, toVert);
                        CHECK_NE(leftDualVert, rightDualVert);
                        dualEdgeLengths[iEdge] = VecMath.dist(2,
                                                              leftDualVert,
                                                              rightDualVert);
                        // Test whether it's negative.
                        if (VecMath.vxv2(VecMath.vmv(rightDualVert,leftDualVert),
                                         VecMath.vmv(toVert,fromVert)) < 0.)
                            dualEdgeLengths[iEdge] *= -1;
                    }
                    return dualEdgeLengths;
                } // vertsToDualEdgeLengths

            } // class Netless8OptimizationStuff

            private void doCannedThingNetless8SlopeOptimized()
            {
                doCannedThingNetless8(); // for topology
                Object optimizationPathVertsAndGoodnesses[/*2*/] = Netless8SlopeOptimizationStuff.optimize(this.mesh);
                double optimizationPathVerts[][][] = (double[][][])optimizationPathVertsAndGoodnesses[0];
                double optimizationPathGoodnesses[] = (double[])optimizationPathVertsAndGoodnesses[1];
                double verts[][] = optimizationPathVerts[optimizationPathVerts.length-1];
                FORI (iVert, 6)
                {
                    mesh.getVert(iVert).setXYHnaive(verts[iVert][0],
                                               verts[iVert][1],
                                               verts[iVert][2]);
                }
                PRINT(optimizationPathVerts.length);
                theOptimizationPath = optimizationPathVerts;
                theOptimizationIndex = optimizationPathVerts.length-1;
                theOptimizationPathGoodnesses = optimizationPathGoodnesses;
            }

            private void doCannedThingNetless8Optimized()
            {
                doCannedThingNetless8();

                double initialGuessVerts[][] = new double[6][3];
                {
                    double x0 = mesh.getVert(0).Xnaive();
                    double y0 = mesh.getVert(0).Ynaive();
                    double h0 = mesh.getVert(0).Hnaive();
                    FORI (iVert, initialGuessVerts.length)
                    {
                        initialGuessVerts[iVert][0] = mesh.getVert(iVert).Xnaive() - x0;
                        initialGuessVerts[iVert][1] = mesh.getVert(iVert).Ynaive() - y0;
                        initialGuessVerts[iVert][2] = mesh.getVert(iVert).Hnaive() - h0;
                    }
                }
                PRINT("before scaling");
                PRINTARRAY(initialGuessVerts);
                PRINTVEC(initialGuessVerts[4]);

                if (false)
                {
                    // XXX TODO: why can't I put a fairly large number here?  not much of an optimization it seems :-(
                    initialGuessVerts[2][0] += .01; // WRENCH-- see what happens
                    initialGuessVerts[3][0] -= .02; // WRENCH-- see what happens
                }

                {
                    // scale so initial guess has radius 1
                    double xradius = Netless8OptimizationStuff.vertsToDualVertsInNetless8(initialGuessVerts)[0][0];
                    double scale = 1./xradius;
                    FORI (iVert, initialGuessVerts.length)
                    {
                        initialGuessVerts[iVert][0] *= scale;
                        initialGuessVerts[iVert][1] *= scale;
                        initialGuessVerts[iVert][2] *= (scale*scale);
                    }
                    CHECK_LT(Math.abs(Netless8OptimizationStuff.vertsToDualVertsInNetless8(initialGuessVerts)[0][0] - 1.), 1e-9);
                }
                PRINT("after scaling");
                PRINTARRAY(initialGuessVerts);
                PRINTVEC(initialGuessVerts[4]);

                PRINTVEC(Netless8OptimizationStuff.vertsToDualVertsInNetless8(initialGuessVerts));

                double initialGuessDualVerts[][] = Netless8OptimizationStuff.vertsToDualVertsInNetless8(initialGuessVerts);

                Object optimizationPathVertsAndGoodnesses[/*2*/] = Netless8OptimizationStuff.optimizeNetless8Verts(
                    initialGuessVerts);
                double optimizationPathVerts[][][] = (double[][][])optimizationPathVertsAndGoodnesses[0];
                double optimizationPathGoodnesses[] = (double[])optimizationPathVertsAndGoodnesses[1];
                double verts[][] = optimizationPathVerts[optimizationPathVerts.length-1];
                FORI (iVert, 6)
                {
                    mesh.getVert(iVert).setXYHnaive(verts[iVert][0],
                                               verts[iVert][1],
                                               verts[iVert][2]);
                }

                PRINT(optimizationPathVerts.length);

                theOptimizationPath = optimizationPathVerts;
                theOptimizationIndex = optimizationPathVerts.length-1;
                theOptimizationPathGoodnesses = optimizationPathGoodnesses;
            } // doCannedThingNetless8Optimized

            private void doCannedThingNetless8Symmetric()
            {
                double vertsGenerators[][] = new double[][] {
                    {0,-1, 0.},
                    //{0,1/5., 0.}, // looks nice but doesn't work well  XXX what did I mean exactly?
                    {0,3/8., 0.}, // so use this instead
                };

                double xforms[][][] = SymmetryUtils.computeSymmetryGroup3d(3, 1, false, false, false);
                double verts[][] = SymmetryUtils.generateVertices(vertsGenerators,
                                                                  xforms);

                // argh, that interpreted as x,y,z instead of x,y,h (I guess) and tacked a w=1
                // at the end.  remove the w=1 from each vertex so it will be interpreted as x,y,h again.
                FORI (i, verts.length)
                    verts[i] = (double[])Arrays.subarray(verts[i], 0, 3);

                if (true)
                {
                    // hack to make the order the same as for netless8
                    double temp[] = verts[3];
                    verts[3] = verts[4];
                    verts[4] = verts[5];
                    verts[5] = temp;
                }

                if (false)
                {
                    // Hack to see what happens... maybe have key for this
                    FORI (iVert, verts.length)
                        verts[iVert][1] *= .1;
                }

                int faces[][] = {};
                mesh = new Mesh(verts, faces);
                delaunayize();
            } // doCannedThingNetless8Symmetric

            // Make the mesh into netless9
            private void doCannedThingNetless9()
            {
                if (true)
                {
                    // s = how much bigger each edge is from the previous
                    double s = 1.05;
                    //double s = 1.001;
                    double sliceAngle;
                    {
                        // In the initial 6 slice pie,
                        // the southeast triangle has sides a=1, b=s^5, c=s^6.
                        // what are its angles?
                        // http://www.teacherschoice.com.au/Maths_Library/Trigonometry/solve_trig_SSS.htm
                        double a = 1;
                        double b = s*s*s*s*s;
                        double c = s*s*s*s*s*s;
                        double C = GeomUtils.triangleAngle(a, b, c);
                        // All right, the southwest angle at the center
                        // is C, a bit more than pi/3.
                        // Distribute the rest of the spokes evenly.
                        sliceAngle = (2*Math.PI-C) / 5;
                    }
                    PRINT(RTOD(sliceAngle));
                    int nVerts = 19;
                    //int nVerts = 40;  // that's about as far as it can go with s=1.05 before it starts wonking out
                    //int nVerts = 1000;
                    double verts[][] = new double[nVerts][3];
                    int nNeighbors[] = new int[nVerts]; // zeros
                    java.util.ArrayList<int[]> facesList = new java.util.ArrayList<int[]>();

                    // Seed with verts 0 and 1, and an edge between them.
                    verts[0][0] = 0;
                    verts[0][1] = 0;
                    verts[0][2] = 0;
                    // Had the seed on the -y axis, changing it to +x axis for the hell of it
                    verts[1][0] = 1;
                    verts[1][1] = 0;
                    verts[1][2] = 0;
                    nNeighbors[0] = 1;
                    nNeighbors[1] = 1;

                    PRINT(VecMath.dist(verts[1], verts[6]));
                    PRINT(Math.pow(s, 6));

                    int oldestPerimeterEdge[] = {0,1};

                    for (int i = 2; i < nVerts; ++i)
                    {
                        //PRINT(i);
                        int arity = nNeighbors[oldestPerimeterEdge[0]];
                        CHECK_LT(arity, 6);
                        double angFrac = 1./(6-arity);
                        //PRINT(1./angFrac);
                        double largestEdge = VecMath.dist(verts[i-1], verts[oldestPerimeterEdge[0]]);
                        //PRINT(largestEdge);
                        //PRINT(Math.pow(s, facesList.size()));

                        double c = VecMath.dist(verts[oldestPerimeterEdge[0]],
                                                verts[oldestPerimeterEdge[1]]);
                        double a = largestEdge * Math.pow(s, 1./angFrac);
                        double b = a*s;
                        //PRINT(a);
                        //PRINT(b);
                        double target[] = GeomUtils.completeTriangle(verts[oldestPerimeterEdge[1]],
                                                                     verts[oldestPerimeterEdge[0]],
                                                                     a, b);
                        double ang0 = Math.atan2(verts[i-1][1]-verts[oldestPerimeterEdge[0]][1],
                                                 verts[i-1][0]-verts[oldestPerimeterEdge[0]][0]);
                        double ang1 = Math.atan2(target[1]-verts[oldestPerimeterEdge[0]][1],
                                                 target[0]-verts[oldestPerimeterEdge[0]][0]);
                        //PRINT(RTOD(ang0));
                        //PRINT(RTOD(ang1));
                        //PRINT(angFrac);
                        while (ang1 < ang0) ang1 += 2*Math.PI;
                        double ang = LERP(ang0, ang1, angFrac);
                        double length = largestEdge * s;
                        verts[i][0] = verts[oldestPerimeterEdge[0]][0] + length*Math.cos(ang);
                        verts[i][1] = verts[oldestPerimeterEdge[0]][1] + length*Math.sin(ang);
                        facesList.add(new int[]{oldestPerimeterEdge[0], i-1, i});
                        nNeighbors[oldestPerimeterEdge[0]]++;
                        nNeighbors[i-1]++;
                        nNeighbors[i] = 2;
                        if (nNeighbors[oldestPerimeterEdge[0]] == 6)
                        {
                            //System.out.println("COMPLETING at "+i);
                            facesList.add(new int[]{oldestPerimeterEdge[1], oldestPerimeterEdge[0], i});
                            nNeighbors[oldestPerimeterEdge[1]]++;
                            nNeighbors[i]++;
                            oldestPerimeterEdge[0]++;
                            oldestPerimeterEdge[1]++;
                        }
                    }

                    {
                        int nPerimeterVerts = 0;
                        FORI (i, nVerts)
                            if (nNeighbors[i] < 6)
                                nPerimeterVerts++;
                        int perimeterVerts[] = new int[nPerimeterVerts];
                        nPerimeterVerts = 0;
                        FORI (i, nVerts)
                            if (nNeighbors[i] < 6)
                                perimeterVerts[perimeterVerts.length-1-nPerimeterVerts++] = i;
                        facesList.add(perimeterVerts);
                        PRINT(nPerimeterVerts);
                    }


                    int faces[][] = new int[facesList.size()][];
                    facesList.toArray(faces);
                    mesh = new Mesh(verts, faces);
                    //PRINTARRAY(nNeighbors);
                    //PRINTARRAY(verts);
                    //PRINTARRAY(faces);
                }
                FORIDOWN (iVert, mesh.verts.size())
                {
                    double scale = .2;
                    Mesh.Vertex vert = mesh.getVert(iVert);
                    vert.setXYHnaive(vert.Xnaive() * scale,
                                vert.Ynaive() * scale,
                                vert.Hnaive() * (scale*scale));
                }
            } // doCannedThingNetless9

            // Argh, short-lived brilliant idea
            // that's going nowhere, since a zig-zag
            // through the cornea is always possible.
            private void doCannedThingEyeball()
            {
                int n = 72;
                int nRows = 15;
                double r0 = .25;
                double aspect = 2;

                // empirically, fudges to make it kind of right for n=72, r0=.25, aspect=2
                double incr = .005;
                incr *= .25; // XXX argh! up and down arrows depend on current view scale! squared!

                double rowHeightFudges[] = {
                    -0*incr,
                               // +3
                     3*incr,          // -1
                               // +2         // -1
                     5*incr,          // -2
                               // +0         // -1
                     5*incr,          // -3
                               // -3         // -2
                     2*incr,          // -5
                               // -8         // -2.5
                    -6*incr,         // -7.5
                               // -15.5      // -4
                    -21.5*incr,       // -11.5
                               // -27        // -5.5
                    -48.5*incr,       // -17
                               // -44        // -8
                    -92.5*incr,       // -25
                               // -69        // -11
                    -161.5*incr,      // -36
                               // -105       // -16
                    -266.5*incr,      // -52
                               // -157       // -22
                    -423.5*incr,      // -74
                               // -231       // -31
                    -654.5*incr,      // -105
                               // -336       // -43
                    -990.5*incr,      // -148
                               // -484
                    -1474.5*incr,
                };

                java.util.ArrayList<double[]> vertsList = new java.util.ArrayList<double[]>();
                java.util.ArrayList<int[]> facesList = new java.util.ArrayList<int[]>();

                vertsList.add(new double[]{0,0,0});
                FORI (iRow, nRows)
                {
                    double multiplier = 1 + aspect*2*Math.PI/n; // magic
                    double r = r0 * Math.pow(multiplier, iRow);
                    FORI (i, n)
                    {
                        double theta = 2*Math.PI*(i+iRow*.5)/n;
                        vertsList.add(new double[]{r*Math.cos(theta),
                                                   r*Math.sin(theta),
                                                   rowHeightFudges[iRow],
                                                   });
                        if (iRow == 0)
                            facesList.add(new int[]{1 + iRow*n + i,
                                                    1 + iRow*n + (i+1)%n,
                                                    0});
                        else
                        {
                            facesList.add(new int[]{1 + iRow*n + i,
                                                    1 + iRow*n + (i+1)%n,
                                                    1 + (iRow-1)*n + (i+1)%n});
                            facesList.add(new int[]{1 + iRow*n + i,
                                                    1 + (iRow-1)*n + (i+1)%n,
                                                    1 + (iRow-1)*n + i});
                        }
                        /*
                        else
                        {
                            facesList.add(new int[]{1 + iRow*n + i,
                                                    1 + (iRow-1)*n + (i+1)%n,
                                                    1 + (iRow-2)*n + (i+1)%n});
                            facesList.add(new int[]{1 + iRow*n + i,
                                                    1 + (iRow-2)*n + (i+1)%n,
                                                    1 + (iRow-1)*n + i});
                        }
                        if (iRow == nRows-1)
                            facesList.add(new int[]{1 + iRow*n + i,
                                                    1 + iRow*n + (i+1)%n,
                                                    1 + (iRow-1)*n + (i+1)%n});
                        */
                    }
                }
                int insideOutFace[] = new int[n];
                FORI (i, n)
                    insideOutFace[i] = vertsList.size()-1-i;
                facesList.add(insideOutFace);


                double verts[][] = new double[vertsList.size()][];
                vertsList.toArray(verts);
                int faces[][] = new int[facesList.size()][];
                facesList.toArray(faces);
                mesh = new Mesh(verts, faces);
            } // doCannedThingEyeball

            // XXX unused? get rid?
            private static double[] triangleApex(double v0[], double ang0,
                                                 double v1[], double ang1)
            {
                double e01ang = Math.atan2(v1[1]-v0[1], v1[0]-v0[0]);
                double e02ang = e01ang + ang0;
                double e21ang = e01ang - ang1;
                double normal02[] = new double[]{Math.cos(e02ang+Math.PI/2),
                                                 Math.sin(e02ang+Math.PI/2)};
                double normal21[] = new double[]{Math.cos(e21ang+Math.PI/2),
                                                 Math.sin(e21ang+Math.PI/2)};
                // Find v2 satisfying:
                //    v2 dot normal02 == v0 dot normal02
                //    v2 dot normal21 == v1 dot normal21
                double A[][] = {normal02,
                                normal21};
                double b[] = {VecMath.dot(v0, normal02),
                              VecMath.dot(v1, normal21)};
                // Solve A v2 == b
                return VecMath.invmxv(A, b);
            } // triangleApex

            // Starting in middle and following crack, there's only one legal way to go
            // and it goes in a spiral.
            private void doCannedThingCrackGoesInSpiral(int nTurns)
            {
                OUT("    in doCannedThingCrackGoesInSpiral");


                // magPerCircle has to be big enough so that the big triangles are substantially obtuse.

                #if 0
                double gonality = 6.;
                double magPerCircle = 256.;
                //double magPerCircle = 128.; // too small
                #endif

                #if 1
                double gonality = 8.;
                //double magPerCircle = 100;
                double magPerCircle = 90; // barely
                //double magPerCircle = 80; // too small
                // huh, can I arrange it so the two edge lengths are equal?  would be nice. 90 is pretty close.
                // oh hmm, maybe even nicer would be if quills become aligned with opposites.
                #endif

                #if 0
                double gonality = 16.;
                double magPerCircle = 64.;
                #endif

                double angleIncrDegrees = 360./gonality;
                double angleIncr = DTOR(angleIncrDegrees);
                double magIncr = Math.pow(magPerCircle, 1./gonality);
                Complex incr = new Complex(magIncr*Math.cos(angleIncr), magIncr*Math.sin(angleIncr));
                Complex decr = incr.inverse();

                int nVerts = (int)(gonality * nTurns);
                Complex cverts[] = new Complex[nVerts];

                cverts[0] = Complex.ONE;
                for (int i = 1; i < nVerts; ++i) // skip 0
                    cverts[i] = cverts[i-1].times(decr);

                double verts[][] = new double[nVerts][2];
                for (int i = 0; i < nVerts; ++i)
                    verts[i] = new double[]{cverts[i].x, cverts[i].y};

                int faces[][] = new int[0][];
                this.mesh = new Mesh(verts, faces);

                this.mesh = MeshUtils.delaunayized(this.mesh,
                                                   false, // wrapAroundSphereFlag
                                                   1., // wrapSphereCurvature
                                                   true, // centerSphereFlag
                                                   true, // calcInsideOutDualVertsFlag
                                                   true); // slightlyVerbose

                if (true)
                {
                    // Doesn't look so great because vert 0 has too many edges out of it.
                    // Get rid of them til it has apparent arity 3 (i.e. 3 frontface edges).
                    // How do we find the ones to keep?
                    // Well, first find the edge from v0 to v1,
                    // then retain it and the 2 adjacent ones walking in the CW direction around v0.

                    Mesh.Edge e01 = null;
                    int v0arity = 0; // and counting
                    FORI (iEdge, mesh.edges.size())
                    {
                        Mesh.Edge e = mesh.getEdge(iEdge);
                        if (e.initialVertex().myIndex() == 0)
                        {
                            v0arity++;
                            if (e.finalVertex().myIndex() == 1)
                            {
                                CHECK_EQ(e01, null);
                                e01 = e;
                            }
                        }
                    }

                    if (false)
                    {
                        // Delete edges until we've got only the three remaining ones left.
                        while (v0arity > 3)
                        {
                           mesh.deleteEdge(e01.prev().opposite());
                           --v0arity;
                        }
                    }
                    else
                    {
                        // Do diagonal swaps on the others until we've got only the three remaining ones left.
                        Mesh.Edge firstEdgeToKeep = e01;
                        Mesh.Edge secondEdgeToKeep = firstEdgeToKeep.opposite().next();
                        Mesh.Edge thirdEdgeToKeep = secondEdgeToKeep.opposite().next();
                        while (v0arity > 3)
                        {
                            Mesh.Edge edgeToKill = thirdEdgeToKeep.opposite().next();
                            mesh.swapDiagonal(edgeToKill, false, false);
                            --v0arity;
                        }
                    }

                    if (true)
                    {
                        // Tweak rotation so that the most interesting edges are vertical.
                        // That is, the highest remaining spoke out of v0 is horizontal.
                        Mesh.Edge edgeToMakeHorizontal = e01.opposite().next()
                                                            .opposite().next();
                        Mesh.Vertex v0 = edgeToMakeHorizontal.initialVertex();
                        CHECK_EQ(v0.myIndex(), 0);
                        Mesh.Vertex v = edgeToMakeHorizontal.finalVertex();
                        double ang = Math.atan2(v0.Ynaive()-v.Ynaive(),
                                                v0.Xnaive()-v.Xnaive());
                        // take ang to 0
                        xformTheMesh(VecMath.makeRowRotMat(4, 0, 1, -ang));
                    }
                }
                OUT("    out doCannedThingCrackGoesInSpiral");
            }

            private void doCannedThingCrackGoesInSpiralSmall()
            {
                doCannedThingCrackGoesInSpiral(4); // can't go too high here; use big for that
            }

            private void doCannedThingCrackGoesInSpiralBig()
            {
                int nTurns = 32; // perhaps excessive, but it works, hooray!

                // Do it with relatively small number of verts,
                // analyze the pattern,
                // then apply the pattern to larger number of verts.
                doCannedThingCrackGoesInSpiral(4);

                int nLittleVerts = mesh.verts.size();
                int nLittleEdges = mesh.edges.size();
                int littleTris[][] = MeshUtils.getMeshFaces(mesh, true);
                int nLittleTris = littleTris.length;
                PRINT(nLittleTris);
                PRINT(nLittleEdges);
                CHECK_EQ(3*nLittleTris, nLittleEdges);

                doCannedThingCrackGoesInSpiral(nTurns);

                // extract the verts
                int nBigVerts = mesh.verts.size();
                double bigVerts[][] = new double[nBigVerts][2];
                for (int iVert = 0; iVert < nBigVerts; ++iVert)
                {
                    bigVerts[iVert][0] = mesh.getVert(iVert).Xnaive();
                    bigVerts[iVert][1] = mesh.getVert(iVert).Ynaive();
                }

                // don't use mesh.edges.size(); it can be completely bogus at this point
                // since convex hull might have said some verts are inside.
                int nBigTris = nLittleTris + (nBigVerts-nLittleVerts)*2;
                int bigTris[][] = new int[nBigTris][3];

                // Assume:
                // first half of littleTris accurately depicts its relationship to first few verts
                // second half of littleTris accurately depicts its relationship to last few verts
                // in the middle part, tris come in pairs
                int iLittleTriThreshold = nLittleTris/2;
                CHECK_EQ(littleTris[iLittleTriThreshold][0], littleTris[iLittleTriThreshold-2][0] + 1);
                CHECK_EQ(littleTris[iLittleTriThreshold][1], littleTris[iLittleTriThreshold-2][1] + 1);
                CHECK_EQ(littleTris[iLittleTriThreshold][2], littleTris[iLittleTriThreshold-2][2] + 1);
                for (int iBigTri = 0; iBigTri < nBigTris; ++iBigTri)
                {
                    if (iBigTri < iLittleTriThreshold)
                    {
                        int iLittleTri = iBigTri;
                        bigTris[iBigTri][0] = littleTris[iLittleTri][0];
                        bigTris[iBigTri][1] = littleTris[iLittleTri][1];
                        bigTris[iBigTri][2] = littleTris[iLittleTri][2];
                    } else if (nBigTris-1-iBigTri < iLittleTriThreshold) {
                        int iLittleTri = nLittleTris-1 - (nBigTris-1-iBigTri);
                        bigTris[iBigTri][0] = nBigVerts-1-(nLittleVerts-1-littleTris[iLittleTri][0]);
                        bigTris[iBigTri][1] = nBigVerts-1-(nLittleVerts-1-littleTris[iLittleTri][1]);
                        bigTris[iBigTri][2] = nBigVerts-1-(nLittleVerts-1-littleTris[iLittleTri][2]);
                    } else {
                        bigTris[iBigTri][0] = bigTris[iBigTri-2][0] + 1;
                        bigTris[iBigTri][1] = bigTris[iBigTri-2][1] + 1;
                        bigTris[iBigTri][2] = bigTris[iBigTri-2][2] + 1;
                    }
                }

                // extract the verts,
                // and apply the tries from smaller.
                this.mesh = new Mesh(bigVerts, bigTris);
            } // doCannedThingCrackGoesInSpiralBig

            // Generalization of netless9.
            // counterexample to "there is an unfolding
            // that uses the sharpest edge at each vertex"
            private void doCannedThingHexesSpiral()
            {
                if (true)
                {
                    // s = how much bigger each edge is from the previous
                    //double s = 1.05;
                    //double s = 1.01;
                    double s = 1.005;
                    //double s = 1.001;
                    //double s = 1.;
                    double sliceAngle;
                    {
                        // In the initial 6 slice pie,
                        // the southwest triangle has sides a=1, b=s^5, c=s^6.
                        // what are its angles?
                        // http://www.teacherschoice.com.au/Maths_Library/Trigonometry/solve_trig_SSS.htm
                        double a = 1;
                        double b = s*s*s*s*s;
                        double c = s*s*s*s*s*s;
                        double C = GeomUtils.triangleAngle(a, b, c);
                        // All right, the southwest angle at the center
                        // is C, a bit more than pi/3.
                        // Distribute the rest of the spokes evenly.
                        sliceAngle = (2*Math.PI-C) / 5;
                    }
                    PRINT(RTOD(sliceAngle));
                    //int nVerts = 19;
                    //int nVerts = 18;
                    //int nVerts = 100;
                    int nVerts = 300;
                    //int nVerts = 500;
                    //int nVerts = 1000;
                    double verts[][] = new double[nVerts][3];
                    int nNeighbors[] = new int[nVerts]; // zeros
                    java.util.ArrayList<int[]> facesList = new java.util.ArrayList<int[]>();

                    // Seed with verts 0 and 1, and an edge between them.
                    verts[0][0] = 0;
                    verts[0][1] = 0;
                    verts[0][2] = 0;
                    // Had the seed on the -y axis, changing it to +x axis for the hell of it
                    verts[1][0] = 1;
                    verts[1][1] = 0;
                    verts[1][2] = 0;
                    nNeighbors[0] = 1;
                    nNeighbors[1] = 1;

                    PRINT(VecMath.dist(verts[1], verts[6]));
                    PRINT(Math.pow(s, 6));

                    int oldestPerimeterEdge[] = {0,1};

                    for (int i = 2; i < nVerts; ++i)
                    {
                        //PRINT(i);
                        int arity = nNeighbors[oldestPerimeterEdge[0]];
                        CHECK_LT(arity, 6);
                        double angFrac = 1./(6-arity);
                        //PRINT(1./angFrac);
                        double largestEdge = VecMath.dist(verts[i-1], verts[oldestPerimeterEdge[0]]);
                        //PRINT(largestEdge);
                        //PRINT(Math.pow(s, facesList.size()));

                        double c = VecMath.dist(verts[oldestPerimeterEdge[0]],
                                                verts[oldestPerimeterEdge[1]]);
                        double a = largestEdge * Math.pow(s, 1./angFrac);
                        double b = a*s;
                        //PRINT(a);
                        //PRINT(b);
                        double target[] = GeomUtils.completeTriangle(verts[oldestPerimeterEdge[1]],
                                                                     verts[oldestPerimeterEdge[0]],
                                                                     a, b);
                        double ang0 = Math.atan2(verts[i-1][1]-verts[oldestPerimeterEdge[0]][1],
                                                 verts[i-1][0]-verts[oldestPerimeterEdge[0]][0]);
                        double ang1 = Math.atan2(target[1]-verts[oldestPerimeterEdge[0]][1],
                                                 target[0]-verts[oldestPerimeterEdge[0]][0]);
                        //PRINT(RTOD(ang0));
                        //PRINT(RTOD(ang1));
                        //PRINT(angFrac);
                        while (ang1 < ang0) ang1 += 2*Math.PI;
                        double ang = LERP(ang0, ang1, angFrac);
                        double length = largestEdge * s;
                        verts[i][0] = verts[oldestPerimeterEdge[0]][0] + length*Math.cos(ang);
                        verts[i][1] = verts[oldestPerimeterEdge[0]][1] + length*Math.sin(ang);
                        facesList.add(new int[]{oldestPerimeterEdge[0], i-1, i});
                        nNeighbors[oldestPerimeterEdge[0]]++;
                        nNeighbors[i-1]++;
                        nNeighbors[i] = 2;
                        if (nNeighbors[oldestPerimeterEdge[0]] == 6)
                        {
                            //System.out.println("COMPLETING at "+i);
                            facesList.add(new int[]{oldestPerimeterEdge[1], oldestPerimeterEdge[0], i});
                            nNeighbors[oldestPerimeterEdge[1]]++;
                            nNeighbors[i]++;
                            oldestPerimeterEdge[0]++;
                            oldestPerimeterEdge[1]++;
                        }
                    }

                    {
                        int nPerimeterVerts = 0;
                        FORI (i, nVerts)
                            if (nNeighbors[i] < 6)
                                nPerimeterVerts++;
                        int perimeterVerts[] = new int[nPerimeterVerts];
                        nPerimeterVerts = 0;
                        FORI (i, nVerts)
                            if (nNeighbors[i] < 6)
                                perimeterVerts[perimeterVerts.length-1-nPerimeterVerts++] = i;
                        facesList.add(perimeterVerts);
                        PRINT(nPerimeterVerts);
                    }


                    int faces[][] = new int[facesList.size()][];
                    facesList.toArray(faces);
                    mesh = new Mesh(verts, faces);
                    //PRINTARRAY(nNeighbors);
                    //PRINTARRAY(verts);
                    //PRINTARRAY(faces);
                }
                FORIDOWN (iVert, mesh.verts.size())
                {
                    double scale = .2;
                    Mesh.Vertex vert = mesh.getVert(iVert);
                    vert.setXYHnaive(vert.Xnaive() * scale,
                                vert.Ynaive() * scale,
                                vert.Hnaive() * (scale*scale));
                }
                //double heightIncr = .005*.14;
                double heightIncr = .005*.01;
                FORIDOWN (iVert, mesh.verts.size())
                {
                    Mesh.Vertex vert = mesh.getVert(iVert);
                    vert.setHnaive(vert.Hnaive() - heightIncr * iVert);
                }
            } // doCannedThingHexesSpiral

            // counterexample to "there is an unfolding
            // that uses the dullest edge on each face", // almost... needs some height adjustments... just hit O to optimize?
            private void doCannedThingHexesSpiralOther()
            {
                int nVerts = 50;
                double r = .7; // XXX actually this would have to gradually increase or decrease each time, to get a consistent direction
                double R = 1.;

                java.util.ArrayList<double[]> vertsList = new java.util.ArrayList<double[]>();
                vertsList.add(new double[]{0,0});
                vertsList.add(new double[]{r,0});
                vertsList.add(GeomUtils.completeTriangle(vertsList.get(0),
                                                         vertsList.get(1), r, R));

                java.util.ArrayList<int[]> facesList = new java.util.ArrayList<int[]>();
                facesList.add(new int[]{0,1,2});


                int oldestOnBoundary = 0;
                while (vertsList.size() < nVerts)
                {
                    double newVertex[] = GeomUtils.completeTriangle(vertsList.get(oldestOnBoundary),
                                                                    vertsList.get(vertsList.size()-1),
                                                                    r, R);
                    if (VecMath.distsqrd(vertsList.get(oldestOnBoundary+1),
                                         newVertex) <= R*R)
                    {
                        facesList.add(new int[]{oldestOnBoundary+1,
                                           oldestOnBoundary,
                                           vertsList.size()-1});
                        oldestOnBoundary++;
                    }
                    else
                    {
                        vertsList.add(newVertex);
                        facesList.add(new int[]{oldestOnBoundary,
                                           vertsList.size()-2,
                                           vertsList.size()-1});
                    }
                }
                // Now add the inside out one
                int insideOutFace[] = new int[vertsList.size() - oldestOnBoundary];
                FORI (i, insideOutFace.length)
                    insideOutFace[i] = vertsList.size()-1-i;
                facesList.add(insideOutFace);

                double verts[][] = new double[vertsList.size()][];
                vertsList.toArray(verts);
                int faces[][] = new int[facesList.size()][];
                facesList.toArray(faces);

                VecMath.mxs(verts, verts,
                            .75/VecMath.norm(verts[verts.length-1]));

                mesh = new Mesh(verts, faces);
                delaunayize(); // so faces were unnecessary, oh well
            } // doCannedThingHexesSpiralOther


    //
    // Definition of stuff for this particular app...
    //

        // XXX move this somewhere else
        double vertOffset(Mesh.Vertex vert, boolean wrapAroundSphereFlagValue)
        {
            if (wrapAroundSphereFlag.get())
            {
                double p[] = {vert.x(), vert.y(), vert.z()};
                return theSurface.offset(p);
            }
            else
            {
                // Mathematically this is theSurface.offset(p),
                // but we want to do it more directly
                // so that when it's exactly zero we'll get exactly zero.
                double p[] = {vert.x(), vert.y(), vert.z()};
                return vert.h();
            }
        } // vertOffset

        // TODO: move this somewhere else, could be generally useful
        private static class PointOctTree
        {
            // CBB: should store a shopping cart of points
            private double point[] = null;
            private PointOctTree children[] = null;
            private double min[], mid[], max[];
            public PointOctTree(double min[], double max[]) // assumes min/max do not change during lifetime of tree
            {
                CHECK_EQ(min.length, max.length);
                this.min = min;
                this.max = max;
                this.mid = VecMath.lerp(min, max, .5);
            }
            public void hang(double newPoint[]) // assumes newPoint does not change during lifetime of tree
            {
                if (this.point == null)
                {
                    this.point = newPoint;
                }
                else if (VecMath.equalsExactly(this.point, newPoint))
                {
                    // nothing
                }
                else
                {
                    int nDims = min.length;
                    if (children == null)
                        children = new PointOctTree[1<<nDims];
                    int whichChild = 0;
                    FORI (iDim, nDims)
                    {
                        if (newPoint[iDim] >= mid[iDim])
                            whichChild |= (1<<iDim);
                    }
                    if (children[whichChild] == null)
                    {
                        double childMin[] = new double[nDims];
                        double childMax[] = new double[nDims];
                        FORI (iDim, nDims)
                        {
                            if (((whichChild>>iDim)&1) == 0)
                            {
                                childMin[iDim] = this.min[iDim];
                                childMax[iDim] = this.mid[iDim];
                            }
                            else
                            {
                                childMin[iDim] = this.mid[iDim];
                                childMax[iDim] = this.max[iDim];
                            }
                        }
                        children[whichChild] = new PointOctTree(childMin, childMax);
                    }
                    children[whichChild].hang(newPoint);
                }
            }
            public boolean isQueryPointStrictlyWithinDist2OfExistingPoint(double queryPoint[],
                                                                          double dist2)
            {
                CHECK_EQ(queryPoint.length, this.min.length);
                if (this.point != null && VecMath.distsqrd(queryPoint, this.point) < dist2)
                    return true;
                if (children == null)
                    return false;
                double dist2FromQueryPointToBBox = 0.;
                FORI (iDim, queryPoint.length)
                {
                    double bboxPoint = CLAMP(queryPoint[iDim], min[iDim], max[iDim]);
                    dist2FromQueryPointToBBox += SQR(queryPoint[iDim] - bboxPoint);
                }
                if (dist2FromQueryPointToBBox >= dist2)
                    return false;
                FORI (iChild, children.length)
                    if (children[iChild] != null)
                        if (children[iChild].isQueryPointStrictlyWithinDist2OfExistingPoint(queryPoint, dist2))
                            return true;
                return false;
            }
        } // class PointOctTree

        private static double[][] generateBlueNoiseOnUnitSphere(double stubbornness,
                                                                double overlappingDiskRadius, // radius of disks that half-overlap.  this is twice the radius of disks that don't overlap.
                                                                java.util.Random randomNumberGenerator)
        {
            OUT("in generateBlueNoiseOnUnitSphere");
            long t0millis = System.currentTimeMillis();
            // disk radius is in radians, on surface of unit sphere.
            // convert to linear separation.
            double minSeparation = 2*Math.sin(.5*overlappingDiskRadius);
            double minSeparationSqrd = SQR(minSeparation);

            PointOctTree tree = new PointOctTree(new double[]{-2,-2,-2}, new double[]{2,2,2});
            double samples[][] = new double[10][];
            double sample[] = new double[3];
            int nSuccesses = 0;
            int nTries;
            for (nTries = 0;
                 nTries==0
              || nTries < nSuccesses * stubbornness; // first one is guaranteed to be a success
                 ++nTries)
            {
                do
                    VecMath.random(sample, randomNumberGenerator);
                while (VecMath.normsqrd(sample) > .5*.5);
                VecMath.normalize(sample, sample);

                // is it within minSeparation of any previous sample?
                boolean isBad = false; // until proven otherwise
                if (false)
                {
                    // Slow simple way
                    int iSample;
                    FOR (iSample, nSuccesses)
                    {
                        if (VecMath.distsqrd(sample, samples[iSample]) < minSeparationSqrd)
                        {
                            isBad = true;
                            break; // no good
                        }
                    }
                }
                else
                {
                    isBad = tree.isQueryPointStrictlyWithinDist2OfExistingPoint(sample, minSeparationSqrd);
                }

                if (!isBad)
                {
                    // it's good!
                    if (samples.length == nSuccesses)
                    {
                        double newSamples[][] = new double[samples.length*2][];
                        FORI (jSample, nSuccesses)
                            newSamples[jSample] = samples[jSample];
                        samples = newSamples;
                    }
                    samples[nSuccesses++] = VecMath.copyvec(sample);
                    tree.hang(samples[nSuccesses-1]);
                }
            }
            double answer[][] = (double[][])Arrays.subarray(samples, 0, nSuccesses);
            long t1millis = System.currentTimeMillis();
            OUT("    "+(t1millis-t0millis)/1000.+" secs");
            OUT("out generateBlueNoiseOnUnitSphere");
            return answer;
        } // generateBlueNoiseOnUnitSphere

        // "unit square" = [-1,1]x[-1,1]
        // (actually it's [0,1]x[0,1])
        private static double[][] generateBlueNoiseOnUnitSquare(double stubbornness,
                                                                double overlappingDiskRadiusX,
                                                                double overlappingDiskRadiusY, // radius of disks that half-overlap.  this is twice the radius of disks that don't overlap.
                                                                java.util.Random randomNumberGenerator)
        {
            System.out.println("    in generateBlueNoiseOnUnitSquare");
            long t0millis = System.currentTimeMillis();
            double answer[][];
            if (true)
            {
                System.out.println("      using maximal method");
                CHECK_EQ(overlappingDiskRadiusX, overlappingDiskRadiusY);
                answer = BlueNoise.blueNoiseInUnitBox(2,
                                                      overlappingDiskRadiusX / 4.,
                                                      randomNumberGenerator);
                VecMath.mpv(answer, answer, new double[]{.5,.5}); // [-.5,.5] -> [0,1]
            }
            else
            {
                // adding margin of 2*overlappingDiskRadius and then throwing it away afterwards
                // should be enough to avoid any boundary artifacts.
                // XXX add another 2 so we don't need to check... ?
                double minX = -2*overlappingDiskRadiusX;
                double maxX = 1+2*overlappingDiskRadiusX;
                double minY = -2*overlappingDiskRadiusY;
                double maxY = 1+2*overlappingDiskRadiusY;

                // we work with cells of size 1, in which overlappingDiskRadius is .5 (nonoverlapping disk radius is 1)
                int nWorkCellsX = (int)Math.ceil((maxX-minX)/overlappingDiskRadiusX);
                int nWorkCellsY = (int)Math.ceil((maxY-minY)/overlappingDiskRadiusY);
                PRINT(nWorkCellsX);
                PRINT(nWorkCellsY);
                double cells[][][][] = new double[nWorkCellsY][nWorkCellsX][6][2];
                int cellSizes[][] = new int[nWorkCellsY][nWorkCellsX]; // zeros initially
                int nSuccesses = 0;
                int nTries;
                for (nTries = 0;
                     nTries==0
                  || nTries < nSuccesses * stubbornness;  // first one is guaranteed to be a success
                     ++nTries)
                {
                    double x = randomNumberGenerator.nextDouble() * nWorkCellsX;
                    double y = randomNumberGenerator.nextDouble() * nWorkCellsY;
                    int iX1 = (int)(x+.5);
                    int iX0 = iX1-1;
                    int iY1 = (int)(y+.5);
                    int iY0 = iY1-1;
                    iX0 = CLAMP(iX0, 0, nWorkCellsX-1);
                    iX1 = CLAMP(iX1, 0, nWorkCellsX-1);
                    iY0 = CLAMP(iY0, 0, nWorkCellsY-1);
                    iY1 = CLAMP(iY1, 0, nWorkCellsY-1);
                    boolean bad = false;
                    for (int iY = iY0; iY <= iY1 && !bad; ++iY)
                    {
                        for (int iX = iX0; iX <= iX1 && !bad; ++iX)
                        {
                            double cell[][] = cells[iY][iX];
                            double cellSize = cellSizes[iY][iX];
                            for (int i = 0; i < cellSize; ++i)
                            {
                                double q[] = cell[i];
                                // if distance from q to new point < .5
                                if (SQR(x-q[0])+SQR(y-q[1]) < .25)
                                {
                                    bad = true;
                                    break;
                                }
                            }
                        }
                    }
                    if (!bad)
                    {
                        int iX = (int)x;
                        int iY = (int)y;
                        iX = CLAMP(iX, 0, nWorkCellsX-1);
                        iY = CLAMP(iY, 0, nWorkCellsY-1);
                        double entry[] = cells[iY][iX][cellSizes[iY][iX]++];
                        entry[0] = x;
                        entry[1] = y;
                        nSuccesses++;
                    }
                }

                PRINT(nTries);
                PRINT(nSuccesses);

                answer = new double[nSuccesses][];
                int iInCells = 0;
                int iAnswer = 0;
                int margin = 1; // should be 1, can set to 0 to see the margin too
                FORI (iX, nWorkCellsX-2*margin)
                FORI (iY, nWorkCellsY-2*margin)
                {
                    double cell[][] = cells[iY+margin][iX+margin];
                    double cellSize = cellSizes[iY+margin][iX+margin];
                    for (int i = 0; i < cellSize; ++i)
                    {
                        double scratch[] = cell[i];
                        answer[iAnswer] = scratch;
                        scratch[0] = LERP(minX, maxX, scratch[0]/nWorkCellsX);
                        scratch[1] = LERP(minY, maxY, scratch[1]/nWorkCellsY);
                        if (INRANGE(0 <=, scratch[0], <= 1)
                         && INRANGE(0 <=, scratch[1], <= 1))
                            iAnswer++;
                        iInCells++;
                    }
                }
                if (margin == 0)
                    CHECK_EQ(iInCells, answer.length);
                answer = (double[][])Arrays.subarray(answer, 0, iAnswer);
            }

            long t1millis = System.currentTimeMillis();
            double seconds = (t1millis-t0millis) * 1e-3;
            System.out.println("    out generateBlueNoiseOnUnitSquare ("+seconds+" seconds)");
            return answer;
        } // generateBlueNoiseOnUnitSquare



        // Holds the information needed to undo and redo a mesh editing operation.
        // This implementation is very simple and inefficient;
        // it just stores a complete copy of the mesh before and after
        // the editing operation.
        private static class UndoItem
        {
            public static class State
            {
                public Mesh mesh;
                public boolean continuouslyDelaunayizeFlag;
                public boolean optimizeFlag;
                public int optimizationTypeIndex;
                public int selectedTris[][];
                public int selectedDualVertIndices[];
                public boolean allDualVertsAreSelected;
                public int mostRecentlyBeingDraggedVertIndex;
                public int netEdgeStatuses[];
                public State(Mesh mesh, boolean continuouslyDelaunayizeFlag, boolean optimizeFlag, int optimizationTypeIndex, int selectedTris[][], int selectedDualVertIndices[], boolean allDualVertsAreSelected, int mostRecentlyBeingDraggedVertIndex, Net net)
                {
                    this.mesh = new Mesh(mesh);
                    this.continuouslyDelaunayizeFlag = continuouslyDelaunayizeFlag;
                    this.optimizeFlag = optimizeFlag;
                    this.optimizationTypeIndex = optimizationTypeIndex;
                    this.selectedTris = (int[][])Arrays.copy(selectedTris, 2);
                    this.selectedDualVertIndices = VecMath.copyvec(selectedDualVertIndices);
                    this.allDualVertsAreSelected = allDualVertsAreSelected;
                    this.mostRecentlyBeingDraggedVertIndex = mostRecentlyBeingDraggedVertIndex;
                    this.netEdgeStatuses = (net==null ? null : VecMath.copyvec(net.getEdgeStatuses()));
                }
            }
            public State before;
            public State after;
            public UndoItem(State before, State after)
            {
                this.before = before;
                this.after = after;
            }
        } // class UndoItem

        private UndoItem.State newUndoItemState()
        {
            return new UndoItem.State(this.mesh,
                                      this.continuouslyDelaunayizeFlag.get(),
                                      this.optimizeFlag.get(),
                                      this.optimizationTypeIndex.get(),
                                      this.selectedTris,
                                      this.selectedDualVertIndices,
                                      this.allDualVertsAreSelected,
                                      this.mostRecentlyBeingDraggedVertIndex,
                                      this.theNet);
        } // newUndoItemState

        private void applyUndoItemState(UndoItem.State state)
        {
            this.mesh = new Mesh(state.mesh);
            this.meshOfSelectedTris = mesh; // hackish
            this.continuouslyDelaunayizeFlag.set(state.continuouslyDelaunayizeFlag);
            this.optimizeFlag.set(state.optimizeFlag);
            this.optimizationTypeIndex.set(state.optimizationTypeIndex);
            this.optimizationType = Mesh.availableOptimizationTypes[optimizationTypeIndex.get()];
            this.selectedTris = (int[][])Arrays.copy(state.selectedTris, 2);
            this.selectedDualVertIndices = VecMath.copyvec(state.selectedDualVertIndices);
            this.allDualVertsAreSelected = state.allDualVertsAreSelected;
            this.mostRecentlyBeingDraggedVertIndex = state.mostRecentlyBeingDraggedVertIndex;
            this.dirtyDualMesh(); // *before* we restore theNet
            this.theNet = (state.netEdgeStatuses==null ? null : new Net(this.getDualMesh(), mesh, state.netEdgeStatuses));
        } // applyUndoItemState

        private void clear()
        {
            beingDraggedVertIndex = -1; // not part of undo state
            UndoItem.State before = newUndoItemState();
            mostRecentlyBeingDraggedVertIndex = -1;
            synchronized(showNetFlag) // since another thread checks it once in a while
            {
                showNetFlag.set(false); // so user won't get confused when clicking doesn't make verts appear
            }
            resetLocalToWorld();
            mesh = new Mesh();
            selectedTris = new int[][] {};
            selectedDualVertIndices = new int[] {};
            allDualVertsAreSelected = false;
            if (continuouslyDelaunayizeFlag.get()) delaunayize();
            dirtyDualMesh(); // before snapping after state, so theNet will be cleared XXX aren't there a zillion places we're neglecting to take this into account?
            UndoItem.State after = newUndoItemState();
            undoTreeSquirrel.Do(new UndoItem(before, after));
            theCanvas.repaint();
        } // clear


        private double[][/*4*/][/*4*/] getTheRotationalSymmetryGroup()
        {
            return SymmetryUtils.getSymmetryGroup(
                pRotationalSymmetry.get(),
                qRotationalSymmetry.get(),
                false, // ignore leftRightSymmetry
                false, // ignore sphereCentralSymmetry
                wrapAroundSphereFlag.get(),
                wrapSphereCurvature.get(),
                centerSphereFlag.get(),
                q346meanRepeatRegardlessOfPFlag.get());
        }
        private double[][/*4*/][/*4*/] getTheSymmetryGroup()
        {
            return SymmetryUtils.getSymmetryGroup(
                pRotationalSymmetry.get(),
                qRotationalSymmetry.get(),
                leftRightSymmetry.get(),
                sphereCentralSymmetry.get(),
                wrapAroundSphereFlag.get(),
                wrapSphereCurvature.get(),
                centerSphereFlag.get(),
                q346meanRepeatRegardlessOfPFlag.get());
        }
        private double[][/*4*/][/*4*/] getTheSymmetryGroupGenerators()
        {
            // XXX TODO: smaller set?
            return getTheSymmetryGroup();
        } // getTheSymmetryGroupGenerators

        // not used any more, but it's a nice little utility
        public static void drawBitmapCentered(java.awt.Graphics g,
                                              java.awt.Dimension size,
                                              String[] rows)
        {
            int x0 = (size.width - rows[0].length())/2;
            int y0 = (size.height - rows.length)/2;
            FORI (iRow, rows.length)
            {
                String row = rows[iRow];
                int nCols = row.length();
                FORI (iCol, nCols)
                {
                    char c = row.charAt(iCol);
                    if (c != ' ')
                        g.fillRect(x0+iCol, y0+iRow, 1, 1);
                }
            }
        } // drawBitmapCentered
        public static void drawPixmapCentered(java.awt.Graphics g,
                                              java.awt.Dimension size,
                                              int mag,
                                              java.awt.Color asciiToColor[],
                                              String[] rows)
        {
            if (false)
            {
                // hack-- pad with the color at 0,0
                g.setColor(asciiToColor[rows[0].charAt(0)]);
                PRINT(size.width);
                PRINT(size.height);
                g.fillRect(0,0, size.width,size.height);
            }

            CHECK_GE(mag, 0);  // 0 would be weird but legal
            if (mag != 1)
            {
                String[] newRows = new String[rows.length*mag];
                FORI (iRow, rows.length)
                {
                    String row = rows[iRow];
                    int nCols = row.length();
                    char chars[] = new char[nCols*mag];
                    FORI (i, nCols)
                        FORI (j, mag)
                          chars[i*mag+j] = row.charAt(i);
                    String newRow = new String(chars);
                    FORI (iMag, mag)
                        newRows[iRow*mag + iMag] = newRow;
                }
                rows = newRows;
            }

            int x0 = (size.width - rows[0].length())/2;
            int y0 = (size.height - rows.length)/2;
            java.awt.Color prevColor = null;
            FORI (iRow, rows.length)
            {
                String row = rows[iRow];
                int nCols = row.length();
                FORI (iCol, nCols)
                {
                    char c = row.charAt(iCol);
                    java.awt.Color color = asciiToColor[c];
                    if (color != null)
                    {
                        if (color != prevColor)
                        {
                            g.setColor(color);
                            prevColor = color;
                        }
                        g.fillRect(x0+iCol, y0+iRow, 1, 1);
                   }
                }
            }
        } // drawPixmapCentered


    //
    // App-specific variables...
    //
        public static int hidpimag = 1; // automagically follows setting of controlFont from java command line
        private UndoTreeSquirrel undoTreeSquirrel = new UndoTreeSquirrel();
        private Mesh mesh = new Mesh();
        private Net theNet = null; // computed on demand
        private Mesh _dualMesh = null; // computed on demand
        private Mesh _primalMeshOfDualMesh = null; // possibly ill-advised attempt to automatically invalidate dualMesh when mesh gets replaced in various ways
        public Mesh getDualMesh()
        {
            if (_dualMesh == null
             || _primalMeshOfDualMesh != mesh)
            {
                _dualMesh = Mesh.makeDualMesh(mesh,
                                              /*includeNonArity3=*/true,
                                              /*includeInsideOut=*/calcInsideOutDualVertsFlag.get(),
                                              /*zeroVerts=*/false,
                                              /*wrapAroundSphereFlagValue=*/wrapAroundSphereFlag.get(),
                                              /*centerSphereFlagValue=*/centerSphereFlag.get(),
                                              /*wrapSphereCurvatureValue=*/wrapSphereCurvature.get());
                _primalMeshOfDualMesh = mesh;
                theNet = null;
            }
            return _dualMesh;
        }
        public void dirtyDualMesh()
        {
            _dualMesh = null;
            _primalMeshOfDualMesh = null; // no sense keeping a ref to it
            theNet = null;
        }

        private Listenable.Long randomSeed = new Listenable.Long(0,Integer.MAX_VALUE, System.currentTimeMillis());
        private java.util.Random randomNumberGenerator = new java.util.Random(randomSeed.get());

        private int beingDraggedVertIndex = -1;
        private int mostRecentlyBeingDraggedVertIndex = -1;
        private double[] beingDraggedVertUnsnappedXY = null;
        private int beingDraggedNetEdgeIndex = -1;
        private double[] beingDraggedNetEdgeDelta = null;
        private boolean rubberBandingNewEdge = false;
        private boolean mousePressWasBackFacing = false;
        private int[][] selectedTris = {};
        private int[] selectedDualVertIndices = {};
        private boolean allDualVertsAreSelected = false; // misnomer-- it really means "all dual verts are selected intentionally" or something
        // for visualizing some kinds of net algorithms
        private double[/*2*/] sweepCircleToDrawThroughPoint = null; // may be soon subsumed by sweepVisualizationGraphics
        private double[/*3*/] sweepCircleToDrawCenterHomo = null; // may be soon subsumed by sweepVisualizationGraphics
        private java.util.ArrayList<MyAlgorithmMaybe.Graphic> sweepVisualizationGraphics = null;

        private Mesh meshOfSelectedTris = mesh; // possibly ill-advised attempt to invalidate selectedTris and selectedDualVertIndices automatically so people can just reset mesh without having to remember

        // XXX is there an easier way to associate that stuff with a certain object? maybe be able to just pass this object to addListener, and make it automatically remove the listener when I go away?  OH, just add it as a member variable in the object, I think?
        private Listenable.Listener continuouslyDelaunayizeFlagListener = null;
        private Listenable.Listener wrapAroundSphereFlagListener = null;
        private Listenable.Listener wrapAroundSphereFlagIntentListener = null;
        private Listenable.Listener centerSphereFlagListener = null;
        private Listenable.Listener wrapSphereCurvatureListener = null;
        private Listenable.Listener wrapSphereSymbolicRadiusListener = null;
        private Listenable.Listener gridBrightnessListener = null;
        private Listenable.Listener backfaceBrightnessListener = null;
        private Listenable.Listener optimizeFlagListener = null;
        private Listenable.Listener optimizationTypeIndexListener = null;
        private Listenable.Listener showMagFlagListener = null;
        private Listenable.Listener showNetFlagListener = null;
        private Listenable.Listener showNetFlagListener2 = null;
        private Listenable.Listener showNetFlowFlagListener = null;
        private Listenable.Listener showNetPolishFlagListener = null;
        private Listenable.Listener netMethodListener = null;
        private Listenable.Listener calcInsideOutDualVertsFlagListener = null;
        private Listenable.Listener showInsideOutDualVertsFlagListener = null;
        private Listenable.Listener showFlatPrimalEdgesFlagListener = null;
        private Listenable.Listener showPrimalVertsFlagListener = null;
        private Listenable.Listener showPrimalEdgesFlagListener = null;
        private Listenable.Listener showDualVertsFlagListener = null;
        private Listenable.Listener showDualEdgesFlagListener = null;
        private Listenable.Listener labelPrimalVertsFlagListener = null;
        private Listenable.Listener labelPrimalEdgesFlagListener = null;
        private Listenable.Listener labelDualVertsFlagListener = null;
        private Listenable.Listener labelDualEdgesFlagListener = null;
        private Listenable.Listener showTopologicalRegionWhenDraggingVertexFlagListener = null;
        private Listenable.Listener showPrimalDualIntersectionFlagListener = null;
        private Listenable.Listener showPrimalDualMinkowskiAverageFlagListener = null;
        private Listenable.Listener primalDualVisFlagListener = null;
        private Listenable.Listener naivePrimalEdgesFlagListener = null;
        private Listenable.Listener naiveDualEdgesFlagListener = null;
        private Listenable.Listener windowTitleListener = null;
        private Listenable.Listener myAlgorithmMaxItersListener = null;
        private Listenable.Listener myAlgorithmSweepOriginHomoSpecListener = null;

        public Listenable.Boolean continuouslyDelaunayizeFlag = new Listenable.Boolean(false);  // has to be false, or it may alter stuff on load
        public Listenable.Boolean optimizeFlag = new Listenable.Boolean(false);
        private Listenable.Int optimizationTypeIndex = new Listenable.Int(0, Mesh.availableOptimizationTypes.length-1, Mesh.OPTIMIZE_LENGTHS_MAX_MIN); // min, max, default
        int optimizationType = Mesh.availableOptimizationTypes[optimizationTypeIndex.get()];
        private Listenable.String radialHeightFieldSpec = new Listenable.String("0. 0.  1. 1.");

            private static final int NETMETHOD_MANUAL = 0;
            private static final int NETMETHOD_RANDOM = 1;
            private static final int NETMETHOD_UPWARD = 2;
            private static final int NETMETHOD_OUTWARD = 3;
            private static final int NETMETHOD_MY_ALGORITHM_MAYBE = 4;
            private static final int NETMETHOD_MY_ALGORITHM_MAYBE2 = 5;
            private static final int NETMETHOD_MY_ALGORITHM_MAYBEFACE = 6;
            private static final int NETMETHOD_SELECT_VERTSWEEP = 7;
            private static final int NETMETHOD_SELECT_FACESWEEP = 8;
            private static final int NETMETHOD_SELECT_NET = 9;
            private static final int NETMETHOD_CUT_SHARPEST = 10;
            private static final int NETMETHOD_CUT_DULLEST = 11;
            private static final int NETMETHOD_CUT_LONGEST = 12;
            private static final int NETMETHOD_CUT_SHORTEST = 13;
            private static final int NETMETHOD_FOLD_SHARPEST = 14;
            private static final int NETMETHOD_FOLD_DULLEST = 15;
            private static final int NETMETHOD_FOLD_LONGEST = 16;
            private static final int NETMETHOD_FOLD_SHORTEST = 17;
            private static final String netMethodNames[] = {
                "Manual",
                "Random",
                "Upward",
                "Outward",
                "My algorithm maybe",
                "My algorithm maybe2",
                "My algorithm facesweep",
                "Select vertsweep (using maxIters for now)",
                "Select facesweep (using maxIters for now)",
                "Select net from all nets (using maxIters for now)",
                "Cut Sharpest at each vert",
                "Cut Dullest at each vert",
                "Cut Longest at each vert",
                "Cut Shortest at each vert",
                "Fold Sharpest at each face",
                "Fold Dullest at each face",
                "Fold Longest at each face",
                "Fold Shortest at each face",
            };
        private Listenable.Int netMethod = new Listenable.Int(0, netMethodNames.length-1, NETMETHOD_MY_ALGORITHM_MAYBE2);  // initial default
        private Listenable.Int myAlgorithmMaxIters = new Listenable.Int(-1, 1000*1000*1000, -1);
        private Listenable.String myAlgorithmSweepOriginHomoSpec = new Listenable.String("0 -1 0      "); // CBB: added spaces to increase textfield width; should make a more legit way to do that

        private java.awt.Component theCanvas = null;
        //private java.awt.Component theHelpWindow = null;
        public JFrame theMainAppletWindow = null;
        public JFrame theControlPanelWindow = null;
        public JFrame theHelpWindow = null;
        public Listenable.String windowTitle = new Listenable.String("Shephards Play Applet");

        // hack
        private int theOptimizationIndex = -1;
        private double theOptimizationPath[][][] = null;
        private double theOptimizationPathGoodnesses[] = null;

        private boolean arrowsTowardsSharpestDihedralsFlag = false;
        private boolean arrowsTowardsShortestEdgesFlag = false;

        private Listenable.Boolean labelPrimalVertsFlag = new Listenable.Boolean(false);
        private Listenable.Boolean labelPrimalEdgesFlag = new Listenable.Boolean(false);
        private Listenable.Boolean labelDualVertsFlag = new Listenable.Boolean(false);
        private Listenable.Boolean labelDualEdgesFlag = new Listenable.Boolean(false);
        private Listenable.Boolean calcInsideOutDualVertsFlag = new Listenable.Boolean(false); // controlled by "Behavior -> Calc underside when delaunayizing.  NOTE: must be Must be false for most net generation.  however, if false, then "Show primal underside and second dual sheet" is non-functional!  ARGH!   The way out:  make net generation ignore inside-out verts, and treat edges to them as infinite
        private Listenable.Boolean showInsideOutDualVertsFlag = new Listenable.Boolean(false);

        private Listenable.Boolean showFlatPrimalEdgesFlag = new Listenable.Boolean(false);
        private Listenable.Boolean showTopologicalRegionWhenDraggingVertexFlag = new Listenable.Boolean(false);
        private Listenable.Boolean showPrimalDualIntersectionFlag = new Listenable.Boolean(false);
        private Listenable.Boolean showPrimalDualMinkowskiAverageFlag = new Listenable.Boolean(false);

        public boolean showPositiveOrthantnessVisualizationFlag = false; // XXX total hack-- it's cool but put it somewhere else!!
        private Listenable.Boolean showPrimalVertsFlag = new Listenable.Boolean(true);
        private Listenable.Boolean showPrimalEdgesFlag = new Listenable.Boolean(true);
        private Listenable.Boolean showDualVertsFlag = new Listenable.Boolean(true);
        private Listenable.Boolean showDualEdgesFlag = new Listenable.Boolean(true);
        private Listenable.Boolean naivePrimalEdgesFlag = new Listenable.Boolean(false);
        private Listenable.Boolean naiveDualEdgesFlag = new Listenable.Boolean(false);
        private Listenable.Boolean showNetFlag = new Listenable.Boolean(false);
        private Listenable.Boolean showFlattenedNetFlag = new Listenable.Boolean(true);
        private Listenable.Boolean showNetFlowFlag = new Listenable.Boolean(false);
        private Listenable.Boolean showNetPolishFlag = new Listenable.Boolean(false);
        private Listenable.Boolean showNetPolishVeryFastFlag = new Listenable.Boolean(false);
        private Listenable.Boolean showNetMakeBadAgainFlag = new Listenable.Boolean(false);
        private Listenable.Boolean showNetContinueAfterQuantumDoneFlag = new Listenable.Boolean(true);
        private int nFixagesSinceLastNoise = 0;
        private Listenable.Int showNetPolishQuantum = new Listenable.Int(0,1000, 10);
        private boolean pointOutRedNetEdges = false;
        private int netFlowIndex = 0;
        private int highlightedDualEdgeIndex = -1;
        private boolean showOriginFlag = false;
        private boolean showGridFlag = true;
        private Listenable.Double gridBrightness = new Listenable.Double(0.,1.,.09); // tweaked til I like it
        private boolean showSmallestEnclosingDisk = false; // no way to change, currently
        private double gridSnapQuantum = 1./64; // no way to change, currently
        private boolean thermometerIsLinear = false;
        private int thermometerWidth = 10;

        // Symmetry to try to use when clicking or dragging with ctrl down.
        // Intent is what's shown in the ui;
        // extent is what's been applied to the model (since changing symmetry can change the model, if one or more of the
        // "when changing symmetry" flags is set).
        // (Or, can just think of the non-intent values as "previous" or "applied" values.)
        public Listenable.Int pRotationalSymmetryIntent = new Listenable.Int(1,10, 1);
        public Listenable.Int qRotationalSymmetryIntent = new Listenable.Int(1,10, 1);
        private Listenable.Int pRotationalSymmetry = new Listenable.Int(1,10, pRotationalSymmetryIntent.get());
        private Listenable.Int qRotationalSymmetry = new Listenable.Int(1,10, qRotationalSymmetryIntent.get());
        private Listenable.Boolean leftRightSymmetry = new Listenable.Boolean(false);
        private Listenable.Boolean sphereCentralSymmetry = new Listenable.Boolean(false);
        public Listenable.Boolean q346meanRepeatRegardlessOfPFlag = new Listenable.Boolean(false);
        private Listenable.Boolean remapFundamentalRegionWhenChangingRotationalSymmetry = new Listenable.Boolean(false);
        private Listenable.Boolean deleteUnmatchedVertsWhenChangingRotationalSymmetry = new Listenable.Boolean(false);

        public Listenable.Boolean wrapAroundSphereFlagIntent = new Listenable.Boolean(false);
        private Listenable.Boolean wrapAroundSphereFlag = new Listenable.Boolean(wrapAroundSphereFlagIntent.get());
        public Listenable.Boolean centerSphereFlag = new Listenable.Boolean(true);
        private Listenable.Double wrapSphereCurvature = new Listenable.Double(.001,2., 1.);
        private Listenable.Double wrapSphereSymbolicRadius = new Listenable.Double(.001,1.999, 1.);
        private Listenable.Boolean transformWhenChangingWrapOrCenterFlag = new Listenable.Boolean(true);

        private Listenable.Double backfaceBrightness = new Listenable.Double(0.,1., .25);
        public Listenable.Int gridN = new Listenable.Int(0,1000,10);
        private Listenable.Double gridRotDegrees = new Listenable.Double(0.,360.,0.);
        private Listenable.Int blueNoiseN = new Listenable.Int(0,1000,100);
        private Listenable.Int justNoiseN = new Listenable.Int(0,1000,100);
        private Listenable.Int convexNoiseN = new Listenable.Int(0,1000,144);
        private Listenable.Double singleExitLagoonVirtualN = new Listenable.Double(0.,100.,16);
        private Listenable.Int singleExitLagoonNBeforeApex = new Listenable.Int(0,100,3);
        private Listenable.Int singleExitLagoonNBeforeBeforeApex = new Listenable.Int(0,100,3);
        private Listenable.Int singleExitLagoonNAfterApex = new Listenable.Int(0,100,3);
        private Listenable.Int singleExitLagoonNAfterAfterApex = new Listenable.Int(0,100,3);
        private Listenable.Double singleExitLagoonQuillSlopeNumerator = new Listenable.Double(0.,1000.,1.);
        private Listenable.Double singleExitLagoonQuillSlopeDenominator = new Listenable.Double(1.,1000.,1.);
        private Listenable.Double singleExitLagoonQuillSlopeNumeratorNumerator = new Listenable.Double(0.,1000.,1.);
        private Listenable.Double singleExitLagoonQuillSlopeDenominatorDenominator = new Listenable.Double(1.,1000.,1.);
        private Listenable.Boolean singleExitLagoonPointApexUpFlag = new Listenable.Boolean(false);
        private Listenable.Boolean singleExitLagoonSynthesizeExactDualFlag = new Listenable.Boolean(false);
        private Listenable.Boolean singleExitLagoonFudgeWeightsSoApexIsFarthestFromCurvatureCenterFlag = new Listenable.Boolean(false);
        private Listenable.Int sweepKiller1Multiplicity = new Listenable.Int(1, 100, 19);
        private Listenable.Int outStressorNLevels = new Listenable.Int(1, 50, 20);
        private Listenable.Int outStressorSpiralN = new Listenable.Int(1, 256, 64);

        private Surface.Sphere theSphereSurface = new Surface.Sphere(new double[]{0,0,centerSphereFlag.get() ? 0. : -1./wrapSphereCurvature.get()}, 1./wrapSphereCurvature.get());
        private Surface.Paraboloid theParaboloidSurface = new Surface.Paraboloid(-.5);
        private Surface theSurface = (wrapAroundSphereFlag.get() ? (Surface)theSphereSurface
                                                                 : (Surface)theParaboloidSurface);
        private Listenable.Int sbaryExperimentType = new Listenable.Int(0,2, 0);
        private Listenable.Boolean showEulerLineWhenShowingWeightsFlag = new Listenable.Boolean(false);


        // very special case visualization... if these are set,
        // highlight the primal/dual feature corresponding to the mouse angle.
        private double primalDualVisAngles[] = null;
        private int primalDualVisPrimalVertInds[] = null;
        private int primalDualVisDualVertInds[] = null;
        private Listenable.Boolean primalDualVisFlag = new Listenable.Boolean(true);


        // when middle-mouse is emulated by alt-left-mouse,
        // releasing alt in the middle of the drag looks like releasing middle, which is unfriendly...
        // so instead, we store draggingRotation.
        // but, have to remember to turn it off on mouse up,
        // whether or not alt is still down.
        private boolean draggingRotation = false;

        private double localScaleZ;
        private double twirl; // x->y
        private double tilt; // z->y
        private double eye[];
        private double localToWorld[][]; // product of matrices of the above 4
        { resetLocalToWorld(); }
        private void resetLocalToWorld()
        {
            localScaleZ = 0.; // yes, zero-- we flatten when parked at tilt=0 or tilt=Math.PI
            twirl = 0.;
            tilt = 0.;
            eye = new double[] {0.,0.,4.}; // XXX doesn't work if not on z axis
        }
        private double[][] getRotMat()
        {
            double cx = Math.cos(twirl);
            double sx = Math.sin(twirl);
            double cy = Math.cos(tilt);
            double sy = Math.sin(tilt);
            double twirlMat[][] = {
                { cx, sx, 0, 0},
                {-sx, cx, 0, 0},
                { 0,   0, 1, 0},
                { 0,   0, 0, 1},
            };
            double tiltMat[][] = {
                {1, 0,  0,  0},
                {0, cy,-sy, 0},
                {0, sy, cy, 0},
                {0, 0, 0,   1},
            };
            return VecMath.mxm(twirlMat, tiltMat);
        }
        private double[][] getLocalToWorld()
        {
            double localScaleMat[][] = {
                {1,0,0,0},
                {0,1,0,0},
                {0,0,wrapAroundSphereFlag.get()?1.:localScaleZ,0},
                {0,0,0,1},
            };
            double rotMat[][] = getRotMat();
            // XXX the following assumes the eye is on the Z axis
            double perspMat[][] = new double[][] {
                {1,0,0,0},
                {0,1,0,0},
                {0,0,1,-1./eye[2]},
                {0,0,-eye[2],1},
            };
            return VecMath.mxmxm(localScaleMat, rotMat, perspMat);
        }
        // Uses:
        //  localScaleZ
        //  getRotMat()
        //  eye
        //  wrap
        private void pickPointOnSurface(double thisP[], double offset, double resultPointOnSurface[/*3*/], boolean preferBackFacing)
        {
            CHECK_EQ(resultPointOnSurface.length, 3); // TODO: change to 4 at some point
            double eyeInLocalSpace[] = VecMath.mxv(getRotMat(), eye); // multiply on wrong side, i.e. apply transpose i.e. inverse
            if (!wrapAroundSphereFlag.get())
                eyeInLocalSpace[2] /= MAX(localScaleZ, 1e-6); // XXX aren't we doing this below too?
            double towardsPointInLocalSpace[] = VecMath.mxv(getRotMat(), new double[]{thisP[0],thisP[1],0.});

            // gag, that returned a 4d vector
            eyeInLocalSpace = (double[])Arrays.subarray(eyeInLocalSpace, 0, 3);
            towardsPointInLocalSpace = (double[])Arrays.subarray(towardsPointInLocalSpace, 0, 3);

            if (!wrapAroundSphereFlag.get())
            {
                if (localScaleZ == 0)
                {
                    resultPointOnSurface[0] = thisP[0];
                    resultPointOnSurface[1] = thisP[1];
                    resultPointOnSurface[2] = -.5*(SQR(thisP[0])+SQR(thisP[1]));
                    return;
                }
                eyeInLocalSpace[2] /= localScaleZ;
                towardsPointInLocalSpace[2] /= localScaleZ; // XXX didn't we do this above too?

                eyeInLocalSpace[2] -= offset;
                towardsPointInLocalSpace[2] -= offset;
                // for paraboloid with parameter -.5, always
            }

            double scratch[][] = new double[2][4];
            int nAnswers = theSurface.rayIntersect(scratch,
                                                   offset,
                                                   eyeInLocalSpace,
                                                   VecMath.vmv(towardsPointInLocalSpace, eyeInLocalSpace),
                                                   Surface.MISS_REFLECT);
            CHECK_GE(nAnswers, 1); // 1 if inside, 2 if outside
            double whichScratch[] = scratch[preferBackFacing ? (nAnswers-1) : 0];
            VecMath.vxs(3, resultPointOnSurface, whichScratch, 1./whichScratch[3]); // TODO: what if infinite?
        } // pickPointOnSurface

        private boolean pickedPointIsBackFacingOnSurface(double pointOnSurface[])
        {
            double eyeInLocalSpace[] = VecMath.mxv(getRotMat(), eye); // multiply on wrong side, i.e. apply transpose i.e. inverse
            if (!wrapAroundSphereFlag.get())
                eyeInLocalSpace[2] /= MAX(localScaleZ, 1e-6);
            // gag, that returned a 4d vector
            eyeInLocalSpace = (double[])Arrays.subarray(eyeInLocalSpace, 0, 3);
            double towardsPointInLocalSpace[] = VecMath.copyvec(pointOnSurface);

            double offset = theSurface.offset(pointOnSurface);

            if (!wrapAroundSphereFlag.get())
            {
                if (localScaleZ == 0)
                {
                    return eyeInLocalSpace[2] < 0;
                }
                eyeInLocalSpace[2] /= localScaleZ;
                towardsPointInLocalSpace[2] /= localScaleZ;

                eyeInLocalSpace[2] -= offset;                   // XXX is this right?
                towardsPointInLocalSpace[2] -= offset;                  // XXX is this right?
                // for paraboloid with parameter -.5, always
            }

            double scratch[][] = new double[2][4];
            int nAnswers = theSurface.rayIntersect(scratch,
                                                   offset,
                                                   eyeInLocalSpace,
                                                   VecMath.vmv(towardsPointInLocalSpace, eyeInLocalSpace),
                                                   Surface.MISS_FORCE);

            CHECK_GE(nAnswers, 1); // 1 if inside, 2 if outside
            FORI (iAnswer, nAnswers)
                VecMath.vxs(3, scratch[iAnswer], scratch[iAnswer], 1./scratch[iAnswer][3]); // TODO: what if infinite?

            if (nAnswers == 1)
                return false; // not really clear, but doesn't matter I don't think


            // which answer? the one closest to the query point (and it should be at it exactly, in fact, modulo roundoff error)
            CHECK_EQ(nAnswers, 2);

            double d0 = VecMath.distsqrd(3, towardsPointInLocalSpace, scratch[0]);
            double d1 = VecMath.distsqrd(3, towardsPointInLocalSpace, scratch[1]);
            return d1<d0;
        } // pickedPointIsBackFacingOnSurface


    //
    // Applet-generic member variables...
    //
        public int eventVerbose = 0; // can set with eventVerbose=1 on command line
        private static int nonEventVerbose = 0; // so static classes can refer to it
        private boolean antiAliasingFlag = false;
        private boolean implementAntiAliasingInHardware = true; // XXX should have a better name for this-- really mean let java runtime do it


        // Still need to mess with these.
        // Current state:
        //      swing true homegrown false: works great, no flicker during resize.
        //      swing false homegrown true: flicker during resize :-(  this would be the one I'd like to use, if it worked.
        public boolean swingDoubleBufferFlag = true;
        public boolean homeGrownDoubleBufferFlag = false; // TODO: swing does this for us... can get rid of it, as soon as I figure out how to do the magnifying glass without it  XXX except it still flickers during resize!  (not violent black/grey any more due to System.setProperty("sun.awt.noerasebackground", "true"), but still flickering!  argh!  wtf?  THERE MUST BE A BUG: Double buffering is not working properly during resize!!!   (note: I have overhauled since I said all that, so need to revisit)

        private java.awt.Image backBufferImage = null;
        private MyGraphics3D mostRecentGraphics = null;
        private Listenable.Boolean showMagFlag = new Listenable.Boolean(false);
        private int magFactor = 9;
        private int magWidth = 25;
        private int nPaints = 0;


        private double prevP[] = null;
        private double origP[] = null;
        // "effective" position is position of the thing being dragged. might be a few pixels away from actual position of mouse cursor.
        private double prevPeffective[] = null;
        private double origPeffective[] = null;

    //
    // Track mouse state...
    // (I think java newer versions of java (XXX starting when?)
    // let you query from the events themselves,
    // but e.g. in 1.1 there is no way to tell whether button1
    // is down during a drag without keeping state
    // TODO: see if I can get rid of these.  the "ctrl newly down!" thing might be a problem.
    //
        private boolean button1IsDown = false;
        private boolean button2IsDown = false;
        private boolean button3IsDown = false;
        private boolean controlIsDown = false;
        private boolean shiftIsDown = false;
        private UndoItem.State stateWhenPressed = null;




    public static class JTextFieldForString extends JValidatingTextField
    {
        private Listenable.Listener listener; // need to keep a strong ref to it for as long as I'm alive
        public JTextFieldForString(final Listenable.String s)
        {
            super(s.get());
            s.addListener(listener = new Listenable.Listener() {
                @Override public void valueChanged()
                {
                    setText(s.get());
                }
            });
            addActionListener(new java.awt.event.ActionListener() {
                @Override public void actionPerformed(java.awt.event.ActionEvent e)
                {
                    s.set(getText());
                }
            });
        }
    } // JTextFieldForString
    // Stolen from MC4DControlPanel.java
    public static class JTextFieldForNumber extends JValidatingTextField
    {
        private Listenable.Listener listener; // need to keep a strong ref to it for as long as I'm alive
        private Listenable.Number f;

        @Override public boolean validate(String text)
        {
            try {
                // attempt to parse, ignore return value
                if (f instanceof Listenable.Int)
                    Integer.parseInt(text);
                else if (f instanceof Listenable.Long)
                    Long.parseLong(text);
                else
                    Double.parseDouble(text);
                return true;
            } catch (Exception e) {
                return false;
            }
        }

        private void updateText(Listenable.Number f)
        {
            if (f instanceof Listenable.Int)
                setText(""+((Listenable.Int)f).get());
            else if (f instanceof Listenable.Long)
                setText(""+((Listenable.Long)f).get());
            else if (f instanceof Listenable.Float)
                setText(""+((Listenable.Float)f).get());
            else
                setText(""+(float)((Listenable.Double)f).get()); // XXX ARGH! we lose precision with this (float) cast, but if we don't do it, we can get, for example, 37.092999999999996 which looks lame.  should figure out another way to prevent that.
        }

        public JTextFieldForNumber(final Listenable.Number f)
        {
            super(f instanceof Listenable.Int ? ""+((Listenable.Int)f).max() // XXX not quite right, min may be longer string than max
                : f instanceof Listenable.Long ? ""+((Listenable.Long)f).max()
                : "99.99"); // give it enough space for 99.999 (on my computer, always seems to give an extra space, which we don't need)
            this.f = f;
            updateText(f);
            f.addListener(listener = new Listenable.Listener() {
                @Override public void valueChanged()
                {
                    updateText(f);
                }
            });
            addActionListener(new java.awt.event.ActionListener() {
                @Override public void actionPerformed(java.awt.event.ActionEvent e)
                {
                    try
                    {
                        f.setDouble(Double.valueOf(getText()).doubleValue());
                    }
                    catch (java.lang.NumberFormatException nfe)
                    {
                        // maybe should print an error message or something
                        updateText(f);
                    }
                }
            });
        }
        @Override public java.awt.Dimension getPreferredSize()
        {
            //System.out.println("in JTextFieldForNumber.getPreferredSize()");
            // default seems taller than necessary
            // on my computer... and in recent VMs it's even worse
            // (changed from 29 to 31).
            // Fudge it a bit...
            // XXX not sure this will look good on all systems... if it doesn't, we can just remove it
            // XXX hmm, actually makes things mess up when growing and shrinking, that's weird
            java.awt.Dimension preferredSize = super.getPreferredSize();
            //System.out.println("textfield.super.preferredSize() = "+preferredSize);
            if (true)
                preferredSize.height -= 2;

            // XXX another hack, wtf?
            if (true)
            {
                if (f instanceof Listenable.Int)
                    preferredSize.width = 50;
                else if (f instanceof Listenable.Long)
                    preferredSize.width = 100;
                else
                    preferredSize.width = 100;
            }

            //System.out.println("out JTextFieldForNumber.getPreferredSize(), returning "+preferredSize);
            return preferredSize;
        }
        // weird, the following is called during horizontal shrinking
        // but not during horizontal expanding... if we don't do this too
        // then it looks wrong when shrinking.  what a hack...
        @Override public java.awt.Dimension getMinimumSize()
        {
            //System.out.println("in JTextFieldForNumber.getMinimumSize()");
            java.awt.Dimension minimumSize = super.getMinimumSize();
            //System.out.println("textfield.super.minimumSize() = "+minimumSize);
            if (true)
                minimumSize.height -= 2;

            // XXX another hack, wtf?
            if (true)
            {
                if (f instanceof Listenable.Int)
                    minimumSize.width = 50;
                else if (f instanceof Listenable.Long)
                    minimumSize.width = 100;
                else
                    minimumSize.width = 100;
            }

            //System.out.println("out JTextFieldForNumber.getMinimumSize(), returning "+minimumSize);
            return minimumSize;
        }
    } // JTextFieldForNumber


    public static class JCheckBoxForBoolean extends JCheckBox
    {
        private Listenable.Listener listener; // need to keep a strong ref to it for as long as I'm alive
        public JCheckBoxForBoolean(String name, final Listenable.Boolean b)
        {
            super(name);
            setSelected(b.get());
            addItemListener(new java.awt.event.ItemListener() {
                @Override public void itemStateChanged(java.awt.event.ItemEvent e)
                {
                    b.set(isSelected());
                }
            });
            b.addListener(listener = new Listenable.Listener() {
                @Override public void valueChanged()
                {
                    setSelected(b.get());
                }
            });
        }
    } // JCheckBoxForBoolean

    public static class JSliderForFloat extends JSlider
    {
        private Listenable.Listener listener; // need to keep a strong ref to it for as long as I'm alive

        // private helper function
        private void updateThumb(Listenable.Number f)
        {
            double value = f.getDouble();
            double defaultValue = f.defaultDouble();
            double frac = (value-f.minDouble())/(f.maxDouble()-f.minDouble());

            //setValue((int)(getMinimum() + ((getMaximum()-getVisibleAmount())-getMinimum())*frac));
            setValue((int)(getMinimum() + (getMaximum()-getMinimum())*frac));
        }

        public JSliderForFloat(final Listenable.Number f)
        {
            // 3 significant digits seems reasonable...
            /*
            super(JSlider.HORIZONTAL,
                  (int)Math.round(f.minDouble()*1000),
                  (int)Math.round(f.maxDouble()*1000),
                  (int)Math.round(f.getDouble())*1000);
            */
            super(JSlider.HORIZONTAL, 0, 1000, 500);

            if (false)
            {
                PRINT(getMinimum());
                PRINT(getMaximum());
                PRINT(getValue());
            }

            setMinorTickSpacing(1);  // .001 units
            setMajorTickSpacing(10); // .01 units
            f.addListener(listener = new Listenable.Listener() {
                @Override public void valueChanged()
                {
                    updateThumb(f);
                }
            });
            addChangeListener(new javax.swing.event.ChangeListener() {
                @Override public void stateChanged(javax.swing.event.ChangeEvent e)
                {
                    if (false)
                    {
                        System.out.println("==================");
                        System.out.println("    min = "+getMinimum());
                        System.out.println("    max = "+getMaximum());
                        System.out.println("    max-min = "+(getMaximum()-getMinimum()));
                        System.out.println("    getValue() = "+getValue());
                        System.out.println("    getMinorTickSpacing() = "+getMinorTickSpacing());
                        System.out.println("    getMajorTickSpacing() = "+getMajorTickSpacing());
                        System.out.println("    getSize() = "+getSize());
                        System.out.println("    getPreferredSize() = "+getPreferredSize());
                    }
                    // Doing the following in double precision makes a difference;
                    // if we do it in float, we get ugly values in the textfield
                    double frac = (double)(getValue()-getMinimum())
                                / (double)(getMaximum()-getMinimum());
                    f.setDouble(f.minDouble() + frac*(f.maxDouble()-f.minDouble()));
                    // will trigger valueChanged()
                    // which will call updateThumb()
                }
            });
            updateThumb(f); // because we fucked it up in the contructor?
        }
    } // JSliderForFloat


    public static class SliderForFloat extends JSliderForFloat
    {
        public SliderForFloat(final Listenable.Number f)
        {
            super(f);
        }
    }


    // stolen from SpiralApplet
    static JRow makeIncrementableTextFieldForMultipleOf(final Listenable.Number f,
                                                        final String name,
                                                        final double increment,
                                                        final double mustBeMultipleOf, // 0 if no constraint
                                                        final boolean mustBePositive)
    {
        if (mustBeMultipleOf != 0.) {
            CHECK_EQ(increment % mustBeMultipleOf, 0.); // otherwise incrementing wouldn't be very useful
        }
        final java.awt.Color asciiToColor[] = new java.awt.Color[128];
        asciiToColor[' '] = null;
        asciiToColor['b'] = java.awt.Color.BLACK;
        return new JRow() {{
            add(new JRepeatingButton("") {
                OVERRIDE public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(11*hidpimag,11*hidpimag); }
                OVERRIDE public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(11*hidpimag,11*hidpimag); }
                OVERRIDE public void paint(java.awt.Graphics g)
                {
                    super.paint(g);
                    drawPixmapCentered(g, getSize(), hidpimag, asciiToColor,
                                       new String[] {
                                          "bbb bbb",
                                       });
                }
            {
                addActionListener(new java.awt.event.ActionListener() {
                    OVERRIDE public void actionPerformed(java.awt.event.ActionEvent e)
                    {
                        f.setDouble(f.getDouble()-increment);
                    }
                });
                setToolTipText("<html>decrement "+name+"</html>");
            }});
            add(new JTextFieldForNumber(f) {
                OVERRIDE public boolean validate(String text)
                {
                    if (!super.validate(text)) return false;
                    try {
                        double d = Double.parseDouble(text);
                        if (mustBePositive && !(d > 0.)) return false;
                        if (mustBeMultipleOf != 0. && d % mustBeMultipleOf != 0.) return false;
                        return true;
                    } catch (Exception e) {
                        return false;
                    }
                }
                {
                    setToolTipText("<html>"+name+"</html>");
                }
            } );
            add(new JRepeatingButton("") {
                OVERRIDE public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(11*hidpimag,11*hidpimag); }
                OVERRIDE public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(11*hidpimag,11*hidpimag); }
                OVERRIDE public void paint(java.awt.Graphics g)
                {
                    super.paint(g);
                    drawPixmapCentered(g, getSize(), hidpimag, asciiToColor,
                                       new String[] {
                                          " b   b ",
                                          "bbb bbb",
                                          " b   b ",
                                       });
                }
            {
                addActionListener(new java.awt.event.ActionListener() {
                    OVERRIDE public void actionPerformed(java.awt.event.ActionEvent e)
                    {
                        f.setDouble(f.getDouble()+increment);
                    }
                });
                setToolTipText("<html>increment "+name+"</html>");
            }});
        }};
    } // makeIncrementableTextFieldForMultipleOf
    static JRow makeIncrementableTextFieldForNumber(final Listenable.Number f,
                                                    final String name,
                                                    final double increment)
    {
        return makeIncrementableTextFieldForMultipleOf(f, name, increment, 0., false);
    } // makeIncrementableTextFieldForNumber


    // Note, caller must store the returned strong reference to this for as long as it wants the listener to live.
    // It might make sense to make alternate versions of this, e.g. tie to negation or other function of listenable(s).
    private static Listenable.Listener tieEnabledTo(final java.awt.Component component, final Listenable.Boolean listenable)
    {
        component.setEnabled(listenable.get());
        Listenable.Listener listener = new Listenable.Listener() {
            @Override public void valueChanged()
            {
                component.setEnabled(listenable.get());
            }
        };
        listenable.addListener(listener);
        return listener;
    }

    private static double[] parseSweepOriginHomo(String text)
    {
        //String[] tokens = text.trim().split("\\s+");
        String[] tokens = com.donhatchsw.compat.regex.split(text.trim(), "\\s+");
        if (tokens.length != 3)
            return null;
        double[] answer = new double[3];
        FORI (i, 3)
        {
            try
            {
                answer[i] = Double.parseDouble(tokens[i]);
            }
            catch (NumberFormatException e)
            {
                return null;
            }
        }
        if (answer[0]==0. && answer[1]==0. && answer[2]==0.)
        {
            // 0 0 0 is not a valid homogenous point
            return null;
        }
        return answer;
    } // parseSweepOriginHomo




    //
    // Half-assed clone.
    // just runs main again (but with no args this time!)
    // and copies the original mesh to the new one,
    // along with as much state as possible by copying fields.
    //
    public void cloneApplet()
    {
        System.out.println("    in cloneApplet");
        ShephardsPlayApplet clonedApplet = main0(new String[0]);
        clonedApplet.mesh = new Mesh(this.mesh); // dup it

        // Now try to copy as much state as possible.  Hack hack hack
        java.lang.reflect.Field fields[] = this.getClass().getDeclaredFields();
        System.out.println("        "+fields.length+" fields:");
        FORI (iField, fields.length)
        {
            java.lang.reflect.Field field = fields[iField];
            System.out.println("            "+field.getName());
            int modifiers = field.getModifiers();
            Class<?> type = field.getType();
            String typeName = type.getName();
            System.out.println("                modifiers: "+field.getModifiers());
            System.out.println("                string: "+field.toString());
            System.out.println("                type: "+type);
            if ((modifiers & java.lang.reflect.Modifier.FINAL) != 0)
                continue; // it's final, can't set, and doesn't matter anyway
            if ((modifiers & java.lang.reflect.Modifier.STATIC) != 0)
                continue; // it's static, can't copy from one instance to another
            try
            {
                if (type.isPrimitive())
                {
                    // clonedApplet.field = this.field;
                    field.set(clonedApplet, field.get(this));
                }
                else if (type.isArray())
                {
                    Class<?> ultimateComponentType = type.getComponentType();
                    while (ultimateComponentType.isArray())
                        ultimateComponentType = ultimateComponentType.getComponentType();
                    if (ultimateComponentType.isPrimitive())
                    {
                        // clonedApplet.field = Arrays.copy(this.field, 100);
                        //field.set(clonedApplet, field.get(this)); // no, want a deep copy
                        //field.set(clonedApplet, Arrays.copy(field.get(this), 100)); // XXX wtf? doesn't work?
                        //field.set(clonedApplet, Arrays.copy(field.get(this), 1)); // XXX wtf? doesn't work?
                        field.set(clonedApplet, Arrays.copy(field.get(this), 0)); // XXX wtf? works?  but I want a deep copy!
                    }
                    else
                    {
                        CHECK(false);
                        // good, there aren't any of these
                    }
                }
                else if (Listenable.class.isAssignableFrom(type))
                {
                    //clonedApplet.field.set(this.field.get())
                    ((Listenable)field.get(clonedApplet)).set((Listenable)field.get(this));
                }
                else
                {
                    // leave it alone (leave clonedApplet with initial field value)
                }
            }
            catch (IllegalAccessException e)
            {
                System.out.println("Hey! wtf? IllegalAccessException!");
            }

        }

        // set window title.  have to do this AFTER all the Listenables,
        // otherwise it will get clobbered.
        clonedApplet.windowTitle.set("clone of " + this.windowTitle.get());

        System.out.println("    out cloneApplet");

    } // cloneApplet


    private static boolean parseBoolean(String s)
    {
      // Boolean.valueOf() is too lax: "t", "xxx", "1" all evaluate to false.
      if (s.equals("true")) return true;
      if (s.equals("false")) return false;
      throw new IllegalArgumentException(Arrays.toStringCompact(s)+" is not \"true\" or \"false\"");
    }

    // TODO: put this in some public place in donhatchsw; it's generally useful
    private static void setPublicFieldsFromArgsOrDie(Object object, String[] args)
    {
        int verboseLevel = 0;
        if (verboseLevel >= 1) System.out.println("        in setPublicFieldsFromArgsOrDie");

        // TODO: consider just using getDeclaredField?  (will that find the field in superclasses?)
        java.util.HashMap<String,java.lang.reflect.Field> name2field = new java.util.HashMap<String,java.lang.reflect.Field>();
        {
            Class<?> classs = object.getClass();
            java.lang.reflect.Field[] fields = classs.getFields();
            for (java.lang.reflect.Field field : fields)
            {
                int modifiers = field.getModifiers();
                if (!java.lang.reflect.Modifier.isPublic(modifiers)) continue;
                if (java.lang.reflect.Modifier.isFinal(modifiers)) continue;
                if (java.lang.reflect.Modifier.isStatic(modifiers)) continue;
                String name = field.getName();
                if (verboseLevel >= 1) System.out.println("              field "+Arrays.toStringCompact(name)+": "+field);
                CHECK_EQ(name2field.get(name), null);
                name2field.put(name, field);
            }
        }
        int nErrors = 0;
        for (String arg : args)
        {
            if (verboseLevel >= 1) System.out.println("          arg = "+Arrays.toStringCompact(arg));
            int equalsIndex = arg.indexOf("=");
            if (equalsIndex == -1)
            {
                System.err.println("unrecognized arg "+Arrays.toStringCompact(arg));
                nErrors++;
                continue;
            }
            String name = arg.substring(0, equalsIndex);
            String valueString = arg.substring(equalsIndex+1);
            if (verboseLevel >= 1) System.out.println("              name = "+Arrays.toStringCompact(name));
            if (verboseLevel >= 1) System.out.println("              valueString = "+Arrays.toStringCompact(valueString));
            java.lang.reflect.Field field = name2field.get(name);
            if (field == null)
            {
                System.err.println("no public non-static non-final field "+Arrays.toStringCompact(name));
                nErrors++;
                continue;
            }
            Class<?> fieldType = field.getType();
            try {
                if (false) {}

                else if (fieldType.equals(boolean.class)) { field.setBoolean(object, parseBoolean(valueString)); }
                // decode instead of parseInt or valueOf, so "0x10" will work, for all integer types
                else if (fieldType.equals(byte.class)) { field.setByte(object, Byte.decode(valueString).byteValue()); }
                else if (fieldType.equals(short.class)) { field.setShort(object, Short.decode(valueString).shortValue()); }
                else if (fieldType.equals(int.class)) { field.setInt(object, Integer.decode(valueString).intValue()); }
                else if (fieldType.equals(long.class)) { field.setLong(object, Long.decode(valueString).longValue()); }
                else if (fieldType.equals(float.class)) { field.setFloat(object, Float.parseFloat(valueString)); }
                else if (fieldType.equals(double.class)) { field.setDouble(object, Double.parseDouble(valueString)); }
                else if (fieldType.equals(char.class)) { field.setChar(object, valueString.charAt(0)); }
                else if (fieldType.equals(String.class)) { field.set(object, valueString); }

                // CBB: derives from instead of equals, for all of the following? not sure
                else if (fieldType.equals(Listenable.Boolean.class)) { ((Listenable.Boolean)field.get(object)).set(parseBoolean(valueString)); }
                else if (fieldType.equals(Listenable.Int.class)) { ((Listenable.Int)field.get(object)).set(Integer.decode(valueString)); }
                else if (fieldType.equals(Listenable.Float.class)) { ((Listenable.Float)field.get(object)).set(Float.parseFloat(valueString)); }
                else if (fieldType.equals(Listenable.Double.class)) { ((Listenable.Double)field.get(object)).set(Double.parseDouble(valueString)); }
                else {
                    System.err.println("don't know how to set field "+field);
                    nErrors++;
                    continue;
                }
            } catch (Exception e) {
                System.err.println(e + " while initializing "+field+" from arg "+Arrays.toStringCompact(arg));
                nErrors++;
                continue;
            };
        }
        if (nErrors > 0) {
            System.err.println("Exiting due to "+nErrors+" error"+(nErrors==1?"":"s")+" while processing command line.");
            System.exit(1);
        }
        if (verboseLevel >= 1) System.out.println("        out setPublicFieldsFromArgsOrDie");
    }  // setPublicFieldsFromArgsOrDie


    //
    // Main...
    //
    public static ShephardsPlayApplet main0(final String args[])
    {
        System.out.println("in main0");
        System.out.println("  java "+System.getProperty("java.version"));


        if (false)
        {
            GeomUtils.testRowProjectiveMatrixFromTiePoints();
            System.exit(0);
        }

        if (false)
        {
            // CBB: put this in SymmetryUtils?
            // test computeSymmetryGroup3d
            int pqs[][] = {
                {1,1},
                {1,2},
                {2,1},
                {1,3},
                {3,1},
                {1,4},
                {4,1},
                {1,5},
                {5,1},
                {1,6},
                {6,1},

                {2,2},
                {2,3},
                {3,2},
                {2,4},
                {4,2},
                {2,5},
                {5,2},
                {2,6},
                {6,2},

                {3,3},
                {3,4},
                {4,3},
                {3,5},
                {5,3},
            };

            FORI (iSphereCentralSymmetry, 2)
            FORI (iLeftRightSymmetry, 2)
            {
                boolean sphereCentralSymmetry = iSphereCentralSymmetry==1;
                boolean leftRightSymmetry = iLeftRightSymmetry==1;
                FORI (i, pqs.length)
                {
                    int p = pqs[i][0];
                    int q = pqs[i][1];
                    {
                        System.out.println("    testing computeSymmetryGroup3d(p="+p+", q="+q+", leftRight="+leftRightSymmetry+", central="+sphereCentralSymmetry);
                        boolean repeatSymmetryWorkInProgress = false; // not testing it, currently
                        SymmetryUtils.computeSymmetryGroup3d(p, q, leftRightSymmetry, sphereCentralSymmetry, repeatSymmetryWorkInProgress);
                    }
                }
            }
            return null;
        } // test computeSymmetryGroup3d

        // TODO: can probably still simplify more, since ShephardsPlayApplet is now a JFrame instead of a JApplet

        final ShephardsPlayApplet applet = new ShephardsPlayApplet();

        final JFrame frame = applet;
        frame.setTitle(applet.windowTitle.get());

        com.donhatchsw.awt.MainWindowCount.setExitOnLastClose(frame);

        //dumpComponentHierarchy(frame, 0, 0, 1);

        {
          // CBB: too much hackery here
          boolean savedTransformFlag = applet.transformWhenChangingWrapOrCenterFlag.get();
          applet.transformWhenChangingWrapOrCenterFlag.set(false);

          setPublicFieldsFromArgsOrDie(applet, args);

          applet.transformWhenChangingWrapOrCenterFlag.set(savedTransformFlag);

          // must do this after setting public members!
          // TODO: make it a listenable!
          if (!applet.swingDoubleBufferFlag) {
            // Disable swing's double buffering.
            // Not sure whether we want it in the long run, and disabling it lets me confirm that
            // ancestor components aren't doing unnecessary clears, if I comment out the clear
            // in paintComponent.
            for (java.awt.Component c = applet.theCanvas; c != null; c = c.getParent()) {
              if (c instanceof javax.swing.JComponent) {
                ((javax.swing.JComponent)c).setDoubleBuffered(false);
              }
            }
          }
        }

        applet.init();

        frame.setLocation(10, 10);
        // no frame.pack(), since we call setSize explicitly
        frame.setSize(720, 745);
        //frame.setSize(100,100);
        frame.setSize(300,300);
        //frame.setSize(512,512);
        //frame.setSize(768,768);
        //frame.setSize(1024,1024);

        frame.setVisible(true);

        applet.theMainAppletWindow = frame;


        // for benefit of any debugging function that wants to loop over frames...
        applet.theControlPanelWindow.setName("the control panel window");
        applet.theMainAppletWindow.setName("the main applet window");
        applet.theHelpWindow.setName("the help window");

        //applet.theControlPanelWindow.setVisible(false); // can uncomment this to hide it initially for debugging

        System.out.println("out main0");
        return applet;
    } // main0

    public static void main(final String args[])
    {
        // Voodoo (nothing on the web explains it satisfactorily):
        // Avoids black-grey flickering during resize.
        // (although the picture still flickers a bit)...
        // *if* applet is added to content pane of frame.
        // (But, I figured out how to avoid that, by transplanting contents instead of adding!
        // voodoo voodoo voodoo.)
        // (And, further simplified since then so we're more and more direct)
        // Do this anyway, since it may make resizes slightly more efficient. (voodoo)
        System.setProperty("sun.awt.noerasebackground", "true");

        // More responsive tooltips that don't go away while mouse is over the thing
        //PRINT(javax.swing.ToolTipManager.sharedInstance().getInitialDelay());  // 750
        //PRINT(javax.swing.ToolTipManager.sharedInstance().getDismissDelay());  // 4000
        //PRINT(javax.swing.ToolTipManager.sharedInstance().getReshowDelay());  // 500, not sure what this is exactly
        javax.swing.ToolTipManager.sharedInstance().setInitialDelay(250);
        javax.swing.ToolTipManager.sharedInstance().setDismissDelay(Integer.MAX_VALUE);

        ShephardsPlayApplet applet = main0(args);
        // release main's token
        com.donhatchsw.awt.MainWindowCount.decrementAndExitIfImTheLastOne();
    } // main

} // class ShephardsPlayApplet
