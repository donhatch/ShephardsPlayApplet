/*
Trying to make a little applet
that will let me play with triangulations with heights,
and produce the dual diagrams with heights.

BUGS:
  Single-lagoon-exit related:
    - dual vert numbering isn't sane (maybe nothing can be done about that...
      I think they come out in order based on tri order,
      which is based on edge order (rather than original tri order; that gets lost).

  Gui-related:
    - scale/pan with ctrl down should do less, with shift down should do more
    - rearrange gui to make room for single-exit lagoon controls, somehow
    - Show Dual verts/edges not right
    - what the hell is the crap being drawn on the borders //of the flip buttons?
    - don't use EXIT_ON_CLOSE if 1.2!! need to use reflection
    - maybe checkboxes next to the sliders for:
        showGridFlag
        showBackFaces
        wrapAroundSphere
    - I hear Swing double-buffers by default so I don't need to
       - ARGH! can't just rip it out, the magnifying glass depends on it!
    - need to put stuff in event thread? not sure
    - arrow keys don't scroll help window
    - use swing sliders instead of scrollbars

  Wrap-sphere related:
    - for Surface, most important thing is that offset is right-- should adjust final result to make it right
    - backfaces now completely nonfunctional
    - backface culling is flakey (or, need a coherent scheme, not keying on show-inside-out)
    - backface culling sometimes slightly wrong-- using wrong criterion? symmetry 3,4 or something, some backfacing tries are shown with frontfacing color
    - doesn't interact correctly with undo/redo or save/restore
    - should compute ray lengths in flat space or something so they don't overshoot
      the point that goes to infinity.  or, just recognize the point
      at infinity and go only halfway there, or something. I don't completely understand yet.
    - use homogeneous coords of some sort, so it doesn't blow up due to singularities
      when converting in either direction?
      Could just always store sphere coords, but the problem is
      we'd lose precise info about the heights, especially when heights are zero
      or exactly equal
    - draw horizon of surface (done) and of ground plane?

  Homogeneous related:
    - DUMP.infinitePrimalVerts.off, the infinite verts are rendered badly
      when flat paraboloid

  Symmetry-related:
    - wrapped, with central symmetry on:
        - changing p from odd to even seems to lose some symmetry connections. OH I see, hmm, it's retaining the fact that it's an antiprism.  this might get better when fundamental regions are handled consistently in general
        - changing p from an even number to anything else gets whacked
    - only enable flips that don't mess up current symmetry
    - when switching symmetry, map the fundamental region (schwarz triangle)
    - symmetry averaging is wrong on sphere--- it shrinks towards sphere center (and even worse now that I'm doing it in homo space, I think).  need a height-above-sphere-preserving average.
    - respect symmetry:
        - rubberbanding
    - collapse to-add verts via symmetries (e.g. so we don't add multiple verts at origin)
          (I think this works correctly on mouse down, but not when dragging new vert from non-origin to origin)
    - improve kaleidescope:
        - detect and use center
        - detect and use complete symmetry group
        - key to increase or decrease period (requires vertex in center?)
        - snap closest image to exact image? hmm, not sure
        - mode to place new verts in kaleidescope? (draw dots at images of cursor? might be subtle)
    - when increasing or decreasing rotational symmetry, show animation?
    - wouldn't hurt to allow {4,4}, {6,3}, {3,6} ... just show a few layers.
        actually hmm, is there a projection from 4d torus that makes
        this actually work?  hmm I'm thinking no.

  Net-related:
    - netless8 / sharpest at every vertex / net -> assertion failed: _W == 1
    - netless9 / outward / net -> assertion failed: _W == 1
    - net flow doesn't work when delaunayized with "calc underside when delaunayizing"
    - dragging net edges is pretty fucked right now

  Inside-outedness-related:
    - I think I do need an option to exclude back faces, or combine them, when delaunayizing--
      the backfacing edges are a nuisance.
      (XXX what was I saying here?  is this done now?)

  Misc:
    - get VERY clear on what negative weights/W's mean through the pipeline
    - on cygwin, can I make it listen for ctrl-z on console, and suspend, just like vim does?
    - don't swap diagonals I can't see (back facing)
    - 'f' button assert-fails
    - think about whether current non-uniform scaling is more useful than keeping primal on sphere and re-computing dual, and/or whether both are useful
      and the horizon in between.  or else use zbuffer?
    - should ConvexHull use fuzzy equality testing in more places, to avoid twinkling on grid? (hmm, maybe twinkling on grid is actually useful in a way?)
    - picking net edges is wrong, need to do it in screen space
    - ctrl-d to swap primal with dual never seems to produce anything good any more
    - dragging edges doesn't work yet when not ortho
    - 'd' to delete edge not working in non-ortho
    - clear and click with shift down-- creates a zero-length edge, I think it shouldn't.
      just make it so the rubberbanding won't create a new vert to exact same place.
    - tri grid, '+' 3 times, tilt 180 degrees -> assert fail in IsMiniBall
        (very big radius?)
    - Hexes Spiral Alt -> assert fail in IsMiniBall
    - miniball still not handling dup vertices well
    - circle drawing is off by a pixel sometimes, e.g. miniball with:
        radius 3/8:
            top is too low by 1 pixel
            bottom can be too low by 1 pixel (if translated)
            left is too right by 1 pixel
        radius 1/2:
            left is too right by 1 pixel
    - why do I need that extendAndOrthogonalize?  it shouldn't be getting non-orthogonal so quickly! (that was when using trackball... maybe a moot issue now)
    - use exact group calculation rather than generateVertices when adding a point

TO DO:
    - use vert.arity to determine arity, silly
    - highlight vert when close enough to pick it?
    - get rid of all calcInsideOutDualVertsFlag=false code, just always calculate them (I think)
    - really need a concept of separate viewing matrix,
      that can be changed without accumulating rounding error in the verts
    - thank about attaching a listener to a tuple of values, so they just get one callback when multiple values changed?
    - also get-on-demand (so can make a push-dirty pull-clean dag)
    - don't draw edges if dihedral angle is flat?  would prevent flicker
    - make verts smaller when not part of convex hull?
    - can we make ConvexHull incremental? might be useful when just dragging a single point.
      hmm, tricky, since interior points can become non-interior.  is there a nice data structure
      that includes them? or, maybe there are not too many, so just add them all explicitly and it might still be a win
    - need different way of expressing drag-all-verts than shift-middle; middle should be for view manip I think
    - get rid of "in/out makeDualMesh" message, maybe replace with in-image counter (for convexHull / makeDualMesh, redraws)
    - actually merge vertices when edge super small? (or guarantee cut?)
    - think about how user can express grid params
    - uniform hyperbolic grid? hmm
    - need a way to ask where remaining bad lagoon exits are (finding them visually
      is a needle in a haystack sometimes)
    - I think I can get rid of the mesh x,y,h
      and have just have the momentAndArea
      (call it coords? not sure)
      it's okay to edit the x,y,h coords directly
      on the primal, since weights are all 1...
      and on the dual, no one ever just tweaks one in isolation.
      (however, note that things like rescale get incredibly painful)
      (I think I'm going to scratch this, it would make everything
      more opaque)
      (then again it would allow higher dimensions
      or alternate interpretations)

    - when dragging a point with continuouslyDelaunayizeFlag true,
      show the nearest-neighbor-interpolation thing
      (i.e. use the DT of all but the dragged point,
      and show the new cell stealing area from others, in a diff color)
    - make IsMiniBall robust to degeneracies
    - color lagoon edges yellow when dragging cut?
    - should save/restore cuts in terms of primal from,to verts to be robust? maybe

    - showNetFlag should go in the undo item, otherwise it's weird when you do something
      that changes it but undo doesn't change it back

    - put in dump files:
        - selected verts
        - net
        - wrapAroundSphereFlag?

    - try to maintain selection when swapping diagonals and stuff

    - think about which optimization types to retain if any
        - maybe optimization should always be max min length, but choice should be how to match scale and translate afterwards.
          Translate:
              - match overall cg of verts to cg of tris
              - match overall cg of verts to circumcenter of tris (can be tricky if degenerate)
          Scale:
              - match variance in some sense?
              - match total length?
              - match bbox?


    - +/- should maybe look at undo and redo stack, and use it if possible, to save memory?

    - animation of optimization
    - animation of swap (what was I talking about here?)
    - animation of delete vertex (maybe-- might have to triangulate the face to get this to work, which wouldn't be a bad thing)
    - key to delaunayize?
    - don't draw crap when resizing (and fix whatever other applet I got this from too)
    - figure out why stack traces show .java on top even after renumbering
    - write a generic applet to reduce pain each time
    - other mesh editing operations (split face by edge, split edge by vertex, join adjacent vertices, separate a vertex into two (but how to assign the neighbors?))  (idea: same interface as split face by edge... but only works if on two different faces... maybe connec dual verts?)
    - BUG: figure out how to make it not repaint continuously when resizing (my other appets too) (is this just a canvas problem?)
    - BUG: when only part of window gets exposed, only the exposed part gets painted?  hmm, not sure I have control over this
    - BUG: can't reconnect an isolated vertex to the rest
    - look at this, maybe clues about positive octant penalty functions...
        http://www.cs.indiana.edu/~yingfeng/ABSURDIST/javadoc/penalty/PenaltyMinimizer.html
      something about "translating into a positive orthant problem" and "optimizing over the positive orthant"
      intersection of a linear subspace witht the positive orthant
      http://projecteuclid.org/Dienst/UI/1.0/Summarize/euclid.mmj/1028988894
      The knee-jerk mapping:
      http://www.math.dartmouth.edu/~doyle/docs/jerk/jerk.pdf
*/

#include "macros.h"

// So can compile in pre-1.4,
// we use these instead of java.awt.event.MouseEvent.BUTTON1 etc.
#define java_awt_event_MouseEvent_BUTTON1 1
#define java_awt_event_MouseEvent_BUTTON2 2
#define java_awt_event_MouseEvent_BUTTON3 3

import com.donhatchsw.util.Arrays;
import com.donhatchsw.util.Complex;
import com.donhatchsw.util.MyMath;
import com.donhatchsw.util.VecMath;
import com.donhatchsw.util.SortStuff;
import com.donhatchsw.util.ConvexHull;
import com.donhatchsw.util.LinearProgramming;
import com.donhatchsw.util.MergeFind;
import com.donhatchsw.util.UndoTreeSquirrel;
import com.donhatchsw.util.TriangulationOptimizer;
import com.donhatchsw.util.FuzzyPointHashTable;
import com.donhatchsw.util.MiniBall;
import com.donhatchsw.util.Minimizer;
import com.donhatchsw.util.NewtonSolver;
import com.donhatchsw.util.Listenable;
import com.donhatchsw.compat.ArrayList;
import com.donhatchsw.compat.IntArrayList;
import com.donhatchsw.compat.DoubleArrayList;

import com.donhatchsw.awt.ColLayout;
import com.donhatchsw.awt.JRow;
import com.donhatchsw.awt.JCol;
import com.donhatchsw.awt.JTablePanel;

import javax.swing.ButtonGroup;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JApplet;
import javax.swing.JLabel;
import javax.swing.JButton;
import javax.swing.JRadioButton;
import javax.swing.JTextField;
import javax.swing.JTextArea;
import javax.swing.JToggleButton;
import javax.swing.JScrollPane;
import javax.swing.JSeparator;
import javax.swing.JSlider;
import javax.swing.JMenuBar;
import javax.swing.JMenu;
import javax.swing.JMenuItem;
import javax.swing.JComboBox;
import javax.swing.JCheckBox;


public class ShephardsPlayApplet
    extends JApplet
{
    //
    // Utilities for applet stuff...
    //
        private String getParameterString(String paramName,
                                       String defaultValue)
        {
            String paramValueString = getParameter(paramName);
            if (paramValueString != null)
                return paramValueString;
            else
                return defaultValue;
        }
        private int getParameterInt(String paramName,
                                    int defaultValue)
        {
            String paramValueString = getParameter(paramName);
            if (paramValueString != null)
            {
                try
                {
                    return Integer.decode(paramValueString).intValue();
                }
                catch (NumberFormatException e)
                {
                    return 0;
                }
            }
            else
                return defaultValue;
        }
        private double getParameterDouble(String paramName,
                                          double defaultValue)
        {
            String paramValueString = getParameter(paramName);
            if (paramValueString != null)
            {
                try
                {
                    return Double.parseDouble(paramValueString);
                }
                catch (NumberFormatException e)
                {
                    return 0;
                }
            }
            else
                return defaultValue;
        }
        private boolean getParameterBoolean(String paramName,
                                            boolean defaultValue)
        {
            String paramValueString = getParameter(paramName);
            if (paramValueString != null)
            {
                // Too simplistic, only honors case-sensitive "true"
                //return Boolean.valueOf(paramValueString).booleanValue();

                try
                {
                    int n = Integer.decode(paramValueString).intValue();
                    return n != 0;
                }
                catch (NumberFormatException e)
                {
                    if (paramValueString.equalsIgnoreCase("true")
                     || paramValueString.equalsIgnoreCase("yes")
                     || paramValueString.equalsIgnoreCase("t")
                     || paramValueString.equalsIgnoreCase("y"))
                        return true;
                    return false;
                }
            }
            else
                return defaultValue;
        }

        // ButtonGroup doesn't support *at most* one checked.
        // Implement one that does.
        private static class ButtonGroupThatAllowsNone
        {
            private ArrayList buttons = new ArrayList();
            private ArrayList actionListeners = new ArrayList();
            public void add(final JToggleButton button) // checkbox or radio button
            {
                java.awt.event.ActionListener actionListener = new java.awt.event.ActionListener() {
                    public void actionPerformed(java.awt.event.ActionEvent e)
                    {
                        if (button.isSelected())
                        {
                            // then deselect everyone else
                            int nButtons = buttons.size();
                            for (int i = 0; i < nButtons; ++i)
                            {
                                JToggleButton otherButton = (JToggleButton)buttons.get(i);
                                if (otherButton != button)
                                    if (otherButton.isSelected())
                                        otherButton.setSelected(false);
                            }
                        }
                    }
                };
                button.addActionListener(actionListener);
                buttons.add(button);
                actionListeners.add(actionListener);
            }
        }; // class ButtonGroupThatAllowsNone
        // That was fun, let's make another that enforces
        // that the selection is a prefix of the set of buttons.
        private static class PrefixButtonGroup
        {
            private ArrayList buttons = new ArrayList();
            private ArrayList actionListeners = new ArrayList();
            public void add(final JToggleButton button) // checkbox or radio button
            {
                java.awt.event.ActionListener actionListener = new java.awt.event.ActionListener() {
                    public void actionPerformed(java.awt.event.ActionEvent e)
                    {
                        int nButtons = buttons.size();
                        if (button.isSelected())
                        {
                            // then select everyone before me
                            FORI (i, nButtons)
                            {
                                JToggleButton otherButton = (JToggleButton)buttons.get(i);
                                if (otherButton == button)
                                    break;
                                if (!otherButton.isSelected())
                                    otherButton.setSelected(true);
                            }
                        }
                        else
                        {
                            // deselect everyone after me
                            FORIDOWN(i, nButtons)
                            {
                                JToggleButton otherButton = (JToggleButton)buttons.get(i);
                                if (otherButton == button)
                                    break;
                                if (otherButton.isSelected())
                                    otherButton.setSelected(false);
                            }
                        }
                    }
                };
                button.addActionListener(actionListener);
                buttons.add(button);
                actionListeners.add(actionListener);
            }
        } // PrefixButtonGroup

        // http://tech-eureka.blogspot.com/2010/12/how-to-implement-repeating-swing.html
        private static class JRepeatingButton extends JButton
        {
            public JRepeatingButton(String text)
            {
                super(text);
            }
            public void addActionListener(final java.awt.event.ActionListener actionListener)
            {
                addMouseListener(new java.awt.event.MouseAdapter() {
                    private javax.swing.Timer repeatTimer = null;
                    private java.awt.event.ActionEvent synthesizedActionEvent = null;
                    public void mousePressed(java.awt.event.MouseEvent mouseEvent)
                    {
                        synthesizedActionEvent = new java.awt.event.ActionEvent(
                            JRepeatingButton.this,
                            java.awt.event.ActionEvent.ACTION_PERFORMED,
                            JRepeatingButton.this.getText(),
                            mouseEvent.getModifiers());
                        // the ctor that takes "when" introduced some time in (1.3, 1.6]
                        // so don't use it, so we can compile using 1.3
                        actionListener.actionPerformed(synthesizedActionEvent); // initial execution

                        repeatTimer = new javax.swing.Timer(100, new java.awt.event.ActionListener() {
                            public void actionPerformed(java.awt.event.ActionEvent timerActionEvent)
                            {
                                actionListener.actionPerformed(synthesizedActionEvent);
                            }
                        });
                        repeatTimer.setInitialDelay(500);
                        repeatTimer.start();
                    }
                    public void mouseReleased(java.awt.event.MouseEvent arg0)
                    {
                        repeatTimer.stop();
                        repeatTimer = null;
                        synthesizedActionEvent = null;
                    }
                });
            }
        } // JRepeatingButton

        // A textfield that turns green or red when editing and not yet committed.
        // Esc reverts.
        private static class JValidatingTextField extends JTextField
        {
            // subclass can override this
            public boolean validate(String text)
            {
                return true; // it's all good by default
            }

            private String committedText;
            public JValidatingTextField(String text)
            {
                super(text);
                committedText = getText();

                getDocument().addDocumentListener(new javax.swing.event.DocumentListener() {
                    private void anyUpdate(javax.swing.event.DocumentEvent e)
                    {
                        if (!getText().equals(committedText)) // TODO: == doesn't work here?  I forget the difference
                        {
                            if (validate(getText()))
                            {
                                // TODO: if value semantically equals committed value, turn white instead.  hmm, can build this into validate() by having it return a value (Object), maybe?
                                setBackground(new java.awt.Color(192,255,192)); // light green
                            }
                            else
                                setBackground(new java.awt.Color(255,192,192)); // pink
                        }
                        else
                            setBackground(java.awt.Color.white);
                    }
                    public void insertUpdate(javax.swing.event.DocumentEvent e)  {anyUpdate(e);}
                    public void removeUpdate(javax.swing.event.DocumentEvent e)  {anyUpdate(e);}
                    public void changedUpdate(javax.swing.event.DocumentEvent e) {anyUpdate(e);}
                });
                addKeyListener(new java.awt.event.KeyAdapter() {
                    public void keyPressed(java.awt.event.KeyEvent e)
                    {
                        if (e.getKeyCode() == java.awt.event.KeyEvent.VK_ESCAPE)
                        {
                            setText(committedText);
                        }
                    }
                });
                addActionListener(new java.awt.event.ActionListener() {
                    public void actionPerformed(java.awt.event.ActionEvent e)
                    {
                        if (validate(getText()))
                        {
                            committedText = getText();
                            setBackground(java.awt.Color.white);
                        }
                    }
                });
            }
            public void setText(String text)
            {
                super.setText(text);
                if (validate(getText()))
                {
                    committedText = getText();
                    setBackground(java.awt.Color.white);
                }
            }
        } // JValidatingTextField

        private abstract static class JTableOfPanIcons extends JTablePanel
        {
            // concrete subclass must implement this
            abstract public void buttonPressed(int iRow, int iCol);

            private java.awt.Color asciiToColor;
            JTableOfPanIcons(int nRows, int nCols, final java.awt.Color asciiToColor[])
            {
                // used as "fill" argument to add()
                final java.awt.GridBagConstraints stretchxy = new java.awt.GridBagConstraints(){{fill=BOTH;weightx=weighty=1.;}};

                final String panIcons[][][] = makePanIcons();
                FORI (iRow, nRows)
                {
                    FORI (iCol, nCols)
                    {
                        // take center chunk out of icons array
                        int iIconRow = iRow + (panIcons.length-nRows)/2;
                        int iIconCol = iCol + (panIcons[iIconRow].length-nCols)/2;
                        final String panIcon[] = panIcons[iIconRow][iIconCol];
                        final int iRowFinal = iRow;
                        final int iColFinal = iCol;
                        add(new JRepeatingButton("") {
                            public java.awt.Dimension getMinimumSize() { return new java.awt.Dimension(panIcon[0].length()*hidpimag, panIcon.length*hidpimag); }
                            public java.awt.Dimension getPreferredSize() { return getMinimumSize(); }
                            public void paint(java.awt.Graphics g)
                            {
                                drawPixmapCentered(g, getSize(), asciiToColor, panIcon);
                            }
                        {
                            addActionListener(new java.awt.event.ActionListener() {
                                public void actionPerformed(java.awt.event.ActionEvent e)
                                {
                                    buttonPressed(iColFinal, iRowFinal);
                                }
                            });
                        }}, stretchxy);
                    }
                    advanceRow();
                }
            }

            // utility function to make a 5x5 array of pan icons
            private static String[][][] makePanIcons()
            {
                // Initialize with a fundamental region;
                // will reflect to get all of them
                String panIcons[][][] = {
                    {
                        {
                            "             ",
                            " *******     ",
                            " ******      ",
                            " *****       ",
                            " **********  ",
                            " *********   ",
                            " ** *****    ",
                            " *  ******   ",
                            "    *******  ",
                            "    ** ***** ",
                            "    *   **** ",
                            "         *** ",
                            "             ",
                        },
                        {
                            "           ",
                            "  ***      ",
                            "  ******   ",
                            "  ******   ",
                            " *****     ",
                            " ******    ",
                            " ** ****** ",
                            "    ****** ",
                            "   *****   ",
                            "   ******  ",
                            "   ** ***  ",
                            "      ***  ",
                            "           ",
                        },
                        {
                            "         ",
                            "    *    ",
                            "   ***   ",
                            "  *****  ",
                            " ******* ",
                            "   ***   ",
                            "  *****  ",
                            " ******* ",
                            "   ***   ",
                            "   ***   ",
                            "   ***   ",
                            "   ***   ",
                            "         ",
                        },
                        null,
                        null
                    },
                    {
                        null,
                        {
                            "           ",
                            "           ",
                            "  *******  ",
                            "  ******   ",
                            "  *****    ",
                            "  ******   ",
                            "  *******  ",
                            "  ** ****  ",
                            "  *   ***  ",
                            "           ",
                            "           ",
                        },
                        {
                            "         ",
                            "         ",
                            "    *    ",
                            "   ***   ",
                            "  *****  ",
                            " ******* ",
                            "   ***   ",
                            "   ***   ",
                            "   ***   ",
                            "         ",
                            "         ",
                        },
                        null,
                        null
                    },
                    {
                        null,
                        null,
                        {
                            "         ",
                            "         ",
                            "         ",
                            "         ",
                            "         ",
                            "         ",
                            "         ",
                            "         ",
                            "         ",
                        },
                        null,
                        null
                    },
                    {null,null,null,null,null},
                    {null,null,null,null,null},
                };
                int mats[][][] = {
                    {{0,1},{1,0}},  // transpose
                    {{-1,0},{0,1}}, // left/right reflect
                    {{1,0},{0,-1}}, // up/down reflect
                };
                FORI (iMat, mats.length)
                {
                    int mat[][] = mats[iMat];
                    final int nRows = panIcons.length;
                    final int nCols = panIcons[0].length;
                    FORI (iRow, nRows)
                    FORI (iCol, nCols)
                    {
                        String panIconIn[] = panIcons[iRow][iCol];
                        if (panIconIn != null)
                        {
                            //System.out.println("            it's not null!");
                            // transform by mat.
                            // what's the destination row and column?
                            int in[] = {1-nCols + 2*iCol,
                                        1-nRows + 2*iRow};
                            int out[] = VecMath.vxm(in, mat);
                            int jCol = (out[0] - (1-nCols))/2;
                            int jRow = (out[1] - (1-nRows))/2;
                            if (panIcons[jRow][jCol] == null)
                            {

                                // xform panIconIn into panIcons[jRow][jCol]

                                int widthIn = panIconIn[0].length();
                                int heightIn = panIconIn.length;
                                int widthOut = mat[0][0]==0. ? heightIn : widthIn;
                                int heightOut = mat[0][0]==0. ? widthIn : heightIn;
                                char charsOut[][] = new char[heightOut][widthOut];
                                FORI (iiRow, heightIn)
                                FORI (iiCol, widthIn)
                                {
                                    // reuse in,out
                                    in[0] = 1-widthIn + 2*iiCol;
                                    in[1] = 1-heightIn + 2*iiRow;
                                    VecMath.vxm(out, in, mat);
                                    int jjCol = (out[0] - (1-widthOut))/2;
                                    int jjRow = (out[1] - (1-heightOut))/2;
                                    charsOut[jjRow][jjCol] = panIconIn[iiRow].charAt(iiCol);
                                }
                                String panIconOut[] = new String[heightOut];
                                FORI (jjRow, heightOut)
                                    panIconOut[jjRow] = new String(charsOut[jjRow]);
                                panIcons[jRow][jCol] = panIconOut;
                            }
                        }
                    }
                }
                return panIcons;
            } // makePanIcons
        } // abstract class JTableOfPanIcons


        private static class ShephardsPlayAppletControlPanel
            extends JPanel
        {
            public ShephardsPlayAppletControlPanel(final ShephardsPlayApplet applet)
            {
                java.awt.Container contentPane = this;

                contentPane.setLayout(new ColLayout());

                // used as "fill" argument to add()
                final java.awt.GridBagConstraints stretchx = new java.awt.GridBagConstraints(){{fill=HORIZONTAL;weightx=1.;}};
                final java.awt.GridBagConstraints stretchy = new java.awt.GridBagConstraints(){{fill=VERTICAL;weighty=1.;}};
                final java.awt.GridBagConstraints stretchxy = new java.awt.GridBagConstraints(){{fill=BOTH;weightx=weighty=1.;}};
                final java.awt.GridBagConstraints rightjustify = new java.awt.GridBagConstraints(){{anchor=EAST;}};

                // used as arg to setMargin()
                final java.awt.Insets nomargin = new java.awt.Insets(0,0,0,0);


                //
                // Make a bunch of named components that we know we'll want;
                // we can decide where to put them later
                //
                final JRepeatingButton undoButton = new JRepeatingButton("Undo") {{
                    setMargin(nomargin);
                    addActionListener(new java.awt.event.ActionListener() {
                        public void actionPerformed(java.awt.event.ActionEvent e)
                        {
                            UndoItem item = (UndoItem)applet.undoTreeSquirrel.undo();
                            if (item != null)
                            {
                                applet.mesh = new Mesh(item.before.mesh);
                                applet.meshOfSelectedTris = applet.mesh; // hackish
                                applet.continuouslyDelaunayizeFlag.set(item.before.continuouslyDelaunayizeFlag);
                                applet.optimizeFlag.set(item.before.optimizeFlag);
                                applet.optimizationTypeIndex.set(item.before.optimizationTypeIndex);
                                applet.optimizationType = applet.availableOptimizationTypes[applet.optimizationTypeIndex.get()];
                                applet.selectedTris = (int[][])Arrays.copy(item.before.selectedTris, 2);
                                applet.selectedDualVertIndices = VecMath.copyvec(item.before.selectedDualVertIndices);
                                applet.allDualVertsAreSelected = item.before.allDualVertsAreSelected;
                                applet.dirtyDualMesh(); // *before* we restore applet.theNet
                                applet.theNet = (item.before.netEdgeStatuses==null ? null : new Net(applet.getDualMesh(), applet.mesh, item.before.netEdgeStatuses));
                            }
                            else
                            {
                                System.out.println("Nothing to undo!");
                            }
                            applet.theCanvas.repaint();
                        }
                    });
                }};
                final JRepeatingButton redoButton = new JRepeatingButton("Redo") {{
                    setMargin(nomargin);
                    addActionListener(new java.awt.event.ActionListener() {
                        public void actionPerformed(java.awt.event.ActionEvent e)
                        {
                            UndoItem item = (UndoItem)applet.undoTreeSquirrel.redo();
                            if (item != null)
                            {
                                applet.mesh = new Mesh(item.after.mesh);
                                applet.meshOfSelectedTris = applet.mesh; // hackish
                                applet.continuouslyDelaunayizeFlag.set(item.after.continuouslyDelaunayizeFlag);
                                applet.optimizeFlag.set(item.after.optimizeFlag);
                                applet.optimizationTypeIndex.set(item.after.optimizationTypeIndex);
                                applet.optimizationType = availableOptimizationTypes[applet.optimizationTypeIndex.get()];
                                applet.selectedTris = (int[][])Arrays.copy(item.after.selectedTris, 2);
                                applet.selectedDualVertIndices = VecMath.copyvec(item.after.selectedDualVertIndices);
                                applet.allDualVertsAreSelected = item.after.allDualVertsAreSelected;
                                applet.dirtyDualMesh(); // *before* we restore applet.theNet
                                applet.theNet = (item.after.netEdgeStatuses==null ? null : new Net(applet.getDualMesh(), applet.mesh, item.after.netEdgeStatuses));
                            }
                            else
                            {
                                System.out.println("Nothing to redo!");
                            }
                            applet.theCanvas.repaint();
                        }
                    });
                }};
                final JButton cloneButton = new JButton("Clone") {{
                    setMargin(nomargin);
                    addActionListener(new java.awt.event.ActionListener() {
                        public void actionPerformed(java.awt.event.ActionEvent e)
                        {
                            applet.cloneApplet();
                        }
                    });
                }};
                final JButton clearButton = new JButton("Clear") {{
                    setMargin(nomargin);
                    addActionListener(new java.awt.event.ActionListener() {
                        public void actionPerformed(java.awt.event.ActionEvent e)
                        {
                            // XXX dup code
                            UndoItem.State before = applet.newUndoItemState();
                            synchronized(applet.showNetFlag) // since another thread checks it once in a while
                            {
                                applet.showNetFlag.set(false); // so user won't get confused when clicking doesn't make verts appear
                            }
                            applet.mesh = new Mesh();
                            applet.selectedTris = new int[][] {};
                            applet.selectedDualVertIndices = new int[] {};
                            applet.allDualVertsAreSelected = false;
                            applet.resetLocalToWorld();
                            if (applet.continuouslyDelaunayizeFlag.get()) applet.delaunayize();
                            applet.dirtyDualMesh(); // before snapping after state, so applet.theNet will be cleared XXX aren't there a zillion places we're neglecting to take this into account?

                            UndoItem.State after = applet.newUndoItemState();
                            applet.undoTreeSquirrel.Do(new UndoItem(before, after));

                            applet.theCanvas.repaint();
                        }
                    });
                }};
                final JButton loadButton = new JButton("Load DUMP.off") {{
                    setMargin(nomargin);
                    addActionListener(new java.awt.event.ActionListener() {
                        public void actionPerformed(java.awt.event.ActionEvent e)
                        {
                            UndoItem.State before = applet.newUndoItemState();

                            applet.load("DUMP.off");

                            UndoItem.State after = applet.newUndoItemState();
                            applet.undoTreeSquirrel.Do(new UndoItem(before, after));

                            applet.theCanvas.repaint();
                        }
                    });
                }};
                final JButton saveButton = new JButton("Save DUMP.off xyh") {{
                    setMargin(nomargin);
                    addActionListener(new java.awt.event.ActionListener() {
                        public void actionPerformed(java.awt.event.ActionEvent e)
                        {
                            applet.save("DUMP.off", false);
                        }
                    });
                }};
                final JButton saveHomoButton = new JButton("Save DUMP.off XYZW") {{
                    setMargin(nomargin);
                    addActionListener(new java.awt.event.ActionListener() {
                        public void actionPerformed(java.awt.event.ActionEvent e)
                        {
                            applet.save("DUMP.off", true);
                        }
                    });
                }};
                final JButton saveDualButton = new JButton("Save DUALVERTS.txt") {{
                    setMargin(nomargin);
                    addActionListener(new java.awt.event.ActionListener() {
                        public void actionPerformed(java.awt.event.ActionEvent e)
                        {
                            applet.dualSave("DUALVERTS.txt");
                        }
                    });
                }};

                final JTextFieldForNumber theGridNTextField = new JTextFieldForNumber(applet.gridN);
                final JTextFieldForNumber theBlueNoiseNTextField = new JTextFieldForNumber(applet.blueNoiseN);

                final java.awt.Component cannedThingButtons[] = {
                    new JButton("Hexes Spiral") {{
                        addActionListener(new java.awt.event.ActionListener() {
                            public void actionPerformed(java.awt.event.ActionEvent e)
                            {
                                UndoItem.State before = applet.newUndoItemState();

                                applet.doCannedThingHexesSpiral();

                                UndoItem.State after = applet.newUndoItemState();
                                applet.undoTreeSquirrel.Do(new UndoItem(before, after));

                                applet.theCanvas.repaint();
                            }
                        });
                    }},
                    new JButton("Hexes Spiral Alt") {{
                        addActionListener(new java.awt.event.ActionListener() {
                            public void actionPerformed(java.awt.event.ActionEvent e)
                            {
                                UndoItem.State before = applet.newUndoItemState();

                                applet.doCannedThingHexesSpiralOther();

                                UndoItem.State after = applet.newUndoItemState();
                                applet.undoTreeSquirrel.Do(new UndoItem(before, after));

                                applet.theCanvas.repaint();
                            }
                        });
                    }},
                    new JButton("netless8 symmetric") {{
                        addActionListener(new java.awt.event.ActionListener() {
                            public void actionPerformed(java.awt.event.ActionEvent e)
                            {
                                UndoItem.State before = applet.newUndoItemState();

                                applet.doCannedThingNetless8Symmetric();

                                UndoItem.State after = applet.newUndoItemState();
                                applet.undoTreeSquirrel.Do(new UndoItem(before, after));

                                applet.theCanvas.repaint();
                            }
                        });
                    }},
                    new JButton("netless8") {{
                        addActionListener(new java.awt.event.ActionListener() {
                            public void actionPerformed(java.awt.event.ActionEvent e)
                            {
                                UndoItem.State before = applet.newUndoItemState();

                                applet.doCannedThingNetless8();

                                UndoItem.State after = applet.newUndoItemState();
                                applet.undoTreeSquirrel.Do(new UndoItem(before, after));

                                applet.theCanvas.repaint();
                            }
                        });
                    }},
                    new JButton("netless9") {{
                        addActionListener(new java.awt.event.ActionListener() {
                            public void actionPerformed(java.awt.event.ActionEvent e)
                            {
                                UndoItem.State before = applet.newUndoItemState();

                                applet.doCannedThingNetless9();

                                UndoItem.State after = applet.newUndoItemState();
                                applet.undoTreeSquirrel.Do(new UndoItem(before, after));

                                applet.theCanvas.repaint();
                            }
                        });
                    }},
                    new JButton("eyeball") {{
                        addActionListener(new java.awt.event.ActionListener() {
                            public void actionPerformed(java.awt.event.ActionEvent e)
                            {
                                UndoItem.State before = applet.newUndoItemState();

                                applet.doCannedThingEyeball();

                                UndoItem.State after = applet.newUndoItemState();
                                applet.undoTreeSquirrel.Do(new UndoItem(before, after));

                                applet.theCanvas.repaint();
                            }
                        });
                    }},
                    new JButton("Crack Killer") {{
                        addActionListener(new java.awt.event.ActionListener() {
                            public void actionPerformed(java.awt.event.ActionEvent e)
                            {
                                UndoItem.State before = applet.newUndoItemState();

                                applet.doCannedThingCrackKiller();

                                UndoItem.State after = applet.newUndoItemState();
                                applet.undoTreeSquirrel.Do(new UndoItem(before, after));

                                applet.theCanvas.repaint();
                            }
                        });
                    }},
                    new JButton("Crack Goes In Spiral") {{
                        addActionListener(new java.awt.event.ActionListener() {
                            public void actionPerformed(java.awt.event.ActionEvent e)
                            {
                                UndoItem.State before = applet.newUndoItemState();

                                applet.doCannedThingCrackGoesInSpiral();

                                UndoItem.State after = applet.newUndoItemState();
                                applet.undoTreeSquirrel.Do(new UndoItem(before, after));

                                applet.theCanvas.repaint();
                            }
                        });
                    }},
                    new JButton("Sweep Killer") {{
                        addActionListener(new java.awt.event.ActionListener() {
                            public void actionPerformed(java.awt.event.ActionEvent e)
                            {
                                UndoItem.State before = applet.newUndoItemState();

                                applet.doCannedThingSweepKiller0();

                                UndoItem.State after = applet.newUndoItemState();
                                applet.undoTreeSquirrel.Do(new UndoItem(before, after));

                                applet.theCanvas.repaint();
                            }
                        });
                    }},
                    new JButton("Sweep Killer 1") {{
                        addActionListener(new java.awt.event.ActionListener() {
                            public void actionPerformed(java.awt.event.ActionEvent e)
                            {
                                UndoItem.State before = applet.newUndoItemState();

                                applet.doCannedThingSweepKiller1();

                                UndoItem.State after = applet.newUndoItemState();
                                applet.undoTreeSquirrel.Do(new UndoItem(before, after));

                                applet.theCanvas.repaint();
                            }
                        });
                    }},
                    new JButton("Sweep Killer 2") {{
                        addActionListener(new java.awt.event.ActionListener() {
                            public void actionPerformed(java.awt.event.ActionEvent e)
                            {
                                UndoItem.State before = applet.newUndoItemState();

                                applet.doCannedThingSweepKiller2();

                                UndoItem.State after = applet.newUndoItemState();
                                applet.undoTreeSquirrel.Do(new UndoItem(before, after));

                                applet.theCanvas.repaint();
                            }
                        });
                    }},
                    new JButton("Algorithm5 Killer0") {{
                        addActionListener(new java.awt.event.ActionListener() {
                            public void actionPerformed(java.awt.event.ActionEvent e)
                            {
                                UndoItem.State before = applet.newUndoItemState();

                                applet.doCannedThingAlgorithm5Killer0();

                                UndoItem.State after = applet.newUndoItemState();
                                applet.undoTreeSquirrel.Do(new UndoItem(before, after));

                                applet.theCanvas.repaint();
                            }
                        });
                    }},
                    new JButton("Algorithm5 Killer1") {{
                        addActionListener(new java.awt.event.ActionListener() {
                            public void actionPerformed(java.awt.event.ActionEvent e)
                            {
                                UndoItem.State before = applet.newUndoItemState();

                                applet.doCannedThingAlgorithm5Killer1();

                                UndoItem.State after = applet.newUndoItemState();
                                applet.undoTreeSquirrel.Do(new UndoItem(before, after));

                                applet.theCanvas.repaint();
                            }
                        });
                    }},
                    new JButton("Far Lagoon Killer 1") {{
                        addActionListener(new java.awt.event.ActionListener() {
                            public void actionPerformed(java.awt.event.ActionEvent e)
                            {
                                UndoItem.State before = applet.newUndoItemState();

                                applet.doCannedThingFarthestLagoonExitKiller();

                                UndoItem.State after = applet.newUndoItemState();
                                applet.undoTreeSquirrel.Do(new UndoItem(before, after));

                                applet.theCanvas.repaint();
                            }
                        });
                    }},
                    new JButton("Far Lagoon Killer 2") {{
                        addActionListener(new java.awt.event.ActionListener() {
                            public void actionPerformed(java.awt.event.ActionEvent e)
                            {
                                UndoItem.State before = applet.newUndoItemState();

                                applet.doCannedThingFarthestLagoonExitKillerAltB();

                                UndoItem.State after = applet.newUndoItemState();
                                applet.undoTreeSquirrel.Do(new UndoItem(before, after));

                                applet.theCanvas.repaint();
                            }
                        });
                    }},
                    new JRow() {{
                        add(new JButton("Grid") {{
                            setMargin(nomargin);
                            addActionListener(new java.awt.event.ActionListener() {
                                public void actionPerformed(java.awt.event.ActionEvent e)
                                {
                                    // Flush the textfield value into gridN
                                    try
                                    {
                                        applet.gridN.setDouble(Double.valueOf(theGridNTextField.getText()).doubleValue());
                                    }
                                    catch (java.lang.NumberFormatException nfe)
                                    {
                                        // maybe should print an error message or something
                                        theGridNTextField.updateText(applet.gridN);
                                    }


                                    UndoItem.State before = applet.newUndoItemState();

                                    applet.doUniformGridThing(applet.gridN.get());

                                    if (applet.continuouslyDelaunayizeFlag.get()) applet.delaunayize();
                                    UndoItem.State after = applet.newUndoItemState();
                                    applet.undoTreeSquirrel.Do(new UndoItem(before, after));

                                    applet.theCanvas.repaint();
                                }
                            });
                        }}, stretchx);
                        add(theGridNTextField, stretchx);
                    }},
                    new JRow() {{
                        add(new JRepeatingButton("Blue Noise") {{
                            setMargin(nomargin);
                            addActionListener(new java.awt.event.ActionListener() {
                                public void actionPerformed(java.awt.event.ActionEvent e)
                                {
                                    // Flush the textfield value into blueNoiseN
                                    try
                                    {
                                        applet.blueNoiseN.setDouble(Double.valueOf(theBlueNoiseNTextField.getText()).doubleValue());
                                    }
                                    catch (java.lang.NumberFormatException nfe)
                                    {
                                        // maybe should print an error message or something
                                        theBlueNoiseNTextField.updateText(applet.blueNoiseN);
                                    }

                                    UndoItem.State before = applet.newUndoItemState();

                                    applet.doBlueNoiseThing(applet.blueNoiseN.get());

                                    if (applet.continuouslyDelaunayizeFlag.get()) applet.delaunayize();
                                    UndoItem.State after = applet.newUndoItemState();
                                    applet.undoTreeSquirrel.Do(new UndoItem(before, after));

                                    applet.theCanvas.repaint();
                                }
                            });
                        }}, stretchx);
                        add(theBlueNoiseNTextField, stretchx);
                    }},
                    new JRow() {{
                        add(new JCol() {{
                            add(new JButton("Single-Exit Lagoon") {{
                                addActionListener(new java.awt.event.ActionListener() {
                                    public void actionPerformed(java.awt.event.ActionEvent e)
                                    {
                                        UndoItem.State before = applet.newUndoItemState();

                                        applet.doCannedThingSingleExitLagoonPolygon(
                                            applet.singleExitLagoonVirtualN.get(),

                                            applet.singleExitLagoonNBeforeApex.get(),
                                            applet.singleExitLagoonNAfterApex.get(),
                                            applet.singleExitLagoonQuillSlopeNumerator.get(),
                                            applet.singleExitLagoonQuillSlopeDenominator.get(),

                                            applet.singleExitLagoonNBeforeBeforeApex.get(),
                                            applet.singleExitLagoonNAfterAfterApex.get(),
                                            applet.singleExitLagoonQuillSlopeNumeratorNumerator.get(),
                                            applet.singleExitLagoonQuillSlopeDenominatorDenominator.get(),

                                            applet.singleExitLagoonPointApexUpFlag.get(),
                                            applet.singleExitLagoonSynthesizeExactDualFlag.get());

                                        UndoItem.State after = applet.newUndoItemState();
                                        applet.undoTreeSquirrel.Do(new UndoItem(before, after));

                                        applet.theCanvas.repaint();
                                    }
                                });
                            }});
                            add(new JCheckBoxForBoolean("<html>Highlight<br>primal/dual<br>feature</html>", applet.primalDualVisFlag) {{
                                setToolTipText("<html>continuously highlight closest primal/dual feature<br>to mouse cursor angle</html>");
                            }});
                        }});
                        add(new JCol() {{
                            add(new JRow() {{
                                setToolTipText("internal angles of dual polygon are based on this"); // TODO: seems to apply to the label but not the textfield, bleah!
                                add(new JLabel("nVirtual:"));
                                add(new JTextFieldForNumber(applet.singleExitLagoonVirtualN));
                                add(new JLabel("        "));
                                add(new JCheckBoxForBoolean("point apex up", applet.singleExitLagoonPointApexUpFlag));
                            }});
                            add(new JTablePanel() {{
                                add(new JLabel("<html>after<br>apex:</html>") {{
                                    setToolTipText("number of dual verts after (on left of) apex");
                                }});
                                add(new JTextFieldForNumber(applet.singleExitLagoonNAfterApex));
                                add(new JLabel("<html>before<br>apex:</html>") {{
                                    setToolTipText("number of dual verts before (on right of) apex");
                                }});
                                add(new JTextFieldForNumber(applet.singleExitLagoonNBeforeApex));
                                add(new JLabel("<html>quill<br>slope:</html>") {{
                                    setToolTipText("slope of quills: 0 means laying flat");
                                }});
                                add(new JTextFieldForNumber(applet.singleExitLagoonQuillSlopeNumerator));
                                add(new JLabel("/"));
                                add(new JTextFieldForNumber(applet.singleExitLagoonQuillSlopeDenominator));
                                add(new JCheckBoxForBoolean("synth exact primal", applet.singleExitLagoonSynthesizeExactDualFlag) {{
                                    setToolTipText("<html>when checked, the dual is computed directly<br>(but with parts missing, so certain operations like scaling will be broken).<br>this is necessary when quill slope is 0 or close to it,<br>since in that case the primal is not well defined<br>and the dual can't be computed accurately from it.<br>NOTE: undo/redo will foil this.</html>");
                                }});
                                advanceRow();
                                add(new JLabel("<html>after<br>after:</html>") {{
                                    setToolTipText("number of dual verts after (on left of) apex");
                                }});
                                add(new JTextFieldForNumber(applet.singleExitLagoonNAfterAfterApex));
                                add(new JLabel("<html>before<br>before:</html>") {{
                                    setToolTipText("number of dual verts before (on right of) apex");
                                }});
                                add(new JTextFieldForNumber(applet.singleExitLagoonNBeforeBeforeApex));
                                add(new JLabel("<html>quill<br>slope:</html>") {{
                                    setToolTipText("slope of quills: 0 means laying flat");
                                }});
                                add(new JTextFieldForNumber(applet.singleExitLagoonQuillSlopeNumeratorNumerator));
                                add(new JLabel("/"));
                                add(new JTextFieldForNumber(applet.singleExitLagoonQuillSlopeDenominatorDenominator));
                            }});
                        }});
                    }},
                };

                final java.awt.Component theGridBrightnessLabel = new JLabel("Grid brightness:");
                final java.awt.Component theGridBrightnessTextField = new JTextFieldForNumber(applet.gridBrightness);
                final java.awt.Component theGridBrightnessSlider = new SliderForFloat(applet.gridBrightness);
                final java.awt.Component theBackfaceBrightnessLabel = new JLabel("Backface brightness:");
                final java.awt.Component theBackfaceBrightnessTextField = new JTextFieldForNumber(applet.backfaceBrightness);
                final java.awt.Component theBackfaceBrightnessSlider = new SliderForFloat(applet.backfaceBrightness);
                final java.awt.Component theWrapRadiusLabel = new JLabel("Wrap radius:") {{setEnabled(false);}};
                final java.awt.Component theWrapRadiusTextField = new JTextFieldForNumber(applet.wrapSphereSymbolicRadius) {{setEnabled(false);}};
                final java.awt.Component theWrapRadiusSlider = new SliderForFloat(applet.wrapSphereSymbolicRadius) {{setEnabled(false);}};


                // for making pixmaps from ascii
                final java.awt.Color asciiToColor[] = new java.awt.Color[128];
                asciiToColor[' '] = java.awt.Color.black;
                asciiToColor['w'] = java.awt.Color.white;
                asciiToColor['B'] = new java.awt.Color(64,64,255); // slightly light blue
                asciiToColor['b'] = new java.awt.Color(224,224,255); // very light blue

                contentPane.add(new JSeparator(), stretchx);
                contentPane.add(new JLabel("File/Edit"));
                add(new JRow() {{
                    add(new JLabel("        ")); // indent a bit
                    add(new JPanel() {{ // flow layout
                        add(cloneButton);
                        add(clearButton);
                        add(new JRow() {{ // so no space between this pair
                            add(undoButton);
                            add(redoButton);
                        }});
                        add(loadButton);
                        add(saveButton);
                        add(saveHomoButton);
                        add(saveDualButton);
                        // scale?
                    }});
                }});
                contentPane.add(new JSeparator(), stretchx);
                contentPane.add(new JLabel("Canned Things"));
                add(new JRow() {{
                    add(new JLabel("        ")); // indent a bit
                    add(new JPanel() {{ // flow layout
                        FORI (i, cannedThingButtons.length)
                        {
                            if (cannedThingButtons[i] instanceof JButton)
                                ((JButton)cannedThingButtons[i]).setMargin(nomargin);
                            add(cannedThingButtons[i], stretchx);
                        }
                        int prefWidth = calcMaxChildPreferredWidth(this) + 2*5; // 5 = flow layout's hgap
                        prefWidth += 8; // fudge for known current items: to get two slightly longer first rows instead of short third row
                        int prefHeight = calcFlowLayoutPreferredHeightGivenPreferredWidth(this, prefWidth);
                        // Experts advise don't ever use this, override getMinimumSize and getPreferredSize instead...
                        // whatever, this is far simpler.
                        setPreferredSize(new java.awt.Dimension(prefWidth, prefHeight));
                        setMinimumSize(new java.awt.Dimension(prefWidth, prefHeight));
                    }}, stretchxy);
                }}, stretchxy);
                contentPane.add(new JSeparator(), stretchx);
                contentPane.add(new JLabel("Optimization of primal vertex heights (dual plane offsets)"));
                add(new JRow() {{
                    add(new JLabel("        ")); // indent a bit
                    add(new JCol() {{
                        add(new JRow() {{
                            add(new JCheckBox("Optimize", applet.optimizeFlag.get()) {{
                                    addItemListener(new java.awt.event.ItemListener() {
                                        public void itemStateChanged(java.awt.event.ItemEvent e)
                                        {
                                            UndoItem.State before = applet.newUndoItemState();
                                            applet.optimizeFlag.set(isSelected());
                                            System.out.println("optimizeFlag -> "+applet.optimizeFlag.get());
                                            if (applet.continuouslyDelaunayizeFlag.get()) applet.delaunayize();
                                            UndoItem.State after = applet.newUndoItemState();
                                            applet.undoTreeSquirrel.Do(new UndoItem(before, after));
                                            applet.dirtyDualMesh(); // XXX why is this necessary here, and not, for example, for Delaunayize? I'm confused
                                            applet.theCanvas.repaint();
                                        }
                                    });
                                    applet.optimizeFlag.addListener(applet.optimizeFlagListener = new Listenable.Listener() {
                                        public void valueChanged()
                                        {
                                            setSelected(applet.optimizeFlag.get()); // of the checkbox
                                        }
                                    });
                                }
                            });

                            add(new JComboBox() {{


                                FORI (i, optimizationTypeNames.length)
                                    addItem(optimizationTypeNames[availableOptimizationTypes[i]]);

                                setSelectedIndex(applet.optimizationTypeIndex.get());
                                addItemListener(new java.awt.event.ItemListener() {
                                    public void itemStateChanged(java.awt.event.ItemEvent e)
                                    {
                                        int newValue = getSelectedIndex();
                                        if (newValue != applet.optimizationTypeIndex.get())
                                        {
                                            UndoItem.State before = applet.newUndoItemState();


                                            applet.optimizationTypeIndex.set(newValue);
                                            applet.optimizationType = availableOptimizationTypes[applet.optimizationTypeIndex.get()];
                                            System.out.println("optimizationType -> "+applet.optimizationTypeNames[applet.optimizationType]);


                                            if (applet.continuouslyDelaunayizeFlag.get()) applet.delaunayize();
                                            UndoItem.State after = applet.newUndoItemState();
                                            applet.undoTreeSquirrel.Do(new UndoItem(before, after));
                                            applet.dirtyDualMesh(); // XXX why is this necessary here, and not, for example, for Delaunayize? I'm confused
                                            applet.theCanvas.repaint();
                                            System.out.println("calling repaint!");
                                        }
                                    }
                                });
                                applet.optimizationTypeIndex.addListener(applet.optimizationTypeIndexListener = new Listenable.Listener() {
                                    public void valueChanged()
                                    {
                                        int newValue = applet.optimizationTypeIndex.get();
                                        if (newValue != getSelectedIndex())
                                            setSelectedIndex(newValue);
                                    }
                                });
                            }});
                            add(new JLabel(""), stretchxy);
                            add(new JCol() {{
                            }});
                            add(new JLabel(""), stretchxy);
                            add(new JLabel(""), stretchxy);
                        }}, stretchx);
                    }});
                }});
                contentPane.add(new JSeparator(), stretchx);
                contentPane.add(new JLabel("Behavior"));
                add(new JRow() {{
                    add(new JLabel("        ")); // indent a bit
                    add(new JCol() {{
                        add(new JRow() {{
                            add(new JCheckBox("Keep delaunayized", applet.continuouslyDelaunayizeFlag.get()) {{
                                    setToolTipText("<html>Turning this on delaunayizes the triangulation and keeps it delaunayized on every applet.mesh editing operation.<br>To just delaunayize it once, turn this on and then off again.</html>");
                                    addItemListener(new java.awt.event.ItemListener() {
                                        public void itemStateChanged(java.awt.event.ItemEvent e)
                                        {
                                            UndoItem.State before = applet.newUndoItemState();
                                            applet.continuouslyDelaunayizeFlag.set(isSelected());
                                            System.out.println("continuouslyDelaunayizeFlag -> "+applet.continuouslyDelaunayizeFlag.get());
                                            if (applet.continuouslyDelaunayizeFlag.get()) applet.delaunayize();
                                            UndoItem.State after = applet.newUndoItemState();
                                            applet.undoTreeSquirrel.Do(new UndoItem(before, after));
                                            applet.theCanvas.repaint();
                                        }
                                    });
                                    applet.continuouslyDelaunayizeFlag.addListener(applet.continuouslyDelaunayizeFlagListener = new Listenable.Listener() {
                                        public void valueChanged()
                                        {
                                            setSelected(applet.continuouslyDelaunayizeFlag.get()); // of the checkbox
                                            // XXX wait a minute, isn't this where we should delaunayize, rather than above?
                                        }
                                    });
                                }
                            });
                            add(new JCheckBoxForBoolean("Calc underside when delaunayizing", applet.calcInsideOutDualVertsFlag));
                        }});
                    }});
                }});
                contentPane.add(new JSeparator(), stretchx);
                contentPane.add(new JLabel("Appearance/Transforms"));
                add(new JRow() {{
                    add(new JLabel("        ")); // indent a bit
                    add(new JCol() {{
                        add(new JRow() {{
                            add(new JRow() {{
                                add(new JLabel("<html>Scale<br>primal<br>only:</html>"));
                                add(new JTablePanel() {{
                                    add(new JLabel(""));
                                    add(new JLabel(""));
                                    add(new JRepeatingButton("") {
                                        public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(20*hidpimag,20*hidpimag); }
                                        public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(20*hidpimag,20*hidpimag); }
                                        public void paint(java.awt.Graphics g)
                                        {
                                            drawPixmapCentered(g, getSize(), asciiToColor,
                                                               new String[] {
                                                                  "                 ",
                                                                  "        w        ",
                                                                  "       www       ",
                                                                  "      ww ww      ",
                                                                  "                 ",
                                                                  "                 ",
                                                                  "   w         w   ",
                                                                  "  ww         ww  ",
                                                                  " ww           ww ",
                                                                  "  ww         ww  ",
                                                                  "   w         w   ",
                                                                  "                 ",
                                                                  "                 ",
                                                                  "      ww ww      ",
                                                                  "       www       ",
                                                                  "        w        ",
                                                                  "                 ",
                                                               });
                                        }
                                    {
                                        addActionListener(new java.awt.event.ActionListener() {
                                            public void actionPerformed(java.awt.event.ActionEvent e)
                                            {
                                                applet.rescalePrimalOnly(Math.sqrt(2.));
                                            }
                                        });
                                    }}, stretchxy);
                                    advanceRow();
                                    add(new JLabel(""));
                                    add(new JButton("f") {
                                        public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(20*hidpimag,20*hidpimag); }
                                        public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(20*hidpimag,20*hidpimag); }
                                        public void paint(java.awt.Graphics g)
                                        {
                                            drawPixmapCentered(g, getSize(), asciiToColor,
                                                               new String[] {
                                                                  "wwwwwwwwwwwwwww",
                                                                  "w  w   w   w  w",
                                                                  "w  w   w   w  w",
                                                                  "wwwwwwwwwwwwwww",
                                                                  "w  w       w  w",
                                                                  "w  w  www  w  w",
                                                                  "w  w  w    w  w",
                                                                  "wwww  ww   wwww",
                                                                  "w  w  w    w  w",
                                                                  "w  w  w    w  w",
                                                                  "w  w       w  w",
                                                                  "wwwwwwwwwwwwwww",
                                                                  "w  w   w   w  w",
                                                                  "w  w   w   w  w",
                                                                  "wwwwwwwwwwwwwww",
                                                               });
                                        }
                                    {
                                        {setToolTipText("frame primal (white figure)");}
                                        addActionListener(new java.awt.event.ActionListener() {
                                            public void actionPerformed(java.awt.event.ActionEvent e)
                                            {
                                                applet.frame(true,false);
                                            }
                                        });
                                    }}, stretchxy);
                                    add(new JLabel(""));
                                    advanceRow();
                                    add(new JRepeatingButton("") {
                                        public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(20*hidpimag,20*hidpimag); }
                                        public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(20*hidpimag,20*hidpimag); }
                                        public void paint(java.awt.Graphics g)
                                        {
                                            drawPixmapCentered(g, getSize(), asciiToColor,
                                                               new String[] {
                                                                  "                 ",
                                                                  "                 ",
                                                                  "                 ",
                                                                  "                 ",
                                                                  "      ww ww      ",
                                                                  "       www       ",
                                                                  "    w   w   w    ",
                                                                  "    ww     ww    ",
                                                                  "     ww   ww     ",
                                                                  "    ww     ww    ",
                                                                  "    w   w   w    ",
                                                                  "       www       ",
                                                                  "      ww ww      ",
                                                                  "                 ",
                                                                  "                 ",
                                                                  "                 ",
                                                                  "                 ",
                                                               });
                                        }
                                    {
                                        addActionListener(new java.awt.event.ActionListener() {
                                            public void actionPerformed(java.awt.event.ActionEvent e)
                                            {
                                                applet.rescalePrimalOnly(Math.sqrt(.5));
                                            }
                                        });
                                    }}, stretchxy);
                                    add(new JLabel(""));
                                    add(new JLabel(""));
                                }}); // table
                            }});
                            add(new JRow() {{
                                add(new JLabel("<html>Pan<br>primal<br>only:</html>"), rightjustify); // TODO: right justify isn't working here

                                final java.awt.Color asciiToColor[] = new java.awt.Color[128];
                                asciiToColor[' '] = java.awt.Color.black;
                                asciiToColor['*'] = java.awt.Color.white;
                                add(new JTableOfPanIcons(5,5,asciiToColor) {
                                    // note, dup code in the two tables of pan icons
                                    final double panIncr = 1./256;
                                    final double PanIncr = 1./16;
                                    final double panIncrs[] = {-PanIncr,-panIncr,0,panIncr,PanIncr};
                                    // implement abstract superclass's
                                    public void buttonPressed(int iCol, int iRow)
                                    {
                                        applet.panPrimalOnly(panIncrs[iCol],
                                                             panIncrs[panIncrs.length-1-iRow]);

                                    }
                                });
                            }});
                            add(new JRow() {{
                                add(new JLabel("Scale: "));
                                add(new JTablePanel() {{
                                    add(new JRepeatingButton("") {
                                        public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(20*hidpimag,20*hidpimag); }
                                        public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(20*hidpimag,20*hidpimag); }
                                        public void paint(java.awt.Graphics g)
                                        {
                                            drawPixmapCentered(g, getSize(), asciiToColor,
                                                               new String[] {
                                                                  "        w        ",
                                                                  "       www       ",
                                                                  "      ww ww      ",
                                                                  "                 ",
                                                                  "      BB BB      ",
                                                                  "       BBB       ",
                                                                  "  B w   B   w B  ",
                                                                  " BB ww     ww BB ",
                                                                  "BB   ww   ww   BB",
                                                                  " BB ww     ww BB ",
                                                                  "  B w   B   w B  ",
                                                                  "       BBB       ",
                                                                  "      BB BB      ",
                                                                  "                 ",
                                                                  "      ww ww      ",
                                                                  "       www       ",
                                                                  "        w        ",
                                                               });
                                        }
                                    {
                                        addActionListener(new java.awt.event.ActionListener() {
                                            public void actionPerformed(java.awt.event.ActionEvent e)
                                            {
                                                applet.rescale(Math.sqrt(.5), Math.sqrt(2.));
                                            }
                                        });
                                    }}, stretchxy);
                                    add(new JRepeatingButton("") {
                                        public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(20*hidpimag,20*hidpimag); }
                                        public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(20*hidpimag,20*hidpimag); }
                                        public void paint(java.awt.Graphics g)
                                        {
                                            drawPixmapCentered(g, getSize(), asciiToColor,
                                                               new String[] {
                                                                  "                 ",
                                                                  "        w        ",
                                                                  "       www       ",
                                                                  "      ww ww      ",
                                                                  "                 ",
                                                                  "                 ",
                                                                  "   B         B   ",
                                                                  "  BB         BB  ",
                                                                  " BB           BB ",
                                                                  "  BB         BB  ",
                                                                  "   B         B   ",
                                                                  "                 ",
                                                                  "                 ",
                                                                  "      ww ww      ",
                                                                  "       www       ",
                                                                  "        w        ",
                                                                  "                 ",
                                                               });
                                        }
                                    {
                                        addActionListener(new java.awt.event.ActionListener() {
                                            public void actionPerformed(java.awt.event.ActionEvent e)
                                            {
                                                applet.rescale(1., Math.sqrt(2.));
                                            }
                                        });
                                    }}, stretchxy);
                                    add(new JRepeatingButton("") {
                                        public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(20*hidpimag,20*hidpimag); }
                                        public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(20*hidpimag,20*hidpimag); }
                                        public void paint(java.awt.Graphics g)
                                        {
                                            drawPixmapCentered(g, getSize(), asciiToColor,
                                                               new String[] {
                                                                  "                 ",
                                                                  "        b        ",
                                                                  "       bbb       ",
                                                                  "      bb bb      ",
                                                                  "                 ",
                                                                  "                 ",
                                                                  "   b         b   ",
                                                                  "  bb         bb  ",
                                                                  " bb           bb ",
                                                                  "  bb         bb  ",
                                                                  "   b         b   ",
                                                                  "                 ",
                                                                  "                 ",
                                                                  "      bb bb      ",
                                                                  "       bbb       ",
                                                                  "        b        ",
                                                                  "                 ",
                                                               });
                                        }
                                    {
                                        addActionListener(new java.awt.event.ActionListener() {
                                            public void actionPerformed(java.awt.event.ActionEvent e)
                                            {
                                                applet.rescale(Math.sqrt(2.), Math.sqrt(2.));
                                            }
                                        });
                                    }}, stretchxy);
                                    advanceRow();
                                    add(new JRepeatingButton("") {
                                        public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(20*hidpimag,20*hidpimag); }
                                        public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(20*hidpimag,20*hidpimag); }
                                        public void paint(java.awt.Graphics g)
                                        {
                                            drawPixmapCentered(g, getSize(), asciiToColor,
                                                               new String[] {
                                                                  "                 ",
                                                                  "                 ",
                                                                  "                 ",
                                                                  "      BB BB      ",
                                                                  "       BBB       ",
                                                                  "    w   B   w    ",
                                                                  "    ww     ww    ",
                                                                  "     ww   ww     ",
                                                                  "    ww     ww    ",
                                                                  "    w   B   w    ",
                                                                  "       BBB       ",
                                                                  "      BB BB      ",
                                                                  "                 ",
                                                                  "                 ",
                                                                  "                 ",
                                                               });
                                        }
                                    {
                                        addActionListener(new java.awt.event.ActionListener() {
                                            public void actionPerformed(java.awt.event.ActionEvent e)
                                            {
                                                applet.rescale(Math.sqrt(.5), 1.);
                                            }
                                        });
                                    }}, stretchxy);
                                    add(new JButton("f") {
                                        public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(20*hidpimag,20*hidpimag); }
                                        public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(20*hidpimag,20*hidpimag); }
                                        public void paint(java.awt.Graphics g)
                                        {
                                            drawPixmapCentered(g, getSize(), asciiToColor,
                                                               new String[] {
                                                                  "bbbbbbbbbbbbbbb",
                                                                  "b  b   b   b  b",
                                                                  "b  b   b   b  b",
                                                                  "bbbbbbbbbbbbbbb",
                                                                  "b  b       b  b",
                                                                  "b  b  bbb  b  b",
                                                                  "b  b  b    b  b",
                                                                  "bbbb  bb   bbbb",
                                                                  "b  b  b    b  b",
                                                                  "b  b  b    b  b",
                                                                  "b  b       b  b",
                                                                  "bbbbbbbbbbbbbbb",
                                                                  "b  b   b   b  b",
                                                                  "b  b   b   b  b",
                                                                  "bbbbbbbbbbbbbbb",
                                                               });
                                        }
                                    {
                                        {setToolTipText("frame both primal (white) and dual (blue)");}
                                        addActionListener(new java.awt.event.ActionListener() {
                                            public void actionPerformed(java.awt.event.ActionEvent e)
                                            {
                                                applet.frame(true,true);
                                            }
                                        });
                                    }}, stretchxy);
                                    add(new JRepeatingButton("") {
                                        public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(20*hidpimag,20*hidpimag); }
                                        public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(20*hidpimag,20*hidpimag); }
                                        public void paint(java.awt.Graphics g)
                                        {
                                            drawPixmapCentered(g, getSize(), asciiToColor,
                                                               // leave 4 spaces horizontally, 2 spaces vertically
                                                               new String[] {
                                                                  "                 ",
                                                                  "        B        ",
                                                                  "       BBB       ",
                                                                  "      BB BB      ",
                                                                  "                 ",
                                                                  "                 ",
                                                                  "   w         w   ",
                                                                  "  ww         ww  ",
                                                                  " ww           ww ",
                                                                  "  ww         ww  ",
                                                                  "   w         w   ",
                                                                  "                 ",
                                                                  "                 ",
                                                                  "      BB BB      ",
                                                                  "       BBB       ",
                                                                  "        B        ",
                                                                  "                 ",
                                                               });
                                        }
                                    {
                                        addActionListener(new java.awt.event.ActionListener() {
                                            public void actionPerformed(java.awt.event.ActionEvent e)
                                            {
                                                applet.rescale(Math.sqrt(2.), 1.);
                                            }
                                        });
                                    }}, stretchxy);
                                    advanceRow();
                                    add(new JRepeatingButton("") {
                                        public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(20*hidpimag,20*hidpimag); }
                                        public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(20*hidpimag,20*hidpimag); }
                                        public void paint(java.awt.Graphics g)
                                        {
                                            drawPixmapCentered(g, getSize(), asciiToColor,
                                                               new String[] {
                                                                  "                 ",
                                                                  "                 ",
                                                                  "                 ",
                                                                  "                 ",
                                                                  "      bb bb      ",
                                                                  "       bbb       ",
                                                                  "    b   b   b    ",
                                                                  "    bb     bb    ",
                                                                  "     bb   bb     ",
                                                                  "    bb     bb    ",
                                                                  "    b   b   b    ",
                                                                  "       bbb       ",
                                                                  "      bb bb      ",
                                                                  "                 ",
                                                                  "                 ",
                                                                  "                 ",
                                                                  "                 ",
                                                               });
                                        }
                                    {
                                        addActionListener(new java.awt.event.ActionListener() {
                                            public void actionPerformed(java.awt.event.ActionEvent e)
                                            {
                                                applet.rescale(Math.sqrt(.5), Math.sqrt(.5));
                                            }
                                        });
                                    }}, stretchxy);
                                    add(new JRepeatingButton("") {
                                        public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(20*hidpimag,20*hidpimag); }
                                        public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(20*hidpimag,20*hidpimag); }
                                        public void paint(java.awt.Graphics g)
                                        {
                                            drawPixmapCentered(g, getSize(), asciiToColor,
                                                               new String[] {
                                                                  "                 ",
                                                                  "                 ",
                                                                  "                 ",
                                                                  "                 ",
                                                                  "      ww ww      ",
                                                                  "       www       ",
                                                                  "    B   w   B    ",
                                                                  "    BB     BB    ",
                                                                  "     BB   BB     ",
                                                                  "    BB     BB    ",
                                                                  "    B   w   B    ",
                                                                  "       www       ",
                                                                  "      ww ww      ",
                                                                  "                 ",
                                                                  "                 ",
                                                                  "                 ",
                                                                  "                 ",
                                                               });
                                        }
                                    {
                                        addActionListener(new java.awt.event.ActionListener() {
                                            public void actionPerformed(java.awt.event.ActionEvent e)
                                            {
                                                applet.rescale(1., Math.sqrt(.5));
                                            }
                                        });
                                    }}, stretchxy);
                                    add(new JRepeatingButton("") {
                                        public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(20*hidpimag,20*hidpimag); }
                                        public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(20*hidpimag,20*hidpimag); }
                                        public void paint(java.awt.Graphics g)
                                        {
                                            drawPixmapCentered(g, getSize(), asciiToColor,
                                                               new String[] {
                                                                  "        B        ",
                                                                  "       BBB       ",
                                                                  "      BB BB      ",
                                                                  "                 ",
                                                                  "      ww ww      ",
                                                                  "       www       ",
                                                                  "  w B   w   B w  ",
                                                                  " ww BB     BB ww ",
                                                                  "ww   BB   BB   ww",
                                                                  " ww BB     BB ww ",
                                                                  "  w B   w   B w  ",
                                                                  "       www       ",
                                                                  "      ww ww      ",
                                                                  "                 ",
                                                                  "      BB BB      ",
                                                                  "       BBB       ",
                                                                  "        B        ",
                                                               });
                                        }
                                    {
                                        addActionListener(new java.awt.event.ActionListener() {
                                            public void actionPerformed(java.awt.event.ActionEvent e)
                                            {
                                                applet.rescale(Math.sqrt(2.), Math.sqrt(.5));
                                            }
                                        });
                                    }}, stretchxy);
                                }}); // table
                            }});
                            add(new JRow() {{
                                add(new JLabel("<html>Pan: </html>"), rightjustify); // TODO: right justify isn't working here

                                final java.awt.Color asciiToColor[] = new java.awt.Color[128];
                                asciiToColor[' '] = java.awt.Color.black;
                                asciiToColor['*'] = new java.awt.Color(224,224,255); // very light blue
                                add(new JTableOfPanIcons(5,5,asciiToColor) {
                                    // note, dup code in the two tables of pan icons
                                    final double panIncr = 1./256;
                                    final double PanIncr = 1./16;
                                    final double panIncrs[] = {-PanIncr,-panIncr,0,panIncr,PanIncr};
                                    // implement abstract superclass's
                                    public void buttonPressed(int iCol, int iRow)
                                    {
                                        applet.pan(panIncrs[iCol],
                                                   panIncrs[panIncrs.length-1-iRow]);

                                    }
                                });
                            }});
                            add(new JRow() {{
                                {setToolTipText("<html>Scale dual (blue figure)<br>by adjusting heights of primal vertices.<html>");}
                                add(new JLabel("<html>Scale<br>dual<br>only: </html>"), rightjustify); // TODO: right justify isn't working here
                                add(new JTablePanel() {{
                                    add(new JLabel(""));
                                    add(new JLabel(""));
                                    add(new JRepeatingButton("") {
                                        public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(20*hidpimag,20*hidpimag); }
                                        public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(20*hidpimag,20*hidpimag); }
                                        public void paint(java.awt.Graphics g)
                                        {
                                            drawPixmapCentered(g, getSize(), asciiToColor,
                                                               new String[] {
                                                                  "                 ",
                                                                  "        B        ",
                                                                  "       BBB       ",
                                                                  "      BB BB      ",
                                                                  "                 ",
                                                                  "                 ",
                                                                  "   B         B   ",
                                                                  "  BB         BB  ",
                                                                  " BB           BB ",
                                                                  "  BB         BB  ",
                                                                  "   B         B   ",
                                                                  "                 ",
                                                                  "                 ",
                                                                  "      BB BB      ",
                                                                  "       BBB       ",
                                                                  "        B        ",
                                                                  "                 ",
                                                               });
                                        }
                                    {
                                        addActionListener(new java.awt.event.ActionListener() {
                                            public void actionPerformed(java.awt.event.ActionEvent e)
                                            {
                                                applet.rescaleDualOnly(Math.sqrt(2.));
                                            }
                                        });
                                    }}, stretchxy);
                                    advanceRow();
                                    add(new JLabel(""));
                                    add(new JButton("f") {
                                        public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(20*hidpimag,20*hidpimag); }
                                        public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(20*hidpimag,20*hidpimag); }
                                        public void paint(java.awt.Graphics g)
                                        {
                                            drawPixmapCentered(g, getSize(), asciiToColor,
                                                               new String[] {
                                                                  "BBBBBBBBBBBBBBB",
                                                                  "B  B   B   B  B",
                                                                  "B  B   B   B  B",
                                                                  "BBBBBBBBBBBBBBB",
                                                                  "B  B       B  B",
                                                                  "B  B  BBB  B  B",
                                                                  "B  B  B    B  B",
                                                                  "BBBB  BB   BBBB",
                                                                  "B  B  B    B  B",
                                                                  "B  B  B    B  B",
                                                                  "B  B       B  B",
                                                                  "BBBBBBBBBBBBBBB",
                                                                  "B  B   B   B  B",
                                                                  "B  B   B   B  B",
                                                                  "BBBBBBBBBBBBBBB",
                                                               });
                                        }
                                    {
                                        {setToolTipText("frame dual (blue figure)");}
                                        addActionListener(new java.awt.event.ActionListener() {
                                            public void actionPerformed(java.awt.event.ActionEvent e)
                                            {
                                                applet.frame(false,true);
                                            }
                                        });
                                    }}, stretchxy);
                                    add(new JLabel(""));
                                    advanceRow();
                                    add(new JRepeatingButton("") {
                                        public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(20*hidpimag,20*hidpimag); }
                                        public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(20*hidpimag,20*hidpimag); }
                                        public void paint(java.awt.Graphics g)
                                        {
                                            drawPixmapCentered(g, getSize(), asciiToColor,
                                                               new String[] {
                                                                  "                 ",
                                                                  "                 ",
                                                                  "                 ",
                                                                  "                 ",
                                                                  "      BB BB      ",
                                                                  "       BBB       ",
                                                                  "    B   B   B    ",
                                                                  "    BB     BB    ",
                                                                  "     BB   BB     ",
                                                                  "    BB     BB    ",
                                                                  "    B   B   B    ",
                                                                  "       BBB       ",
                                                                  "      BB BB      ",
                                                                  "                 ",
                                                                  "                 ",
                                                                  "                 ",
                                                                  "                 ",
                                                               });
                                        }
                                    {
                                        addActionListener(new java.awt.event.ActionListener() {
                                            public void actionPerformed(java.awt.event.ActionEvent e)
                                            {
                                                applet.rescaleDualOnly(Math.sqrt(.5));
                                            }
                                        });
                                    }}, stretchxy);
                                    add(new JLabel(""));
                                    add(new JLabel(""));
                                }}); // table
                            }});
                            add(new JRow() {{
                                {setToolTipText("<html>Pan dual (blue figure)<br>by adjusting heights of primal vertices.<html>");}
                                add(new JLabel("<html>Pan<br>dual<br>only: </html>"), rightjustify); // TODO: right justify isn't working here

                                final java.awt.Color asciiToColor[] = new java.awt.Color[128];
                                asciiToColor[' '] = java.awt.Color.black;
                                asciiToColor['*'] = new java.awt.Color(64,64,255); // slightly light blue
                                add(new JTableOfPanIcons(5,5,asciiToColor) {
                                    // note, dup code in the two tables of pan icons
                                    final double panIncr = 1./256;
                                    final double PanIncr = 1./16;
                                    final double panIncrs[] = {-PanIncr,-panIncr,0,panIncr,PanIncr};
                                    // implement abstract superclass's
                                    public void buttonPressed(int iCol, int iRow)
                                    {
                                        applet.panDualOnly(panIncrs[iCol],
                                                           panIncrs[panIncrs.length-1-iRow]);

                                    }
                                });
                            }});
                            add(new JLabel("        "));
                            add(new JCol() {{
                                add(new JRow() {{
                                    add(new JLabel("Rot: "));
                                    add(new JTablePanel() {{
                                        add(new JRepeatingButton("CCW") {
                                            public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(13*hidpimag,13*hidpimag); }
                                            public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(13*hidpimag,13*hidpimag); }
                                            public void paint(java.awt.Graphics g)
                                            {
                                                drawPixmapCentered(g, getSize(), asciiToColor,
                                                                   new String[] {
                                                                      "         ",
                                                                      "   bbbbb ",
                                                                      "   b     ",
                                                                      "   b     ",
                                                                      "   b     ",
                                                                      " bbbbb   ",
                                                                      "  bbb    ",
                                                                      "   b     ",
                                                                      "         ",
                                                                   });
                                            }
                                            {
                                                addActionListener(new java.awt.event.ActionListener() {
                                                    public void actionPerformed(java.awt.event.ActionEvent e)
                                                    {
                                                        UndoItem.State before = applet.newUndoItemState();

                                                        // cop out
                                                        applet.mesh.flipUpperLeftLowerRight();
                                                        applet.mesh.flipLeftRight();

                                                        applet.dirtyDualMesh(); // flip doesn't work when verts missing
                                                        // should be no need to re-delaunayize
                                                        UndoItem.State after = applet.newUndoItemState();
                                                        applet.undoTreeSquirrel.Do(new UndoItem(before, after));
                                                        applet.theCanvas.repaint();
                                                    }
                                                });
                                            }
                                        });
                                        add(new JRepeatingButton("CW") {
                                            public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(13*hidpimag,13*hidpimag); }
                                            public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(13*hidpimag,13*hidpimag); }
                                            public void paint(java.awt.Graphics g)
                                            {
                                                drawPixmapCentered(g, getSize(), asciiToColor,
                                                                   new String[] {
                                                                      "         ",
                                                                      " bbbbb   ",
                                                                      "     b   ",
                                                                      "     b   ",
                                                                      "     b   ",
                                                                      "   bbbbb ",
                                                                      "    bbb  ",
                                                                      "     b   ",
                                                                      "         ",
                                                                   });
                                            }
                                            {
                                                addActionListener(new java.awt.event.ActionListener() {
                                                    public void actionPerformed(java.awt.event.ActionEvent e)
                                                    {
                                                        UndoItem.State before = applet.newUndoItemState();

                                                        // cop out
                                                        applet.mesh.flipLowerLeftUpperRight();
                                                        applet.mesh.flipLeftRight();

                                                        applet.dirtyDualMesh(); // flip doesn't work when verts missing
                                                        // should be no need to re-delaunayize
                                                        UndoItem.State after = applet.newUndoItemState();
                                                        applet.undoTreeSquirrel.Do(new UndoItem(before, after));
                                                        applet.theCanvas.repaint();
                                                    }
                                                });
                                            }
                                        });
                                    }});
                                }});
                                add(new JLabel("")); // just a little vertical space
                                add(new JRow() {{
                                    add(new JLabel("Flip: "));
                                    add(new JTablePanel() {{
                                        add(new JRepeatingButton("/") {
                                            public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(13*hidpimag,13*hidpimag); }
                                            public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(13*hidpimag,13*hidpimag); }
                                            public void paint(java.awt.Graphics g)
                                            {
                                                drawPixmapCentered(g, getSize(), asciiToColor,
                                                                   new String[] {
                                                                      "         ",
                                                                      " bbb   b ",
                                                                      " bb   b  ",
                                                                      " b b b   ",
                                                                      "    b    ",
                                                                      "   b b b ",
                                                                      "  b   bb ",
                                                                      " b   bbb ",
                                                                      "         ",
                                                                   });
                                            }
                                            {
                                                addActionListener(new java.awt.event.ActionListener() {
                                                    public void actionPerformed(java.awt.event.ActionEvent e)
                                                    {
                                                        UndoItem.State before = applet.newUndoItemState();
                                                        applet.mesh.flipUpperLeftLowerRight();
                                                        applet.dirtyDualMesh(); // flip doesn't work when verts missing
                                                        // should be no need to re-delaunayize
                                                        UndoItem.State after = applet.newUndoItemState();
                                                        applet.undoTreeSquirrel.Do(new UndoItem(before, after));
                                                        applet.theCanvas.repaint();
                                                    }
                                                });
                                            }
                                        });
                                        add(new JRepeatingButton("-") {
                                            public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(13*hidpimag,13*hidpimag); }
                                            public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(13*hidpimag,13*hidpimag); }
                                            public void paint(java.awt.Graphics g)
                                            {
                                                drawPixmapCentered(g, getSize(), asciiToColor,
                                                                   new String[] {
                                                                      "    b    ",
                                                                      "   bbb   ",
                                                                      "  bbbbb  ",
                                                                      "    b    ",
                                                                      "         ",
                                                                      " bbbbbbb ",
                                                                      "         ",
                                                                      "    b    ",
                                                                      "  bbbbb  ",
                                                                      "   bbb   ",
                                                                      "    b    ",
                                                                   });
                                            }
                                            {
                                                addActionListener(new java.awt.event.ActionListener() {
                                                    public void actionPerformed(java.awt.event.ActionEvent e)
                                                    {
                                                        UndoItem.State before = applet.newUndoItemState();
                                                        applet.mesh.flipUpDown();
                                                        applet.dirtyDualMesh(); // flip doesn't work when verts missing
                                                        // should be no need to re-delaunayize
                                                        UndoItem.State after = applet.newUndoItemState();
                                                        applet.undoTreeSquirrel.Do(new UndoItem(before, after));
                                                        applet.theCanvas.repaint();
                                                    }
                                                });
                                            }
                                        });
                                        add(new JRepeatingButton("\\") {
                                            public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(13*hidpimag,13*hidpimag); }
                                            public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(13*hidpimag,13*hidpimag); }
                                            public void paint(java.awt.Graphics g)
                                            {
                                                drawPixmapCentered(g, getSize(), asciiToColor,
                                                                   new String[] {
                                                                      "         ",
                                                                      " b   bbb ",
                                                                      "  b   bb ",
                                                                      "   b b b ",
                                                                      "    b    ",
                                                                      " b b b   ",
                                                                      " bb   b  ",
                                                                      " bbb   b ",
                                                                      "         ",
                                                                   });
                                            }
                                            {
                                                addActionListener(new java.awt.event.ActionListener() {
                                                    public void actionPerformed(java.awt.event.ActionEvent e)
                                                    {
                                                        UndoItem.State before = applet.newUndoItemState();
                                                        applet.mesh.flipLowerLeftUpperRight();
                                                        applet.dirtyDualMesh(); // flip doesn't work when verts missing
                                                        // should be no need to re-delaunayize
                                                        UndoItem.State after = applet.newUndoItemState();
                                                        applet.undoTreeSquirrel.Do(new UndoItem(before, after));
                                                        applet.theCanvas.repaint();
                                                    }
                                                });
                                            }
                                        });
                                        advanceRow();
                                        add(new JRepeatingButton("|") {
                                            public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(13*hidpimag,13*hidpimag); }
                                            public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(13*hidpimag,13*hidpimag); }
                                            public void paint(java.awt.Graphics g)
                                            {
                                                drawPixmapCentered(g, getSize(), asciiToColor,
                                                                   new String[] {
                                                                      "           ",
                                                                      "     b     ",
                                                                      "  b  b  b  ",
                                                                      " bb  b  bb ",
                                                                      "bbbb b bbbb",
                                                                      " bb  b  bb ",
                                                                      "  b  b  b  ",
                                                                      "     b     ",
                                                                      "           ",
                                                                   });
                                            }
                                            {
                                                addActionListener(new java.awt.event.ActionListener() {
                                                    public void actionPerformed(java.awt.event.ActionEvent e)
                                                    {
                                                        UndoItem.State before = applet.newUndoItemState();
                                                        applet.mesh.flipLeftRight();
                                                        applet.dirtyDualMesh(); // flip doesn't work when verts missing
                                                        // should be no need to re-delaunayize
                                                        UndoItem.State after = applet.newUndoItemState();
                                                        applet.undoTreeSquirrel.Do(new UndoItem(before, after));
                                                        applet.theCanvas.repaint();
                                                    }
                                                });
                                            }
                                        });
                                    }});
                                }});
                            }});
                        }});
                        add(new JRow() {{
                                add(new JRow() {{
                                    add(new JCheckBox("Wrap around sphere", applet.wrapAroundSphereFlag.get()) {{
                                            addItemListener(new java.awt.event.ItemListener() {
                                                public void itemStateChanged(java.awt.event.ItemEvent e)
                                                {
                                                    UndoItem.State before = applet.newUndoItemState();
                                                    applet.wrapAroundSphereFlag.set(isSelected());
                                                    System.out.println("wrapAroundSphereFlag -> "+applet.wrapAroundSphereFlag.get());
                                                    UndoItem.State after = applet.newUndoItemState();
                                                    applet.undoTreeSquirrel.Do(new UndoItem(before, after));
                                                    applet.theCanvas.repaint();
                                                }
                                            });
                                            applet.wrapAroundSphereFlag.addListener(applet.wrapAroundSphereFlagListener = new Listenable.Listener() {
                                                public void valueChanged()
                                                {
                                                    // XXX this should go in one listener
                                                    setSelected(applet.wrapAroundSphereFlag.get()); // of the checkbox

                                                    // XXX the rest should go in a separate listener

                                                    // XXX this isn't really the right place for the following; should do the following regardless of whether there's a checkbox for it
                                                    if (applet.wrapAroundSphereFlag.get())
                                                    {
                                                        applet.theSurface = applet.theSphereSurface;
                                                        applet.wrapAroundSphere(applet.wrapSphereCurvature.get(), applet.centerSphereFlag.get());
                                                        theWrapRadiusLabel.setEnabled(true);
                                                        theWrapRadiusTextField.setEnabled(true);
                                                        theWrapRadiusSlider.setEnabled(true);
                                                    }
                                                    else
                                                    {
                                                        applet.theSurface = applet.theParaboloidSurface;
                                                        applet.unwrapAroundSphere(applet.wrapSphereCurvature.get(), applet.centerSphereFlag.get());
                                                        theWrapRadiusLabel.setEnabled(false);
                                                        theWrapRadiusTextField.setEnabled(false);
                                                        theWrapRadiusSlider.setEnabled(false);
                                                    }
                                                }
                                            });
                                    }});
                                    add(new JCheckBoxForBoolean("Center sphere", applet.centerSphereFlag));
                                }});
                        }});
                        add(new JRow() {{
                            add(new JLabel("Show Primal:"));
                            final PrefixButtonGroup buttonGroup = new PrefixButtonGroup();
                            add(new JCheckBoxForBoolean("verts", applet.showPrimalVertsFlag) {{
                                // don't add to button group, it's independent now
                            }});
                            add(new JCheckBoxForBoolean("edges", applet.showPrimalEdgesFlag) {{
                                buttonGroup.add(this);
                            }});
                            add(new JCheckBoxForBoolean("and flat edges", applet.showFlatPrimalEdgesFlag) {{
                                buttonGroup.add(this);
                            }});
                        }});
                        add(new JRow() {{
                            add(new JLabel("Show Dual:"));
                            add(new JCheckBoxForBoolean("verts", applet.showDualVertsFlag));
                            add(new JCheckBoxForBoolean("edges", applet.showDualEdgesFlag));
                            add(new JCheckBoxForBoolean("naive", applet.naiveDualEdgesFlag) {{
                                setToolTipText("display all dual edges as internal");
                            }});
                        }});
                        add(new JCheckBoxForBoolean("Show primal underside and second dual sheet (if any) (if not naive)", applet.showInsideOutDualVertsFlag));
                        add(new JTablePanel() {{
                            add(theGridBrightnessLabel);
                            add(theGridBrightnessTextField);
                            add(theGridBrightnessSlider, stretchx);
                            advanceRow();
                            add(theBackfaceBrightnessLabel);
                            add(theBackfaceBrightnessTextField);
                            add(theBackfaceBrightnessSlider, stretchx);
                            advanceRow();
                            add(theWrapRadiusLabel);
                            add(theWrapRadiusTextField);
                            add(theWrapRadiusSlider, stretchx);
                        }}, stretchx);
                    }}, stretchx);
                }}, stretchx);
                contentPane.add(new JSeparator(), stretchx);
                contentPane.add(new JLabel("Symmetry"));
                add(new JRow() {{
                    add(new JLabel("        ")); // indent a bit
                    add(new JCol() {{
                        add(new JRow() {{
                            add(new JCheckBox("left-right") {
                                {setToolTipText("Left-right symmetry");}
                                Listenable.Listener listener;
                                {
                                    //setMargin(nomargin);
                                    addActionListener(new java.awt.event.ActionListener() {
                                        public void actionPerformed(java.awt.event.ActionEvent e)
                                        {
                                            boolean newLeftRightSymmetry = isSelected();
                                            applet.changeSymmetry(applet.pRotationalSymmetry.get(), applet.qRotationalSymmetry.get(), newLeftRightSymmetry, applet.centralSymmetry.get(), applet.remapFundamentalRegionWhenChangingSymmetry.get(), applet.replicateVertsWhenChangingSymmetry.get(), applet.deleteNonReplicatedVertsWhenChangingSymmetry.get());
                                        }
                                    });
                                    setSelected(applet.leftRightSymmetry.get());
                                    applet.leftRightSymmetry.addListener(listener = new Listenable.Listener() {
                                        public void valueChanged()
                                        {
                                            setSelected(applet.leftRightSymmetry.get());
                                        }
                                    });
                                }
                            });
                            //add(new JLabel("    ")); // hack, just give a little space
                            add(new JCheckBox("central") {
                                {setToolTipText("Central symmetry");}
                                Listenable.Listener listener;
                                {
                                    //setMargin(nomargin);
                                    addActionListener(new java.awt.event.ActionListener() {
                                        public void actionPerformed(java.awt.event.ActionEvent e)
                                        {
                                            boolean newCentralSymmetry = isSelected();
                                            applet.changeSymmetry(applet.pRotationalSymmetry.get(), applet.qRotationalSymmetry.get(), applet.leftRightSymmetry.get(), newCentralSymmetry, applet.remapFundamentalRegionWhenChangingSymmetry.get(), applet.replicateVertsWhenChangingSymmetry.get(), applet.deleteNonReplicatedVertsWhenChangingSymmetry.get());
                                        }
                                    });
                                    setSelected(applet.centralSymmetry.get());
                                    applet.centralSymmetry.addListener(listener = new Listenable.Listener() {
                                        public void valueChanged()
                                        {
                                            setSelected(applet.centralSymmetry.get());
                                        }
                                    });
                                }
                            });
                            add(new JLabel("    ")); // hack, just give a little space
                            add(new JTablePanel() {{
                                final int maxpq = 10;
                                final ButtonGroup pButtonGroup = new ButtonGroup();
                                final ButtonGroup qButtonGroup = new ButtonGroup();

                                add(new JLabel(""), rightjustify);
                                for (int i = 1; i <= maxpq; ++i)
                                {
                                    add(new JLabel((i<=9?"  ":" ")+i)); // XXX I don't quite understand why this makes it look ok
                                }
                                advanceRow();
                                add(new JLabel("p:") {{
                                    {setToolTipText("\"p\" symmetry: rotational symmetry about z axis");}
                                }}, rightjustify);
                                {
                                    for (int i = 1; i <= maxpq; ++i)
                                    {
                                        final int final_i = i;
                                        add(new JRadioButton("") {
                                            Listenable.Listener listener;
                                            {
                                                addActionListener(new java.awt.event.ActionListener() {
                                                    public void actionPerformed(java.awt.event.ActionEvent e)
                                                    {
                                                        int p = final_i;
                                                        System.out.println("p = "+p);
                                                        applet.changeSymmetry(p, applet.qRotationalSymmetry.get(), applet.leftRightSymmetry.get(), applet.centralSymmetry.get(), applet.remapFundamentalRegionWhenChangingSymmetry.get(), applet.replicateVertsWhenChangingSymmetry.get(), applet.deleteNonReplicatedVertsWhenChangingSymmetry.get());
                                                        int maxq = p<=2 ? maxpq : p==3 ? 5 : p==4 ? 3 : p==5 ? 3 : 2;
                                                        int q = 1;
                                                        for (java.util.Enumeration qButtons = qButtonGroup.getElements();
                                                             qButtons.hasMoreElements();
                                                             q++)
                                                        {
                                                            JRadioButton qButton = (JRadioButton)qButtons.nextElement();
                                                            qButton.setEnabled(q <= maxq);
                                                            qButton.setVisible(q <= maxq);
                                                        }
                                                    }
                                                });
                                                setSelected(final_i == applet.pRotationalSymmetry.get());
                                                setMargin(nomargin);
                                                pButtonGroup.add(this);

                                                applet.pRotationalSymmetry.addListener(listener = new Listenable.Listener() {
                                                    public void valueChanged()
                                                    {
                                                        setSelected(applet.pRotationalSymmetry.get() == final_i);
                                                    }
                                                });
                                            }
                                        });
                                    }
                                }
                                advanceRow();
                                add(new JLabel("q:") {{
                                    {setToolTipText("\"q\" symmetry: rotational symmetry about an axis somewhere between +z and +y");}
                                }}, rightjustify);
                                {
                                    for (int i = 1; i <= maxpq; ++i)
                                    {
                                        final int final_i = i;
                                        add(new JRadioButton("") {
                                            Listenable.Listener listener;
                                            {
                                                addActionListener(new java.awt.event.ActionListener() {
                                                    public void actionPerformed(java.awt.event.ActionEvent e)
                                                    {
                                                        int q = final_i;
                                                        System.out.println("q = "+q);
                                                        applet.changeSymmetry(applet.pRotationalSymmetry.get(), q, applet.leftRightSymmetry.get(), applet.centralSymmetry.get(), applet.remapFundamentalRegionWhenChangingSymmetry.get(), applet.replicateVertsWhenChangingSymmetry.get(), applet.deleteNonReplicatedVertsWhenChangingSymmetry.get());
                                                        int maxp = q<=2 ? maxpq : q==3 ? 5 : q==4 ? 3 : q==5 ? 3 : 2;
                                                        int p = 1;
                                                        for (java.util.Enumeration pButtons = pButtonGroup.getElements();
                                                             pButtons.hasMoreElements();
                                                             p++)
                                                        {
                                                            JRadioButton pButton = (JRadioButton)pButtons.nextElement();
                                                            pButton.setEnabled(p <= maxp);
                                                            pButton.setVisible(p <= maxp);
                                                        }
                                                    }
                                                });
                                                setSelected(final_i == applet.qRotationalSymmetry.get());
                                                setMargin(nomargin);
                                                qButtonGroup.add(this);

                                                applet.qRotationalSymmetry.addListener(listener = new Listenable.Listener() {
                                                    public void valueChanged()
                                                    {
                                                        setSelected(applet.qRotationalSymmetry.get() == final_i);
                                                    }
                                                });
                                            }
                                        });
                                    }
                                }
                            }});
                        }});
                        add(new JCol() {{
                            add(new JCheckBox("remap fundamental region when changing symmetry (doesn't work yet)") { Listenable.Listener listener; {
                                setSelected(applet.remapFundamentalRegionWhenChangingSymmetry.get());
                                setMargin(nomargin);
                                addActionListener(new java.awt.event.ActionListener() {
                                    public void actionPerformed(java.awt.event.ActionEvent e)
                                    {
                                        applet.remapFundamentalRegionWhenChangingSymmetry.set(isSelected());
                                    }
                                });
                                applet.remapFundamentalRegionWhenChangingSymmetry.addListener(listener = new Listenable.Listener() {
                                    public void valueChanged()
                                    {
                                        setSelected(applet.remapFundamentalRegionWhenChangingSymmetry.get());
                                    }
                                });
                            }});

                            final ButtonGroupThatAllowsNone buttonGroup = new ButtonGroupThatAllowsNone();

                            add(new JCheckBox("force symmetry by replicating existing verts (doesn't work yet)") { Listenable.Listener listener; {
                                buttonGroup.add(this);
                                setSelected(applet.replicateVertsWhenChangingSymmetry.get());
                                setMargin(nomargin);
                                addActionListener(new java.awt.event.ActionListener() {
                                    public void actionPerformed(java.awt.event.ActionEvent e)
                                    {
                                        applet.replicateVertsWhenChangingSymmetry.set(isSelected());
                                    }
                                });
                                applet.replicateVertsWhenChangingSymmetry.addListener(listener = new Listenable.Listener() {
                                    public void valueChanged()
                                    {
                                        setSelected(applet.replicateVertsWhenChangingSymmetry.get());
                                    }
                                });
                            }});
                            add(new JCheckBox("force symmetry by deleting non-replicated existing verts (doesn't work yet)") { Listenable.Listener listener; {
                                buttonGroup.add(this);
                                setSelected(applet.deleteNonReplicatedVertsWhenChangingSymmetry.get());
                                setMargin(nomargin);
                                addActionListener(new java.awt.event.ActionListener() {
                                    public void actionPerformed(java.awt.event.ActionEvent e)
                                    {
                                        applet.deleteNonReplicatedVertsWhenChangingSymmetry.set(isSelected());
                                    }
                                });
                                applet.deleteNonReplicatedVertsWhenChangingSymmetry.addListener(listener = new Listenable.Listener() {
                                    public void valueChanged()
                                    {
                                        setSelected(applet.deleteNonReplicatedVertsWhenChangingSymmetry.get());
                                    }
                                });
                            }});
                        }});
                    }});
                }});
                contentPane.add(new JSeparator(), stretchx);
                contentPane.add(new JLabel("Net"));
                add(new JRow() {{
                    add(new JLabel("        ")); // indent a bit
                    add(new JCol() {{
                        add(new JRow() {{
                            add(new JCol() {{
                                add(new JCheckBox("Net", applet.showNetFlag.get()) {{
                                        setMargin(nomargin);
                                        addItemListener(new java.awt.event.ItemListener() {
                                            public void itemStateChanged(java.awt.event.ItemEvent e)
                                            {
                                                synchronized(applet.showNetFlag) // since another thread checks it once in a while
                                                {
                                                    applet.showNetFlag.set(isSelected());
                                                }
                                                applet.theCanvas.repaint();
                                            }
                                        });
                                        applet.showNetFlag.addListener(applet.showNetFlagListener = new Listenable.Listener() {
                                            public void valueChanged()
                                            {
                                                setSelected(applet.showNetFlag.get()); // of the checkbox

                                                // XXX TODO: arguably this should be in a different listener... it should happen even if we decided not to have this checkbox
                                                // XXX TODO: dup code
                                                if (applet.showNetFlag.get() && applet.showNetFlowFlag.get())
                                                {
                                                    Runnable runnable = new Runnable() {
                                                        public void run()
                                                        {
                                                            System.out.println("starting animator thread");
                                                            int fps = 10; // XXX need user control of this?
                                                            while (true) // while (applet.showNetFlag.get() && applet.showNetFlowFlag.get()), but synchronized
                                                            {
                                                                synchronized(applet.showNetFlag)
                                                                {
                                                                    synchronized(applet.showNetFlowFlag)
                                                                    {
                                                                        if (!applet.showNetFlag.get() || !applet.showNetFlowFlag.get())
                                                                            break;
                                                                    }
                                                                }

                                                                applet.theCanvas.repaint();
                                                                //System.out.println("    sleeping for "+(1000/fps)+" ms");
                                                                try {
                                                                    Thread.sleep(1000/fps);
                                                                } catch (InterruptedException e) {
                                                                    break;
                                                                }
                                                            }
                                                            System.out.println("terminating animator thread");
                                                            // XXX TODO: does master thread need to join?
                                                        }
                                                    };
                                                    Thread animatorThread = new Thread(runnable);
                                                    animatorThread.setDaemon(true); // make it so the java vm won't wait for it to finish before exiting
                                                    animatorThread.start();
                                                }

                                            }
                                        });
                                    }
                                });
                                add(new JCheckBox("Flow", applet.showNetFlowFlag.get()) {{
                                        setEnabled(applet.showNetFlag.get());
                                        setMargin(nomargin);
                                        addItemListener(new java.awt.event.ItemListener() {
                                            public void itemStateChanged(java.awt.event.ItemEvent e)
                                            {
                                                synchronized(applet.showNetFlowFlag) // since another thread checks it once in a while
                                                {
                                                    applet.showNetFlowFlag.set(isSelected());
                                                }
                                                applet.theCanvas.repaint();
                                            }
                                        });
                                        applet.showNetFlag.addListener(applet.showNetFlagListener2 = new Listenable.Listener() {
                                            public void valueChanged()
                                            {
                                                setEnabled(applet.showNetFlag.get()); // of the applet.showNetFlowFlag checkbox
                                            }
                                        });
                                        applet.showNetFlowFlag.addListener(applet.showNetFlowFlagListener = new Listenable.Listener() {
                                            public void valueChanged()
                                            {
                                                setSelected(applet.showNetFlowFlag.get()); // of the checkbox

                                                // XXX TODO: arguably this should be in a different listener... it should happen even if we decided not to have this checkbox
                                                // XXX TODO: dup code
                                                if (applet.showNetFlag.get() && applet.showNetFlowFlag.get())
                                                {
                                                    Runnable runnable = new Runnable() {
                                                        public void run()
                                                        {
                                                            System.out.println("starting animator thread");
                                                            int fps = 10; // XXX need user control of this?
                                                            while (true) // while (applet.showNetFlag.get() && applet.showNetFlowFlag.get()), but synchronized
                                                            {
                                                                synchronized(applet.showNetFlag)
                                                                {
                                                                    synchronized(applet.showNetFlowFlag)
                                                                    {
                                                                        if (!applet.showNetFlag.get() || !applet.showNetFlowFlag.get())
                                                                            break;
                                                                    }
                                                                }

                                                                applet.theCanvas.repaint();
                                                                //System.out.println("    sleeping for "+(1000/fps)+" ms");
                                                                try {
                                                                    Thread.sleep(1000/fps);
                                                                } catch (InterruptedException e) {
                                                                    break;
                                                                }
                                                            }
                                                            System.out.println("terminating animator thread");
                                                            // XXX TODO: does master thread need to join?
                                                        }
                                                    };
                                                    Thread animatorThread = new Thread(runnable);
                                                    animatorThread.setDaemon(true); // make it so the java vm won't wait for it to finish before exiting
                                                    animatorThread.start();
                                                }

                                            }
                                        });
                                    }
                                });
                            }});
                            add(new JComboBox(netMethodNames) {{
                                setSelectedIndex(applet.netMethod.get());
                                addItemListener(new java.awt.event.ItemListener() {
                                    public void itemStateChanged(java.awt.event.ItemEvent e)
                                    {
                                        // evidently this gets called twice??
                                        // no idea why (java.awt.Choice doesn't behave like that)
                                        // (well it had a different bug,
                                        // namely it called the callback on mouse up
                                        // even if the user selected what was already selected).
                                        // so check whether the new value is really new,
                                        // and if not, don't do anything.
                                        // (not that the extra stuff was expensive...
                                        // but I was noticing the "netMethod -> whatever"
                                        // was coming out 4 times)
                                        int newValue = getSelectedIndex();
                                        if (getSelectedIndex() != applet.netMethod.get())
                                        {
                                            applet.netMethod.set(newValue);
                                            System.out.println("netMethod -> "+applet.netMethodNames[applet.netMethod.get()]);
                                            applet.theNet = null;
                                            applet.theCanvas.repaint();
                                        }
                                    }
                                });
                                applet.netMethod.addListener(applet.netMethodListener = new Listenable.Listener() {
                                    public void valueChanged()
                                    {
                                        int newValue = applet.netMethod.get();
                                        // setSelectedIndex does callbacks
                                        // even if the value isn't new,
                                        // so don't call it unless the value is new
                                        if (newValue != getSelectedIndex())
                                            setSelectedIndex(newValue);
                                    }
                                });
                            }});
                        }});
                    }});
                }});
                contentPane.add(new JSeparator(), stretchx);
                contentPane.add(new JLabel("Debug"));
                add(new JRow() {{
                    add(new JLabel("        ")); // indent a bit
                    add(new JCol() {{
                        add(new JRow() {{
                            add(new JLabel("Labels:"));
                            add(new JCheckBoxForBoolean("primal verts", applet.labelPrimalVertsFlag));
                            add(new JCheckBoxForBoolean("primal edges", applet.labelPrimalEdgesFlag));
                            add(new JCheckBoxForBoolean("dual verts", applet.labelDualVertsFlag));
                            add(new JCheckBoxForBoolean("dual edges", applet.labelDualEdgesFlag));
                        }});
                        add(new JCheckBox("Magnifying glass", applet.showMagFlag.get()) {{
                                addItemListener(new java.awt.event.ItemListener() {
                                    public void itemStateChanged(java.awt.event.ItemEvent e)
                                    {
                                        applet.showMagFlag.set(isSelected());
                                        System.out.println("showMagFlag -> "+applet.showMagFlag.get());
                                        // need to double buffer iff magnifying
                                        applet.doubleBufferFlag = applet.showMagFlag.get();
                                        System.out.println("    doubleBufferFlag -> "+applet.doubleBufferFlag);
                                        applet.theCanvas.repaint();
                                    }
                                });
                                applet.showMagFlag.addListener(applet.showMagFlagListener = new Listenable.Listener() {
                                    public void valueChanged()
                                    {
                                        setSelected(applet.showMagFlag.get()); // of the checkbox
                                    }
                                });
                            }
                        });
                        add(new JRow() {{
                            add(new JButton("Dump window positions and sizes") {{
                                setMargin(nomargin);
                                addActionListener(new java.awt.event.ActionListener() {
                                    public void actionPerformed(java.awt.event.ActionEvent e)
                                    {
                                        System.out.println("----------------");
                                        System.out.println("      main applet: "+applet.theMainAppletWindow.getWidth()+"x"+applet.theMainAppletWindow.getHeight()+"+"+applet.theMainAppletWindow.getX()+"+"+applet.theMainAppletWindow.getY()+"");
                                        System.out.println("    control panel: "+applet.theControlPanelWindow.getWidth()+"x"+applet.theControlPanelWindow.getHeight()+"+"+applet.theControlPanelWindow.getX()+"+"+applet.theControlPanelWindow.getY()+"");
                                        System.out.println("             help: "+applet.theHelpWindow.getWidth()+"x"+applet.theHelpWindow.getHeight()+"+"+applet.theHelpWindow.getX()+"+"+applet.theHelpWindow.getY()+"");
                                        System.out.println("----------------");
                                    }
                                });
                            }});
                            add(new JLabel("    "));
                            add(new JRow() {{
                                add(new JLabel("Window title:"));
                                add(new JTextFieldForString(applet.windowTitle), stretchx);
                            }}, stretchx);
                        }}, stretchx);
                    }}, stretchx);
                }}, stretchx);
                contentPane.add(new JSeparator(), stretchx);

                //randomlyColorize(this);
                //dumpComponentHierarchy(this, 0, 0, 1);

            } // ShephardsPlayAppletControlPanel ctor
        } // class ShephardsPlayAppletControlPanel

    //
    // Implementing Applet methods...
    //
        public ShephardsPlayApplet()
        {
            if (true)
            {
                // Note, there's a MetalLookAndFeel.setCurrentTheme,
                // not sure how to get it, or even how to get the look and feel.
                // Anyway, the following seems to be a good heuristic.
                javax.swing.plaf.metal.DefaultMetalTheme defaultMetalTheme = new javax.swing.plaf.metal.DefaultMetalTheme();
                javax.swing.plaf.FontUIResource controlTextFont = defaultMetalTheme.getControlTextFont();
                int size = controlTextFont.getSize();
                //PRINT(controlTextFont);
                //PRINT(size);
                // Expected: size=12 is the default.
                // Anything bigger means it was probably messed with on the command line.
                if (true)
                {
                    if (size > 12)
                    {
                        hidpimag = 2;
                        System.out.println("Default controlFont size is "+size+">12, assuming my pixels are the tiny pixels of a hidpi display, setting hidpimag to "+hidpimag);
                      }
                    else
                    {
                        System.out.println("Default controlFont size is "+size+"<=12, not messing with hidpimag");
                    }
                }
            }

            java.awt.Container contentPane = getContentPane();

            contentPane.setLayout(new ColLayout());

            // used as "fill" argument to add()
            final java.awt.GridBagConstraints stretchxy = new java.awt.GridBagConstraints(){{fill=BOTH;weightx=weighty=1.;}};

            contentPane.add(theCanvas = new TheCanvas() {}, stretchxy);

            //
            // Make the menu bar
            //
            if (true)
            {
                // http://www.isr.umd.edu/~austin/ence688r.d/java-swing/menu.d/DemoMenuItem.java
                JMenuBar menuBar = new JMenuBar();

                menuBar.setBorderPainted(false); // true is default. false makes it blend into the background a tiny bit more, which is good.

                this.setJMenuBar(menuBar);

                JMenu fileMenu = new JMenu("File", true);
                menuBar.add(fileMenu);

                fileMenu.add(new JMenuItem("New"));
                fileMenu.addSeparator();
                fileMenu.add(new JMenuItem("Load DUMP.off"));
                fileMenu.add(new JMenuItem("Save DUMP.off"));
                fileMenu.addSeparator();
                fileMenu.addSeparator();

                JMenu editMenu = new JMenu("Edit", true);
                menuBar.add(editMenu);
                editMenu.add(new JMenuItem("Undo (not implemented here, use button in control panel)"));
                editMenu.add(new JMenuItem("Redo (not implemented here, use button in control panel)"));
                editMenu.addSeparator();
                editMenu.add(new JMenuItem("Clear (not implemented here, use button in control panel)"));

                JMenu windowsMenu = new JMenu("Windows", true);
                menuBar.add(windowsMenu);
                windowsMenu.add(new JMenuItem("Control Panel") {{
                    addActionListener(new java.awt.event.ActionListener() {
                        public void actionPerformed(java.awt.event.ActionEvent e)
                        {
                            theControlPanelWindow.setState(JFrame.NORMAL); // not iconified
                            theControlPanelWindow.setVisible(true); // also brings it to front, apparently
                        }
                    });
                }});

                JMenu helpMenu = new JMenu("Help", true);
                menuBar.add(helpMenu);
                helpMenu.add(new JMenuItem("Help") {{
                    addActionListener(new java.awt.event.ActionListener() {
                        public void actionPerformed(java.awt.event.ActionEvent e)
                        {
                            help();
                        }
                    });
                }});
                helpMenu.add(new JMenuItem("About...") {{
                    // TODO: do me
                }});
            }

            //randomlyColorize(this);

            //
            // Make the control panel window
            //
            if (true)
            {
                theControlPanelWindow = new JFrame(windowTitle + " Control Panel");
                // no need for setDefaultCloseOperation
                // since the default is HIDE_ON_CLOSE which is what we want


                theControlPanelWindow.getContentPane().add(new JScrollPane(new ShephardsPlayAppletControlPanel(this)));

                //theControlPanelWindow.setLocation(730, 10);
                theControlPanelWindow.setLocation(810, 10);
                theControlPanelWindow.pack();
                theControlPanelWindow.setVisible(true);
            }


            //
            // Make the help window
            //
            {
                theHelpWindow = new JFrame("Shephard's Play Applet Help");
                // no need for setDefaultCloseOperation
                // since the default is HIDE_ON_CLOSE which is what we want

                // TODO: figure out how to make it scroll in response to arrow keys

                if (true)
                {
                    // Use a JTextArea made to look like a label so text will be selectable
                    String text = "";
                    FORI (i, helpMessage.length)
                        text += "  " + helpMessage[i] + "  \n";
                    theHelpWindow.getContentPane().add(
                        new JScrollPane(
                            new JTextArea(text) {{
                                // make it like a JLabel as much as possible, but text selectable
                                this.setEditable(false);
                                this.setDisabledTextColor(java.awt.Color.black);
                                this.setBackground(null); // same as JLabel
                                this.setBorder(null); // same as JLabel
                            }}
                        ) {{
                            // if we don't do the following, it will screw up
                            // and pick a width that forces a horizontal scrollbar... lame!
                            this.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
                        }}
                    );
                }
                else
                {
                    // Use a JLabel -- text not selectable :-(
                    String htmlHelpMessage = "<html><pre>";
                    FORI (i, helpMessage.length)
                        htmlHelpMessage += helpMessage[i] + "  \n";
                    htmlHelpMessage += "</pre></html>";

                    theHelpWindow.getContentPane().add(new JScrollPane(new JLabel(htmlHelpMessage)) {{

                        // if we don't do the following, it will screw up
                        // and pick a width that forces a horizontal scrollbar... lame!
                        this.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
                    }});
                }

                theHelpWindow.setLocation(210,30); // XXX do I really want this?  can I center it instead? doing it so the help window doesn't end up in same place as main window.
                theHelpWindow.pack(); // so that getWidth() will be the preferred width
                theHelpWindow.setSize(theHelpWindow.getWidth(),700); // XXX heuristic for my screen
                //theHelpWindow.setVisible(true); // uncomment when debugging
            }


            gridBrightness.addListener(gridBrightnessListener = new Listenable.Listener() {
                public void valueChanged()
                {
                    System.out.println("in gridBrightness valueChanged");
                    PRINT(gridBrightness.get());
                    theCanvas.repaint();
                    System.out.println("out gridBrightness valueChanged");
                }
            });
            backfaceBrightness.addListener(backfaceBrightnessListener = new Listenable.Listener() {
                public void valueChanged()
                {
                    System.out.println("in backfaceBrightness valueChanged");
                    PRINT(backfaceBrightness.get());
                    theCanvas.repaint();
                    System.out.println("out backfaceBrightness valueChanged");
                }
            });
            wrapSphereSymbolicRadius.addListener(wrapSphereSymbolicRadiusListener = new Listenable.Listener() {
                public void valueChanged()
                {
                    //System.out.println("in wrapSphereSymbolicRadius valueChanged");
                    // the widgets control this, not wrapSphereCurvature directly
                    double value = wrapSphereSymbolicRadius.get();
                    if (value <= 1.)
                        wrapSphereCurvature.set(1./value);
                    else
                        wrapSphereCurvature.set(2.-value);
                    //System.out.println("out wrapSphereSymbolicRadius valueChanged");
                }
            });
            wrapSphereCurvature.addListener(wrapSphereCurvatureListener = new Listenable.Listener() {
                double previousValue = wrapSphereCurvature.get(); // track value of the Listenable
                public void valueChanged()
                {
                    //System.out.println("    in wrapSphereCurvature valueChanged");
                    double currentValue = wrapSphereCurvature.get();
                    assert(currentValue != previousValue); // Listenable wouldn't notify us otherwise

                    theSphereSurface.radius = 1./currentValue;
                    if (!centerSphereFlag.get())
                        theSphereSurface.center[2] = -theSphereSurface.radius;

                    if (wrapAroundSphereFlag.get())
                    {
                        unwrapAroundSphere(previousValue, centerSphereFlag.get());
                        wrapAroundSphere(currentValue, centerSphereFlag.get());
                        theCanvas.repaint();
                    }

                    previousValue = currentValue;
                    //System.out.println("    out wrapSphereCurvature valueChanged");
                }
            });
            centerSphereFlag.addListener(centerSphereFlagListener = new Listenable.Listener() {
                boolean previousValue = centerSphereFlag.get(); // track value of the Listenable
                public void valueChanged()
                {
                    //System.out.println("    in centerSphereFlag valueChanged");
                    boolean currentValue = centerSphereFlag.get();
                    assert(currentValue != previousValue); // Listenable wouldn't notify us otherwise

                    if (centerSphereFlag.get())
                        theSphereSurface.center[2] = 0.;
                    else
                    {
                        theSphereSurface.radius = 1./wrapSphereCurvature.get();
                        theSphereSurface.center[2] = -theSphereSurface.radius;
                    }

                    if (wrapAroundSphereFlag.get())
                    {
                        unwrapAroundSphere(wrapSphereCurvature.get(), previousValue);
                        wrapAroundSphere(wrapSphereCurvature.get(), currentValue);
                        theCanvas.repaint();
                    }

                    previousValue = currentValue;
                    //System.out.println("    out centerSphereFlag valueChanged");
                }
            });
            calcInsideOutDualVertsFlag.addListener(calcInsideOutDualVertsFlagListener = new Listenable.Listener() {
                public void valueChanged()
                {
                    System.out.println("calcInsideOutDualVertsFlag -> "+calcInsideOutDualVertsFlag.get());
                    if (continuouslyDelaunayizeFlag.get())
                    {
                        UndoItem.State before = newUndoItemState();
                        delaunayize();
                        UndoItem.State after = newUndoItemState();
                        undoTreeSquirrel.Do(new UndoItem(before, after));
                        theCanvas.repaint();
                    }
                }
            });
            showInsideOutDualVertsFlag.addListener(showInsideOutDualVertsFlagListener = new Listenable.Listener() {
                public void valueChanged()
                {
                    System.out.println("showInsideOutDualVertsFlag -> "+showInsideOutDualVertsFlag.get());
                    theCanvas.repaint();
                }
            });
            showPrimalVertsFlag.addListener(showPrimalVertsFlagListener = new Listenable.Listener() {
                public void valueChanged()
                {
                    System.out.println("showPrimalVertsFlag -> "+showPrimalVertsFlag.get());
                    theCanvas.repaint();
                }
            });
            showPrimalEdgesFlag.addListener(showPrimalEdgesFlagListener = new Listenable.Listener() {
                public void valueChanged()
                {
                    System.out.println("showPrimalEdgesFlag -> "+showPrimalEdgesFlag.get());
                    theCanvas.repaint();
                }
            });
            showFlatPrimalEdgesFlag.addListener(showFlatPrimalEdgesFlagListener = new Listenable.Listener() {
                public void valueChanged()
                {
                    System.out.println("showFlatPrimalEdgesFlag -> "+showFlatPrimalEdgesFlag.get());
                    theCanvas.repaint();
                }
            });
            showDualVertsFlag.addListener(showDualVertsFlagListener = new Listenable.Listener() {
                public void valueChanged()
                {
                    System.out.println("showDualVertsFlag -> "+showDualVertsFlag.get());
                    theCanvas.repaint();
                }
            });
            showDualEdgesFlag.addListener(showDualEdgesFlagListener = new Listenable.Listener() {
                public void valueChanged()
                {
                    System.out.println("showDualEdgesFlag -> "+showDualEdgesFlag.get());
                    theCanvas.repaint();
                }
            });
            naiveDualEdgesFlag.addListener(naiveDualEdgesFlagListener = new Listenable.Listener() {
                public void valueChanged()
                {
                    System.out.println("naiveDualEdgesFlag -> "+naiveDualEdgesFlag.get());
                    theCanvas.repaint();
                }
            });
            labelPrimalVertsFlag.addListener(labelPrimalVertsFlagListener = new Listenable.Listener() {
                public void valueChanged()
                {
                    System.out.println("labelPrimalVertsFlag -> "+labelPrimalVertsFlag.get());
                    theCanvas.repaint();
                }
            });
            labelPrimalEdgesFlag.addListener(labelPrimalEdgesFlagListener = new Listenable.Listener() {
                public void valueChanged()
                {
                    System.out.println("labelPrimalEdgesFlag -> "+labelPrimalEdgesFlag.get());
                    theCanvas.repaint();
                }
            });
            labelDualVertsFlag.addListener(labelDualVertsFlagListener = new Listenable.Listener() {
                public void valueChanged()
                {
                    System.out.println("labelDualVertsFlag -> "+labelDualVertsFlag.get());
                    theCanvas.repaint();
                }
            });
            labelDualEdgesFlag.addListener(labelDualEdgesFlagListener = new Listenable.Listener() {
                public void valueChanged()
                {
                    System.out.println("labelDualEdgesFlag -> "+labelDualEdgesFlag.get());
                    theCanvas.repaint();
                }
            });
            primalDualVisFlag.addListener(primalDualVisFlagListener = new Listenable.Listener() {
                public void valueChanged()
                {
                    System.out.println("primalDualVisFlag -> "+primalDualVisFlag.get());
                    theCanvas.repaint();
                }
            });
            windowTitle.addListener(windowTitleListener = new Listenable.Listener() {
                public void valueChanged()
                {
                    System.out.println("Changing main window title to "+windowTitle.get());
                    theMainAppletWindow.setTitle(windowTitle.get());
                    theControlPanelWindow.setTitle(windowTitle.get()+" Control Panel");
                }
            });
        } // ShephardsPlayApplet ctor

        static final String helpMessage[] = {
            "===================================================================",
            "Mouse:",
            "    left: add or drag a vertex",
            "    middle (or alt-left): rotate picture in 3d",
            "    right click: delete a vertex (shift-right-click deletes 10)",
            "    shift-middle drag: pan entire picture",
            "    shift-left drag: create new edge between two vertices",
            "    ctrl-left: snap to grid when creating and dragging vertices",
            "Keys:",
            "    '1'...'9' - set rotational symmetry for creating and dragging verts (1=none)",
            "    shift-'1'...shift-'9' - set left-right mirror and rotational symmetry",
            "    '0' - set rotational symmetry to 10",
            "    shift-'0' - set left-right mirror and rotational symmetry to 10",
            "    'V' - cycle event verbosity (to java console or system output)",
            "    ' ' - just repaint",
            "    'A' - toggle antiAliasingFlag",
            "    't'/'T' - toggle primary (triangle) mesh",
            "    'i'/'+'/'=' - zoom in",
            "    'o'/'-' - zoom out",
            "    'f' - frame picture",
            "    '|' - flip left-right",
            "    '_' - flip up-down",
            "    '/' - flip upper-left lower-right",
            "    '\' - flip lower-left upper-right",
            "    's' - swap a diagonal",
            "    ctrl-'s' - swap a diagonal if the result is more Delaunay",
            "    'D' - Delaunay triangulate",
            "    'w' - add or remove closest dual vertex from list of points to show curvature center of",
            "    'W' - select *all* dual verts for weighting (positive weight, of arity 3), or deselect all if selected all previously",
            "    'O' - toggle optimizeFlag",
            "    'l' - toggle showLabels",
            "    '0' - toggle showOrigin",
            "    'g' - toggle showGrid",
            "    'M'/'m' - increase/decrease magnification focus region",
            "    'P'/'p' - increase/decrease magnified pixel size",
            "    ctrl-'m' - toggle magnifying glass",
            "    'a' - toggle arrowsTowardsSharpestDihedralsFlag (green)",
            "    alt-'a' - toggle arrowsTowardsShortestEdgesFlag (cyan)",
            "    'n' - toggle showNet",
            "    Left/Right arrow - rotate closest cut or fold CCW or CW around its lagoon in the net",
            "    'S' - turn off optimize, and re-spherize",
            "    'd' - delete closest edge",
            "    ctrl-'i' - toggle showInsideOutDualVertsFlag",
            "    ctrl-'o' - cycle optimizationType",
            "    ctrl-'v' - toggle nonEventVerbose",
            "    Up arrow: pull face plane of closest vertex out",
            "    Down arrow: push face plane of closest vertex in",
            "    'c' - clear",
            "    'u' / ctrl-'z' - undo",
            "    'r' / 'U' / ctrl-'r' / ctrl-'y' - redo",
            "    'h' - help",
            "    ctrl-'q' - quit",
            "===================================================================",
        }; // helpMessage

        private void help()
        {
            theHelpWindow.setState(java.awt.Frame.NORMAL); // not ICONTIFIED
            theHelpWindow.setVisible(true);
            theHelpWindow.toFront();

            if (true)
            {
                FORI (i, helpMessage.length)
                    System.out.println(helpMessage[i]);
            }
        } // help

        // classNameAncestors
        private static String classNameAncestors(Class classs)
        {
            String text = classs.getName();

            if (text.indexOf("java.lang.") == 0)
                text = text.substring(10);
            if (text.indexOf("java.awt.") == 0)
                text = text.substring(9);
            if (text.indexOf("javax.swing.J") == 0)
                text = text.substring(12);

            //if (text.indexOf('$') != -1)
            if (classs.getSuperclass() != null)
                text += " > " + classNameAncestors(classs.getSuperclass());
            return text;
        } // classNameAncestors
        private static void dumpComponentHierarchy(java.awt.Component component, int depth, int iChildInParent, int nChildrenInParent)
        {
            FORI (i, depth) System.out.print(" ");

            System.out.print(iChildInParent+"/"+nChildrenInParent+" ");
            System.out.println(classNameAncestors(component.getClass()));

            if (component instanceof java.awt.Container)
            {
                java.awt.Container C = (java.awt.Container)component;
                int n = C.getComponentCount();
                for (int iChild = 0; iChild < n; ++iChild)
                {
                    //FORI (iIndent, depth) System.out.print(" "); System.out.println(iChild+"/"+n);
                    dumpComponentHierarchy(C.getComponent(iChild), depth+1, iChild, n);
                }
                if (n > 0)
                {
                    //FORI (iIndent, depth) System.out.print(" "); System.out.println(n+"/"+n);
                }
            }
        } // dumpComponentHierarchy

        private static void randomlyColorize(java.awt.Component c)
        {
            c.setBackground(new java.awt.Color((float)Math.random(),
                                               (float)Math.random(),
                                               (float)Math.random()));
            c.setForeground(new java.awt.Color((float)Math.random(),
                                               (float)Math.random(),
                                               (float)Math.random()));
            if (c instanceof java.awt.Container)
            {
                java.awt.Container C = (java.awt.Container)c;
                int n = C.getComponentCount();
                for (int i = 0; i < n; ++i)
                    randomlyColorize(C.getComponent(i));
            }
        } // randomlyColorize

        // This is a bit ridiculous, but... figure out the height a flowLayout wants to be, given a width.
        // Maybe ask on stackOverflow?
        private static int calcFlowLayoutPreferredHeightGivenPreferredWidth(java.awt.Container container, int width) {
            // Strategy:
            //    - set size to given width and large height
            //    - do layout
            //    - traverse children and see what the bottom is
            java.awt.FlowLayout flowLayout = (java.awt.FlowLayout)container.getLayout();
            int hgap = flowLayout.getHgap();
            int vgap = flowLayout.getVgap();
            int n = container.getComponentCount();

            // height upper bound is the height we'd get if every child on different row
            int heightUpperBound = vgap;
            for (int i = 0; i < n; ++i)
            {
                int childPreferredHeight = container.getComponent(i).getPreferredSize().height;
                heightUpperBound += childPreferredHeight + vgap;
            }
            container.setSize(width, heightUpperBound);
            container.doLayout();  // validate() doesn't seem to do it
            int maxBottom = 0;
            for (int i = 0; i < n; ++i) {
                java.awt.Component child = container.getComponent(i);
                int childBottom = child.getY() + child.getHeight();
                maxBottom = MAX(maxBottom, childBottom);
            }
            return maxBottom + vgap;
        }  // calcFlowLayoutPreferredHeightGivenPreferredWidth
        private static int calcMaxChildPreferredWidth(java.awt.Container container)
        {
            int n = container.getComponentCount();
            int answer = 0;
            for (int i = 0; i < n; ++i)
            {
                int childPreferredWidth = container.getComponent(i).getPreferredSize().width;
                answer = MAX(answer, childPreferredWidth);
            }
            return answer;
        } // calcMaxChildPreferredWidth

        public void dualSave(String fileName)
        {
            System.out.println("Saving dual verts to "+fileName+"... ");
            System.out.flush();
            try {
                java.io.PrintWriter writer = new java.io.PrintWriter(new java.io.BufferedWriter(new java.io.FileWriter(fileName)));
                // XXX want \r\n no matter which platform I'm on, I think

                Mesh dualMesh = getDualMesh();
                int nDualVerts = dualMesh.verts.size();
                boolean showInsideOutDualVertsFlagValue = showInsideOutDualVertsFlag.get();
                FORI (iDualVert, nDualVerts)
                {
                    Mesh.Vertex dualVert = dualMesh.getVert(iDualVert);
                    if (dualVert.arity == 3
                     && (showInsideOutDualVertsFlagValue
                      || dualVert.weight >= 0))
                    {
                        writer.println("        {" + dualVert.X()
                                            + ", " + dualVert.Y()
                                            + ", " + dualVert.Z()
                                            + ", " + dualVert.W()
                                            + "},");
                    }
                    else
                        writer.println("null");
                }

                writer.flush();
                writer.close();
            }
            catch (Exception exc)
            {
                System.out.println("save to file "+fileName+" failed:" + exc);
            }
            System.out.println("done.");
        } // save
        public void save(String fileName,
                         boolean saveHomo)
        {
            System.out.println("Saving to "+fileName+"... ");
            System.out.flush();
            try {
                java.io.PrintWriter writer = new java.io.PrintWriter(new java.io.BufferedWriter(new java.io.FileWriter(fileName)));

                // XXX want \n\r no matter which platform I'm on!

                writer.println("OFF");

                // count faces
                int nFaces;
                {
                    boolean didEdge[] = new boolean[mesh.edges.size()]; // all false
                    nFaces = 0; // and counting
                    int nEdges = mesh.edges.size();
                    FORI (iEdge, nEdges)
                    {
                        if (didEdge[iEdge])
                            continue;
                        nFaces++;
                        Mesh.Edge e = mesh.getEdge(iEdge);
                        while (!didEdge[e.myIndex()])
                        {
                            didEdge[e.myIndex()] = true;
                            e = e.next();
                        }
                    }
                }
                writer.println("" + mesh.verts.size()
                            + " " + nFaces
                            + " " + 0);
                FORI (iVert, mesh.verts.size())
                {
                    Mesh.Vertex vert = mesh.getVert(iVert);
                    if (saveHomo) // nonstandard .off file, 4 coords per vertex
                        writer.println("" + vert.X() + " " + vert.Y() + " " + vert.Z() + " " + vert.W());
                    else
                        writer.println("" + vert.x() + " " + vert.y() + " " + vert.h());
                }

                // If we're going to output net cuts,
                // then we need to keep track of the order in which the edges
                // appear in the output, since that's the order
                // they'll be in when it gets read back in.
                int edgeToOutputIndex[] = (theNet==null ? null : Arrays.fill(mesh.edges.size(), -1));
                int outputIndex = 0;

                {
                    boolean didEdge[] = new boolean[mesh.edges.size()]; // all false
                    int nEdges = mesh.edges.size();
                    IntArrayList vertsThisFace = new IntArrayList();
                    FORI (iEdge, nEdges)
                    {
                        if (didEdge[iEdge])
                            continue;
                        vertsThisFace.clear();
                        Mesh.Edge e = mesh.getEdge(iEdge);
                        while (!didEdge[e.myIndex()])
                        {
                            if (edgeToOutputIndex != null
                             && edgeToOutputIndex[e.myIndex()] == -1) // if not already seen
                            {
                                edgeToOutputIndex[e.myIndex()] = outputIndex++;
                                edgeToOutputIndex[e.opposite().myIndex()] = outputIndex++;
                            }

                            didEdge[e.myIndex()] = true;
                            vertsThisFace.add(e.initialVertex().myIndex());
                            e = e.next();
                        }
                        writer.print("" + vertsThisFace.size() + " ");
                        FORI (iVertThisFace, vertsThisFace.size())
                            writer.print(" " + vertsThisFace.get(iVertThisFace));
                        writer.println();
                    }
                }

                if (theNet != null)
                {
                    writer.print("# Cuts:");
                    FORI (iEdge, theNet._edgeStatuses.length)
                        if (theNet._edgeStatuses[iEdge] == Net.CUT
                         && mesh.getEdge(iEdge).myIndex() < mesh.getEdge(iEdge).opposite().myIndex())
                            writer.print(" "+edgeToOutputIndex[iEdge]);
                    writer.println();

                    writer.print("# Folds:");
                    FORI (iEdge, theNet._edgeStatuses.length)
                        if (theNet._edgeStatuses[iEdge] == Net.FOLD
                         && mesh.getEdge(iEdge).myIndex() < mesh.getEdge(iEdge).opposite().myIndex())
                            writer.print(" "+edgeToOutputIndex[iEdge]);
                    writer.println();
                }


                writer.flush();
                writer.close();
            }
            catch (Exception exc)
            {
                System.out.println("save to file "+fileName+" failed:" + exc);
            }
            System.out.println("done.");
        } // save
        public void load(String fileName)
        {
            System.out.print("Loading from "+fileName+"... ");
            System.out.flush();
            try {
                java.io.LineNumberReader reader = new java.io.LineNumberReader(new java.io.FileReader(fileName)); // LineNumberReader is already a buffered reader
                String line;
                if ((line = reader.readLine()) == null)
                {
                    reader.close();
                    throw new Exception("premature EOF expecting OFF");
                }
                if (!line.equals("OFF"))
                {
                    reader.close();
                    throw new Exception("expected OFF, got \""+line+"\"");
                }
                if ((line = reader.readLine()) == null)
                {
                    reader.close();
                    throw new Exception("premature EOF expecting number of verts, faces, 0");
                }
                //String[] tokens = line.trim().split("\\s+");
                String[] tokens = com.donhatchsw.compat.regex.split(line.trim(), "\\s+");
                if (tokens.length != 3)
                {
                    reader.close();
                    throw new Exception("expected number of verts, number of faces, 0, got \""+line+"\"");
                }
                int nVerts = Integer.parseInt(tokens[0]);
                int nFaces = Integer.parseInt(tokens[1]);
                int zero = Integer.parseInt(tokens[2]);
                double verts[][] = new double[nVerts][/* 3 or 4 */];
                int faces[][] = new int[nFaces][];

                FORI (iVert, nVerts)
                {
                    if ((line = reader.readLine()) == null)
                    {
                        reader.close();
                        throw new Exception("premature EOF trying to read vertex "+iVert+"/"+nVerts+"");
                    }
                    //tokens = line.trim().split("\\s+");
                    tokens = com.donhatchsw.compat.regex.split(line.trim(), "\\s+");
                    if (tokens.length != 3
                     && tokens.length != 4)
                    {
                        reader.close();
                        throw new Exception("expected 3 or 4 floating point numbers, got \""+line+"\"");
                    }
                    verts[iVert] = new double[tokens.length];
                    FORI (i, tokens.length)
                        verts[iVert][i] = Double.parseDouble(tokens[i]);
                }
                FORI (iFace, nFaces)
                {
                    if ((line = reader.readLine()) == null)
                    {
                        reader.close();
                        throw new Exception("premature EOF trying to read face "+iFace+"/"+nFaces+"");
                    }
                    //tokens = line.trim().split("\\s+");
                    tokens = com.donhatchsw.compat.regex.split(line.trim(), "\\s+");
                    if (tokens.length == 0)
                    {
                        reader.close();
                        throw new Exception("expected a face, got \""+line+"\"");
                    }
                    int faceSize = Integer.parseInt(tokens[0]);
                    if (tokens.length != 1 + faceSize)
                    {
                        reader.close();
                        throw new Exception("expected a face, got \""+line+"\" (wrong number of indices)");
                    }
                    faces[iFace] = new int[faceSize];
                    FORI (i, faceSize)
                        faces[iFace][i] = Integer.parseInt(tokens[i+1]);
                }
                int nEdgesExpected = 0;
                FORI (iFace, nFaces)
                    nEdgesExpected += faces[iFace].length;

                // Read optional cuts and folds in comments at the end
                int edgeStatuses[] = null; // we'll lazily set this to something if we see a Cuts or Folds line
                while ((line = reader.readLine()) != null)
                {
                    // XXX TODO: be more lenient with syntax
                    if (line.startsWith("# Cuts:"))
                    {
                        if (edgeStatuses == null) edgeStatuses = VecMath.fillvec(nEdgesExpected, Net.UNDECIDED);
                        tokens = com.donhatchsw.compat.regex.split(line.substring(7).trim(), "\\s+");

                        // regex.split("", "\\s+") returns {""} when I think it should return {}.
                        // so, we have to special-case that, sigh.
                        if (tokens.length == 1 && tokens[0] == "") tokens = new String[]{};

                        FORI (iToken, tokens.length)
                            edgeStatuses[Integer.parseInt(tokens[iToken])] = Net.CUT;
                    }
                    else if (line.startsWith("# Folds:"))
                    {
                        if (edgeStatuses == null) edgeStatuses = VecMath.fillvec(nEdgesExpected, Net.UNDECIDED);
                        tokens = com.donhatchsw.compat.regex.split(line.substring(8).trim(), "\\s+");

                        // regex.split("", "\\s+") returns {""} when I think it should return {}.
                        // so, we have to special-case that, sigh.
                        if (tokens.length == 1 && tokens[0] == "") tokens = new String[]{};

                        FORI (iToken, tokens.length)
                            edgeStatuses[Integer.parseInt(tokens[iToken])] = Net.FOLD;
                    }
                    else
                    {
                        System.out.println("WARNING: unrecognized line after OFF data: "+line);
                    }
                }

                reader.close();

                mesh = new Mesh(verts, faces);

                assert(mesh.edges.size() == nEdgesExpected);

                if (edgeStatuses != null) // if there was Cut and/or Fold info at the end...
                    theNet = new Net(getDualMesh(), mesh, edgeStatuses);

                if (continuouslyDelaunayizeFlag.get()) delaunayize();
            }
            catch (Exception exc)
            {
                exc.printStackTrace();
                System.out.println("load from file "+fileName+" failed:" + exc);            }
            System.out.println("done.");
        } // load

        public void pan(double dx, double dy)
        {
            UndoItem.State before = newUndoItemState();
            FORIDOWN(iVert, mesh.verts.size())
            {
                Mesh.Vertex vert = mesh.getVert(iVert);
                vert.setxyh(vert.x()+dx,
                            vert.y()+dy,
                            vert.h());
                // TODO: do it in hom space
                /*
                vert.setXYZW(vert.X(),
                             vert.Y(),
                             vert.Z(),
                             vert.W());
                */
                assert(vert.momentAndArea == null);
            }
            dirtyDualMesh();
            UndoItem.State after = newUndoItemState();
            undoTreeSquirrel.Do(new UndoItem(before, after));
            theCanvas.repaint();
        } // rescaleDualOnly

        public void panDualOnly(double dx, double dy)
        {
            UndoItem.State before = newUndoItemState();
            FORIDOWN(iVert, mesh.verts.size())
            {
                Mesh.Vertex vert = mesh.getVert(iVert);
                vert.setXYZW(vert.x(),
                             vert.y(),
                             vert.z() - dx*vert.x() - dy*vert.y(),
                             1.);
                // TODO: do it in hom space
                /*
                vert.setXYZW(vert.X(),
                             vert.Y(),
                             vert.Z(),
                             vert.W());
                */
                assert(vert.momentAndArea == null);
            }
            dirtyDualMesh();
            UndoItem.State after = newUndoItemState();
            undoTreeSquirrel.Do(new UndoItem(before, after));
            theCanvas.repaint();
        } // panDualOnly

        public void panPrimalOnly(double dx, double dy)
        {
            // cop out
            pan(dx, dy);
            panDualOnly(-dx, -dy);
        }

        public void rescaleDualOnly(double scale)
        {
            UndoItem.State before = newUndoItemState();
            FORIDOWN(iVert, mesh.verts.size())
            {
                Mesh.Vertex vert = mesh.getVert(iVert);
                vert.setXYZW(vert.X(),
                             vert.Y(),
                             vert.Z() * scale,
                             vert.W());
                assert(vert.momentAndArea == null);
            }
            dirtyDualMesh();
            UndoItem.State after = newUndoItemState();
            undoTreeSquirrel.Do(new UndoItem(before, after));
            theCanvas.repaint();
        } // rescaleDualOnly

        public void rescalePrimalOnly(double scale)
        {
            // cop out
            rescale(scale, scale);
            rescaleDualOnly(1./scale);
        }

        public void rescale(double scaleX, double scaleY)
        {
            UndoItem.State before = newUndoItemState();
            Mesh dualMesh = getDualMesh(); // before scaling mesh!
            double scale = Math.sqrt(.5);
            FORIDOWN (iVert, mesh.verts.size())
            {
                Mesh.Vertex vert = mesh.getVert(iVert);

                vert.setXYZW(vert.X() * scaleX,
                             vert.Y() * scaleY,
                             vert.Z() * scaleX * scaleY,
                             vert.W());
                assert(vert.momentAndArea == null);
            }

            if (scaleX != scaleY && continuouslyDelaunayizeFlag.get()) // no need to re-delaunayize if uniform scale   TODO: actually if everything's working right, shouldn't have to do this anyway!?
            {
                delaunayize();
                dirtyDualMesh();
            }
            else
            {
                // don't recalculate dual mesh, rather, just rescale its points accordingly.
                // this makes it so we don't have to blow away the net.
                FORIDOWN(iDualVert, dualMesh.verts.size())
                {
                    Mesh.Vertex dualVert = dualMesh.getVert(iDualVert);
                    dualVert.setXYZW(dualVert.X() * scaleY, // converse
                                     dualVert.Y() * scaleX, // converse
                                     dualVert.Z() * scaleX * scaleY,
                                     dualVert.W());
                    if (dualVert.momentAndArea != null) // it will be null in strange cases such as when I created it by hand in cannedThingSingleExitLagoonPolygon
                    {
                        assert(dualVert.momentAndArea.length == 4);

                        // holy hell this is incredibly hard to get right!!
                        dualVert.momentAndArea[2] -= .5 * (SQR(dualVert.momentAndArea[0]) + SQR(dualVert.momentAndArea[1])); // convert to "actual"

                        dualVert.momentAndArea[0] *= SQR(scaleX) * scaleY;
                        dualVert.momentAndArea[1] *= scaleX * SQR(scaleY);
                        dualVert.momentAndArea[2] *= CUB(scaleX*scaleY);
                        dualVert.momentAndArea[3] *= scaleX*scaleY;

                        dualVert.momentAndArea[2] += .5 * (SQR(dualVert.momentAndArea[0]) + SQR(dualVert.momentAndArea[1])); // convert from "actual"
                    }
                }

                // dual directions are now totally messed up... fix them
                fixDualDirections(mesh, dualMesh, wrapAroundSphereFlag.get(), centerSphereFlag.get(), wrapSphereCurvature.get());
            }

            UndoItem.State after = newUndoItemState();
            undoTreeSquirrel.Do(new UndoItem(before, after));
            theCanvas.repaint();
        } // rescale

        public void frame(boolean framePrimalFlag, boolean frameDualFlag)
        {
            assert(framePrimalFlag || frameDualFlag);
            UndoItem.State before = newUndoItemState();

            {
                // XXX do I want this?
                resetLocalToWorld();
            }
            {
                double minx = Double.POSITIVE_INFINITY;
                double miny = Double.POSITIVE_INFINITY;
                double maxx = Double.NEGATIVE_INFINITY;
                double maxy = Double.NEGATIVE_INFINITY;
                if (framePrimalFlag)
                    FORIDOWN(iVert, mesh.verts.size())
                    {
                        Mesh.Vertex vert = mesh.getVert(iVert);
                        minx = MIN(minx, vert.x());
                        maxx = MAX(maxx, vert.x());
                        miny = MIN(miny, vert.y());
                        maxy = MAX(maxy, vert.y());
                    }
                if (frameDualFlag)
                {
                    Mesh dualMesh = getDualMesh();
                    FORIDOWN(iDualVert, dualMesh.verts.size())
                    {
                        Mesh.Vertex dualVert = dualMesh.getVert(iDualVert);
                        minx = MIN(minx, dualVert.x());
                        maxx = MAX(maxx, dualVert.x());
                        miny = MIN(miny, dualVert.y());
                        maxy = MAX(maxy, dualVert.y());
                    }
                }
                double center[] = {(minx+maxx)*.5, (miny+maxy)*.5};
                if (pRotationalSymmetry.get() > 1)
                    VecMath.zerovec(center);

                double maxRadius = MAX4(maxx-center[0], center[0]-minx,
                                        maxy-center[1], center[1]-miny);
                double scale = 1./maxRadius;
                if (maxRadius > 0.)
                {
                    FORIDOWN(iVert, mesh.verts.size())
                    {
                        Mesh.Vertex vert = mesh.getVert(iVert);
                        vert.setXYHnaive((vert.Xnaive() - center[0]) * scale,
                                    (vert.Ynaive() - center[1]) * scale,
                                    vert.Hnaive() * (scale*scale));
                    }
                    Mesh dualMesh = getDualMesh();
                    FORIDOWN(iDualVert, dualMesh.verts.size())
                    {
                        Mesh.Vertex dualVert = dualMesh.getVert(iDualVert);
                        dualVert.setXYHnaive((dualVert.Xnaive() - center[0]) * scale,
                                        (dualVert.Ynaive() - center[1]) * scale,
                                        dualVert.Hnaive() * (scale*scale)); // XXX probably wrong
                    }
                }
            }

            // should be no need to re-delaunayize, since uniform scale
            UndoItem.State after = newUndoItemState();
            undoTreeSquirrel.Do(new UndoItem(before, after));
            theCanvas.repaint();
        } // frame


        private static double[][] getWrapAroundSphereMatrix(double wrapSphereCurvature, boolean centerSphereFlag)
        {
            // inverse of getUnwrapAroundSphereMatrix, I don't claim to understand it
            double m[][] = {
                {1,0,0,0},
                {0,1,0,0},
                {0,0,wrapSphereCurvature,-.5*SQR(wrapSphereCurvature)},
                {0,0,0,1},
            };
            if (centerSphereFlag)
            {
                // end by moving center from -r to origin
                m = VecMath.mxm(m, new double[][] {
                    {1,0,0,0},
                    {0,1,0,0},
                    {0,0,1,0},
                    {0,0,1./wrapSphereCurvature,1},
                });
            }
            return m;
        } // getWrapAroundSphereMatrix
        private static double[][] getUnwrapAroundSphereMatrix(double wrapSphereCurvature, boolean centerSphereFlag)
        {
            /*
            // divide by wrap sphere radius, to wrap around unit sphere
               1/r 0 0 0
               0 1/r 0 0
               0 0 1/r 0
               0 0  0  1
            // divide by 1+z/2, to send far point to infinity
                1  0  0  0
                0  1  0  0
                0  0  1  .5
                0  0  0  1
            // multiply by wrap sphere radius, to get original scale and curvature at origin
               r 0 0 0
               0 r 0 0
               0 0 r 0
               0 0 0 1
            i.e. 
                1  0  0  0
                0  1  0  0
                0  0  1  .5/r
                0  0  0  1
            // Then, since we want paraboloid to have curvature 1 instead of 1/r,
            // multiply by:
               1 0 0 0
               0 1 0 0
               0 0 r 0
               0 0 0 1
            // i.e. (if we cared, which we probably don't since we don't unwrap around infinite radius sphere, do we?)
               1/r 0  0  0
               0  1/r 0  0
               0   0  1  0
               0   0  0 1/r
            */

            double m[][] = {
                {1,0,0,0},
                {0,1,0,0},
                {0,0,1./wrapSphereCurvature,.5*wrapSphereCurvature},
                {0,0,0,1},
            };
            if (centerSphereFlag)
            {
                // start by moving center from origin to -r
                m = VecMath.mxm(new double[][] {
                    {1,0,0,0},
                    {0,1,0,0},
                    {0,0,1,0},
                    {0,0,-1./wrapSphereCurvature,1},
                }, m);
            }
            return m;
        } // getUnwrapAroundSphereMatrix


        // wrap from parabola to sphere
        private void wrapAroundSphere(double wrapSphereCurvature, boolean centerSphereFlag)
        {
            xformTheMesh(getWrapAroundSphereMatrix(wrapSphereCurvature, centerSphereFlag));
        } // wrapAroundSphere


        // unwrap from sphere to parabola
        private void unwrapAroundSphere(double wrapSphereCurvature, boolean centerSphereFlag)
        {
            xformTheMesh(getUnwrapAroundSphereMatrix(wrapSphereCurvature, centerSphereFlag));
        } // unwrapAroundSphere

        private void xformTheMesh(double mat[/*4*/][/*4*/])
        {
            double in[] = new double[4];
            double out[] = new double[4];

            FORIDOWN(iVert, mesh.verts.size())
            {
                Mesh.Vertex vert = mesh.getVert(iVert);
                in[0] = vert.X();
                in[1] = vert.Y();
                in[2] = vert.Z();
                in[3] = vert.W();
                VecMath.vxm(out, in, mat);
                vert.setXYZW(out[0],
                             out[1],
                             out[2],
                             out[3]);
            }

            dirtyDualMesh();
            if (continuouslyDelaunayizeFlag.get()) delaunayize();
        } // xformTheMesh


        // crappy name-- this is changeMeshSymmetry with undo and repaint
        private void changeSymmetry(int p, int q, boolean leftRight, boolean central, boolean remap, boolean replicate, boolean deleteNonReplicated)
        {
            if (p == pRotationalSymmetry.get()
             && q == qRotationalSymmetry.get()
             && leftRight == leftRightSymmetry.get()
             && central == centralSymmetry.get())
            {
                return; // no change
            }

            System.out.println("rotationalSymmetry -> "+p+","+q
                + " "+(leftRight?"with":"without")+" left-right symmetry"
                + " "+(central?"with":"without")+" central symmetry");

            UndoItem.State before = newUndoItemState();
            if (remap)
                changeMeshSymmetry(pRotationalSymmetry.get(), qRotationalSymmetry.get(), leftRightSymmetry.get(), centralSymmetry.get(),
                                   p, q, leftRight, central);
            // probably a lot of excess messages going on...
            pRotationalSymmetry.set(p);
            qRotationalSymmetry.set(q);
            leftRightSymmetry.set(leftRight);
            centralSymmetry.set(central);
            if (continuouslyDelaunayizeFlag.get()) delaunayize();
            UndoItem.State after = newUndoItemState();
            undoTreeSquirrel.Do(new UndoItem(before, after));

            theCanvas.repaint();
        } // changeSymmetry

        // TODO: needs an overhaul, doesn't use q or central yet
        public void changeMeshSymmetry(int oldRotationalSymmetry, int oldQ, boolean oldLeftRightSymmetry, boolean oldCentral,
                                       int newRotationalSymmetry, int newQ, boolean newLeftRightSymmetry, boolean newCentral)
        {
            System.out.println("    in changeMeshSymmetry");
            if (oldRotationalSymmetry == newRotationalSymmetry
             && oldQ == newQ
             && oldLeftRightSymmetry == newLeftRightSymmetry
             && oldCentral == newCentral)
            {
                System.out.println("    out changeMeshSymmetry (nothing changed)");
                return; // nothing change; no point in introducing round-off error
            }

            int nOldVerts = mesh.verts.size();
            PRINT(nOldVerts);
            double oldVerts[][] = new double[nOldVerts][3];
            double maxAbsCoord = 0.;
            FORI (iOldVert, nOldVerts)
            {
                Mesh.Vertex vert = mesh.getVert(iOldVert);
                oldVerts[iOldVert][0] = vert.x();
                oldVerts[iOldVert][1] = vert.y();
                oldVerts[iOldVert][2] = vert.h();
            }
            double oldBbox[][] = VecMath.bbox(oldVerts);
            double workAreaSize = (nOldVerts==0 ? 1. : MAX4(ABS(oldBbox[0][0]),
                                                            ABS(oldBbox[0][1]),
                                                            ABS(oldBbox[1][0]),
                                                            ABS(oldBbox[1][1])));

            ArrayList/*<double[]>*/ newVerts = new ArrayList();

            // as recommended in FuzzyPointHashTable doc...
            double littleTol = 1e-12 * workAreaSize;
            double bigTol = 1e-10 * workAreaSize;
            double bucketSize = 1/1024. * workAreaSize;
            FuzzyPointHashTable newVertsTable = new FuzzyPointHashTable(littleTol,
                                                                        bigTol,
                                                                        bucketSize);
            Object dummy = new Object(); // we really want a hash set, not hash table, so need a dummy object, distinct from null
            FORI (iOldVert, nOldVerts)
            {
                double oldVert[] = oldVerts[iOldVert];
                double magnitude = MyMath.hypot(oldVert[0], oldVert[1]);
                double oldAngle = Math.atan2(oldVert[1], oldVert[0]);
                // find fraction in the canonical fundamental region...
                double frac = (oldAngle/(2*Math.PI) + .25) // so -90 degrees produces frac=0
                            * oldRotationalSymmetry;
                frac -= Math.floor(frac); // so frac should now be between 0 and 1
                if (oldLeftRightSymmetry)
                {
                    if (frac > .5)
                        frac = 1. - frac;
                    frac *= 2.;
                }

                if (false) // nah, this looks like hell
                {
                    // make it a conformal mapping (raising to a power in the complex plane)...
                    magnitude = Math.pow(magnitude, (double)oldRotationalSymmetry/(double)newRotationalSymmetry);
                }

                FORI (iReflect, (newLeftRightSymmetry ? 2 : 1))
                    FORI (iNewImage, newRotationalSymmetry)
                    {
                        double newAngle = ((iNewImage+frac*(newLeftRightSymmetry ? .5 : 1)) / newRotationalSymmetry - .25) * (2*Math.PI);
                        double newVert[] = {
                            magnitude * Math.cos(newAngle) * (iReflect==1 ? -1. : 1.),
                            magnitude * Math.sin(newAngle),
                        };
                        if (newVertsTable.put(newVert,dummy) == null) // i.e. if it wasn't already there
                        {
                            newVerts.add(new double[] {
                                newVert[0],
                                newVert[1],
                                oldVert[2], // takes one of the old heights arbitrarily, if multiple
                            });
                        }
                    }
            }

            // For now, don't try to retain any connectivity.
            mesh = new Mesh();
            int nNewVerts = newVerts.size();
            PRINT(nNewVerts);
            FORI (iNewVert, nNewVerts)
            {
                double newVert[] = (double[])newVerts.get(iNewVert);
                mesh.addIsolatedVertex(newVert[0],
                                       newVert[1],
                                       newVert[2]);
            }
            System.out.println("    out changeMeshSymmetry");
        } // changeMeshSymmetry


        public void init()
        {
            eventVerbose = getParameterInt("EventVerbose", eventVerbose);
            if (eventVerbose >= 1) System.out.println("in init");

            // These (and eventVerbose) can be specified on the command line as, e.g. showLabelsFlag=true
            // TODO: just automatically get any public member
            continuouslyDelaunayizeFlag.set(getParameterBoolean("continuouslyDelaunayizeFlag", continuouslyDelaunayizeFlag.get()));
            optimizeFlag.set(getParameterBoolean("optimizeFlag", optimizeFlag.get()));
            showPositiveOrthantnessVisualizationFlag = getParameterBoolean("showPositiveOrthantnessVisualizationFlag", showPositiveOrthantnessVisualizationFlag);
            // XXX this is kind of messed up, we don't get to know whether the user misspelled something


            graphicsAntiAliasingSetter = new GraphicsAntiAliasingSetter();

            //doCannedThingHexesSpiral();
            //doCannedThingNetless9();
            //doCannedThingEyeball();
            //doCannedThingNetless8();
            //doCannedThingCrackKiller();
            //doCannedThingCrackGoesInSpiral();
            //doCannedThingHexesSpiralOther();
            //doCannedThingNetless8Symmetric();
            doCannedThingNetless8Optimized();
            //doCannedThingSweepKiller0();
            //doCannedThingSweepKiller1();
            //doCannedThingAlgorithm5Killer0();
            //doCannedThingAlgorithm5Killer1();
            //doCannedThingFarthestLagoonExitKiller();
            //doCannedThingFarthestLagoonExitKillerAltB();
            //doCannedThingFarthestLagoonExitKillerOptimized();
            //doBlueNoiseThing(blueNoiseN.get());

            //load("DUMP.off");

            if (false)
                doCannedThingSingleExitLagoonPolygon(
                    singleExitLagoonVirtualN.get(),

                    singleExitLagoonNBeforeApex.get(),
                    singleExitLagoonNAfterApex.get(),
                    singleExitLagoonQuillSlopeNumerator.get(),
                    singleExitLagoonQuillSlopeDenominator.get(),
                    singleExitLagoonNBeforeBeforeApex.get(),
                    singleExitLagoonNAfterAfterApex.get(),
                    singleExitLagoonQuillSlopeNumeratorNumerator.get(),
                    singleExitLagoonQuillSlopeDenominatorDenominator.get(),
                    singleExitLagoonPointApexUpFlag.get(),

                    singleExitLagoonSynthesizeExactDualFlag.get());

            if (eventVerbose >= 1) System.out.println("out init");
        } // init

        public void start()
        {
            if (eventVerbose >= 1) System.out.println("in start");
            if (eventVerbose >= 1) System.out.println("out start");
        }
        public void stop()
        {
            if (eventVerbose >= 1) System.out.println("in stop");
            if (eventVerbose >= 1) System.out.println("out stop");
        }
        public void destroy()
        {
            if (eventVerbose >= 1) System.out.println("in destroy");
            if (eventVerbose >= 1) System.out.println("out destroy");
        }

        //
        // Button behavor changed incompatibly between Java 1.1 and 1.4
        // (not sure exactly what version it changed in though).
        // (I think it was 1.4 since that's when getButton() was added
        // to MouseEvent).
        //
        private static int getButton(java.awt.event.MouseEvent e)
        {
            // gag me! we can't even query the java spec version number
            // since System.getProperty() throws a security exception
            // in netscape!
            // so use empirical evidence...
            int mods = e.getModifiers();
#if 0 // can't seem to get this to work under IE at all, so don't try for now, it will just be wrong under 1.4
            boolean is_1_4_or_greater = ((mods & ~0x1fff) != 0);
            if (is_1_4_or_greater)
            {
                try
                {
                    return e.getButton();
                }
                catch (NoSuchMethodError err)
                {
                    // this only happens in IE, not netscape. fall through...
                }
            }
#endif

            if ((mods & java.awt.event.InputEvent.ALT_MASK) != 0)
                return java_awt_event_MouseEvent_BUTTON2;
            if ((mods & java.awt.event.InputEvent.META_MASK) != 0)
                return java_awt_event_MouseEvent_BUTTON3;
            return java_awt_event_MouseEvent_BUTTON1;
        } // getButton

        private class TheCanvas
            extends JPanel
            implements java.awt.event.MouseListener,
                       java.awt.event.MouseMotionListener,
                       java.awt.event.KeyListener
        {
            TheCanvas()
            {
                // Specify an "event listener" object
                // to respond to events.
                // (>= Java 1.1 event model).
                this.addMouseListener(this);
                this.addMouseMotionListener(this);
                this.addKeyListener(this);
            }

            //
            // MouseListener and MouseMotionListener methods...
            //
            public void mousePressed(java.awt.event.MouseEvent e)
            {
                if (eventVerbose >= 1) System.out.println("in mousePressed: "+e);
                if (eventVerbose >= 1)
                {
                    if (getButton(e) == java_awt_event_MouseEvent_BUTTON1)
                        System.out.println("    (left mouse)");
                    if (getButton(e) == java_awt_event_MouseEvent_BUTTON2)
                        System.out.println("    (middle mouse)");
                    if (getButton(e) == java_awt_event_MouseEvent_BUTTON3)
                        System.out.println("    (right mouse)");
                }

                double thisP[] = new double[2];

                mostRecentGraphics.pick(e.getX()+.5, e.getY()+.5, thisP);
                double thisPeffective[] = thisP;

                double projectedThisPeffective[] = new double[3];
                pickPointOnSurface(thisPeffective, 0., projectedThisPeffective, false);
                mousePressWasBackFacing = false;

                // reset these guys...
                prevP = thisP;
                origP = thisP;
                // and these... may further refine the effective ones below if actually picking a vertex
                prevPeffective = thisPeffective;
                origPeffective = thisPeffective;

                boolean snapToGrid = e.isControlDown();
                double snappedProjectedThisP[] = !snapToGrid ? projectedThisPeffective : new double[] {
                    (double)Math.round(projectedThisPeffective[0]/gridSnapQuantum)*gridSnapQuantum,
                    (double)Math.round(projectedThisPeffective[1]/gridSnapQuantum)*gridSnapQuantum,
                    projectedThisPeffective[2], // we'll fix this in a moment
                };

                if (snapToGrid)
                {
                    if (wrapAroundSphereFlag.get())
                    {
                        // not sure what snapToGrid means when surface is sphere
                    }
                    else
                        snappedProjectedThisP[2] = 0. - .5 * (SQR(snappedProjectedThisP[0]) + SQR(snappedProjectedThisP[1])); // actual
                }

                stateWhenPressed = newUndoItemState();

                int whichButton = getButton(e);

                if (whichButton == java_awt_event_MouseEvent_BUTTON1)
                {
                    button1IsDown = true;

                    if (e.isShiftDown())
                    {
                        //
                        // Add an edge from the closest vertex
                        //
                        System.out.println("    Rubberbanding a new edge from "+snappedProjectedThisP[0]+" "+snappedProjectedThisP[1]+" "+0+"");

                        //
                        // If there are no vertices, add one
                        //
                        ArrayList verts = mesh.verts;
                        if (verts.size() == 0)
                        {
                            System.out.println("        (Adding a vertex first)");
                            mesh.addIsolatedVertex(snappedProjectedThisP[0], snappedProjectedThisP[1], 0);

                            // added something-- invalidate dual mesh
                            dirtyDualMesh();
                            if (continuouslyDelaunayizeFlag.get()) delaunayize();
                        }

                        //
                        // Select closest vertex
                        //
                        beingDraggedVertIndex = mesh.indexOfClosestVert(thisP[0],thisP[1], mostRecentGraphics);
                        Mesh.Vertex vert = mesh.getVert(beingDraggedVertIndex);

                        // figure out whether it's on the front or back of its offset surface.
                        // this is a bit of a hack.
                        {
                            double scratch[] = {vert.x(), vert.y(), vert.z()};
                            mousePressWasBackFacing = pickedPointIsBackFacingOnSurface(scratch);
                            PRINT(mousePressWasBackFacing);
                        }

                        beingDraggedVertUnsnappedXY = new double[]{vert.x(), vert.y()};
                        rubberBandingNewEdge = true;
                    }
                    else // shift is not down
                    {
                        if (showNetFlag.get())
                        {
                            if (e.getX() < thermometerWidth
                             || e.getX() >= theCanvas.getWidth()-thermometerWidth)
                            {
                                thermometerIsLinear ^= true;
                                System.out.println("thermometerIsLinear -> "+thermometerIsLinear);
                            }
                            else
                            {
                                if (theNet._nUndecideds > 0)
                                {
                                    int iEdge = getDualMesh().indexOfClosestEdge(thisP, true);
                                    if (theNet._edgeStatuses[iEdge] == Net.UNDECIDED)
                                    {
                                        theNet.cut(iEdge, true);
                                        if (theNet._nUndecideds == 0)
                                        {
                                            int root = getDualMesh().verts.size();
                                            theNet.chooseDirections(root);
                                        }
                                    }
                                    else
                                    {
                                        System.out.println("BONK!");
                                    }
                                }
                                else
                                {
                                    // begin dragging a net edge or fold
                                    //PRINT(beingDraggedNetEdgeIndex);
                                    beingDraggedNetEdgeIndex = getDualMesh().indexOfClosestEdge(projectedThisPeffective, true); // XXX not right actually... want closest edge in screen space, not doing this paraboloid thing
                                    //PRINT(beingDraggedNetEdgeIndex);
                                    beingDraggedNetEdgeDelta = new double[]{0,0};
                                }
                            }
                            theCanvas.repaint();
                        }
                        else
                        {
                            //
                            // Add a vertex...
                            // but only if not very close to an existing one.
                            //
                            int closestVertIndex = mesh.indexOfClosestVert(thisP[0],thisP[1],mostRecentGraphics);
                            if (closestVertIndex != -1) // if we have a candidate...
                            {
                                // we want to measure the distance
                                // in actual pixels, from the actual
                                // integer pixel coord where the vertex appears.
                                // XXX TODO: this is getting really arcane, need a more straightforward procedure
                                Mesh.Vertex closestVert = mesh.getVert(closestVertIndex);
                                double scratch[] = new double[3];
                                mostRecentGraphics.xform(closestVert.X(), closestVert.Y(), closestVert.Z(), closestVert.W(), scratch);
                                double vertPixelCoords[] = new double[2];
                                mostRecentGraphics.unpick(scratch[0], scratch[1], vertPixelCoords);
                                int maxPixelDist = MAX(ABS(e.getX()-(int)Math.round(vertPixelCoords[0]-.5)),
                                                       ABS(e.getY()-(int)Math.round(vertPixelCoords[1]-.5)));
                                //PRINT(maxPixelDist);
                                if (maxPixelDist > 3*hidpimag)
                                    closestVertIndex = -1; // too far
                            }
                            if (closestVertIndex != -1) // if it wasn't too far
                            {
                                beingDraggedVertIndex = closestVertIndex;
                                System.out.println("Dragging vertex "+beingDraggedVertIndex);
                                Mesh.Vertex beingDraggedVert = mesh.getVert(beingDraggedVertIndex);
                                // figure out whether it's on the front or back of its offset surface.
                                // this is a bit of a hack.
                                {
                                    double scratch[] = {beingDraggedVert.x(), beingDraggedVert.y(), beingDraggedVert.z()};
                                    mousePressWasBackFacing = pickedPointIsBackFacingOnSurface(scratch);
                                    PRINT(mousePressWasBackFacing);
                                }
                                beingDraggedVertUnsnappedXY = new double[]{beingDraggedVert.x(), beingDraggedVert.y()};

                                Mesh.Vertex closestVert = mesh.getVert(closestVertIndex);
                                double scratch[] = new double[3];
                                mostRecentGraphics.xform(closestVert.X(), closestVert.Y(), closestVert.Z(), closestVert.W(), scratch);
                                thisPeffective = (double[])Arrays.subarray(scratch, 0, 2);
                                origPeffective = thisPeffective;
                                prevPeffective = thisPeffective;


                                if (snapToGrid)
                                {
                                    double unsnappedCoords[] = {beingDraggedVert.x(), beingDraggedVert.y()};
                                    double snappedCoords[] = {(double)Math.round(beingDraggedVert.x()/gridSnapQuantum)*gridSnapQuantum,
                                                              (double)Math.round(beingDraggedVert.y()/gridSnapQuantum)*gridSnapQuantum};
                                    double group[][][] = getTheSymmetryGroup();
                                    int nVerts = mesh.verts.size();
                                    FORI (iGroup, group.length)
                                    {
                                        double unsnappedImage[] = VecMath.vxm(unsnappedCoords,group[iGroup]);
                                        FORI (iVert, nVerts)
                                        {
                                            Mesh.Vertex vertI = mesh.getVert(iVert);
                                            if (EQ(unsnappedImage[0], vertI.x(), 1e-6)
                                             && EQ(unsnappedImage[1], vertI.y(), 1e-6))
                                            {
                                                double snappedImage[] = VecMath.vxm(snappedCoords,group[iGroup]);
                                                System.out.println("Snapping vertex "+iVert+" from "+vertI.x()+" "+vertI.y()+" "+vertI.h()+"");
                                                vertI.setxyh(snappedImage[0],
                                                             snappedImage[1],
                                                             vertI.h());
                                                System.out.println("Dragging vertex "+iVert+" from "+vertI.x()+" "+vertI.y()+" "+vertI.h()+"");
                                            }
                                        }
                                    }

                                    if (continuouslyDelaunayizeFlag.get()) delaunayize();
                                }
                            }
                            else // closest was too far-- add a new vert
                            {
                                double vertsToAdd[][] = {snappedProjectedThisP};

                                if (pRotationalSymmetry.get() > 1
                                 || qRotationalSymmetry.get() > 1
                                 || leftRightSymmetry.get()
                                 || centralSymmetry.get())
                                {
                                    double gens[][][] = getTheSymmetryGroupGenerators();
                                    vertsToAdd = generateVertices(vertsToAdd, gens);
                                }

                                // we add them in reverse order, so that the original one
                                // will be the last one added, so that it will be the one to be dragged
                                FORIDOWN (iVertToAdd, vertsToAdd.length)
                                {
                                    double vertToAdd[] = vertsToAdd[iVertToAdd];
                                    double x = vertToAdd[0];
                                    double y = vertToAdd[1];
                                    double z = vertToAdd[2];

                                    System.out.println("    Adding vertex "+mesh.verts.size()+" at "+x+" "+y+" "+0+"");
                                    if (wrapAroundSphereFlag.get())
                                        mesh.addIsolatedVertex(x, y, z, 1.);
                                    else
                                        mesh.addIsolatedVertex(x, y, 0);

                                    //PRINT(vertOffset(mesh.getVert(mesh.verts.size()-1), wrapAroundSphereFlag.get()));
                                    assert(EQ(vertOffset(mesh.getVert(mesh.verts.size()-1), wrapAroundSphereFlag.get()), 0., 1e-6));

                                    ArrayList verts = mesh.verts;
                                    ArrayList edges = mesh.edges;
                                    if (verts.size() >= 2)
                                    {
                                        //
                                        // If are no edges at all, add an edge.
                                        // XXX this is kind of lame when there were more than one isolated vertex, should connect to them all
                                        //
                                        if (edges.size() == 0)
                                        {
                                            System.out.println("Adding an edge between two verts");
                                            mesh.addEdgeBetweenTwoIsolatedVertices((Mesh.Vertex)verts.get(verts.size()-2),
                                                                                   (Mesh.Vertex)verts.get(verts.size()-1));
                                        }
                                        else // edges.size() >= 1
                                        {
                                            // There was already at least one edge.
                                            // Find out which face we are on
                                            // (all triangles CCW), and kis that face.
                                            // if we are not inside any face by that criterion,
                                            // then assume we are inside the outer face
                                            // and connect the new vertex to every vertex
                                            // that's visible from it.
                                            //
                                            boolean kissed = false;
                                            double twiceMostNegativeFaceArea = Double.POSITIVE_INFINITY;
                                            Mesh.Edge edgeOnMostNegativeFace = null;
                                            // XXX traverses each face of size n n times!  need to keep track of what we've done already
                                            int nEdges = mesh.edges.size();
                                            FORI (iEdge, nEdges)
                                            {
                                                boolean thisFaceIsGoodSoFar = true;
                                                Mesh.Edge edgeI = mesh.getEdge(iEdge);
                                                double twiceThisFaceArea = 0.;
                                                for (Mesh.Edge edge = edgeI;;)
                                                {
                                                    double twiceThisTriArea = twiceTriangleArea(
                                                                            x, y,
                                                                            edge.initialVertex().x(),
                                                                            edge.initialVertex().y(),
                                                                            edge.finalVertex().x(),
                                                                            edge.finalVertex().y());
                                                    if (twiceThisTriArea < 0)
                                                    {
                                                        thisFaceIsGoodSoFar = false; // it's bad!
                                                    }
                                                    twiceThisFaceArea += twiceThisTriArea;

                                                    if ((edge = edge.next()) == edgeI)
                                                        break;
                                                }
                                                if (thisFaceIsGoodSoFar)
                                                {
                                                    // I'm inside this face;
                                                    // kis it and done
                                                    mesh.kisIsolatedVertex((Mesh.Vertex)verts.get(verts.size()-1),
                                                                           edgeI);
                                                    kissed = true;
                                                    break;
                                                }
                                                if (twiceThisFaceArea < twiceMostNegativeFaceArea)
                                                {
                                                    twiceMostNegativeFaceArea = twiceThisFaceArea;
                                                    edgeOnMostNegativeFace = edgeI;
                                                }
                                            }
                                            if (!kissed)
                                            {
                                                System.out.println("In the outer face");
                                                //
                                                // It wasn't inside any face.
                                                // Assume it's in the outer face.
                                                // In this case,
                                                // make a kiss to the outer face
                                                // and then delete all newly added edges
                                                // that cross the boundary of the outer face.
                                                //

                                                ArrayList/*<Mesh.Edge>*/ oldOuterFaceBoundary = new ArrayList();
                                                for (Mesh.Edge edge = edgeOnMostNegativeFace;;)
                                                {
                                                    oldOuterFaceBoundary.add(edge);
                                                    if ((edge = edge.next()) == edgeOnMostNegativeFace)
                                                        break;
                                                }
                                                int oldOuterFaceBoundarySize = oldOuterFaceBoundary.size();

                                                int oldNumEdges = mesh.edges.size();
                                                mesh.kisIsolatedVertex((Mesh.Vertex)verts.get(verts.size()-1),
                                                                       edgeOnMostNegativeFace);
                                                if (!showInsideOutDualVertsFlag.get())
                                                {
                                                    for (int iEdge = oldNumEdges;
                                                         iEdge < mesh.edges.size();
                                                         iEdge += 2) // only do one of an edge and its opposite
                                                    {
                                                        for (int iOldBoundaryEdge = 0;
                                                             iOldBoundaryEdge < oldOuterFaceBoundarySize;
                                                             ++iOldBoundaryEdge)
                                                        {
                                                            Mesh.Edge oldEdge = (Mesh.Edge)oldOuterFaceBoundary.get(iOldBoundaryEdge);
                                                            Mesh.Edge newEdge = mesh.getEdge(iEdge);

                                                            if (newEdge.initialVertex() == oldEdge.initialVertex()
                                                             || newEdge.initialVertex() == oldEdge.finalVertex()
                                                             || newEdge.finalVertex() == oldEdge.initialVertex()
                                                             || newEdge.finalVertex() == oldEdge.finalVertex())
                                                                continue;
                                                            //System.out.println("    Seeing whether new edge v"+newEdge.initialVertex().myIndex()+" -> v"+newEdge.finalVertex().myIndex()+" crosses old boundary edges v"+oldEdge.initialVertex().myIndex()+" -> v"+oldEdge.finalVertex().myIndex()+"");
                                                            if (edgesCrossOrCloseToIt(
                                                                            oldEdge.initialVertex().x(),
                                                                            oldEdge.initialVertex().y(),
                                                                            oldEdge.finalVertex().x(),
                                                                            oldEdge.finalVertex().y(),
                                                                            newEdge.initialVertex().x(),
                                                                            newEdge.initialVertex().y(),
                                                                            newEdge.finalVertex().x(),
                                                                            newEdge.finalVertex().y(),
                                                                            1e-6))
                                                            {
                                                                //System.out.println("        It does.");
                                                                mesh.deleteEdge(newEdge);
                                                                iEdge -= 2; // so we don't skip the one that gets moved into the deleted spot
                                                                break;
                                                            }
                                                            else
                                                            {
                                                                //System.out.println("        It doesn't.");
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        } // if verts.length >= 3
                                    } // if verts.size() >= 2 after adding the new vertex

                                    mesh.sanityCheck();

                                    beingDraggedVertIndex = verts.size()-1; // start dragging the one we just added
                                    // XXX not sure the following is right, since it's already been snapped, right? or has it?
                                    beingDraggedVertUnsnappedXY = new double[]{vertsToAdd[0][0],
                                                                               vertsToAdd[0][1]};
                                }

                                // added something-- invalidate dual mesh
                                dirtyDualMesh();
                                if (continuouslyDelaunayizeFlag.get()) delaunayize();
                            }
                        } // !showNetFlag
                    } // shift not down

                }
                else if (whichButton == java_awt_event_MouseEvent_BUTTON2)
                {
                    button2IsDown = true;

                    if (e.isShiftDown())
                    {
                        // Drag all verts (XXX need different way of expressing this I think, now that middle button being used for rotate)
                        beingDraggedVertIndex = mesh.indexOfClosestVert(thisP[0],thisP[1],mostRecentGraphics);
                        if (beingDraggedVertIndex == -1)
                            System.out.println("Dragging vertex "+beingDraggedVertIndex);
                        else
                        {
                            if (snapToGrid)
                            {
                                // Snap all the vertices we're about to drag
                                // XXX need to store unsnapped for all of them!
                                FORIDOWN (iVert, mesh.verts.size())
                                {
                                    Mesh.Vertex vert = mesh.getVert(iVert);
                                    vert.setxyh((double)Math.round(vert.x()/gridSnapQuantum)*gridSnapQuantum,
                                                (double)Math.round(vert.y()/gridSnapQuantum)*gridSnapQuantum,
                                                vert.h());
                                }
                                if (continuouslyDelaunayizeFlag.get()) delaunayize();
                            }
                        }
                    }
                    else
                    {
                        if (eventVerbose >= 1) System.out.println("setting draggingRotation=true on BUTTON2 down");
                        draggingRotation = true;
                    }
                }
                else if (whichButton == java_awt_event_MouseEvent_BUTTON3)
                {
                    button3IsDown = true;

                    if (showNetFlag.get())
                    {
                        int iEdge = getDualMesh().indexOfClosestEdge(thisP, true);
                        if (theNet._edgeStatuses[iEdge] == Net.CUT)
                        {
                            theNet.uncut(iEdge);
                            beingDraggedNetEdgeIndex = -1;
                        }
                        else
                        {
                            System.out.println("BONK!");
                        }
                    }
                    else
                    {
                        int nVertsToDelete = e.isShiftDown() ? 10 : 1;
                        FORI (iiVertToDelete, nVertsToDelete)
                        {
                            //
                            // Delete closest vertex,
                            // and all its reflections and rotations in the symmetry group
                            //
                            beingDraggedVertIndex = mesh.indexOfClosestVert(thisP[0],thisP[1],mostRecentGraphics);
                            PRINT(beingDraggedVertIndex);
                            int oldToNew[] = VecMath.identityperm(mesh.verts.size());
                            int newToOld[] = VecMath.identityperm(mesh.verts.size());
                            if (beingDraggedVertIndex != -1)
                            {
                                Mesh.Vertex beingDraggedVert = mesh.getVert(beingDraggedVertIndex);
                                double v[] = {beingDraggedVert.x(), beingDraggedVert.y(), beingDraggedVert.z()};
                                double group[][][] = getTheSymmetryGroup();
                                Mesh.Vertex vertsToDelete[] = findAllVertsThatAreImages(mesh, v, group, 1e-6);
                                FORI (iVertToDelete, vertsToDelete.length)
                                    mesh.deleteVertex(vertsToDelete[iVertToDelete], oldToNew, newToOld);
                            }
                            beingDraggedVertIndex = -1;

                            // re-index selectedTris and invalidate selectedDualVertIndices
                            if (!allDualVertsAreSelected)
                            {
                                selectedDualVertIndices = new int[] {}; // TODO: maybe shouldn't even be a member var, it's too volatile
                                // re-index selectedTris using oldToNew.
                                // indices of verts that disappeared will turn into -1.

                                //Arrays.getMany(selectedTris, oldToNew, selectedTris); // TODO: use this when it exists
                                selectedTris = (int[][])Arrays.getMany(oldToNew, selectedTris);
                            }

                            // deleted something-- invalidate dual mesh
                            dirtyDualMesh();

                            mesh.sanityCheck();

                            if (continuouslyDelaunayizeFlag.get()) delaunayize();
                        }
                    }

                } // right mouse


                theCanvas.repaint();

                if (eventVerbose >= 1) System.out.println("out mousePressed: "+e);
            } // mousePressed
            public void mouseReleased(java.awt.event.MouseEvent e)
            {
                if (eventVerbose >= 1) System.out.println("in mouseReleased: "+e);

                double thisP[] = new double[2];
                mostRecentGraphics.pick(e.getX()+.5, e.getY()+.5, thisP);
                double thisPeffective[] = VecMath.vpvmv(thisP,origPeffective,origP);
                double projectedThisPeffective[] = new double[3];
                pickPointOnSurface(thisPeffective, 0., projectedThisPeffective, mousePressWasBackFacing);
                boolean snapToGrid = e.isControlDown();
                double snappedProjectedThisPeffective[] = !snapToGrid ? projectedThisPeffective : new double[] {
                    (double)Math.round(projectedThisPeffective[0]/gridSnapQuantum)*gridSnapQuantum,
                    (double)Math.round(projectedThisPeffective[1]/gridSnapQuantum)*gridSnapQuantum,
                    0., // we'll fix this in a moment
                };
                // XXX TODO: this doesn't seem right... if not snapToGrid, then we're modifying projectedThisPeffective.  confused
                snappedProjectedThisPeffective[2] = 0. - .5 * (SQR(snappedProjectedThisPeffective[0]) + SQR(snappedProjectedThisPeffective[1]));

                int whichButton = getButton(e);
                if (whichButton == java_awt_event_MouseEvent_BUTTON1)
                {
                    if (rubberBandingNewEdge)
                    {
                        if (mesh.verts.size() == 1)
                        {
                            System.out.println("    Adding vertex "+mesh.verts.size()+" at "+snappedProjectedThisPeffective[0]+" "+snappedProjectedThisPeffective[1]+" "+0+"");
                            mesh.addIsolatedVertex(snappedProjectedThisPeffective[0], snappedProjectedThisPeffective[1], 0);
                        }
                        int finalVertIndex = mesh.indexOfClosestVert(thisP[0],thisP[1],mostRecentGraphics);
                        if (beingDraggedVertIndex != -1
                         && finalVertIndex != -1
                         && beingDraggedVertIndex != finalVertIndex)
                        {
                            System.out.println("Trying to add an edge between "+beingDraggedVertIndex+" and "+finalVertIndex);
                            ArrayList verts = mesh.verts;
                            mesh.addEdgeBetweenTwoVertices(mesh.getVert(beingDraggedVertIndex),
                                                           mesh.getVert(finalVertIndex));
                            mesh.sanityCheck();
                            PRINT(mesh.edges.size());

                            // added something-- invalidate dual mesh
                            dirtyDualMesh();
                        }
                        if (continuouslyDelaunayizeFlag.get()) delaunayize();
                    }
                    rubberBandingNewEdge = false;

                    if (beingDraggedNetEdgeIndex != -1
                     && showNetFlag.get())
                    {
                        Mesh dualMesh = getDualMesh();
                        int targetEdgeIndex = dualMesh.indexOfClosestEdge(projectedThisPeffective, true); // XXX not really right, see similar comment on mouse down
                        if (targetEdgeIndex != -1
                         && targetEdgeIndex != beingDraggedNetEdgeIndex
                         && dualMesh.getEdge(targetEdgeIndex).opposite().myIndex() != beingDraggedNetEdgeIndex)
                        {
                            // Make sure it's a valid alternative.
                            // (could do this once on mouse down,
                            // but whatever, it's O(n) which is fine here)
                            Mesh.Edge alternatives[] = theNet.alternatives(beingDraggedNetEdgeIndex);
                            if (Arrays.indexOfUsingEqualsSymbol(alternatives, dualMesh.getEdge(targetEdgeIndex)) != -1
                             || Arrays.indexOfUsingEqualsSymbol(alternatives, dualMesh.getEdge(targetEdgeIndex).opposite()) != -1)
                            {
                                theNet.swapCutAndFold(beingDraggedNetEdgeIndex,
                                                      targetEdgeIndex);
                            }
                            else
                            {
                                System.out.println("BONK!");
                            }
                        }
                    }

                    beingDraggedVertIndex = -1;
                    beingDraggedNetEdgeIndex = -1;


                    // HACK to get around stuck isDragging when alt is released before left mouse button,
                    // when simulating middle with alt-left.
                    // This is actually wrong on a 3-button system... I think?  Confusing
                    if (draggingRotation && (e.getModifiers() & java.awt.event.InputEvent.BUTTON2_MASK) == 0)
                    {
                        if (eventVerbose >= 1) System.out.println("setting draggingRotation=false on BUTTON1 up!!");
                        draggingRotation = false;
                    }

                    button1IsDown = false;
                }
                else if (whichButton == java_awt_event_MouseEvent_BUTTON2)
                {
                    beingDraggedVertIndex = -1;
                    beingDraggedNetEdgeIndex = -1;
                    if (eventVerbose >= 1) System.out.println("setting draggingRotation=false on BUTTON2 up");
                    draggingRotation = false;

                    button2IsDown = false;
                }
                else if (whichButton == java_awt_event_MouseEvent_BUTTON3)
                {
                    button3IsDown = false;
                }

                if (stateWhenPressed != null)
                {
                    UndoItem.State stateWhenReleased = newUndoItemState();
                    undoTreeSquirrel.Do(new UndoItem(stateWhenPressed, stateWhenReleased));
                    stateWhenPressed = null;
                }

                prevP = thisP;

                theCanvas.repaint();

                if (eventVerbose >= 1) System.out.println("out mouseReleased: "+e);
            }
            public void mouseEntered(java.awt.event.MouseEvent e)
            {
                if (eventVerbose >= 1) System.out.println("in mouseEntered: "+e);
                // Steal keyboard focus, so user doesn't need to click first.
                // I think the state of things is:
                //      - Buttons and TextFields are apparently "focus traversable"
                //        by default.  Canvases and Applets aren't,
                //        implying (not obvious) that you need to click to type
                //        when the app starts,
                requestFocus(); // hey it works! (javac 1.3, runtime 1.6) so overriding isFocusTraversable() no longer necessary
                if (eventVerbose >= 1) System.out.println("out mouseEntered: "+e);
            }
            public void mouseExited(java.awt.event.MouseEvent e)
            {
                if (eventVerbose >= 1) System.out.println("in mouseExited: "+e);
                if (eventVerbose >= 1) System.out.println("out mouseExited: "+e);
            }
            public void mouseClicked(java.awt.event.MouseEvent e)
            {
                if (eventVerbose >= 1) System.out.println("in mouseClicked: "+e);
                if (eventVerbose >= 1) System.out.println("out mouseClicked: "+e);
            }
            public void mouseDragged(java.awt.event.MouseEvent e)
            {
                if (eventVerbose >= 2) System.out.println("  in mouseDragged: "+e);

                boolean snapToGrid = e.isControlDown();
                double thisP[] = new double[2];
                mostRecentGraphics.pick(e.getX()+.5, e.getY()+.5, thisP);
                double thisPeffective[] = VecMath.vpvmv(thisP,origPeffective,origP);

                if (draggingRotation)
                {
                    // increment tilt according to deltaY,
                    // and twirl according to deltaX
                    double deltaX = thisP[0]-prevP[0];
                    double deltaY = thisP[1]-prevP[1];

                    // too slow unless we multiply it by something!
                    deltaX *= 5.;
                    deltaY *= 5.;

                    // so we ignore pure x jiggle when tilt is maxed...
                    if (!(tilt <= 0. && deltaY <= 0.)
                     && !(tilt >= Math.PI && deltaY >= 0))
                        twirl += deltaX;
                    tilt += deltaY;

                    while (twirl < -Math.PI) twirl += 2*Math.PI;
                    while (twirl >  Math.PI) twirl -= 2*Math.PI;

                    // any excess tilt is turned into twirl towards zero,
                    // making it park at tilt=0, twirl=0
                    if (tilt < 0.)
                    {
                        if (twirl < 0.)
                            twirl = MIN(twirl + -tilt, 0.);
                        else
                            twirl = MAX(twirl - -tilt, 0.);
                        tilt = 0.;
                    }
                    else if (tilt > Math.PI)
                    {
                        if (twirl < 0.)
                            twirl = MIN(twirl + (tilt-Math.PI), 0.);
                        else
                            twirl = MAX(twirl - (tilt-Math.PI), 0.);
                        tilt = Math.PI;
                    }

                    if (true)
                    {

                        // tweak the scale part:
                        // make it so if the z axis didn't rotate much, z scale is 0.
                        // this is so that all the perpendiculars and stuff will look right
                        // when looking at it top-down.
                        double limitDegrees = 10.;
                        if (tilt < DTOR(limitDegrees))
                        {
                            localScaleZ = tilt / DTOR(limitDegrees);
                            //OUT("flattish");
                        }
                        else
                        {
                            localScaleZ = 1.;
                            //OUT("bumpy");
                        }
                    }
                }

                if (button1IsDown || button2IsDown) // XXX wean away from the button2IsDown thing
                {
                    if (rubberBandingNewEdge)
                    {
                        if (snapToGrid)
                        {
                            double projectedThisPeffective[] = new double[3];
                            pickPointOnSurface(thisPeffective, 0., projectedThisPeffective, mousePressWasBackFacing);
                            double snappedProjectedThisPeffective[] = !snapToGrid ? projectedThisPeffective : new double[] {
                                (double)Math.round(projectedThisPeffective[0]/gridSnapQuantum)*gridSnapQuantum,
                                (double)Math.round(projectedThisPeffective[1]/gridSnapQuantum)*gridSnapQuantum,
                                0., // we'll fix this in a moment
                            };
                            projectedThisPeffective = null; // done with it, transferred ownership
                            snappedProjectedThisPeffective[2] = 0. - .5 * (SQR(snappedProjectedThisPeffective[0]) + SQR(snappedProjectedThisPeffective[1]));

                            // now what??? project back to screen and set prevP to it.
                            // argh, but then it will get clobbered at the bottom.
                            // oh, set *thisP* to it, so prevP will get set to that! hacky

                            double scratch[] = new double[3];
                            mostRecentGraphics.xform(snappedProjectedThisPeffective[0],
                                                     snappedProjectedThisPeffective[1],
                                                     snappedProjectedThisPeffective[2],
                                                     1.,
                                                     scratch);
                            VecMath.copyvec(2, thisP, scratch);
                        }
                    }
                    else
                    {
                        if (beingDraggedNetEdgeIndex != -1)
                        {
                            // XXX not really right... see similar comment on mouse down
                            double projectedThisPeffective[] = new double[3];
                            pickPointOnSurface(thisP, 0., projectedThisPeffective, mousePressWasBackFacing);
                            double projectedPrevP[] = new double[3];
                            pickPointOnSurface(prevP, 0., projectedPrevP, mousePressWasBackFacing);

                            beingDraggedNetEdgeDelta[0] += projectedThisPeffective[0]-projectedPrevP[0]; // no snap to grid for this
                            beingDraggedNetEdgeDelta[1] += projectedThisPeffective[1]-projectedPrevP[1]; // no snap to grid for this
                        }
                        else if (e.isShiftDown())
                        {
                            // Drag all the verts and dual verts.
                            // No need to invalidate anything.
                            FORIDOWN (iVert, mesh.verts.size())
                            {
                                Mesh.Vertex vert = mesh.getVert(iVert);
                                vert.setxyh(vert.x() + thisP[0]-prevP[0],
                                            vert.y() + thisP[1]-prevP[1],
                                            vert.h());
                            }
                            Mesh dualMesh = getDualMesh();
                            FORIDOWN (iDualVert, dualMesh.verts.size())
                            {
                                Mesh.Vertex dualVert = dualMesh.getVert(iDualVert);
                                dualVert.setxyh(dualVert.x() + thisP[0]-prevP[0],
                                                dualVert.y() + thisP[1]-prevP[1],
                                                dualVert.h());
                                double momentAndArea[] = dualVert.momentAndArea;
                                assert(momentAndArea.length == 4);
                                momentAndArea[0] += (thisP[0]-prevP[0]) * momentAndArea[3];
                                momentAndArea[1] += (thisP[1]-prevP[1]) * momentAndArea[3];
                                // height doesn't change
                            }
                        }
                        else if (beingDraggedVertIndex != -1)
                        {
                            Mesh.Vertex beingDraggedVert = mesh.getVert(beingDraggedVertIndex);
                            double offset = vertOffset(beingDraggedVert, wrapAroundSphereFlag.get()); // XXX TODO: should just snapshot this on mouse down... MAYBE. but keep in mind, user can change offset while dragging, with arrow keys

                            /*
                                All right, how should this look?
                                    1. Find closest vert, in pixels, to the mouse cursor (already found, since dragging)
                                    2. determine its surface offset and whether it's front-facing or back-facing
                                    3. project it to screen space
                                    4. apply delta to it in screen space
                                    5. project screen point to offset surface at same height as before to get new position,
                                       with same facing (or opposite facing if ray misses surface)
                                    6. if paraboloid, snap x,y part to grid but retain same offset (height above paraboloid)
                                    7. for any symmetry images, do same thing to them

                                Spaces:
                                    pixel space   (mouse coords in this space)
                                        most recent graphics mat
                                    eye space (same as world space I think)
                                    world space
                                        localToWorld
                                    vert local space
                                    homogeneous vert space
                            */
                            double beingDraggedVertNewCoords[] = new double[3];
                            pickPointOnSurface(thisPeffective, offset, beingDraggedVertNewCoords, mousePressWasBackFacing);
                            beingDraggedVertNewCoords = (double[])Arrays.append(beingDraggedVertNewCoords, 1.); // TODO: just make this homogeneous throughout

                            beingDraggedVertUnsnappedXY = new double[] {beingDraggedVertNewCoords[0],beingDraggedVertNewCoords[1]};

                            double beingDraggedVertNewCoordsSnapped[] = !snapToGrid ? beingDraggedVertNewCoords : new double[] {
                                (double)Math.round(beingDraggedVertNewCoords[0]/gridSnapQuantum)*gridSnapQuantum,
                                (double)Math.round(beingDraggedVertNewCoords[1]/gridSnapQuantum)*gridSnapQuantum,
                                beingDraggedVertNewCoords[2], // we'll fix this in a moment
                                1.,
                            };
                            beingDraggedVertNewCoords = null; // done with it, transferred ownership
                            if (snapToGrid)
                                beingDraggedVertNewCoordsSnapped[2] -= .5 * (SQR(beingDraggedVertNewCoordsSnapped[0]) + SQR(beingDraggedVertNewCoordsSnapped[1]));

                            // we're going to change the position of beingDraggedVert
                            // to beingDraggedVertNewCoordsSnapped.

                            if (pRotationalSymmetry.get() > 1
                             || qRotationalSymmetry.get() > 1
                             || leftRightSymmetry.get()
                             || centralSymmetry.get())
                            {
                                double beingDraggedVertOldCoords[] = {beingDraggedVert.x(),
                                                                      beingDraggedVert.y(),
                                                                      beingDraggedVert.z(),
                                                                      1.};
                                // Drag all points of kaleidoscope.
                                //
                                // If any other verts are images of beingDraggedVert in the kaleidescope,
                                // the new position of that vert should be the new position
                                // of beingDraggedVert, with the same symmetry applied.
                                // In cases when another vertex (or beingDraggedVert itself)
                                // is an image under more than one symmetry (i.e. when exactly on a mirror),
                                // we average the images under each of the symmetries.
                                //
                                double group[][][] = getTheSymmetryGroup();

                                int nVerts = mesh.verts.size();
                                double newVertexPositionSums[][] = new double[nVerts][]; // all null initially
                                int newVertexPositionWeights[] = new int[nVerts]; // all zeros initially
                                double scratch[] = new double[4];

                                FORI (iGroup, group.length)
                                {
                                    double oldImage[] = VecMath.vxm(beingDraggedVertOldCoords, group[iGroup]);
                                    VecMath.normalize(oldImage, oldImage);
                                    double newImage[] = null; // calculated on demand the first time it's needed below
                                    FORI (iVert, nVerts)
                                    {
                                        Mesh.Vertex vert = mesh.getVert(iVert);
                                        scratch[0] = vert.X();
                                        scratch[1] = vert.Y();
                                        scratch[2] = vert.Z();
                                        scratch[3] = vert.W();
                                        VecMath.normalize(scratch, scratch);
                                        if (EQ(oldImage[0], scratch[0], 1e-6)
                                         && EQ(oldImage[1], scratch[1], 1e-6)
                                         && EQ(oldImage[2], scratch[2], 1e-6)
                                         && EQ(oldImage[3], scratch[3], 1e-6))
                                        {
                                            if (newImage == null)
                                                newImage = VecMath.vxm(beingDraggedVertNewCoordsSnapped, group[iGroup]);
                                            if (newVertexPositionSums[iVert] == null)
                                                newVertexPositionSums[iVert] = new double[4]; // zeros
                                            // XXX TODO: wow this is totally wrong now, can't just add in homogeneous space
                                            assert(newImage.length == 4);
                                            assert(newVertexPositionSums[iVert].length == 4);
                                            VecMath.vpv(newVertexPositionSums[iVert],
                                                        newVertexPositionSums[iVert],
                                                        newImage);
                                            newVertexPositionWeights[iVert]++;
                                        }
                                    }
                                }
                                FORI (iVert, nVerts)
                                {
                                    int weight = newVertexPositionWeights[iVert];
                                    if (weight != 0)
                                    {
                                        double newCoords[] = scratch;
                                        VecMath.vxs(newCoords, newVertexPositionSums[iVert], 1./weight);
                                        Mesh.Vertex vert = mesh.getVert(iVert);
                                        if (wrapAroundSphereFlag.get())
                                        {
                                            vert.setXYZW(newCoords[0],
                                                         newCoords[1],
                                                         newCoords[2],
                                                         newCoords[3]);
                                        }
                                        else
                                        {
                                            // on paraboloid; h doesn't change, and more accurate if we use the old h
                                            vert.setxyh(newCoords[0]/newCoords[3],
                                                        newCoords[1]/newCoords[3],
                                                        vert.h());
                                        }
                                    }
                                }
                            }
                            else // no non-identity symmetries, just the vert
                            {
                                if (wrapAroundSphereFlag.get())
                                {
                                    beingDraggedVert.setXYZW(beingDraggedVertNewCoordsSnapped[0],
                                                             beingDraggedVertNewCoordsSnapped[1],
                                                             beingDraggedVertNewCoordsSnapped[2],
                                                             beingDraggedVertNewCoordsSnapped[3]);
                                }
                                else
                                {
                                    // on paraboloid; h doesn't change
                                    beingDraggedVert.setxyh(beingDraggedVertNewCoordsSnapped[0]/beingDraggedVertNewCoordsSnapped[3],
                                                            beingDraggedVertNewCoordsSnapped[1]/beingDraggedVertNewCoordsSnapped[3],
                                                            beingDraggedVert.h());
                                }
                            }

                            if (continuouslyDelaunayizeFlag.get()) delaunayize();
                            if (nonEventVerbose >= 1)
                            {
                                double verts[][] = new double[mesh.verts.size()][];
                                FORIDOWN (iVert, mesh.verts.size())
                                    verts[iVert] = new double[] {mesh.getVert(iVert).x(),
                                                                 mesh.getVert(iVert).y(),
                                                                 mesh.getVert(iVert).h()};
                                int edges[][] = new int[mesh.edges.size()][];
                                FORIDOWN (iEdge, mesh.edges.size())
                                    edges[iEdge] = new int[] {(mesh.getEdge(iEdge)).initialVertex().myIndex(),
                                                              (mesh.getEdge(iEdge)).finalVertex().myIndex()};
                                PRINTARRAY(verts);
                                PRINTARRAY(edges);
                            }
                            // moved something-- invalidate dual mesh XXX could retain structure and just update positions and angles?? then wouldn't have to invalidate net!
                            dirtyDualMesh();
                        }
                    }
                }

                if (button3IsDown) // right mouse
                {
                }

                theCanvas.repaint();

                prevP = thisP;
                prevPeffective = thisPeffective;

                if (eventVerbose >= 2) System.out.println("  out mouseDragged: "+e);
            } // mouseDragged
            public void mouseMoved(java.awt.event.MouseEvent e)
            {
                if (eventVerbose >= 3) System.out.println("    in mouseMoved: "+e);

                if (mostRecentGraphics != null)
                {
                    double thisP[] = new double[2];
                    mostRecentGraphics.pick(e.getX()+.5, e.getY()+.5, thisP);
                    if (showNetFlag.get())
                    {
                        int closestDualEdgeIndex = getDualMesh().indexOfClosestEdge(thisP, true);
                        if (closestDualEdgeIndex != highlightedDualEdgeIndex)
                        {
                            //System.out.println("    closest dual edge changed: "+getDualMesh().getEdge(closestDualEdgeIndex));
                            highlightedDualEdgeIndex = closestDualEdgeIndex;
                            theCanvas.repaint();
                        }
                    }
                    prevP = thisP;

                    if (showMagFlag.get())
                        theCanvas.repaint();

                    if (primalDualVisFlag.get()
                     && primalDualVisAngles != null
                     && primalDualVisPrimalVertInds != null
                     && primalDualVisDualVertInds != null)
                        theCanvas.repaint();
                }

                if (eventVerbose >= 3) System.out.println("    out mouseMoved: "+e);
            } // mouseMoved

            //
            // KeyListener methods...
            //
            public void keyPressed(java.awt.event.KeyEvent e)
            {
                if (eventVerbose >= 1) System.out.println("in keyPressed: "+e);
                double incr = .005;
                if (e.isShiftDown())
                    incr *= 10.;
                else if (e.isControlDown())
                    incr /= 10.;
                int keyCode = e.getKeyCode();
                switch(keyCode)
                {
                    case java.awt.event.KeyEvent.VK_UP:
                    {
                        UndoItem.State before = newUndoItemState();
                        if (optimizeFlag.get())
                        {
                            optimizeFlag.set(false);
                            System.out.println("optimizeFlag -> "+optimizeFlag.get()+" ('O' to turn back on)");
                        }
                        System.out.print("Up");
                        System.out.flush();
                        int iVert = mesh.indexOfClosestVert(prevP[0], prevP[1],mostRecentGraphics);
                        if (iVert != -1)
                        {
                            Mesh.Vertex vertI = mesh.getVert(iVert);
                            double v[] = {vertI.x(), vertI.y(), vertI.z()};
                            double group[][][] = getTheSymmetryGroup();
                            Mesh.Vertex vertsToMove[] = findAllVertsThatAreImages(mesh, v, group, 1e-6);

                            // only used in wrapAroundSphere case
                            boolean wrapAroundSphereFlagValue = wrapAroundSphereFlag.get();

                            if (wrapAroundSphereFlag.get())
                            {
                                double sphereCenterZ = (centerSphereFlag.get() ? 0. : -1./wrapSphereCurvature.get());
                                FORI (iVertToMove, vertsToMove.length)
                                {
                                    Mesh.Vertex vert = vertsToMove[iVertToMove];
                                    v[0] = vert.x();
                                    v[1] = vert.y();
                                    v[2] = vert.z() - sphereCenterZ;
                                    double oldR = Math.sqrt(SQR(v[0])+SQR(v[1])+SQR(v[2]));
                                    double newR = oldR - incr;
                                    double scale = newR / oldR;
                                    vert.setXYZW(v[0]*scale, v[1]*scale, v[2]*scale + sphereCenterZ, 1.);
                                }
                            }
                            else
                            {
                                FORI (iVertToMove, vertsToMove.length)
                                {
                                    Mesh.Vertex vert = vertsToMove[iVertToMove];
                                    // pull the dual face *out* of the screen,
                                    // i.e. increase its height,
                                    // i.e. decrease height of primal vert.
                                    vert.setxyh(vert.x(),
                                                vert.y(),
                                                vert.h() - incr);
                                    System.out.println("    verts["+vert.myIndex()+"].Hnaive() -> "+vert.Hnaive());
                                }
                            }
                            if (continuouslyDelaunayizeFlag.get()) delaunayize();
                        }
                        UndoItem.State after = newUndoItemState();
                        undoTreeSquirrel.Do(new UndoItem(before, after));
                        dirtyDualMesh();
                        theCanvas.repaint();
                        break;
                    }
                    case java.awt.event.KeyEvent.VK_DOWN:
                    {
                        UndoItem.State before = newUndoItemState();
                        if (optimizeFlag.get())
                        {
                            optimizeFlag.set(false);
                            System.out.println("optimizeFlag -> "+optimizeFlag.get()+" ('O' to turn back on)");
                        }
                        System.out.print("Down");
                        System.out.flush();
                        int iVert = mesh.indexOfClosestVert(prevP[0], prevP[1],mostRecentGraphics);
                        if (iVert != -1)
                        {
                            Mesh.Vertex vertI = mesh.getVert(iVert);
                            double v[] = {vertI.x(), vertI.y(), vertI.z()};
                            double group[][][] = getTheSymmetryGroup();
                            Mesh.Vertex vertsToMove[] = findAllVertsThatAreImages(mesh, v, group, 1e-6);

                            if (wrapAroundSphereFlag.get())
                            {
                                double sphereCenterZ = (centerSphereFlag.get() ? 0. : -1./wrapSphereCurvature.get());
                                FORI (iVertToMove, vertsToMove.length)
                                {
                                    Mesh.Vertex vert = vertsToMove[iVertToMove];
                                    v[0] = vert.x();
                                    v[1] = vert.y();
                                    v[2] = vert.z() - sphereCenterZ;
                                    double oldR = Math.sqrt(SQR(v[0])+SQR(v[1])+SQR(v[2]));
                                    double newR = oldR + incr;
                                    double scale = newR / oldR;
                                    vert.setXYZW(v[0]*scale, v[1]*scale, v[2]*scale + sphereCenterZ, 1.);
                                }
                            }
                            else
                            {
                                FORI (iVertToMove, vertsToMove.length)
                                {
                                    Mesh.Vertex vert = vertsToMove[iVertToMove];
                                    // push the dual face *into* the screen,
                                    // i.e. decrease its height,
                                    // i.e. increase height of primal vert.
                                    vert.setxyh(vert.x(),
                                                vert.y(),
                                                vert.h() + incr);
                                    System.out.println("    verts["+vert.myIndex()+"].Hnaive() -> "+vert.Hnaive());
                                }
                            }
                            if (continuouslyDelaunayizeFlag.get()) delaunayize();
                        }
                        UndoItem.State after = newUndoItemState();
                        undoTreeSquirrel.Do(new UndoItem(before, after));
                        dirtyDualMesh();
                        theCanvas.repaint();
                        break;
                    }
                    case java.awt.event.KeyEvent.VK_LEFT:
                    case java.awt.event.KeyEvent.VK_RIGHT:
                    {
                        if (false) // I'm thinking no... left/right will only do this if already showing net
                            synchronized(showNetFlag) // since another thread checks it once in a while
                            {
                                showNetFlag.set(true);
                            }
                        if (showNetFlag.get())
                        {
                            if (_dualMesh != null
                             && theNet != null
                             && highlightedDualEdgeIndex != -1)
                            {
                                if (theNet._edgeStatuses[highlightedDualEdgeIndex] == Net.CUT)
                                {
                                    // It's a cut; direction matters.
                                    // (for fold, we rely in the closest-edge picking
                                    // to pick the correct one of the two half-edges)
                                    // Make sure edge in question is pointing
                                    // towards root of cut tree.  If not, switch to its opposite.
                                    if (_dualMesh.getEdge(highlightedDualEdgeIndex).initialVertex() == null
                                     || theNet._vertToParentEdgeInd[_dualMesh.getEdge(highlightedDualEdgeIndex).initialVertex().myIndex()] != highlightedDualEdgeIndex)
                                        highlightedDualEdgeIndex = _dualMesh.getEdge(highlightedDualEdgeIndex).opposite().myIndex();
                                    assert(theNet._vertToParentEdgeInd[_dualMesh.getEdge(highlightedDualEdgeIndex).initialVertex().myIndex()] == highlightedDualEdgeIndex);
                                }

                                Mesh.Edge alternatives[] = theNet.alternatives(highlightedDualEdgeIndex);
                                if (alternatives.length > 0)
                                {
                                    int other = alternatives[(keyCode == java.awt.event.KeyEvent.VK_LEFT ? 0 : alternatives.length-1)].myIndex();

                                    UndoItem.State before = newUndoItemState();
                                    theNet.swapCutAndFold(highlightedDualEdgeIndex,
                                                          other);
                                    // make the highlighted one be the one we swapped with.
                                    // that makes it so, if the user doesn't jiggle the mouse,
                                    // hitting the key repeatedly will rotate around the lagoon.
                                    highlightedDualEdgeIndex = other;
                                    UndoItem.State after = newUndoItemState();
                                    undoTreeSquirrel.Do(new UndoItem(before, after));
                                    theCanvas.repaint();
                                }
                                else
                                {
                                    System.out.println("HEY! edge "+_dualMesh.getEdge(highlightedDualEdgeIndex)+" has no alternative! status="+theNet._edgeStatuses[highlightedDualEdgeIndex]);
                                    assert(theNet._edgeStatuses[highlightedDualEdgeIndex] == Net.FOLD);
                                    assert(false); // wtf? this shouldn't happen
                                }

                                if (true)
                                {
                                    // just sanity check that we can walk around the net tree starting from highlighted dual edge index

                                    //System.out.println("===================");
                                    //System.out.println("Walking around net tree:");
                                    Mesh.Edge dualEdge = _dualMesh.getEdge(highlightedDualEdgeIndex);
                                    // assert against infinite loop...
                                    boolean seen[] = new boolean[_dualMesh.edges.size()]; // false initially
                                    while (true)
                                    {
                                        assert(!seen[dualEdge.myIndex()]);
                                        if (false)
                                            System.out.println("    "+dualEdge);
                                        seen[dualEdge.myIndex()] = true;
                                        assert(_dualMesh.getEdge(dualEdge.myIndex()) == dualEdge); // check that nextInTree didn't get confused and switch trees
                                        dualEdge = theNet.nextInTree(dualEdge);
                                        assert(_dualMesh.getEdge(dualEdge.myIndex()) == dualEdge); // check that nextInTree didn't get confused and switch trees
                                        if (dualEdge.myIndex() == highlightedDualEdgeIndex)
                                            break;
                                    }
                                    //System.out.println("===================");
                                }
                            }
                        }
                        else // !showNetFlag.get()
                        {
                            int oldIndex = theOptimizationIndex;

                            if (keyCode == java.awt.event.KeyEvent.VK_LEFT)
                                theOptimizationIndex = e.isShiftDown() ? 0 : MAX(theOptimizationIndex-1, 0);
                            else
                                theOptimizationIndex = e.isShiftDown() ? theOptimizationPath.length-1
                                                                            : MIN(theOptimizationIndex+1, theOptimizationPath.length-1);
                            System.out.println("theOptimizationIndex "+oldIndex+" -> "+theOptimizationIndex+"");

                            if (theOptimizationIndex != oldIndex)
                            {
                                double verts[][] = theOptimizationPath[theOptimizationIndex];
                                if (mesh.verts.size() == verts.length)
                                {
                                    FORI (iVert, verts.length)
                                    {
                                        mesh.getVert(iVert).setxyh(verts[iVert][0],
                                                                   verts[iVert][1],
                                                                   verts[iVert][2]);
                                    }
                                }
                                dirtyDualMesh();

                                theCanvas.repaint();
                            }
                            break;
                        }
                        break;
                    }
                    case java.awt.event.KeyEvent.VK_CONTROL:
                    {
                        if (!controlIsDown)
                        {
                            //System.out.println("ctrl newly down!");
                            if (beingDraggedVertIndex != -1)
                            {
                                Mesh.Vertex beingDraggedVert = mesh.getVert(beingDraggedVertIndex);

                                double oldCoords[] = {beingDraggedVert.x(), beingDraggedVert.y()};
                                // only difference between ctrl-newly-down and ctrl-newly-up...
                                double newCoords[] = {
                                    (double)Math.round(oldCoords[0]/gridSnapQuantum)*gridSnapQuantum,
                                    (double)Math.round(oldCoords[1]/gridSnapQuantum)*gridSnapQuantum,
                                };

                                double group[][][] = getTheSymmetryGroup();
                                int nVerts = mesh.verts.size();
                                FORI (iGroup, group.length)
                                {
                                    double oldImage[] = VecMath.vxm(oldCoords,group[iGroup]);
                                    FORI (iVert, nVerts)
                                    {
                                        Mesh.Vertex vertI = mesh.getVert(iVert);
                                        if (EQ(oldImage[0], vertI.x(), 1e-6)
                                         && EQ(oldImage[1], vertI.y(), 1e-6))
                                        {
                                            double newImage[] = VecMath.vxm(newCoords,group[iGroup]);
                                            System.out.println("Snapping vertex "+iVert+" from "+vertI.x()+" "+vertI.y()+" "+vertI.h()+"");
                                            vertI.setXYnaive(newImage[0],
                                                             newImage[1]);
                                            System.out.println("Dragging vertex "+iVert+" from "+vertI.x()+" "+vertI.y()+" "+vertI.h()+"");
                                        }
                                    }
                                }

                                if (continuouslyDelaunayizeFlag.get()) delaunayize();

                                theCanvas.repaint();
                            }
                        }
                        controlIsDown = true;
                        break;
                    }

                    default:
                        // don't print anything, or we'll print too much (e.g. Shift, and any keys we handle in keyTyped())
                        //System.out.println("Unknown keycode "+java.awt.event.KeyEvent.getKeyText(keyCode)+" ("+keyCode+")");
                        break;
                }
                if (eventVerbose >= 1) System.out.println("out keyPressed: "+e);
            } // keyPressed
            public void keyReleased(java.awt.event.KeyEvent e)
            {
                if (eventVerbose >= 1) System.out.println("in keyReleased: "+e);
                int keyCode = e.getKeyCode();
                switch(keyCode)
                {
                    case java.awt.event.KeyEvent.VK_CONTROL:
                    {
                        if (controlIsDown)
                        {
                            // note, one of the ctrl keys might still be down at this point
                            // (if they were both down previously),
                            // but most likely they are both now up.
                            // if we get this wrong it's not a huge deal.
                            //System.out.println("ctrl newly up!");
                            if (beingDraggedVertIndex != -1)
                            {
                                Mesh.Vertex beingDraggedVert = mesh.getVert(beingDraggedVertIndex);

                                double oldCoords[] = {beingDraggedVert.x(), beingDraggedVert.y()};

                                // only difference between ctrl-newly-down and ctrl-newly-up...
                                double newCoords[] = beingDraggedVertUnsnappedXY;

                                double group[][][] = getTheSymmetryGroup();
                                int nVerts = mesh.verts.size();
                                FORI (iGroup, group.length)
                                {
                                    double oldImage[] = VecMath.vxm(oldCoords,group[iGroup]);
                                    FORI (iVert, nVerts)
                                    {
                                        Mesh.Vertex vertI = mesh.getVert(iVert);
                                        if (EQ(oldImage[0], vertI.x(), 1e-6)
                                         && EQ(oldImage[1], vertI.y(), 1e-6))
                                        {
                                            double newImage[] = VecMath.vxm(newCoords,group[iGroup]);
                                            System.out.println("Snapping vertex "+iVert+" from "+vertI.x()+" "+vertI.y()+" "+vertI.h()+"");
                                            vertI.setxyh(newImage[0],
                                                         newImage[1],
                                                         vertI.h());
                                            System.out.println("Dragging vertex "+iVert+" from "+vertI.x()+" "+vertI.y()+" "+vertI.h()+"");
                                        }
                                    }
                                }

                                if (continuouslyDelaunayizeFlag.get()) delaunayize();

                                theCanvas.repaint();
                            }
                        }
                        controlIsDown = false;
                        break;
                    }
                    default:
                        break;
                }
                if (eventVerbose >= 1) System.out.println("out keyReleased: "+e);
            } // keyReleased
            public void keyTyped(java.awt.event.KeyEvent e)
            {
                if (eventVerbose >= 1) System.out.println("in keyTyped: "+e);
                char c = e.getKeyChar();

                // In java 1.6, apparently ctrl-letter
                // started coming out as just the letter
                // (with ke.isControlDown() true).
                // Detect this and change it to the old behavior...
                // XXX need to do something else, or nothing at all here, for old javas (1.1) in which isControlDown doesn't exist... or else just stop trying to support 1.1 at all
                if (c >= 'a' && c <= 'z' && e.isControlDown())
                {
                    c -= ('a'-1);
                }

    #define CTRL(lowerCaseLetter) ((lowerCaseLetter)-'a' + 1)
                switch (c)
                {
                    case 'V': // cycle verbosity-- upper-case to minimize possibility of hitting it by accident thus causing subsequent perfomance degradation with no visible reason if Java Console is not visible
                        System.out.print("eventVerbose "+eventVerbose);
                        eventVerbose = (eventVerbose+1) % 4;
                        System.out.println(" -> "+eventVerbose);
                        break;

                    case ' ': // just repaint (i.e. mark dirty)
                        theCanvas.repaint();
                        break;
                    case 'A': // toggle antiAliasingFlag
                        antiAliasingFlag ^= true;
                        System.out.println("antiAliasingFlag -> "+antiAliasingFlag+" (if this platform supports it)");
                        theCanvas.repaint();
                        break;

                    case 't': // cycle showTriangles down
                        if (showPrimalEdgesFlag.get())
                            showPrimalEdgesFlag.set(false);
                        else if (showPrimalVertsFlag.get())
                            showPrimalVertsFlag.set(false);
                        else
                        {
                            showPrimalVertsFlag.set(true);
                            showPrimalEdgesFlag.set(true);
                        }
                        theCanvas.repaint();
                        break;

                    case 'T': // cycle showTriangles up
                        if (showPrimalEdgesFlag.get())
                        {
                            showPrimalVertsFlag.set(false);
                            showPrimalEdgesFlag.set(false);
                        }
                        else if (showPrimalVertsFlag.get())
                            showPrimalEdgesFlag.set(true);
                        else
                            showPrimalVertsFlag.set(true);
                        theCanvas.repaint();
                        break;

                    case 'n': // toggle showNetFlag
                        synchronized(showNetFlag) // since another thread checks it once in a while
                        {
                            showNetFlag.set(!showNetFlag.get());
                        }
                        System.out.println("showNetFlag -> "+showNetFlag.get());
                        theCanvas.repaint();
                        break;

                    case 'R': // toggle pointOutRedNetEdges
                        pointOutRedNetEdges = !pointOutRedNetEdges;
                        System.out.println("pointOutRedNetEdges -> "+pointOutRedNetEdges);
                        theCanvas.repaint();
                        break;

                    case 'i': case '+': case '=': // zoom in
                    {
                        //rescale(2., 2.);
                        rescale(Math.sqrt(2.), Math.sqrt(2.));
                        break;
                    }
                    case 'o': case '-':           // zoom out
                    {
                        //rescale(.5, .5);
                        rescale(Math.sqrt(.5), Math.sqrt(.5));
                        break;
                    }
                    case 'f': // frame
                    {
                        frame(true,true);
                        break;
                    }
                    case '|': // left-to-right flip whole diagram
                    {
                        UndoItem.State before = newUndoItemState();
                        mesh.flipLeftRight();
                        dirtyDualMesh(); // flip doesn't work when verts missing
                        // should be no need to re-delaunayize
                        UndoItem.State after = newUndoItemState();
                        undoTreeSquirrel.Do(new UndoItem(before, after));
                        theCanvas.repaint();
                        break;
                    }
                    case '_': // up-to-down flip whole diagram
                    {
                        UndoItem.State before = newUndoItemState();
                        mesh.flipUpDown();
                        dirtyDualMesh(); // flip doesn't work when verts missing
                        // should be no need to re-delaunayize
                        UndoItem.State after = newUndoItemState();
                        undoTreeSquirrel.Do(new UndoItem(before, after));
                        theCanvas.repaint();
                        break;
                    }
                    case '\\': // lower-left to upper-right flip whole diagram
                    {
                        UndoItem.State before = newUndoItemState();
                        mesh.flipLowerLeftUpperRight();
                        dirtyDualMesh(); // flip doesn't work when verts missing
                        // should be no need to re-delaunayize
                        UndoItem.State after = newUndoItemState();
                        undoTreeSquirrel.Do(new UndoItem(before, after));
                        theCanvas.repaint();
                        break;
                    }
                    case '/': // upper-left to lower-right flip whole diagram
                    {
                        UndoItem.State before = newUndoItemState();
                        mesh.flipUpperLeftLowerRight();
                        dirtyDualMesh(); // flip doesn't work when verts missing
                        // should be no need to re-delaunayize
                        UndoItem.State after = newUndoItemState();
                        undoTreeSquirrel.Do(new UndoItem(before, after));
                        theCanvas.repaint();
                        break;
                    }

                    case 's': // swap diagonal
                    {
                        UndoItem.State before = newUndoItemState();
                        //
                        // Really would like everything selected
                        // that was selected before,
                        // except for the two dual verts that changed...
                        // the new two should both be selected
                        // if the original two were selected,
                        // or both unselected otherwise.
                        // XXX TODO: do this


                        int closestEdgeIndex = mesh.indexOfClosestEdge(prevP, false);
                        if (closestEdgeIndex != -1)
                        {
                            System.out.println("Swapping diagonal edge e"+closestEdgeIndex);
                            continuouslyDelaunayizeFlag.set(false); // otherwise it's not obvious what the hell happened
                            mesh.swapDiagonal(mesh.getEdge(closestEdgeIndex), /*onlyIfMoreDelaunay=*/false, /*verbose=*/true);
                            mesh.sanityCheck();
                            dirtyDualMesh();
                        }

                        UndoItem.State after = newUndoItemState();
                        undoTreeSquirrel.Do(new UndoItem(before, after));
                        theCanvas.repaint();
                        break;
                    }

                    case CTRL('s'): // swap diagonal but only if it makes it closer to delaunay
                    {
                        // Swap diagonal but only if it makes it closer to delaunay
                        UndoItem.State before = newUndoItemState();
                        int closestEdgeIndex = mesh.indexOfClosestEdge(prevP, false);
                        if (closestEdgeIndex != -1)
                        {
                            System.out.println("Swapping diagonal edge e"+closestEdgeIndex);
                            continuouslyDelaunayizeFlag.set(false); // otherwise it's not obvious what the hell happened
                            mesh.swapDiagonal(mesh.getEdge(closestEdgeIndex), /*onlyIfMoreDelaunay=*/true, /*verbose=*/true);
                            mesh.sanityCheck();
                            dirtyDualMesh();
                        }
                        UndoItem.State after = newUndoItemState();
                        undoTreeSquirrel.Do(new UndoItem(before, after));
                        theCanvas.repaint();
                        break;
                    }

                    case 'D': // delaunayize
                    {
                        UndoItem.State before = newUndoItemState();
                        delaunayize();
                        UndoItem.State after = newUndoItemState();
                        undoTreeSquirrel.Do(new UndoItem(before, after));
                        theCanvas.repaint();
                        break;
                    }

                    case 'W': // select *all* dual verts for weighting (positive weight, of arity 3), or deselect all if all selected
                    {
                        UndoItem.State before = newUndoItemState();
                        {
                            if (allDualVertsAreSelected)
                            {
                                selectedDualVertIndices = new int[0];
                                selectedTris = new int[0][3];
                                allDualVertsAreSelected = false;
                            }
                            else
                            {
                                // TODO: actually I don't think this loop is necessary, it gets done automatically as we continuously update selected array, since we're setting allDualVertsAreSelected = true

                                Mesh dualMesh = getDualMesh();
                                int nDualVerts = dualMesh.verts.size();
                                int nDualEdges = dualMesh.edges.size();

                                selectedDualVertIndices = new int[nDualVerts];
                                selectedTris = new int[nDualVerts][];
                                int nSelected = 0;
                                FORI (iDualEdge, nDualEdges)
                                {
                                    Mesh.Edge dualEdge = dualMesh.getEdge(iDualEdge);
                                    Mesh.Vertex dualVert = dualEdge.initialVertex();
                                    if (dualVert != null && dualVert.weight >= 0.)
                                    {
                                        Mesh.Edge primalEdge = (mesh.getEdge(iDualEdge)).opposite();
                                        if (primalEdge.next().next().next() == primalEdge) // if it's a tri
                                        {
                                            int i0 = primalEdge.initialVertex().myIndex();
                                            int i1 = primalEdge.finalVertex().myIndex();
                                            int i2 = primalEdge.prev().initialVertex().myIndex();
                                            if (i0 < i1 && i0 < i2) // if it's in canonical order
                                            {
                                                selectedTris[nSelected] = new int[]{i0,i1,i2};
                                                selectedDualVertIndices[nSelected] = dualVert.myIndex();
                                                nSelected++;
                                            }
                                        }
                                    }
                                }
                                selectedDualVertIndices = (int[])Arrays.subarray(selectedDualVertIndices, 0, nSelected);
                                selectedTris = (int[][])Arrays.subarray(selectedTris, 0, nSelected);
                                allDualVertsAreSelected = true;
                            }
                        }
                        UndoItem.State after = newUndoItemState();
                        undoTreeSquirrel.Do(new UndoItem(before, after));
                        theCanvas.repaint();
                        break;
                    }

                    case 'w': // toggle closest dual vertex for weighting (think of better mnemonic)
                    {
                        UndoItem.State before = newUndoItemState();
                        {
                            Mesh dualMesh = getDualMesh();
                            double closestDistSqrd = Double.POSITIVE_INFINITY;
                            int closestIndex = -1;
                            int nDualVerts = dualMesh.verts.size();
                            PRINT(nDualVerts);
                            double scratch[] = new double[3];
                            FORI (iDualVert, nDualVerts) // beginning to end, so we choose first of equal
                            {
                                Mesh.Vertex dualVert = dualMesh.getVert(iDualVert);
                                if (dualVert.arity != 3)
                                    continue; // not a triangle
                                if (!showInsideOutDualVertsFlag.get())
                                {
                                    if (dualVert.weight < 0)
                                        continue; // the triangle is inside out; it's the boundary
                                }

                                mostRecentGraphics.xform(dualVert.X(), dualVert.Y(), dualVert.Z(), dualVert.W(), scratch);
                                double thisDistSqrd = VecMath.distsqrd(2, prevP, scratch);
                                if (thisDistSqrd < closestDistSqrd)
                                {
                                    closestDistSqrd = thisDistSqrd;
                                    closestIndex = iDualVert;
                                }
                            }
                            if (closestIndex != -1)
                            {
                                PRINT(closestIndex);
                                // figure out the 3 primal verts
                                int closestTri[] = null;
                                {
                                    int nEdges = dualMesh.edges.size();
                                    assert(nEdges == mesh.edges.size());
                                    FORI (iEdge, nEdges)
                                    {
                                        Mesh.Edge dualEdge = dualMesh.getEdge(iEdge);
                                        Mesh.Vertex initialVertex = dualEdge.initialVertex();
                                        if (initialVertex != null
                                         && initialVertex.myIndex() == closestIndex)
                                        {
                                            Mesh.Edge primalEdge = (mesh.getEdge(iEdge)).opposite();
                                            // advance around triangle til initial vertex is smallest
                                            while (primalEdge.initialVertex().myIndex() > primalEdge.finalVertex().myIndex()
                                                || primalEdge.initialVertex().myIndex() > primalEdge.prev().initialVertex().myIndex())
                                                primalEdge = primalEdge.next();
                                            int i0 = primalEdge.initialVertex().myIndex();
                                            int i1 = primalEdge.finalVertex().myIndex();
                                            int i2 = primalEdge.prev().initialVertex().myIndex();
                                            closestTri = new int[] {i0,i1,i2};
                                        }
                                    }
                                }
                                assert(closestTri != null);
                                PRINTARRAY(closestTri);

                                int indInd = Arrays.indexOf(selectedDualVertIndices, closestIndex);
                                double closestDualVertWeight = (dualMesh.getVert(closestIndex)).weight;
                                double totalWeightBefore = 0.; FORIDOWN(iSelected, selectedDualVertIndices.length) if (selectedDualVertIndices[iSelected] != -1) totalWeightBefore += (dualMesh.getVert(selectedDualVertIndices[iSelected])).weight;

                                if (indInd != -1)
                                {
                                    System.out.println("    deselecting dual vert "+closestIndex+" (primal tri "+Arrays.toStringCompact(selectedTris[indInd])+")");
                                    selectedTris = (int[][])Arrays.delete(selectedTris, indInd);
                                    selectedDualVertIndices = (int[])Arrays.delete(selectedDualVertIndices, indInd);
                                    allDualVertsAreSelected = false;
                                }
                                else
                                {
                                    System.out.println("    selecting dual vert "+closestIndex);
                                    selectedTris = (int[][])Arrays.append(selectedTris, closestTri);
                                    selectedDualVertIndices = (int[])Arrays.append(selectedDualVertIndices, closestIndex);
                                    // don't mess with allDualVertsAreSelected, it's hard to tell. they have to 'W' to get it back
                                    // TODO: fix this
                                }
                                double totalWeightAfter = 0.; FORIDOWN(iSelected, selectedDualVertIndices.length) if (selectedDualVertIndices[iSelected] != -1) totalWeightAfter += (dualMesh.getVert(selectedDualVertIndices[iSelected])).weight;
                                System.out.println("    Total selected weight: "+totalWeightBefore+" "+(indInd!=-1?'-':'+')+" "+closestDualVertWeight+" = "+totalWeightAfter+"");
                            }
                        }
                        UndoItem.State after = newUndoItemState();
                        undoTreeSquirrel.Do(new UndoItem(before, after));
                        theCanvas.repaint();
                        break;
                    }
                    case 'd': // delete closest edge
                    {
                        UndoItem.State before = newUndoItemState();
                        int closestEdgeIndex = mesh.indexOfClosestEdge(prevP, false);
                        if (closestEdgeIndex != -1)
                        {
                            System.out.println("Deleting edge e"+closestEdgeIndex);
                            mesh.deleteEdge(mesh.getEdge(closestEdgeIndex));
                            mesh.sanityCheck();
                            // deleted something-- invalidate dual mesh
                            dirtyDualMesh();
                        }
                        continuouslyDelaunayizeFlag.set(false); // otherwise it will mysteriously come back!
                        UndoItem.State after = newUndoItemState();
                        undoTreeSquirrel.Do(new UndoItem(before, after));
                        theCanvas.repaint();
                        break;
                    }
                    case 'S': // turn off optimize, and re-sphereize
                    {
                        UndoItem.State before = newUndoItemState();
                        if (optimizeFlag.get())
                        {
                            optimizeFlag.set(false);
                            System.out.println("optimizeFlag -> "+optimizeFlag.get()+" ('O' to turn back on)");
                        }
                        if (wrapAroundSphereFlag.get())
                        {
                            double wrapSphereRadius = 1./wrapSphereCurvature.get();
                            boolean centerSphereFlagValue = centerSphereFlag.get();
                            double scratch[] = new double[3];
                            FORIDOWN (iVert, mesh.verts.size())
                            {
                                Mesh.Vertex vert = mesh.getVert(iVert);
                                scratch[0] = vert.x();
                                scratch[1] = vert.y();
                                scratch[2] = vert.z();
                                if (!centerSphereFlagValue)
                                    scratch[2] += wrapSphereRadius;
                                VecMath.normalize(scratch, scratch);
                                VecMath.vxs(scratch, scratch, wrapSphereRadius);
                                if (!centerSphereFlagValue)
                                    scratch[2] -= wrapSphereRadius;
                                vert.setXYZW(scratch[0],
                                             scratch[1],
                                             scratch[2],
                                             1.);
                            }
                        }
                        else
                        {
                            FORIDOWN (iVert, mesh.verts.size())
                            {
                                Mesh.Vertex vert = mesh.getVert(iVert);
                                vert.setxyh(vert.x(),
                                            vert.y(),
                                            0.);
                            }
                        }
                        dirtyDualMesh();
                        if (continuouslyDelaunayizeFlag.get()) delaunayize();
                        UndoItem.State after = newUndoItemState();
                        undoTreeSquirrel.Do(new UndoItem(before, after));
                        theCanvas.repaint();
                        break;
                    }

                    case 'l': // toggle showLabelsFlag (which actually doesn't exist)
                    {
                        boolean showLabelsFlag = labelPrimalVertsFlag.get()
                                              || labelPrimalEdgesFlag.get()
                                              || labelDualVertsFlag.get()
                                              || labelDualEdgesFlag.get();
                        showLabelsFlag ^= true;
                        System.out.println("showLabelsFlag -> "+showLabelsFlag);
                        labelPrimalVertsFlag.set(showLabelsFlag);
                        labelPrimalEdgesFlag.set(showLabelsFlag);
                        labelDualVertsFlag.set(showLabelsFlag);
                        labelDualEdgesFlag.set(showLabelsFlag);
                        theCanvas.repaint();
                        break;
                    }
                    case 'g': // toggle showGridFlag
                        showGridFlag ^= true;
                        System.out.println("showGridFlag -> "+showGridFlag);
                        theCanvas.repaint();
                        break;

                    case 'M':
                        System.out.print("magWidth "+magWidth);
                        magWidth += 2;
                        System.out.println(" -> "+magWidth);
                        theCanvas.repaint();
                        break;
                    case 'm':
                        System.out.print("magWidth "+magWidth);
                        magWidth = MAX(1, magWidth-2);
                        System.out.println(" -> "+magWidth);
                        theCanvas.repaint();
                        break;
                    case 'P':
                        System.out.print("magFactor "+magFactor);
                        magFactor += 1;
                        System.out.println(" -> "+magFactor);
                        showMagFlag.set(true); // so it's clear what happened
                        theCanvas.repaint();
                        break;
                    case 'p':
                        System.out.print("magFactor "+magFactor);
                        magFactor = MAX(0, magFactor-1);
                        System.out.println(" -> "+magFactor);
                        showMagFlag.set(true); // so it's clear what happened
                        theCanvas.repaint();
                        break;

                    case CTRL('m'):
                    case CTRL('j'): // ARGH! ctrl-m comes out as ctrl-j!?
                        showMagFlag.set(!showMagFlag.get());
                        System.out.println("showMagFlag -> "+showMagFlag.get());
                        theCanvas.repaint();
                        break;


#if 0 // conflicts with symmetry stuff... disable for now
                    case '0': // toggle showOriginFlag
                        showOriginFlag ^= true;
                        System.out.println("showOriginFlag -> "+showOriginFlag);
                        theCanvas.repaint();
                        break;
#endif

                    case 'O': // toggle optimizeFlag
                    {
                        UndoItem.State before = newUndoItemState();
                        optimizeFlag.set(!optimizeFlag.get());
                        System.out.println("optimizeFlag -> "+optimizeFlag.get());
                        if (continuouslyDelaunayizeFlag.get()) delaunayize();
                        UndoItem.State after = newUndoItemState();
                        undoTreeSquirrel.Do(new UndoItem(before, after));
                        theCanvas.repaint();
                        break;
                    }

                    case 'a': // toggle arrowsTowardsSharpestDihedralsFlag or arrowsTowardsShortestEdgesFlag
                    {
                        if (e.isAltDown())
                        {
                            arrowsTowardsShortestEdgesFlag ^= true;
                            System.out.println("arrowsTowardsShortestEdgesFlag -> "+arrowsTowardsShortestEdgesFlag);
                        }
                        else
                        {
                            arrowsTowardsSharpestDihedralsFlag ^= true;
                            System.out.println("arrowsTowardsSharpestDihedralsFlag -> "+arrowsTowardsSharpestDihedralsFlag);
                        }
                        theCanvas.repaint();
                        break;
                    }

                    case CTRL('d'): // swap primal and dual
                    {
                        UndoItem.State before = newUndoItemState();

                        boolean heightsWereAllZero = true;
                        FORI (iVert, mesh.verts.size())
                            if (mesh.getVert(iVert).Hnaive() != 0.)
                            {
                                heightsWereAllZero = false;
                                break;
                            }

                        mesh = makeDualMesh(mesh,
                                            true, // includeNonArity3 (so we get full mesh)
                                            true, // includeInsideOut
                                            wrapAroundSphereFlag.get(),
                                            centerSphereFlag.get(),
                                            wrapSphereCurvature.get());

                        // this seems to make it a bit better, though I don't really understand.
                        if (heightsWereAllZero)
                        {
                            FORI (iVert, mesh.verts.size())
                                mesh.getVert(iVert).setHnaive(0.);
                        }

                        selectedTris = new int[][] {};
                        selectedDualVertIndices = new int[] {};
                        allDualVertsAreSelected = false;
                        if (continuouslyDelaunayizeFlag.get()) delaunayize();
                        UndoItem.State after = newUndoItemState();
                        undoTreeSquirrel.Do(new UndoItem(before, after));
                        theCanvas.repaint();
                        break;
                    }

                    case 'u': case CTRL('z'): // undo
                    {
                        UndoItem item = (UndoItem)undoTreeSquirrel.undo();
                        if (item != null)
                        {
                            mesh = new Mesh(item.before.mesh);
                            meshOfSelectedTris = mesh; // hackish
                            continuouslyDelaunayizeFlag.set(item.before.continuouslyDelaunayizeFlag);
                            optimizeFlag.set(item.before.optimizeFlag);
                            optimizationTypeIndex.set(item.before.optimizationTypeIndex);
                            optimizationType = availableOptimizationTypes[optimizationTypeIndex.get()];
                            selectedTris = (int[][])Arrays.copy(item.before.selectedTris, 2);
                            selectedDualVertIndices = VecMath.copyvec(item.before.selectedDualVertIndices);
                            allDualVertsAreSelected = item.before.allDualVertsAreSelected;
                            dirtyDualMesh(); // *before* we restore theNet
                            theNet = (item.before.netEdgeStatuses==null ? null : new Net(getDualMesh(), mesh, item.before.netEdgeStatuses));
                        }
                        else
                        {
                            System.out.println("Nothing to undo!");
                        }
                        theCanvas.repaint();
                        break;
                    }
                    case 'r': case 'U': case CTRL('r'): case CTRL('y'): // redo
                    {
                        UndoItem item = (UndoItem)undoTreeSquirrel.redo();
                        if (item != null)
                        {
                            mesh = new Mesh(item.after.mesh);
                            meshOfSelectedTris = mesh; // hackish
                            continuouslyDelaunayizeFlag.set(item.after.continuouslyDelaunayizeFlag);
                            optimizeFlag.set(item.after.optimizeFlag);
                            optimizationTypeIndex.set(item.after.optimizationTypeIndex);
                            optimizationType = availableOptimizationTypes[optimizationTypeIndex.get()];
                            selectedTris = (int[][])Arrays.copy(item.after.selectedTris, 2);
                            selectedDualVertIndices = VecMath.copyvec(item.after.selectedDualVertIndices);
                            allDualVertsAreSelected = item.after.allDualVertsAreSelected;
                            dirtyDualMesh(); // *before* we restore theNet
                            theNet = (item.after.netEdgeStatuses==null ? null : new Net(getDualMesh(), mesh, item.after.netEdgeStatuses));
                        }
                        else
                        {
                            System.out.println("Nothing to redo!");
                        }
                        theCanvas.repaint();
                        break;
                    }
                    case 'c': // clear
                    {
                        // XXX dup code
                        UndoItem.State before = newUndoItemState();
                        synchronized(showNetFlag) // since another thread checks it once in a while
                        {
                            showNetFlag.set(false); // so user won't get confused when clicking doesn't make verts appear
                        }
                        resetLocalToWorld();
                        mesh = new Mesh();
                        selectedTris = new int[][] {};
                        selectedDualVertIndices = new int[] {};
                        allDualVertsAreSelected = false;
                        if (continuouslyDelaunayizeFlag.get()) delaunayize();
                        dirtyDualMesh(); // before snapping after state, so theNet will be cleared XXX aren't there a zillion places we're neglecting to take this into account?
                        UndoItem.State after = newUndoItemState();
                        undoTreeSquirrel.Do(new UndoItem(before, after));
                        theCanvas.repaint();
                        break;
                    }
                    case CTRL('q'): // quit
                    {
                        System.out.println("Aww.");
                        System.exit(1);
                    }

                    case 'h': // help
                        help();
                        break;

                    case CTRL('i'): // toggle showInsideOutDualVertsFlag
                        showInsideOutDualVertsFlag.set(!showInsideOutDualVertsFlag.get());
                        System.out.println("showInsideOutDualVertsFlag -> "+showInsideOutDualVertsFlag.get());
                        theCanvas.repaint();
                        break;

                    case CTRL('o'): // cycle optimizationType
                        optimizationTypeIndex.set((optimizationTypeIndex.get()+1)%availableOptimizationTypes.length);
                        optimizationType = availableOptimizationTypes[optimizationTypeIndex.get()];
                        System.out.println("optimizationType -> "+optimizationTypeNames[optimizationType]);
                        theCanvas.repaint();
                        break;

                    case CTRL('v'): // toggle nonEventVerbose
                        nonEventVerbose = (nonEventVerbose+1)%2;
                        System.out.println("nonEventVerbose -> "+nonEventVerbose);
                        theCanvas.repaint();
                        break;

                    case '1': case '2': case '3': case '4': case '5':
                    case '6': case '7': case '8': case '9': case '0':
                    {
                        changeSymmetry(c=='0' ? 10 : c-'0', qRotationalSymmetry.get(), false, false, remapFundamentalRegionWhenChangingSymmetry.get(), replicateVertsWhenChangingSymmetry.get(), deleteNonReplicatedVertsWhenChangingSymmetry.get());
                        break;
                    }
                    case '!': case '@': case '#': case '$': case '%':
                    case '^': case '&': case '*': case '(': case ')':
                    {
                        changeSymmetry(c==')' ? 10 : ")!@#$%^&*(".indexOf(c), qRotationalSymmetry.get(), true, false, remapFundamentalRegionWhenChangingSymmetry.get(), replicateVertsWhenChangingSymmetry.get(), deleteNonReplicatedVertsWhenChangingSymmetry.get());
                        break;
                    }

                    case CTRL('b'): // blue noise pattern
                    {
                        UndoItem.State before = newUndoItemState();

                        doBlueNoiseThing(blueNoiseN.get());

                        if (continuouslyDelaunayizeFlag.get()) delaunayize();
                        UndoItem.State after = newUndoItemState();
                        undoTreeSquirrel.Do(new UndoItem(before, after));
                        theCanvas.repaint();
                        break;
                    }
                    case 'b': // uniform grid thing
                    {
                        UndoItem.State before = newUndoItemState();

                        doUniformGridThing(gridN.get());

                        if (continuouslyDelaunayizeFlag.get()) delaunayize();
                        UndoItem.State after = newUndoItemState();
                        undoTreeSquirrel.Do(new UndoItem(before, after));
                        theCanvas.repaint();
                        break;
                    }
                    case CTRL('l'): // optimize farthest lagoon exit killer XXX this should be temporary maybe
                    {
                        UndoItem.State before = newUndoItemState();
                        optimizeFarthestLagoonExitKiller();
                        if (continuouslyDelaunayizeFlag.get()) delaunayize();
                        UndoItem.State after = newUndoItemState();
                        undoTreeSquirrel.Do(new UndoItem(before, after));
                        theCanvas.repaint();
                        break;
                    }

                    case CTRL('t'): // analyze random spanning trees
                    {
                        analyzeRandomSpanningTrees(mesh);
                        break;
                    }


                    default:
                        System.out.println("Unknown key '"+c+"'("+(int)c+") typed");
                        break;
                }
                if (eventVerbose >= 1) System.out.println("out keyTyped: "+e);
            } // keyTyped


                // common code used twice
                private void drawLabels(MyGraphics3D mg,
                                        Mesh mesh,
                                        boolean isDualMesh,
                                        boolean showInsideOutParts,
                                        boolean labelVertsFlag,
                                        boolean labelEdgesFlag,
                                        double edgeInitialCoords[/*nEdges*/][/*at most 2*/][/*4*/], // optional-- only used for dual... for primal, we just get from verts directly
                                        boolean whichEdgesGotDrawn[])
                {
                    boolean trySmartVertexAngles = true;

                    double smartVertexAngles[] = null;
                    if (trySmartVertexAngles)
                    {
                        int nVerts = mesh.verts.size();
                        int nEdges = mesh.edges.size();
                        boolean didVert[] = new boolean[nVerts]; // initialized to false
                        smartVertexAngles = new double[nVerts]; // initialized to 0
                        double angsAroundThisVert[] = new double[nEdges]; // scratch, worst case arity

                        FORI (iEdge0, nEdges)
                        {
                            Mesh.Edge edge0 = mesh.getEdge(iEdge0);
                            Mesh.Vertex vert = edge0.initialVertex();
                            if (vert == null || didVert[vert.myIndex()])
                                continue;
                            didVert[vert.myIndex()] = true;

                            // walk CCW around vertex
                            Mesh.Edge thisEdge = edge0;
                            int nAngsAroundThisVert = 0;
                            do {
                                assert(thisEdge.initialVertex() == vert);
                                double thisAng =
                                    thisEdge.direction != null
                                  ? Math.atan2(thisEdge.direction[1],
                                               thisEdge.direction[0])
                                  : Math.atan2(thisEdge.finalVertex().y()-thisEdge.initialVertex().y(),
                                               thisEdge.finalVertex().x()-thisEdge.initialVertex().x());
                                angsAroundThisVert[nAngsAroundThisVert++] = thisAng;
                            } while ((thisEdge = thisEdge.prev().opposite()) != edge0);

                            SortStuff.sort(angsAroundThisVert, 0, nAngsAroundThisVert);
                            double biggestGap = -1.;
                            double angOfBiggestGap = 0.;
                            FORI (iAng, nAngsAroundThisVert)
                            {
                                double thisAng = angsAroundThisVert[iAng];
                                double nextAng = angsAroundThisVert[(iAng+1)%nAngsAroundThisVert];
                                double thisGap = nextAng - thisAng;
                                if (thisGap < 0.)
                                {
                                    thisGap += 2*Math.PI;
                                }
                                if (thisGap > biggestGap)
                                {
                                    biggestGap = thisGap;
                                    angOfBiggestGap = thisAng + thisGap/2.;
                                }
                            }
                            smartVertexAngles[vert.myIndex()] = angOfBiggestGap;
                        }
                    }



                    if (labelVertsFlag)
                    {
                        //
                        // Vertex labels
                        //
                        ArrayList verts = mesh.verts;
                        FORIDOWN (iVert, verts.size())
                        {
                            Mesh.Vertex vert = (Mesh.Vertex)verts.get(iVert);
                            if (vert.weight < 0. && !showInsideOutParts)
                                continue;
                            double X = vert.X();
                            double Y = vert.Y();
                            double Z = vert.Z();
                            double W = vert.W();

                            // TODO: re-think the whole damn pipeline, should not be any negative W's at this point I don't think.
                            // TODO: and why isn't this succeeding? I thought when we generated dual verts we did it properly so w is equal to weight? oh it's because primal verts W sometimes come from unwrapping from sphere
                            //assert(W == vert.weight);
                            if (W < 0.)
                            {
                                //System.out.println("ow! label for vertex "+iVert+" needed correcting, W="+W);
                                X *= -1.;
                                Y *= -1.;
                                Z *= -1.;
                                W *= -1.;
                            }

                            double ang;
                            if (trySmartVertexAngles)
                            {
                                ang = smartVertexAngles[iVert];
                            }
                            else
                            {
                                ang = Math.random() * 2*Math.PI;
                            }
                            double offr = 5/mg.getScaleX(); // pixels
                            double offx = offr*Math.cos(ang);
                            double offy = offr*Math.sin(ang);
                            double offmax = MAX(ABS(offx),ABS(offy));

                            mg.drawString("v"+iVert,
                                          X+offx*W,
                                          Y+offy*W,
                                          Z,
                                          W,
                                          -offx/offmax, offy/offmax);
                        }
                    }

                    if (labelEdgesFlag)
                    {
                        //
                        // Edge labels
                        //
                        ArrayList edges = mesh.edges;
                        FORIDOWN (iEdge, edges.size())
                        {
                            if (whichEdgesGotDrawn != null
                             && !whichEdgesGotDrawn[iEdge])
                                continue;

                            Mesh.Edge edge = (Mesh.Edge)edges.get(iEdge);
                            Mesh.Vertex v0 = edge.initialVertex();
                            Mesh.Vertex v1 = edge.finalVertex();

                            int nParts = showInsideOutParts && edgeInitialCoords!=null ? 2 : 1;
                            FORI (iPart, nParts)
                            {
                                double x0,y0,z0, x1,y1,z1;
                                if (edgeInitialCoords != null)
                                {
                                    if (edgeInitialCoords[iEdge][iPart] == null)
                                        continue;
                                    int oEdge = edge.opposite().myIndex();
                                    x0 = edgeInitialCoords[iEdge][iPart][0]/edgeInitialCoords[iEdge][iPart][3];
                                    y0 = edgeInitialCoords[iEdge][iPart][1]/edgeInitialCoords[iEdge][iPart][3];
                                    z0 = edgeInitialCoords[iEdge][iPart][2]/edgeInitialCoords[iEdge][iPart][3];
                                    x1 = edgeInitialCoords[oEdge][iPart][0]/edgeInitialCoords[oEdge][iPart][3];
                                    y1 = edgeInitialCoords[oEdge][iPart][1]/edgeInitialCoords[oEdge][iPart][3];
                                    z1 = edgeInitialCoords[oEdge][iPart][2]/edgeInitialCoords[oEdge][iPart][3];
                                }
                                else
                                {
                                    double rayLength = 1.;
                                    x0 = (v0!=null ? v0.x() : v1.x() - edge.direction[0]*rayLength);
                                    y0 = (v0!=null ? v0.y() : v1.y() - edge.direction[1]*rayLength);
                                    z0 = (v0!=null ? v0.z() : v1.z() - edge.direction[2]*rayLength);
                                    x1 = (v1!=null ? v1.x() : v0.x() + edge.direction[0]*rayLength);
                                    y1 = (v1!=null ? v1.y() : v0.y() + edge.direction[1]*rayLength);
                                    z1 = (v1!=null ? v1.z() : v0.z() + edge.direction[2]*rayLength);
                                }

                                double x = (x0+x1)/2;
                                double y = (y0+y1)/2;
                                double z = (z0+z1)/2;
                                double ang = Math.PI/2 + Math.atan2(y1-y0, x1-x0);
                                if (isDualMesh)
                                    ang += Math.PI;
                                double offr = 2/mg.getScaleX(); // pixels
                                double offx = offr*Math.cos(ang);
                                double offy = offr*Math.sin(ang);
                                double offmax = MAX(ABS(offx),ABS(offy));
                                mg.drawString("e"+iEdge,
                                              x+offx,
                                              y+offy,
                                              z,
                                              1.,
                                              -offx/offmax, offy/offmax);
                            }
                        }
                    }
                } // drawLabels


                //
                // Experimental--
                // show the net of the faces in 3d, flattened onto the xy plane
                //
                void drawFlattenedNet(MyGraphics3D mg, Mesh mesh, Mesh dualMesh, double dualEdgeInitialCoords[/*nDualEdges*/][/*2*/][/*4*/], int nVerts, int nEdges, java.awt.Color dualEdgeColors[/*nEdges*/])
                {
                    // We want a rotate/translate matrix for each dual face
                    // (i.e. each primal vertex)
                    // that takes the face to the xy plane,
                    // in the form of the net.

                    // Starting face should be the one containing the origin,
                    // but for now we'll just use the dual vertex
                    // closest to the origin.
                    int iStartVert;
                    {
                        int iClosest = -1;
                        double closestDist2 = Double.POSITIVE_INFINITY;
                        FORI(iVert, nVerts)
                        {
                            Mesh.Vertex vert = mesh.getVert(iVert);
                            double dist2 = SQR(vert.x()) + SQR(vert.x());
                            if (dist2 < closestDist2)
                            {
                                iClosest = iVert;
                                closestDist2 = dist2;
                            }
                        }
                        //PRINT(iClosest);
                        iStartVert = iClosest;
                    }


                    double dualFaceMats[][][] = new double[nVerts][][];
                    //
                    // Compute the matrix for the starting dual face.
                    //
                    {
                        Mesh.Vertex startVert = mesh.getVert(iStartVert);

                        //   p dot (x,y,1) == offset
                        //  px,py,scaleZ*pz dot scaleZ*x,scaleZ*y,1 == scaleZ * offset
                        double startDualFacePlaneNormal[] = {localScaleZ*startVert.x(), localScaleZ*startVert.y(), 1}; // not unit length
                        double startDualFacePlaneOffset = -localScaleZ*startVert.z(); // magic!  I don't know why, but this is the correct value

                        // what translation by a multiple of startDualFacePlaneNormal
                        // will take the dual face plane to the origin?
                        // The equation of the face plane is:
                        //      n dot x == offset
                        // we want s such that:
                        //      n dot (x + s*n) == 0
                        // i.e. (n dot x) + s * (n dot n) == 0
                        //      s = -(n dot x) / (n dot n)
                        //        = -offset / (n dot n)
                        double s = -startDualFacePlaneOffset / VecMath.normsqrd(startDualFacePlaneNormal);
                        double translateVector[] = VecMath.sxv(s, startDualFacePlaneNormal);
                        double translateMat[][] = {
                            {1,0,0,0},
                            {0,1,0,0},
                            {0,0,1,0},
                            {translateVector[0],
                             translateVector[1],
                             translateVector[2],1},
                        };
                        double rotMat33[][] = parallelTransport(VecMath.normalize(startDualFacePlaneNormal),
                                                                new double[]{0,0,1});
                        // XXX bleah, this seems awkward
                        double rotMat44[][] = VecMath.identitymat(4);
                        VecMath.copymat(rotMat44, rotMat33);
                        double M0[][] = VecMath.mxm(translateMat, rotMat44);
                        dualFaceMats[iStartVert] = M0;
                    }

                    // make a data structure that allows us to find neighbors of each dual face easily...
                    Mesh.Edge firstEdgeStartingAtVertex[] = new Mesh.Edge[nVerts]; // null initially
                    Mesh.Edge nextEdgeStartingAtVertex[] = new Mesh.Edge[nEdges]; // null initially
                    FORI (iEdge, nEdges)
                    {
                        Mesh.Edge edge = mesh.getEdge(iEdge);
                        int iVert = edge.initialVertex().myIndex();
                        nextEdgeStartingAtVertex[edge.myIndex()] = firstEdgeStartingAtVertex[iVert];
                        firstEdgeStartingAtVertex[iVert] = edge;
                    }

                    //
                    // Now traverse outwards from the starting dual face,
                    // computing the transform at each new face
                    // and putting it into dualFaceMats.
                    // 

                    int stack[] = new int[nVerts];
                    int stackSize = 0;
                    stack[stackSize++] = iStartVert;
                    while (stackSize > 0)
                    {
                        int iVert = stack[--stackSize];
                        double M0[][] = dualFaceMats[iVert];
                        double M0rotPart[][] = new double[3][3];
                        VecMath.copymat(M0rotPart, M0);
                        // For all neighbor verts whose matrix has not yet been computed...
                        for (Mesh.Edge edge = firstEdgeStartingAtVertex[iVert];
                             edge != null;
                             edge = nextEdgeStartingAtVertex[edge.myIndex()])
                        {
                            int iEdge = edge.myIndex();
                            Mesh.Vertex vertJ = edge.finalVertex();
                            int jVert = vertJ.myIndex();
                            if (theNet._edgeStatuses[iEdge] == Net.CUT)
                                continue;
                            if (dualFaceMats[jVert] != null) // this can happen if there are some undecideds
                                continue;

                            // Compute matrix for jVert'th dual face.
                            // The incremental matrix should rotate (normal times M0)
                            // to the +z axis, while keeping (dual edge times M0) fixed.

                            // XXX correct for scale!
                            double jDualFacePlaneNormal[] = {localScaleZ*vertJ.x(), localScaleZ*vertJ.y(), 1}; // not unit length
                            jDualFacePlaneNormal = VecMath.vxm(jDualFacePlaneNormal, M0rotPart);


                            Mesh.Edge dualEdge = dualMesh.getEdge(iEdge);
                            Mesh.Vertex someVertOnDualEdge = dualEdge.initialVertex();
                            if (someVertOnDualEdge == null)
                                someVertOnDualEdge = dualEdge.finalVertex();
                            // XXX correct for scale!
                            double thisDualVertCoords[] = {someVertOnDualEdge.x(),
                                                           someVertOnDualEdge.y(),
                                                           someVertOnDualEdge.z()};
                            thisDualVertCoords = VecMath.vxm(thisDualVertCoords, M0);




                            double rotMat33[][] = parallelTransport(VecMath.normalize(jDualFacePlaneNormal),
                                                                    new double[]{0,0,1});
                            // XXX bleah, this seems awkward
                            double rotMat44[][] = VecMath.identitymat(4);
                            VecMath.copymat(rotMat44, rotMat33);

                            // M = M0 * (translate dual vert to origin)
                            //        * rotate
                            //        * (translate origin to dual vert)
                            double translateDualVertToOrigin[][] = {
                                {1,0,0,0},
                                {0,1,0,0},
                                {0,0,1,0},
                                {-thisDualVertCoords[0],
                                 -thisDualVertCoords[1],
                                 -thisDualVertCoords[2],1},
                            };
                            double translateOriginToDualVert[][] = {
                                {1,0,0,0},
                                {0,1,0,0},
                                {0,0,1,0},
                                {thisDualVertCoords[0],
                                 thisDualVertCoords[1],
                                 thisDualVertCoords[2],1},
                            };
                            double M[][] = VecMath.mxmxmxm(M0,
                                                       translateDualVertToOrigin,
                                                       rotMat44,
                                                       translateOriginToDualVert);
                            dualFaceMats[jVert] = M;

                            stack[stackSize++] = jVert;
                        }
                    }




                    FORI (iEdge, nEdges)
                    {
                        Mesh.Edge edge = mesh.getEdge(iEdge);
                        Mesh.Vertex v0 = edge.initialVertex();
                        Mesh.Edge dualEdge = dualMesh.getEdge(iEdge);
                        double M[][] = dualFaceMats[v0.myIndex()];
                        if (dualEdgeInitialCoords[iEdge][0] == null)
                            continue; // edge has no positively oriented part
                        double coords[][] = {
                            dualEdgeInitialCoords[iEdge][0],
                            dualEdgeInitialCoords[dualEdge.opposite().myIndex()][0],
                        };
                        FORI (i, 2)
                            coords[i] = VecMath.vxm(coords[i], M);
                        if (theNet._edgeStatuses[iEdge] == Net.CUT)
                            mg.setColor(java.awt.Color.yellow);
                        else
                            mg.setColor(new java.awt.Color(0.f,0.f,1/4.f)); // XXX darkBlue
                        mg.setColor(dualEdgeColors[iEdge]);
                        mg.drawLine(coords[0][0],
                                    coords[0][1],
                                    coords[0][2],
                                    coords[1][0],
                                    coords[1][1],
                                    coords[1][2],
                                    antiAliasingFlag);
                    }
                } // drawFlattenedNet



            private double sphericalTriangleArea(double v0[],
                                                 double v1[],
                                                 double v2[])
            {
                // inward normals
                double n0[] = VecMath.normalize(VecMath.vxv3(v1,v2));
                double n1[] = VecMath.normalize(VecMath.vxv3(v2,v0));
                double n2[] = VecMath.normalize(VecMath.vxv3(v0,v1));
                double externalAngle0 = VecMath.angleBetweenUnitVectors(n1,n2);
                double externalAngle1 = VecMath.angleBetweenUnitVectors(n2,n0);
                double externalAngle2 = VecMath.angleBetweenUnitVectors(n0,n1);
                // sum = 2*pi -> area = 0
                // sum = 0 -> area = 2*pi
                // area = 2*pi - sum
                double area = 2*Math.PI - (externalAngle0+externalAngle1+externalAngle2);
                double det = VecMath.vxvxv3(n0, n1, n2);
                if (det < 0)
                    area *= -1;
                return area;
            } // sphericalTriangleArea

            // experimental... spherical barycentrics based on triangle areas.
            // XXX was this just an experiment? get rid?
            private double[] sbary(final double v0[],
                                   final double v1[], double t1,
                                   final double v2[], double t2)
            {
                double t0 = 1. - (t1 + t2);
                double Area = sphericalTriangleArea(v0,v1,v2);

                // find s1,s2 such that bary(v0,v1,s1,v2,s2) normalized
                // has the desired areas.
                double targetArea1 = Area * t1;
                double targetArea2 = Area * t2;
                assert(false); // coverate
                NewtonSolver.Fun fun = new NewtonSolver.Fun(2) {
                    @Override public void f(double x[], double answer[])
                    {
                        double s1 = x[0];
                        double s2 = x[1];
                        double v[] = VecMath.normalize(VecMath.bary(v0,v1,s1,v2,s2));
                        double area1 = sphericalTriangleArea(v0,v,v2);
                        double area2 = sphericalTriangleArea(v0,v1,v);
                        answer[0] = area1;
                        answer[1] = area2;
                    }
                };
                double x[] = {t1,t2}; // initial guess
                double y[] = {targetArea1, targetArea2};
                NewtonSolver.solve(x, y, fun,
                                   10, // minIterations-- probably not needed, but that's what the default used to be and I haven't tested this since making it explicit
                                   20,
                                   false); // adaptiveFlag XXX could experiment with this if needed
                double s1 = x[0];
                double s2 = x[1];
                double v[] = VecMath.normalize(VecMath.bary(v0,v1,s1,v2,s2));
                return v;
            }

            // PAINT/DISPLAY/DRAW
            public void paintComponent(java.awt.Graphics frontBufferGraphics)
            {
                if (eventVerbose >= 1) System.out.println("in paint");

                makeSureBackBufferIsRight();
                java.awt.Graphics g;
                java.awt.Dimension size;
                if (doubleBufferFlag)
                {
                    g = backBufferImage.getGraphics();
                    size = new java.awt.Dimension(backBufferImage.getWidth(null),
                                                  backBufferImage.getHeight(null));
                }
                else
                {
                    g = frontBufferGraphics;
                    size = getSize();
                }


                final boolean wrapAroundSphereFlagValue = wrapAroundSphereFlag.get();
                double minSize = (double)MIN(size.width, size.height);
                MyGraphics3D mg = new MyGraphics3D(g, size,
                                        -size.width/minSize,size.width/minSize,
                                        -size.height/minSize,size.height/minSize,
                                        getLocalToWorld());
                mostRecentGraphics = mg;

                if (implementAntiAliasingInHardware)
                {
                    graphicsAntiAliasingSetter.setAntiAliasing(g,
                                                               antiAliasingFlag,
                                                               //1
                                                               eventVerbose
                                                               );
                }


                //
                // Clear to black...
                //
                mg.setColor(java.awt.Color.black);
                mg.fillWindow();

                if (showGridFlag)
                {
                    // experiment with grids... not sure exactly what I want yet

                    double gridBrightnessValue = gridBrightness.get();

                    double xmax = size.width/minSize;
                    double ymax = size.height/minSize;
                    

                    // bigger levels are finer
                    // level 0 : 1 apart
                    // level 1: 1/2 apart
                    // level 2: 1/4 apart
                    // etc.
                    int nLevels = 7;
                    FORIDOWN(iLevel, nLevels)
                    {
                        // color for grid and circle
                        {
                            double start = gridBrightnessValue;
                            double speed = 1./3.;
                            float luminance = (float)(start * Math.pow(.5, iLevel*speed));
                            mg.setColor(new java.awt.Color(luminance,luminance,luminance));
                        }

                        int gridLinesPerUnit = 1 << iLevel;
                        FORI (iGridLine, gridLinesPerUnit * xmax)
                        {
                            if (iLevel == 0
                             || iGridLine % 2 == 1)
                            {
                                double x = iGridLine / (double)gridLinesPerUnit;
                                mg.drawLine(x, -ymax, 0.,
                                            x,  ymax, 0.,
                                            antiAliasingFlag);
                                mg.drawLine(-x, -ymax, 0.,
                                            -x,  ymax, 0.,
                                             antiAliasingFlag);
                            }
                        }
                        FORI (iGridLine, gridLinesPerUnit * ymax)
                        {
                            if (iLevel == 0
                             || iGridLine % 2 == 1)
                            {
                                double y = iGridLine / (double)gridLinesPerUnit;
                                mg.drawLine(-xmax, y, 0.,
                                             xmax, y, 0.,
                                             antiAliasingFlag);
                                mg.drawLine(-xmax, -y, 0.,
                                             xmax, -y, 0.,
                                             antiAliasingFlag);
                            }
                        }



                    }
                }

                boolean showHorizon = true;
                if (showHorizon)
                {
                    double eyeInLocalSpace[] = VecMath.mxv(getRotMat(), eye); // multiply on wrong side, i.e. apply transpose i.e. inverse
                    // gag, that returned a 4d vector
                    eyeInLocalSpace = (double[])Arrays.subarray(eyeInLocalSpace, 0, 3);
                    if (!wrapAroundSphereFlag.get())
                        eyeInLocalSpace[2] /= MAX(localScaleZ, 1e-6);

                    int nPoints = 360;
                    double horizonPoints[][] = theSurface.horizon(0.,eyeInLocalSpace,nPoints);
                    mg.setColor(java.awt.Color.red);
                    FORI (iPoint, horizonPoints.length)
                        mg.drawPoint(horizonPoints[iPoint][0],
                                     horizonPoints[iPoint][1],
                                     horizonPoints[iPoint][2],
                                     1);
                }

                if (showSmallestEnclosingDisk)
                {
                    int nVerts = mesh.verts.size();

                    double xys[][] = new double[nVerts][2];
                    // actually this is damn silly... a 3d sphere might make sense... but currently we only know how to draw circles, not ellipses
                    FORI (iVert, nVerts)
                    {
                        Mesh.Vertex vert = mesh.getVert(iVert);
                        mg.xform(vert.X(), vert.Y(), vert.Z(), vert.W(), xys[iVert]);
                    }
                    double center[] = new double[2];
                    //MiniBall.verboseLevel = 2; // 2 for nice diagram
                    double radiusSquared = MiniBall.MiniBall(center, xys);
                    MiniBall.verboseLevel = 0;
                    if (pRotationalSymmetry.get() * (leftRightSymmetry.get() ? 2 : 1) <= 3) // otherwise the test degenerates-- more than 3 points on circle, not general position
                    {
                        //PRINTARRAY(xys);
                        //MiniBall.verboseLevel = 1;
                        assert(MiniBall.IsMiniBall(center, radiusSquared, xys.length, xys));
                        MiniBall.verboseLevel = 0;
                    }
                    if (radiusSquared >= 0.)
                    {
                        double radius = Math.sqrt(radiusSquared);
                        //PRINTVEC(center);
                        //PRINT(radius);

                        float luminance = .05f; // currently grid is .09f
                        mg.setColor(new java.awt.Color(luminance,luminance,luminance));
                        if (GT(radius, 0., 1e-6)) // otherwise I think the arc drawing might go into an infinite loop, not sure.  oh hmm, maybe that was just with NaN, I think I can remove this check
                            mg.drawThickArc(center[0]-radius, center[1]-radius,
                                            2*radius, 2*radius,
                                            0., Math.PI*2,
                                            1., // thicknessInPixels,
                                            antiAliasingFlag);
                    }
                }





                //
                // Try optimizing the heights...
                // XXX paint is a funky place for this
                //
                if (optimizeFlag.get())
                    mesh.findAndApplyOptimalVertexHeights(optimizationType);

                boolean makeVert0CoplanarWith145Flag = false;
                if (makeVert0CoplanarWith145Flag)
                {
                    // XXX total hack
                    Mesh.Vertex v0 = mesh.getVert(0);
                    Mesh.Vertex v1 = mesh.getVert(1);
                    Mesh.Vertex v4 = mesh.getVert(4);
                    Mesh.Vertex v5 = mesh.getVert(5);
                    double A[] = {v1.Xnaive(), v1.Ynaive(), v1.Hnaive() - .5 * (SQR(v1.Xnaive()) + SQR(v1.Ynaive()))};
                    double B[] = {v4.Xnaive(), v4.Ynaive(), v4.Hnaive() - .5 * (SQR(v4.Xnaive()) + SQR(v4.Ynaive()))};
                    double C[] = {v5.Xnaive(), v5.Ynaive(), v5.Hnaive() - .5 * (SQR(v5.Xnaive()) + SQR(v5.Ynaive()))};
                    double N[] = VecMath.vxv3(VecMath.vmv(B,A),
                                              VecMath.vmv(C,A));
                    double desiredDot = VecMath.dot(N,A);
                    double D[] = {v0.Xnaive(), v0.Ynaive(), v0.Hnaive()};
                    // Find D[2] such that N dot D == desiredDot
                    // I.e. N[0]*D[0] + N[1]*D[1] + N[2]*D[2] == desiredDot
                    D[2] = (desiredDot - (N[0]*D[0] + N[1]*D[1])) / N[2];

                    v0.setHnaive(D[2]
                          + .5 * (SQR(v0.Xnaive()) + SQR(v0.Ynaive())));
                }



                //
                // Draw the dual diagram in color...
                //
                java.awt.Color lightBlue = new java.awt.Color(128,128,255);
                java.awt.Color darkGreen = new java.awt.Color(0,32,0);
                java.awt.Color darkRed = new java.awt.Color(64,0,0);
                java.awt.Color darkCyan = new java.awt.Color(0,32,32);
                java.awt.Color darkMagenta = new java.awt.Color(64,0,64);
                /*
                java.awt.Color dualVertSelectionColor = java.awt.Color.green;
                java.awt.Color dualColor = java.awt.Color.red;
                java.awt.Color dualColorBothSelected = lightBlue;
                java.awt.Color dualColorOneSelectedBad = java.awt.Color.magenta;
                java.awt.Color dualColorOneSelectedGood = java.awt.Color.green;
                java.awt.Color perpColorBad = new java.awt.Color(64,0,64); // dark magenta
                java.awt.Color perpColorGood = new java.awt.Color(0,32,0); // dark green
                */
                java.awt.Color dualVertSelectionColor = java.awt.Color.yellow;
                java.awt.Color dualColor = lightBlue;
                java.awt.Color dualColorBothSelected = java.awt.Color.yellow;
                java.awt.Color dualColorOneSelectedBad = java.awt.Color.red;
                java.awt.Color dualColorOneSelectedGood = java.awt.Color.green;
                java.awt.Color perpColorBad = darkRed;
                java.awt.Color perpColorGood = darkGreen;

                int nVerts = mesh.verts.size();
                int nEdges = mesh.edges.size();
                Mesh dualMesh = getDualMesh();
                int nDualVerts = dualMesh.verts.size();
                int nDualEdges = dualMesh.edges.size();
                assert(nDualEdges == nEdges);

                //
                // Gather coords of dual verts and dual ray ends.
                // dualEdgeInitialCoords[iDualEdge][iPart] will be dualVertCoords[initial vertex of this part]
                // if there is an initial vertex, otherwise an appropriately computed
                // place to draw the edge from.
                // The coord will be negated if necessary so that the w coord is nonnegative
                // (even if the vert coord's w is negative-- need to get rid of that)
                // What are the "parts" of a dual edge?  Well, part 0 is the part of it on the primal sheet,
                // and part 1 is the part of it on the dual sheet.
                //     - an edge connecting two dual verts on first sheet has only part 0.
                //     - an edge connecting two dual verts on second sheet has only part 1.
                //     - an edge from initial vert on first sheet to final vert on second:
                //        - part 0 is from initial vertex to ray display end, on primal sheet
                //        - part 1 is from ray display beginning to final vertex, on dual sheet
                //     - an edge from initial vert on second sheet to final vert on first:
                //        - part 0 is from ray display beginning to final vert, on first sheet
                //        - part 1 is from initial vert to ray display end, on second sheet
                double dualVertCoords[][] = new double[nDualVerts][]; // TODO: wait a minute, there's also dualVertsHomoNormalized or something
                double dualEdgeInitialCoords[/*nEdges*/][/*2*/][/*4*/] = new double[nEdges][2][];
                {
                    FORI (iDualVert, nDualVerts)
                    {
                        Mesh.Vertex v = dualMesh.getVert(iDualVert);
                        dualVertCoords[iDualVert] = new double[]{v.X(), v.Y(), v.Z(), v.W()};
                    }
                    boolean naiveDualEdgesFlagValue = naiveDualEdgesFlag.get();
                    FORI (iDualEdge, nDualEdges)
                    {
                        Mesh.Edge dualEdge = dualMesh.getEdge(iDualEdge);
                        Mesh.Vertex v0 = dualEdge.initialVertex();
                        Mesh.Vertex v1 = dualEdge.finalVertex();
                        double v0coords[] = v0!=null ? dualVertCoords[v0.myIndex()] : null;
                        double v1coords[] = v1!=null ? dualVertCoords[v1.myIndex()] : null;
                        // TODO REGARDING NEGATIVE WEIGHTS: don't test for [3]<0, test for weight<0.  I think?  not sure.

                        if (naiveDualEdgesFlagValue)
                        {
                            // naive way-- all internal edges
                            if (v0 != null)
                            {
                                dualEdgeInitialCoords[iDualEdge][0] = v0coords[3]<0?VecMath.sxv(-1.,v0coords) : v0coords;
                            }
                            else if (v1 != null)
                            {
                                dualEdgeInitialCoords[iDualEdge][0] = new double[] {
                                    // TODO: do math in homo coords, from v1coords, not v1.x(),y(),z()
                                    v1.x() - dualEdge.direction[0],
                                    v1.y() - dualEdge.direction[1],
                                    v1.z() - dualEdge.direction[2],
                                    1.,
                                };
                            }
                        }
                        else
                        {
                            // proper external edges
                            if (v0 != null)
                                dualEdgeInitialCoords[iDualEdge][v0coords[3]<0.?1:0] = v0coords[3]<0.?VecMath.sxv(-1.,v0coords) : v0coords;
                            if (v1 != null && (v0==null || (v1coords[3]<0.) != (v0coords[3]<0.)))
                            {
                                assert(dualEdgeInitialCoords[iDualEdge][v1coords[3]<0.?1:0] == null);
                                dualEdgeInitialCoords[iDualEdge][v1coords[3]<0.?1:0] = new double[] {
                                    // TODO: do math in homo coords, from v1coords, not v1.x(),y(),z()
                                    v1.x() - dualEdge.direction[0],
                                    v1.y() - dualEdge.direction[1],
                                    v1.z() - dualEdge.direction[2],
                                    1.,
                                };
                            }
                        }

                        if (v0==null && v1==null)
                        {
                            // Both ends infinite.
                            // This edge is the dual of an isolated edge or whisker
                            // in the primal.
                            // In this case we want to draw a perpendicular line,
                            // of length 1.
                            //
                            // We know the edge direction,
                            // we need its center.
                            // this will lie directly above (or below)
                            // the point on the dual (original primal) edge line
                            // that's deepest in the paraboloid.
                            // the formula for this has to be
                            // lerp(w0,w1,t) where t is some simple
                            // multiple of w0.h-w1.h I bet.
                            Mesh.Edge primalEdge = mesh.getEdge(iDualEdge);
                            Mesh.Vertex w0 = primalEdge.initialVertex();
                            Mesh.Vertex w1 = primalEdge.finalVertex();
                            double t = .5 + (w0.h() - w1.h()) / (SQR(w1.x()-w0.x())+SQR(w1.y()-w0.y())); // XXX beware the zero divide
                            double p[] = {LERP(w0.x(),w1.x(),t),
                                          LERP(w0.y(),w1.y(),t),
                                          LERP(w0.z(),w1.z(),t)};
                            // whatever depth it was below the paraboloid, raise it to that height above it for the dual
                            p[2] = LERP(p[2], -.5*(SQR(p[0])+SQR(p[1])), 2.);
                            // -.5 instead of +.5 in the following is empirical... if we do it the other way, it ends up looking like an external edge
                            VecMath.vpsxv(p, p, -.5, dualEdge.direction); // XXX TODO: should dualEdge.direction be homogeneous?
                            p = Arrays.append(p, 1.);
                            dualEdgeInitialCoords[iDualEdge][0] = p; // TODO: this always makes these positive. is that right?
                        }
                    }
                }


                //
                // Classify the primal and dual elements
                // as front facing, back facing, or side (neither front nor back).
                //
                int faceFacings[] = new int[nDualVerts+1];
                int edgeFacings[] = new int[nEdges];
                int vertFacings[] = new int[nVerts]; 
                int dualFaceFacings[] = new int[nVerts];
                int dualEdgeFacings[] = new int[nEdges];
                int dualVertFacings[] = new int[nDualVerts+1];
                double eyeInLocalSpace[] = VecMath.mxv(getRotMat(), eye); // multiply on wrong side, i.e. apply transpose i.e. inverse
                eyeInLocalSpace[2] /= MAX(localScaleZ, 1e-6);
                getFacings(eyeInLocalSpace, mesh, dualMesh, faceFacings, edgeFacings, vertFacings, wrapAroundSphereFlag.get(), centerSphereFlag.get(), wrapSphereCurvature.get());
                getFacings(eyeInLocalSpace, dualMesh, mesh, dualFaceFacings, dualEdgeFacings, dualVertFacings, wrapAroundSphereFlag.get(), centerSphereFlag.get(), wrapSphereCurvature.get());
                //PRINTARRAY(faceFacings);
                //PRINTARRAY(dualFaceFacings);

                //
                // Draw the primal mesh in white.
                // Draw it first (before dual)
                // since the primal edges tend to be behind
                // the dual edges in 3d (primal is inscribed, dual is circumscribed)
                //

                double vertCoordsHomo[][] = new double[nVerts][4];
                double dualVertCoordsHomoNormalized[][] = new double[nDualVerts][4];
                FORI (iVert, nVerts)
                {
                    Mesh.Vertex v = mesh.getVert(iVert);
                    vertCoordsHomo[iVert] = new double[]{v.X(), v.Y(), v.Z(), v.W()};
                }
                FORI (iDualVert, nDualVerts)
                {
                    Mesh.Vertex v = dualMesh.getVert(iDualVert);
                    dualVertCoordsHomoNormalized[iDualVert] = new double[]{v.X(), v.Y(), v.Z(), v.W()};
                    VecMath.normalize(dualVertCoordsHomoNormalized[iDualVert],
                                      dualVertCoordsHomoNormalized[iDualVert]);
                }

                // bunch of stuff that only gets set if drawing dual diagram...
                java.awt.Color dualVertColors[] = null;
                java.awt.Color dualEdgeColors[] = null;
                double avg[] = null; // we set it to non-null if drawing one
                double lagoonCenter[] = null; // we set it to non-null if drawing one
                double momentAndWeightStrictlyBelowEachDualVertex[][] = null;
                boolean dualEdgeIsOffBalanceCut[] = null;

                int nOffBalanceCuts = -1;
                int nNonZeroLengthWholeEdges = -1;
                int nNonZeroLengthOffBalanceCuts = -1;

                boolean drawDualDiagramFlag = showDualVertsFlag.get()
                                           || showDualEdgesFlag.get();

                if (drawDualDiagramFlag)
                {
                    //
                    // Compute and store the dual mesh if necessary
                    //
                    if (highlightedDualEdgeIndex >= dualMesh.edges.size())
                    {
                        // prevent indexing out of bounds later on
                        System.out.println("clearing highlightedDualEdgeIndex since it's obviously wrong");
                        highlightedDualEdgeIndex = -1;
                    }


                    if (meshOfSelectedTris != mesh)
                    {
                        if (selectedTris.length > 0) System.out.println("MESH CHANGED-- INVALIDATING SELECTION!");
                        selectedTris = new int[][] {};
                        selectedDualVertIndices = new int[] {};
                        allDualVertsAreSelected = false;
                        meshOfSelectedTris = mesh;
                    }
                    if (true)
                    {
                        // Re-generate selectedDualVertIndices from selectedTris.
                        // Mesh topology may have changed, but we consider a tri selected
                        // if any of its three directed edges were part of a selected tri before.
                        // TODO: this only works well if not too much changed.  If a vertex is moved too fast,
                        // it can leave a swath of unselected verts :-(
                        //System.out.println("    Regenerting selectedDualVertIndices from selectedTris...");
                        int dualVertToIndexInSelectedDualVerts[] = Arrays.fill(dualMesh.verts.size(), -1);
                        {
                            IntArrayList selectedDualVertIndicesArrayList = new IntArrayList();
                            //PRINT(allDualVertsAreSelected);
                            if (allDualVertsAreSelected)
                            {
                                // select all dual verts of arity 3 with non-negative weight
                                FORI (iEdge, nEdges)
                                {
                                    Mesh.Edge edge = mesh.getEdge(iEdge);
                                    if (edge.next().next().next() != edge)
                                        continue; // not a triangle
                                    int i0 = edge.initialVertex().myIndex();
                                    int i1 = edge.finalVertex().myIndex();
                                    int i2 = edge.next().finalVertex().myIndex();
                                    if (i0 < i1 && i0 < i2) // if in canonical order
                                    {
                                        Mesh.Edge dualEdge = dualMesh.getEdge(iEdge);
                                        Mesh.Vertex dualVert = dualEdge.finalVertex();
                                        if (dualVert != null && dualVert.weight >= 0.)
                                        {
                                            dualVertToIndexInSelectedDualVerts[dualVert.myIndex()] = selectedDualVertIndicesArrayList.size();
                                            selectedDualVertIndicesArrayList.add(dualVert.myIndex());
                                        }
                                    }
                                }
                            }
                            else
                            {
                                java.util.HashMap edgeEndsToEdge = new java.util.HashMap();
                                assert(nEdges == dualMesh.edges.size());
                                FORI (iEdge, nEdges)
                                {
                                    Mesh.Edge edge = mesh.getEdge(iEdge);
                                    int i0 = edge.initialVertex().myIndex();
                                    int i1 = edge.finalVertex().myIndex();
                                    edgeEndsToEdge.put(""+i0+" "+i1, edge);
                                }
                                FORI (iSelectedTri, selectedTris.length)
                                {
                                    int tri[] = selectedTris[iSelectedTri];
                                    //System.out.println("        tri = "+Arrays.toStringCompact(tri));
                                    FORI (j, tri.length)
                                    {
                                        int i0 = tri[j];
                                        int i1 = tri[(j+1)%tri.length];
                                        Mesh.Edge edge = (Mesh.Edge)edgeEndsToEdge.get(""+i0+" "+i1);
                                        if (edge == null)
                                        {
                                            // there's no longer an edge between the two verts-- don't worry about it
                                            continue;
                                        }
                                        if (edge.next().next().next() != edge)
                                        {
                                            // there's no longer a tri here-- don't worry about it
                                            continue;
                                        }

                                        Mesh.Edge dualEdge = dualMesh.getEdge(edge.myIndex()); // right to left
                                        Mesh.Vertex dualVert = dualEdge.finalVertex();
                                        if (dualVert != null && dualVert.weight >= 0.)
                                        {
                                            if (dualVertToIndexInSelectedDualVerts[dualVert.myIndex()] != -1)
                                            {
                                                // already did this one
                                                continue;
                                            }
                                            dualVertToIndexInSelectedDualVerts[dualVert.myIndex()] = selectedDualVertIndicesArrayList.size();
                                            selectedDualVertIndicesArrayList.add(dualVert.myIndex());
                                        }
                                    }
                                }
                            }
                            selectedDualVertIndices = selectedDualVertIndicesArrayList.toArray();
                        }

                        // Re-generate selectedTris from selectedDualVerts.
                        //System.out.println("    Regenerting selectedTris from selectedDualVerts...");
                        {
                            selectedTris = new int[selectedDualVertIndices.length][3];
                            FORI (iEdge, nEdges)
                            {
                                Mesh.Edge edge = mesh.getEdge(iEdge);
                                int i0 = edge.initialVertex().myIndex();
                                int i1 = edge.finalVertex().myIndex();
                                int i2 = edge.next().finalVertex().myIndex();
                                if (i0 < i1 && i0 < i2) // if in canonical order
                                {
                                    Mesh.Edge dualEdge = dualMesh.getEdge(iEdge);
                                    Mesh.Vertex dualVert = dualEdge.finalVertex();
                                    if (dualVert != null)
                                    {
                                        int iSelected = dualVertToIndexInSelectedDualVerts[dualVert.myIndex()];
                                        if (iSelected != -1)
                                        {
                                            int tri[] = selectedTris[iSelected++];
                                            tri[0] = i0;
                                            tri[1] = i1;
                                            tri[2] = i2;
                                        }
                                    }
                                }
                            }
                        }
                    }

                    boolean isSelectedDualVert[] = new boolean[dualMesh.verts.size()]; // all false initially
                    FORI (i, selectedDualVertIndices.length)
                        if (selectedDualVertIndices[i] != -1)
                            isSelectedDualVert[selectedDualVertIndices[i]] = true;

                    dualVertColors = new java.awt.Color[dualMesh.verts.size()];
                    FORI (i, dualVertColors.length)
                        dualVertColors[i] = dualColor; // default-- may change if special
                    dualEdgeColors = new java.awt.Color[dualMesh.edges.size()];
                    FORI (i, dualEdgeColors.length)
                        dualEdgeColors[i] = dualColor; // default-- may change if special

                    //
                    // Set color for selected dual vertices,
                    // and compute their center of curvature
                    //
                    {
                        double momentAndAreaSum[] = new double[4]; // zeros
                        FORI (i, selectedDualVertIndices.length)
                        {
                            int ind = selectedDualVertIndices[i];
                            if (ind == -1)
                                continue;
                            dualVertColors[ind] = dualVertSelectionColor;
                            Mesh.Vertex dualVert = dualMesh.getVert(ind);
                            accumulateMomentAndArea(momentAndAreaSum, dualVert.momentAndArea);
                        }
                        if (selectedDualVertIndices.length > 0)
                            PRINTVEC(momentAndAreaSum);
                        double A = momentAndAreaSum[3];
                        if (A != 0.)
                            avg = new double[] {
                                momentAndAreaSum[0] / A,
                                momentAndAreaSum[1] / A,
                                momentAndAreaSum[2] / (A*A),
                            };
                    }

                    //
                    // If showing net, compute a net.
                    // For now, sweep upwards,
                    // color good edges green and off-balance ones red.
                    //

                    if (showNetFlag.get())
                    {
                        try
                        {
                            if (theNet == null)
                            {
                                boolean dualEdgeIsCut[] = new boolean[mesh.edges.size()]; // all false initially
                                boolean dualEdgeIsFold[] = null; // only needed in some cases

                                Mesh.Edge dualVertIndexToParentEdge[] = new Mesh.Edge[dualMesh.verts.size()]; // all null initially
                                int netMethodValue = netMethod.get();
                                if (netMethodValue == NETMETHOD_RANDOM)
                                {
                                    // don't be verbose about net if animating, that would be too much
                                    boolean netVerboseFlag = !(showNetFlag.get() && showNetFlowFlag.get());
                                    if (netVerboseFlag)
                                        System.out.println("   computing random net");

                                    // Use uniform random spanning tree algorithm, from David Bruce Wilson
                                    // "Generating Random Spanning Trees More Quickly than the Cover Time"

                                    Mesh.Edge edgesOut[][] = new Mesh.Edge[nDualVerts+1][];
                                    {
                                        int totalArity = 0;
                                        FORI (iDualVert, nDualVerts) // all but vertex at infinity
                                        {
                                            Mesh.Vertex dualVert = dualMesh.getVert(iDualVert);
                                            edgesOut[iDualVert] = new Mesh.Edge[dualVert.arity];
                                            totalArity += dualVert.arity;
                                        }
                                        // figure out arity of vertex at infinity.
                                        // total arity of all verts *including* the one at infinity
                                        // is twice num edges (i.e. num half-edges), so...
                                        int arityOfVertexAtInfinity = nDualEdges - totalArity;
                                        edgesOut[nDualVerts] = new Mesh.Edge[arityOfVertexAtInfinity];

                                        int nEdgesOut[] = new int[nDualVerts+1]; // all zeros initially
                                        FORI (iDualEdge, nDualEdges)
                                        {
                                            Mesh.Edge dualEdge = dualMesh.getEdge(iDualEdge);
                                            Mesh.Vertex v0 = dualEdge.initialVertex();
                                            int i0 = v0==null ? nDualVerts : v0.myIndex();

                                            edgesOut[i0][nEdgesOut[i0]++] = dualEdge;
                                        }
                                        FORI (iDualVert, nDualVerts+1)
                                            assert(nEdgesOut[iDualVert] == edgesOut[iDualVert].length);
                                    }

                                    // It's unclear from the paper whether it's okay
                                    // to start from an arbitrary vertex or what
                                    // (and whether a non-random initial vertex
                                    // results in skewing the distribution,
                                    // or making it more inefficient, or what).
                                    // The paper recommends starting at a random end
                                    // of a random edge.
                                    // But it seems to me that
                                    //     (1) a non-random initial vertex will *not* skew the distribution
                                    //         (since the trees rooted at any particular vertex
                                    //         are the same, by simple re-rooting,
                                    //         as the trees rooted at any other particular vertex)
                                    //     (2) starting at a random end of a random edge
                                    //         is the same as selecting an initial vertex
                                    //         with probability proportional to its arity
                                    //     (3) if doing that is advantageous for efficiency,
                                    //         then simply starting with the highest-arity
                                    //         vertex is even more advantageous
                                    // Typically the dual graph's vertices all have arity 3
                                    // except for the infinite vertex which has relatively high arity,
                                    // so we'll just let the root (start of the algorithm) be the infinite vertex.
                                    // Empirically (on delaunay triangulation of blue noise),
                                    // this does keep the running time low...
                                    // and furthermore the "next" data structure returned by using the infinite vertex
                                    // as root is exactly the one we'll need later.

                                    java.util.Random generator = new java.util.Random(0);
                                    int r = nDualVerts; // start with the infinite vertex

                                    // Algorithm RandomTreeWithRoot(r) from paper...
                                    // Since the infinite vertex doesn't have a root,
                                    // we can work directly with the final output array dualVertIndexToParentEdge
                                    // of size nDualVerts (rather than nDualVerts+1,
                                    // the size we'd need if starting at some other vertex),
                                    // which is initially all nulls.
                                    int nRandomCalls = 0;
                                    {
                                        boolean inTree[] = new boolean[nDualVerts+1]; // +1 to include infinite vertex; all false initially
                                        inTree[r] = true;
                                        FORI (iDualVert, nDualVerts+1)
                                        {
                                            int u = iDualVert;
                                            while (!inTree[u])
                                            {
                                                nRandomCalls++;
                                                Mesh.Edge dualEdge = edgesOut[u][generator.nextInt(edgesOut[u].length)];
                                                dualVertIndexToParentEdge[u] = dualEdge;
                                                u = dualEdge.finalVertex() != null ? dualEdge.finalVertex().myIndex() : nDualVerts;
                                            }
                                            u = iDualVert;
                                            while (!inTree[u])
                                            {
                                                inTree[u] = true;
                                                Mesh.Edge dualEdge = dualVertIndexToParentEdge[u];
                                                dualEdgeIsCut[dualEdge.myIndex()] = true;
                                                dualEdgeIsCut[dualEdge.opposite().myIndex()] = true;
                                                u = dualEdge.finalVertex() != null ? dualEdge.finalVertex().myIndex() : nDualVerts;
                                            }
                                        }
                                    }
                                    if (netVerboseFlag)
                                    {
                                        PRINT(nDualVerts);
                                        PRINT(nDualEdges);
                                        PRINT(nRandomCalls);
                                    }


                                    if (netVerboseFlag)
                                        System.out.println("   done computing random net");
                                }
                                else if (netMethodValue == NETMETHOD_UPWARD
                                      || netMethodValue == NETMETHOD_OUTWARD)
                                {
                                    FORIDOWN (iEdge, mesh.edges.size())
                                    {
                                        Mesh.Vertex triCenterDualVert = (dualMesh.getEdge(iEdge)).finalVertex();
                                        if (triCenterDualVert == null)
                                            continue; // primal face was not a triangle, or inside out
                                        if (triCenterDualVert.weight < 0.)
                                            continue; // primal face is on underside (if calculated underside), i.e. inside out
                                        if (dualVertIndexToParentEdge[triCenterDualVert.myIndex()] != null)
                                            continue; // definitely already did this vertex  XXX but root vertex stays null so it will be done 3 times :-(
                                        double triCenterDualVertPos[] = {
                                            triCenterDualVert.x(),
                                            triCenterDualVert.y(),
                                        };

                                        Mesh.Edge e0 = mesh.getEdge(iEdge);
                                        Mesh.Edge e1 = e0.next();
                                        Mesh.Edge e2 = e1.next();
                                        assert(e2.next() == e0);

                                        double threeDirections[][] = {
                                            (dualMesh.getEdge(e0.myIndex())).opposite().direction,
                                            (dualMesh.getEdge(e1.myIndex())).opposite().direction,
                                            (dualMesh.getEdge(e2.myIndex())).opposite().direction,
                                        };

                                        Mesh.Edge threeDualEdges[] = {
                                            (dualMesh.getEdge(e0.myIndex())).opposite(),
                                            (dualMesh.getEdge(e1.myIndex())).opposite(),
                                            (dualMesh.getEdge(e2.myIndex())).opposite(),
                                        };
                                        double threeFinalPositions[][] = new double[3][];
                                        FORI (i, 3)
                                        {
                                            Mesh.Edge dualEdge = threeDualEdges[i];
                                            Mesh.Vertex finalVertex = dualEdge.finalVertex();
                                            if (finalVertex == null)
                                                threeFinalPositions[i] = new double[] {Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY};
                                            else
                                                threeFinalPositions[i] = new double[] {finalVertex.x(), finalVertex.y()};
                                        }

                                        int bestSide = netMethodValue==NETMETHOD_OUTWARD ? 
                                                       /*
                                                       MAXI3(VecMath.dot(threeDirections[0], triCenterDualVertPos),
                                                             VecMath.dot(threeDirections[1], triCenterDualVertPos),
                                                             VecMath.dot(threeDirections[2], triCenterDualVertPos))
                                                       */
                                                       MAXI3(VecMath.normsqrd(threeFinalPositions[0]),
                                                             VecMath.normsqrd(threeFinalPositions[1]),
                                                             VecMath.normsqrd(threeFinalPositions[2]))
                                                     : MAXI3(threeDirections[0][1],
                                                             threeDirections[1][1],
                                                             threeDirections[2][1]);
                                        if (true && netMethodValue == NETMETHOD_UPWARD) // XXX do I want something like this for OUTWARD? the following isn't right in that case...
                                        {
                                            // Hack to simulate symbolic perterbation
                                            // by an infinitesimal rotation counterclockwise
                                            if (EQ(threeDirections[bestSide][1], threeDirections[(bestSide+1)%3][1], 1e-6)
                                             && LT(threeDirections[bestSide][0], threeDirections[(bestSide+1)%3][0], 1e-6))
                                            {
                                                bestSide = (bestSide+1)%3;
                                                if (EQ(threeDirections[bestSide][1], threeDirections[(bestSide+1)%3][1], 1e-6)
                                                 && LT(threeDirections[bestSide][0], threeDirections[(bestSide+1)%3][0], 1e-6))
                                                    bestSide = (bestSide+1)%3;
                                            }
                                            else
                                            {
                                                if (EQ(threeDirections[bestSide][1], threeDirections[(bestSide+2)%3][1], 1e-6)
                                                 && LT(threeDirections[bestSide][0], threeDirections[(bestSide+2)%3][0], 1e-6))
                                                    bestSide = (bestSide+2)%3;
                                            }
                                        }
                                        if (true)
                                        {
                                            // Hack to ensure that a negative-weight (assume that means boundary)
                                            // vertex never has a non-negative-weight vertex as parent
                                            Mesh.Edge threeEdges[] = {
                                                (dualMesh.getEdge(e0.myIndex())).opposite(),
                                                (dualMesh.getEdge(e1.myIndex())).opposite(),
                                                (dualMesh.getEdge(e2.myIndex())).opposite(),
                                            };
                                            if (triCenterDualVert.weight < 0.
                                             && threeEdges[bestSide].finalVertex() != null
                                             && threeEdges[bestSide].finalVertex().weight >= 0.)
                                            {
                                                int origBestSide = bestSide;
                                                bestSide = (threeDirections[(bestSide+1)%3][1] >= threeDirections[(bestSide+2)%3][1] ? (bestSide+1)%3 : (bestSide+2)%3);
                                                if (triCenterDualVert.weight < 0.
                                                 && threeEdges[bestSide].finalVertex() != null
                                                 && threeEdges[bestSide].finalVertex().weight >= 0.)
                                                {
                                                    bestSide = 3 - bestSide - origBestSide;
                                                }
                                            }
                                        }

                                        if (false) // set this to true to debug
                                        {
                                            PRINTARRAY(triCenterDualVert);
                                            double whereToDrawMark[] = {
                                                triCenterDualVert.x() + .05 * threeDirections[bestSide][0],
                                                triCenterDualVert.y() + .05 * threeDirections[bestSide][1],
                                            };
                                            mg.drawPoint(whereToDrawMark[0],
                                                         whereToDrawMark[1],
                                                         0.,
                                                         5);
                                        }


                                        Mesh.Edge e = bestSide==0 ? e0 : bestSide==1 ? e1 : e2;
                                        // remember each edge gets drawn in an arbitrary one of the two directions,
                                        // so we have to set the flag on both of them
                                        dualEdgeIsCut[e.myIndex()] = true;
                                        dualEdgeIsCut[e.opposite().myIndex()] = true;

                                        // Set parent... but only if the edge
                                        // is really upwards.
                                        // to avoid a cycle in the graph
                                        {
                                            Mesh.Edge maybeParentEdge = (dualMesh.getEdge(e.myIndex())).opposite();
                                            if (netMethodValue == NETMETHOD_OUTWARD)
                                                dualVertIndexToParentEdge[triCenterDualVert.myIndex()] = maybeParentEdge;
                                            else
                                                if (GT(maybeParentEdge.direction[1], 0, 1e-6)
                                                 || (EQ(maybeParentEdge.direction[1], 0, 1e-6)
                                                  && maybeParentEdge.direction[0] > 0.))
                                                dualVertIndexToParentEdge[triCenterDualVert.myIndex()] = maybeParentEdge;
                                        }
                                    }
                                } // UPWARD or OUTWARD
                                else if (netMethodValue == NETMETHOD_CUT_SHARPEST
                                      || netMethodValue == NETMETHOD_CUT_DULLEST
                                      || netMethodValue == NETMETHOD_CUT_LONGEST
                                      || netMethodValue == NETMETHOD_CUT_SHORTEST
                                      || netMethodValue == NETMETHOD_FOLD_SHARPEST
                                      || netMethodValue == NETMETHOD_FOLD_DULLEST
                                      || netMethodValue == NETMETHOD_FOLD_LONGEST
                                      || netMethodValue == NETMETHOD_FOLD_SHORTEST)
                                {
                                    Mesh meshToUse, dualMeshToUse;
                                    if (netMethodValue == NETMETHOD_CUT_SHARPEST
                                     || netMethodValue == NETMETHOD_CUT_DULLEST
                                     || netMethodValue == NETMETHOD_CUT_LONGEST
                                     || netMethodValue == NETMETHOD_CUT_SHORTEST)
                                    {
                                        //System.out.println("USING PRIMAL MESH");
                                        meshToUse = mesh;
                                        dualMeshToUse = dualMesh;
                                    }
                                    else
                                    {
                                        //System.out.println("USING DUAL MESH");
                                        meshToUse = dualMesh;
                                        dualMeshToUse = mesh;

                                        // need dualEdgeIsFold, not dualEdgeIsCut
                                        dualEdgeIsFold = dualEdgeIsCut;
                                        dualEdgeIsCut = null;
                                    }

                                    boolean seenEdge[] = new boolean[mesh.edges.size()]; // all false initially
                                    FORIDOWN (iEdge, seenEdge.length)
                                    {
                                        if (seenEdge[iEdge])
                                            continue;

                                        // Walk around the primal face,
                                        // accumulating the bestest dual edge.
                                        Mesh.Edge edge = meshToUse.getEdge(iEdge);

                                        boolean verbose = edge.initialVertex() != null && edge.finalVertex() != null && (MIN(edge.initialVertex().myIndex(), edge.finalVertex().myIndex()) == 4
                                                        && MAX(edge.initialVertex().myIndex(), edge.finalVertex().myIndex()) == 5); // XXX get rid when debugged adequately
                                        verbose = false;

                                        if (verbose)
                                            System.out.println("    examining edge "+edge);
                                        double bestValue = Double.NaN; // initialize to something to shut up compiler
                                        int bestIndex = -1;

                                        {
                                            Mesh.Edge thisEdge = edge;
                                            do
                                            {
                                                if (verbose)
                                                    System.out.println("        is this better? "+thisEdge);
                                                int thisEdgeIndex = thisEdge.myIndex();
                                                double thisValue;
                                                if (netMethodValue == NETMETHOD_CUT_SHARPEST
                                                 || netMethodValue == NETMETHOD_CUT_DULLEST
                                                 || netMethodValue == NETMETHOD_FOLD_LONGEST
                                                 || netMethodValue == NETMETHOD_FOLD_SHORTEST)
                                                {
                                                    // sharpest dual edge === longest primal edge
                                                    Mesh.Vertex v0 = thisEdge.initialVertex();
                                                    Mesh.Vertex v1 = thisEdge.finalVertex();
                                                    double edgeLength2 = (v0==null||v1==null ? Double.POSITIVE_INFINITY
                                                                                             : SQR(v1.Xnaive()-v0.Xnaive())
                                                                                             + SQR(v1.Ynaive()-v0.Ynaive()));
                                                    thisValue = edgeLength2;
                                                    if (netMethodValue == NETMETHOD_CUT_DULLEST
                                                     || netMethodValue == NETMETHOD_FOLD_SHORTEST)
                                                        thisValue = -thisValue;
                                                }
                                                else // CUT_LONGEST or CUT_SHORTEST or FOLD_SHARPEST or FOLD_DULLEST
                                                {
                                                    Mesh.Edge dualEdge = dualMeshToUse.getEdge(thisEdgeIndex);
                                                    if (verbose)
                                                        System.out.println("        dual edge: "+dualEdge);
                                                    Mesh.Vertex v0 = dualEdge.initialVertex();
                                                    Mesh.Vertex v1 = dualEdge.finalVertex();
                                                    double edgeLength2 = (v0==null||v1==null ? Double.POSITIVE_INFINITY
                                                                                             : SQR(v1.Xnaive()-v0.Xnaive())
                                                                                             + SQR(v1.Ynaive()-v0.Ynaive()));
                                                    thisValue = edgeLength2;
                                                    if (netMethodValue == NETMETHOD_CUT_SHORTEST
                                                     || netMethodValue == NETMETHOD_FOLD_DULLEST)
                                                        thisValue = -thisValue;
                                                    if (verbose)
                                                        System.out.println("        thisValue: "+thisValue);
                                                }
                                                if (verbose && bestIndex != -1)
                                                {
                                                    PRINT(thisValue);
                                                    PRINT(bestValue);
                                                    PRINT(GT(thisValue, bestValue, SQR(1e-6)));
                                                    PRINT(GEQ(thisValue, bestValue, SQR(1e-6)));
                                                    PRINT(MIN(thisEdgeIndex,meshToUse.getEdge(thisEdgeIndex).opposite().myIndex()) < MIN(bestIndex,meshToUse.getEdge(bestIndex).opposite().myIndex()));
                                                }
                                                if (bestIndex == -1
                                                 || (GT(thisValue, bestValue, SQR(1e-6))

                                                //|| (GEQ(thisValue, bestValue, SQR(1e-6)) // GEQ macro doesn't work for comparing -Infinity with -Infinity! argh!
                                                  || ((thisValue >= bestValue-SQR(1e-6))

                                                   && (MIN(thisEdgeIndex,meshToUse.getEdge(thisEdgeIndex).opposite().myIndex()) < MIN(bestIndex,meshToUse.getEdge(bestIndex).opposite().myIndex()))) ) ) // tie breaker: lowest index wins
                                                {
                                                    if (verbose)
                                                        System.out.println("            yes better: "+thisEdge);
                                                    bestValue = thisValue;
                                                    bestIndex = thisEdgeIndex;
                                                }
                                                else
                                                {
                                                    if (verbose)
                                                        System.out.println("            no, not better");
                                                }
                                                seenEdge[thisEdgeIndex] = true;
                                            } while ((thisEdge=thisEdge.next()) != edge);
                                        }
                                        if (netMethodValue == NETMETHOD_FOLD_SHARPEST
                                         || netMethodValue == NETMETHOD_FOLD_DULLEST
                                         || netMethodValue == NETMETHOD_FOLD_LONGEST
                                         || netMethodValue == NETMETHOD_FOLD_SHORTEST)
                                        {
                                            // this is kind of silly... should just use the Net directly
                                            dualEdgeIsFold[bestIndex] = true;
                                            dualEdgeIsFold[meshToUse.getEdge(bestIndex).opposite().myIndex()] = true; // currently not necessary but makes things cleaner
                                        }
                                        else
                                        {
                                            dualEdgeIsCut[bestIndex] = true;
                                            dualEdgeIsCut[meshToUse.getEdge(bestIndex).opposite().myIndex()] = true; // currently not necessary but makes things cleaner
                                        }
                                    }
                                }
                                else // MANUAL
                                {
                                    // nothing
                                }

                                {
                                    theNet = new Net(dualMesh, mesh);
                                    if (dualEdgeIsCut != null)
                                        FORI(iEdge, nEdges)
                                            if (dualEdgeIsCut[iEdge])
                                                theNet.cut(iEdge, true);
                                    if (dualEdgeIsFold != null)
                                        FORI(iEdge, nEdges)
                                            if (dualEdgeIsFold[iEdge])
                                                theNet.fold(iEdge, true);
                                    int root = nDualVerts;
                                    if (theNet._nUndecideds == 0)
                                        theNet.chooseDirections(root);
                                }
                            } // theNet was null

                            //
                            // Now figure out which ones are off balance.
                            //
                            // accumulate weights...
                            if (theNet._topSortedVertInds != null) // i.e. if complete
                            {
                                momentAndWeightStrictlyBelowEachDualVertex = new double[nDualVerts][3]; // initially zeros
                                {
                                    FORIDOWN(iiChild, theNet._topSortedVertInds.length) // leaves to roots
                                    {
                                        int iChild = theNet._topSortedVertInds[iiChild];
                                        if (iChild == nDualVerts)
                                            continue; // it's the infinite vertex, i.e. the root
                                        Mesh.Vertex child = dualMesh.getVert(iChild);
                                        int parentEdgeInd = theNet._vertToParentEdgeInd[iChild];
                                        if (parentEdgeInd != -1)
                                        {
                                            Mesh.Edge parentEdge = dualMesh.getEdge(parentEdgeInd);
                                            Mesh.Vertex parent = parentEdge.finalVertex();
                                            if (parent != null)
                                            {
                                                int iParent = parent.myIndex();
                                                accumulateMomentAndArea(momentAndWeightStrictlyBelowEachDualVertex[iParent],
                                                                        momentAndWeightStrictlyBelowEachDualVertex[iChild]);
                                                accumulateMomentAndArea(momentAndWeightStrictlyBelowEachDualVertex[iParent],
                                                                        child.momentAndArea);
                                            }
                                        }
                                    }
                                }

                                dualEdgeIsOffBalanceCut = new boolean[mesh.edges.size()]; // all false initially
                                nOffBalanceCuts = 0;

                                FORI (iDualVert, nDualVerts)
                                {
                                    double momentAndWeightStrictlyBelowDualVertex[] = momentAndWeightStrictlyBelowEachDualVertex[iDualVert];
                                    double weightStrictlyBelowDualVertex = momentAndWeightStrictlyBelowDualVertex[2];
                                    if (weightStrictlyBelowDualVertex != 0.)
                                    {
                                        int iDualEdge = theNet._vertToParentEdgeInd[iDualVert];
                                        if (iDualEdge == -1)
                                            continue; // this is the root / highest node

                                        Mesh.Edge dualEdge = dualMesh.getEdge(iDualEdge);

                                        Mesh.Vertex dualVert = dualEdge.initialVertex();
                                        assert(dualVert.myIndex() == iDualVert);
                                        if (dualVert.weight < 0.)
                                            continue; // nodes on the boundary are automatically okay

                                        double centerX = momentAndWeightStrictlyBelowDualVertex[0] / weightStrictlyBelowDualVertex;
                                        double centerY = momentAndWeightStrictlyBelowDualVertex[1] / weightStrictlyBelowDualVertex;
                                        if (GT(dualEdge.direction[0] * (centerX - dualVert.x())
                                             + dualEdge.direction[1] * (centerY - dualVert.y()), 0., 1e-6))
                                        {
                                            dualEdgeIsOffBalanceCut[dualEdge.myIndex()] = true;
                                            dualEdgeIsOffBalanceCut[dualEdge.opposite().myIndex()] = true;
                                            nOffBalanceCuts++;
                                            //System.out.println("    edge at dual vert "+iDualVert+" is off balance!");
                                        }
                                        else
                                        {
                                            //System.out.println("    edge at dual vert "+iDualVert+" is balanced");
                                        }
                                    }
                                }

                                // We want to omit zero-length (or very close to zero-length) edges
                                // from the thermometer.
                                // Count number of non-zero-length edges...
                                // TODO: this should maybe just be in the above loop.
                                nNonZeroLengthWholeEdges = 0; // and counting
                                nNonZeroLengthOffBalanceCuts = 0; // and counting
                                FORI (iDualEdge, nEdges)
                                {
                                    int oDualEdge = dualMesh.getEdge(iDualEdge).opposite().myIndex();
                                    if (iDualEdge < oDualEdge)
                                    {
                                        double from[] = dualEdgeInitialCoords[iDualEdge][0];
                                        double to[] = dualEdgeInitialCoords[oDualEdge][0];

                                        assert((from==null)==(to==null));
                                        if (from==null)
                                            continue; // this part doesn't exist-- edge is wholely on second sheet

                                        if (GT(VecMath.distsqrd(from,to), 0., SQR(1e-6)))
                                        {
                                            nNonZeroLengthWholeEdges++;
                                            if (dualEdgeIsOffBalanceCut[iDualEdge])
                                                nNonZeroLengthOffBalanceCuts++;
                                        }
                                    }
                                }
                            }
                            else
                            {
                                dualEdgeIsOffBalanceCut = new boolean[mesh.edges.size()]; // all false
                            }
                        }
                        catch (Throwable e)
                        {
                            // an assertion failed, no doubt
                            // TODO: probably need a way to force the animation off whenever anything bad happens in paint, now
                            e.printStackTrace();
                            System.out.println("Well that sucked-- forcing showNetFlag off");
                            theNet = null; // in case it got partially set
                            synchronized(showNetFlag) // since another thread checks it once in a while
                            {
                                showNetFlag.set(false);
                            }
                        }
                    } // if (showNetFlag.get())

                    if (!showNetFlag.get())
                    {
                        //
                        // Select colors for the good and bad ways out of the lagoon.
                        //

                        // first identify the edges out of the lagoon...
                        FORI (iDualEdge, dualMesh.edges.size())
                        {
                            Mesh.Edge dualEdge = dualMesh.getEdge(iDualEdge);
                            Mesh.Vertex initialVertex = dualEdge.initialVertex();
                            if (initialVertex == null)
                                continue; // no initial vertex
                            int iDualVert = initialVertex.myIndex();
                            if (!isSelectedDualVert[iDualVert])
                                continue; // doesn't originate in the lagoon
                            int iDualEdgeOpposite = dualEdge.opposite().myIndex();
                            Mesh.Vertex finalVertex = dualEdge.finalVertex();
                            if (finalVertex != null
                             && isSelectedDualVert[finalVertex.myIndex()])
                            {
                                // both ends are in the lagoon.
                                int jDualVert = finalVertex.myIndex();
                                if (iDualVert > jDualVert)
                                    continue; // only need to do it in canonical dir
                                dualEdgeColors[iDualEdge] = dualColorBothSelected;
                                dualEdgeColors[iDualEdgeOpposite] = dualColorBothSelected;
                            }
                            else
                            {
                                // starts in the lagoon, ends outside it.
                                // is it a good exit?
                                double initialVertexCoords[] = {initialVertex.x(), initialVertex.y()};
                                assert(dualEdge.direction != null); // XXX TODO: remove when I get this debugged
                                double goodness = VecMath.dot(2, dualEdge.direction,
                                                              VecMath.vmv(2, initialVertexCoords, avg));
                                boolean isGoodExit = GEQ(goodness, 0., SQR(1e-6));

                                if (true)
                                {
                                    if (selectedDualVertIndices.length > 1)
                                    {
                                        if (isGoodExit)
                                            mg.setColor(perpColorGood);
                                        else
                                            mg.setColor(perpColorBad);

                                        // draw perpendicular at the zero level (not at the vertex),
                                        // to emphasize the wrongness if viewing non-orthogonally
                                        double rayLength = 1.;
                                        mg.drawLine(initialVertex.x() - rayLength * dualEdge.direction[1],
                                                    initialVertex.y() + rayLength * dualEdge.direction[0],
                                                    0,
                                                    initialVertex.x() + rayLength * dualEdge.direction[1],
                                                    initialVertex.y() - rayLength * dualEdge.direction[0],
                                                    0,
                                                    antiAliasingFlag);
                                    }
                                }

                                if (isGoodExit)
                                {
                                    dualEdgeColors[iDualEdge] = dualColorOneSelectedGood;
                                    dualEdgeColors[iDualEdgeOpposite] = dualColorOneSelectedGood;
                                }
                                else
                                {
                                    dualEdgeColors[iDualEdge] = dualColorOneSelectedBad;
                                    dualEdgeColors[iDualEdgeOpposite] = dualColorOneSelectedBad;
                                }

                            }
                        }
                    } // if (!showNetFlag)
                } // if (drawDualDiagramFlag)

                boolean whichPrimalEdgesGotDrawn[] = showPrimalEdgesFlag.get() ? new boolean[nEdges] : null; // all false initially
                boolean showInsideOutDualVertsFlagValue = showInsideOutDualVertsFlag.get();

                FORI (iFacingPass, 2) // back, then front
                {
                    int frontBrightness = 240;
                    int backBrightness = (int)(backfaceBrightness.get() * frontBrightness);
                    if (iFacingPass == 0 && backBrightness <= 0)
                        continue;

                    if (showPrimalVertsFlag.get() || showPrimalEdgesFlag.get())
                    {
                        ArrayList verts = mesh.verts;
                        ArrayList edges = mesh.edges;
                        ArrayList dualEdges = dualMesh.edges;

                        if (iFacingPass == 0) // back faces
                            mg.setColor(new java.awt.Color(backBrightness,backBrightness,backBrightness));
                        else
                            mg.setColor(new java.awt.Color(frontBrightness,frontBrightness,frontBrightness));


                        if (showPrimalVertsFlag.get())
                            FORI (iVert, nVerts)
                            {
                                if ((vertFacings[iVert]!=FACING_BACK||iVert==beingDraggedVertIndex) == (iFacingPass==1))
                                {
                                    double vCoordHomo[] = vertCoordsHomo[iVert];
                                    mg.drawPoint(vCoordHomo[0],
                                                 vCoordHomo[1],
                                                 vCoordHomo[2],
                                                 vCoordHomo[3],
                                                 iVert==beingDraggedVertIndex ? 5 : 3);
                                }
                            }

#if 0 // XXX was this just an experiment? can I get rid?
                        if (showTriangles.get() == 3) // spherical barycentrics experiment
                        {
                            double wrapSphereRadius = 1./wrapSphereCurvature.get();
                            FORIDOWN(iEdge, edges.size())
                            {
                                Mesh.Edge edge0 = (Mesh.Edge)edges.get(iEdge);
                                Mesh.Edge edge1 = edge0.next();
                                Mesh.Edge edge2 = edge1.next();
                                if (edge2.next() == edge0)
                                {
                                    // it's a triangle
                                    Mesh.Vertex vert0 = edge0.initialVertex();
                                    Mesh.Vertex vert1 = edge1.initialVertex();
                                    Mesh.Vertex vert2 = edge2.initialVertex();
                                    double ppp[][] = {{vert0.x(),vert0.y(),vert0.z()+wrapSphereRadius},
                                                      {vert1.x(),vert1.y(),vert1.z()+wrapSphereRadius},
                                                      {vert2.x(),vert2.y(),vert2.z()+wrapSphereRadius}};
                                    int N = 4;
                                    int n = 8;
                                    mg.setColor(new java.awt.Color(0,0,255));
                                    FORI (iii, 3)
                                    {
                                        double p0[] = ppp[iii];
                                        double p1[] = ppp[(iii+1)%3];
                                        double p2[] = ppp[(iii+2)%3];
                                        FORI (I, N)
                                        {
                                            double t0 = (double)I/(double)N;
                                            double t1 = (1.-t0)/2.;
                                            double t2 = (1.-t0)/2.;
                                            double midpoint[] = sbary(p0, p1,t1, p2,t2);
                                            double point1[] = sbary(p0, p1,1.-t0, p2, 0.);
                                            double point2[] = sbary(p0, p1,0., p2, 1.-t0);
                                            double normal[] = VecMath.normalize(VecMath.vxv3(VecMath.vmv(midpoint,point1),VecMath.vmv(point2,midpoint)));
                                            double offset = VecMath.dot(normal, midpoint);
                                            double r = Math.sqrt(1.-SQR(offset));
                                            double basis[/*3*/][/*3*/] = {normal,new double[3], new double[3]};
                                            VecMath.extendAndOrthogonalize(1,3,basis,basis);
                                            double from[] = new double[3];
                                            double to[] = new double[3];
                                            double circleCenter[] = VecMath.vxs(normal, offset);
                                            for (int i = 0; i < 360; ++i)
                                            {
                                                double ang0 = (i+0.)/360*(2*Math.PI);
                                                double ang1 = (i+1.)/360*(2*Math.PI);
                                                VecMath.vpsxvpsxv(from, circleCenter, r*Math.cos(ang0), basis[1], r*Math.sin(ang0), basis[2]);
                                                VecMath.vpsxvpsxv(to, circleCenter, r*Math.cos(ang1), basis[1], r*Math.sin(ang1), basis[2]);
                                                mg.drawLine(from[0],from[1],from[2]-wrapSphereRadius,
                                                            to[0],to[1],to[2]-wrapSphereRadius,
                                                            antiAliasingFlag);
                                            }


                                            if (false)
                                            {
                                                mg.drawLine(midpoint[0],midpoint[1],midpoint[2]-wrapSphereRadius,
                                                            point1[0],point1[1],point1[2]-wrapSphereRadius,
                                                            antiAliasingFlag);
                                                mg.drawLine(midpoint[0],midpoint[1],midpoint[2]-wrapSphereRadius,
                                                            point2[0],point2[1],point2[2]-wrapSphereRadius,
                                                            antiAliasingFlag);
                                            }
                                        }
                                    }
                                    mg.setColor(java.awt.Color.white);
                                    FORI (iii, 3)
                                    {
                                        double p0[] = ppp[iii];
                                        double p1[] = ppp[(iii+1)%3];
                                        double p2[] = ppp[(iii+2)%3];
                                        FORI (I, N+1)
                                        FORI (J, I+1)
                                        {
                                            double p[] = sbary(p0,
                                                               p1, (double)(N-I)/(double)N,
                                                               p2, (double)J/(double)N);
                                            mg.drawPoint(p[0],
                                                         p[1],
                                                         p[2] - wrapSphereRadius,
                                                         2);
                                        }
                                        FORI (I, N+1)
                                        FORI (j, n*I+1)
                                        {
                                            double p[] = sbary(p0,
                                                               p1, (double)(N-I)/(double)N,
                                                               p2, (double)j/(double)n/(double)N);
                                            mg.drawPoint(p[0],
                                                         p[1],
                                                         p[2] - wrapSphereRadius,
                                                         1);
                                        }

                                    }


#ifdef NOTYET
                                    // draw three circles that will intersect in a point, hopefully
                                    double Area = sphericalTriangleArea(p0,p1,p2);
                                    FORI (iii, 3)
                                    {
                                        double p0[] = ppp[iii];
                                        double p1[] = ppp[(iii+1)%3];
                                        double p2[] = ppp[(iii+2)%3];
                                        double t0 = 1/3.;
                                        double t1 = 1/3.;
                                        double t2 = 1/3.;
                                        double area0 = t0*Area;
                                        double area1 = t1*Area;
                                        double area2 = t2*Area;
                                        double point1[] = VecMath.vxs(p1, -1.);
                                        double point2[] = VecMath.vxs(p1, -2.);

                                        // point0 will be on the perpendicular bisector of p1p2, with area area0
                                        // area of a right spherical triangle
                                        // with legs alpha,beta is:


                                        double point3[] = ???
                                    }
#endif // NOTYET
                                }
                            }
                            continue;
                        }
#endif // 0

                        if (showPrimalEdgesFlag.get())
                        {
                            boolean showFlatPrimalEdgesFlagValue = showFlatPrimalEdgesFlag.get();
                            FORIDOWN (iWholeEdge, edges.size()/2)
                            {
                                if ((edgeFacings[iWholeEdge*2]!=FACING_BACK) == (iFacingPass==1))
                                {
                                    Mesh.Edge edge = (Mesh.Edge)edges.get(iWholeEdge*2);

                                    if (!showFlatPrimalEdgesFlagValue || !showInsideOutDualVertsFlagValue)
                                    {
                                        Mesh.Edge dualEdge = (Mesh.Edge)dualEdges.get(iWholeEdge*2);
                                        Mesh.Vertex vert0 = dualEdge.initialVertex();
                                        Mesh.Vertex vert1 = dualEdge.finalVertex();
                                        if (vert0 != null && vert1 != null)
                                        {
                                            double v0[] = dualVertCoordsHomoNormalized[vert0.myIndex()];
                                            double v1[] = dualVertCoordsHomoNormalized[vert1.myIndex()];

                                            if (!showFlatPrimalEdgesFlagValue)
                                            {
                                                // Is it flat?  It's flat if the two dual verts
                                                // are very close together.
                                                // This works even for a triangular dihedron,
                                                // since in that case we negated the whole homogeneous coords of one of them.
                                                // TODO REGARDING NEGATIVE WEIGHTS: except I'm going to stop doing that I think?
                                                double flatThreshold = 1e-6;
                                                if (VecMath.distsqrd(v0,v1) < SQR(flatThreshold))
                                                {
                                                    PRINTVEC(v0);
                                                    PRINTVEC(v1);
                                                    PRINT(VecMath.distsqrd(v0,v1));
                                                    continue;
                                                }
                                            }
                                            if (!showInsideOutDualVertsFlagValue)
                                            {
                                                if (v0[3] < 0. && v1[3] < 0.)
                                                    continue;
                                            }
                                        }
                                    }

                                    double v0[] = vertCoordsHomo[edge.initialVertex().myIndex()];
                                    double v1[] = vertCoordsHomo[edge.finalVertex().myIndex()];
                                    mg.drawLine(v0[0],v0[1],v0[2],v0[3],
                                                v1[0],v1[1],v1[2],v1[3],
                                                antiAliasingFlag);

                                    whichPrimalEdgesGotDrawn[iWholeEdge*2+0] = true;
                                    whichPrimalEdgesGotDrawn[iWholeEdge*2+1] = true;
                                }
                            }
                        }
                    } // if showing primal verts or edges or both


                    if (showDualVertsFlag.get() || showDualEdgesFlag.get())
                    {
                        //
                        // Draw dual edges, in chosen colors
                        // 

                        java.awt.Color darkBlue = new java.awt.Color(0.f,0.f,1/4.f);
                        //java.awt.Color darkBlue = new java.awt.Color(0.f,0.f,1/2.f);
                        //java.awt.Color darkBlue = new java.awt.Color(0.f,0.f,3/4.f);
                        //java.awt.Color darkBlue = new java.awt.Color(0.f,0.f,7/8.f);
                        java.awt.Color darkGray = new java.awt.Color(1/4.f,1/4.f,1/4.f);


                        if (showNetFlag.get())
                        {
                            //
                            // showing net-- different color scheme,
                            // and draw the being-dragged net edge if any
                            //
                            FORIDOWN(iEdge, mesh.edges.size())
                            {
                                if (dualEdgeIsOffBalanceCut[iEdge])
                                {
                                    dualEdgeColors[iEdge] = java.awt.Color.red;
                                }
                                else if (theNet._edgeStatuses[iEdge] == Net.CUT)
                                {
                                    dualEdgeColors[iEdge] = java.awt.Color.green;
                                }
                                else if (theNet._edgeStatuses[iEdge] == Net.FOLD)
                                {
                                    dualEdgeColors[iEdge] = darkBlue;
                                }
                                else
                                {
                                    dualEdgeColors[iEdge] = darkGray;
                                }
                            }
                            if (beingDraggedNetEdgeIndex != -1)
                            {
                                boolean itsACut = (theNet._edgeStatuses[beingDraggedNetEdgeIndex] == Net.CUT);
                                if (itsACut)
                                {
                                    // Make sure beingDraggedNetEdgeIndex points towards root of cut tree--
                                    // if not, reverse it.
                                    if (dualMesh.getEdge(beingDraggedNetEdgeIndex).initialVertex() == null
                                     || theNet._vertToParentEdgeInd[dualMesh.getEdge(beingDraggedNetEdgeIndex).initialVertex().myIndex()] != beingDraggedNetEdgeIndex)
                                        beingDraggedNetEdgeIndex = _dualMesh.getEdge(beingDraggedNetEdgeIndex).opposite().myIndex();
                                    assert(theNet._vertToParentEdgeInd[dualMesh.getEdge(beingDraggedNetEdgeIndex).initialVertex().myIndex()] == beingDraggedNetEdgeIndex);

                                    // set lagoonCenter from null... this will cause it to be drawn down below, after edges
                                    {
                                        Mesh.Edge netEdgeBeingDragged = dualMesh.getEdge(beingDraggedNetEdgeIndex);
                                        Mesh.Vertex initialVertex = netEdgeBeingDragged.initialVertex();

                                        double lagoonMomentAndWeight[] = new double[4]; // zeros
                                        accumulateMomentAndArea(lagoonMomentAndWeight, momentAndWeightStrictlyBelowEachDualVertex[initialVertex.myIndex()]);
                                        accumulateMomentAndArea(lagoonMomentAndWeight, initialVertex.momentAndArea);
                                        lagoonCenter = new double[] {
                                            lagoonMomentAndWeight[0] / lagoonMomentAndWeight[3],
                                            lagoonMomentAndWeight[1] / lagoonMomentAndWeight[3],
                                            lagoonMomentAndWeight[2] / SQR(lagoonMomentAndWeight[3]),
                                        };
                                    }
                                }

                                Mesh.Edge alternatives[] = theNet.alternatives(beingDraggedNetEdgeIndex);

                                // add in the original exit itself, to simplify the loop
                                alternatives = (Mesh.Edge[])Arrays.append(alternatives, dualMesh.getEdge(beingDraggedNetEdgeIndex));

                                FORI (iAlternative, alternatives.length)
                                {
                                    Mesh.Edge alternativeExit = alternatives[iAlternative];
                                    Mesh.Vertex alternativeExitVertex = alternativeExit.initialVertex();
                                    java.awt.Color color;
                                    if (itsACut)
                                    {
                                        // Dragging a cut: highlight alternative exits--
                                        // cyan for good, magenta for bad.
                                        boolean isGood = LEQ(VecMath.dot(2, alternativeExit.direction,
                                                                            VecMath.vmv(2, lagoonCenter,
                                                                                           new double[]{alternativeExitVertex.Xnaive(),
                                                                                                        alternativeExitVertex.Ynaive()})), 0., SQR(1e-6));
                                        color = isGood ? java.awt.Color.cyan : java.awt.Color.magenta;
                                    }
                                    else
                                    {
                                        // If dragging a fold: just highlight alternative folds
                                        // in whatever color they are in (green->cyan, red->magenta, darkBlue->blue)
                                        color = dualEdgeColors[alternativeExit.myIndex()];
                                        color = (alternativeExit.myIndex()==beingDraggedNetEdgeIndex
                                              || alternativeExit.opposite().myIndex()==beingDraggedNetEdgeIndex) ? java.awt.Color.blue :
                                                dualEdgeIsOffBalanceCut[alternativeExit.myIndex()] ? java.awt.Color.magenta
                                                                                                   : java.awt.Color.cyan;
                                    }

                                    dualEdgeColors[alternativeExit.myIndex()] = color;
                                    dualEdgeColors[alternativeExit.opposite().myIndex()] = color;
                                }

                                if (VecMath.normsqrd(beingDraggedNetEdgeDelta) != 0.)
                                {
                                    if (dualEdgeColors[beingDraggedNetEdgeIndex] == java.awt.Color.cyan)
                                    {
                                        //mg.setColor(darkGreen);
                                        mg.setColor(darkCyan);
                                    }
                                    else if (dualEdgeColors[beingDraggedNetEdgeIndex] == java.awt.Color.magenta)
                                    {
                                        //mg.setColor(darkRed);
                                        mg.setColor(darkMagenta);
                                    }
                                    else if (dualEdgeColors[beingDraggedNetEdgeIndex] == java.awt.Color.blue)
                                        mg.setColor(darkBlue);


                                    double from[] = dualEdgeInitialCoords[beingDraggedNetEdgeIndex][0];
                                    double to[] = dualEdgeInitialCoords[dualMesh.getEdge(beingDraggedNetEdgeIndex).opposite().myIndex()][0];
                                    mg.drawLine(from[0]+beingDraggedNetEdgeDelta[0],
                                                from[1]+beingDraggedNetEdgeDelta[1],
                                                from[2],
                                                to[0]+beingDraggedNetEdgeDelta[0],
                                                to[1]+beingDraggedNetEdgeDelta[1],
                                                to[2],
                                                antiAliasingFlag);
                                }
                            }
                        }


                        if (showNetFlag.get()
                         && showFlattenedNetFlag.get()
                         && localScaleZ != 0.
                         && tilt > Math.PI*.5) // i.e. if xy plane is behind rest of picture
                            drawFlattenedNet(mg, mesh, dualMesh, dualEdgeInitialCoords, nVerts, nEdges, dualEdgeColors);

                        double backfaceBrightnessValue = backfaceBrightness.get();

                        //
                        // Dual edges.
                        // If showing the cut tree,
                        // we draw the non-cut edges first, then the cut edges--
                        // this makes the tree appear more connected.
                        //
                        if (showDualEdgesFlag.get())
                        {
                            double destPoint[] = new double[3]; // scratch for loop
                            int nPasses = showNetFlag.get() ? 2 : 1;
                            FORI (iPass, nPasses)
                            {
                                FORIDOWN (iDualEdge, mesh.edges.size())
                                {
                                    if (nPasses == 2
                                     && (theNet._edgeStatuses[iDualEdge]==Net.CUT) != (iPass==1))
                                        continue; // when two passes, draw cuts iff iPass==1



                                    if ((dualEdgeFacings[iDualEdge]!=FACING_BACK) != (iFacingPass==1))
                                        continue;

                                    java.awt.Color frontColor = dualEdgeColors[iDualEdge];
                                    if (iFacingPass == 0)
                                    {
                                        // holy moly this is inefficient, probably
                                        int rgb = frontColor.getRGB();
                                        int R = (rgb>>16)&255;
                                        int G = (rgb>>8)&255;
                                        int B = rgb&255;
                                        java.awt.Color backColor = new java.awt.Color((int)(R*backfaceBrightnessValue), (int)(G*backfaceBrightnessValue), (int)(B*backfaceBrightnessValue));
                                        mg.setColor(backColor);
                                    }
                                    else
                                        mg.setColor(frontColor);


                                    Mesh.Edge dualEdge = dualMesh.getEdge(iDualEdge);
                                    int oDualEdge = dualEdge.opposite().myIndex();

                                    int nParts = showInsideOutDualVertsFlagValue ? 2 : 1;
                                    FORI (iPart, nParts)
                                    {
                                        double from[] = dualEdgeInitialCoords[iDualEdge][iPart];
                                        double to[] = dualEdgeInitialCoords[oDualEdge][iPart];

                                        assert((from==null)==(to==null));
                                        if (from==null)
                                            continue; // this part doesn't exist-- edge is wholely on other sheet

                                        mg.drawLine(from[0], from[1], from[2], from[3],
                                                    to[0], to[1], to[2], to[3],
                                                    antiAliasingFlag);

                                        if (showNetFlag.get()
                                         && pointOutRedNetEdges
                                         && mg.getColor() == java.awt.Color.red)
                                        {
                                            mg.drawPoint((to[0]+from[0])*.5,
                                                         (to[1]+from[1])*.5,
                                                         (to[2]+from[2])*.5,
                                                         7);
                                        }
                                    }
                                }
                            }
                        }

                        //
                        // Draw dual verts
                        // (only if NOT showing net flow... they are disruptive to the flow)
                        //
                        FORIDOWN(iDualVert, dualMesh.verts.size())
                        {
                            // if showing flow, don't show regular verts (only show selected ones)
                            if (showNetFlag.get() && showNetFlowFlag.get() && dualVertColors[iDualVert] != dualVertSelectionColor)
                                continue;
                            if (!showDualVertsFlag.get() && dualVertColors[iDualVert] != dualVertSelectionColor)
                                continue;

                            Mesh.Vertex dualVert = dualMesh.getVert(iDualVert);

                            if (!showInsideOutDualVertsFlagValue
                             && dualVert.weight < 0.)
                                continue;

                            //System.out.println("    drawing dual vert at "+Arrays.toStringCompact(dualVert));

                            if ((dualVertFacings[iDualVert]!=FACING_BACK) != (iFacingPass==1))
                                continue;

                            java.awt.Color frontColor = dualVertColors[iDualVert];
                            if (iFacingPass == 0)
                            {
                                // holy moly this is inefficient, probably
                                int rgb = frontColor.getRGB();
                                int R = (rgb>>16)&255;
                                int G = (rgb>>8)&255;
                                int B = rgb&255;
                                java.awt.Color backColor = new java.awt.Color((int)(R*backfaceBrightnessValue), (int)(G*backfaceBrightnessValue), (int)(B*backfaceBrightnessValue));
                                mg.setColor(backColor);
                            }
                            else
                                mg.setColor(frontColor);

                            double p[] = dualVertCoords[iDualVert];
                            double sign = p[3]<0. ? -1 : 1;
                            mg.drawPoint(sign*p[0], sign*p[1], sign*p[2], sign*p[3],
                                         showNetFlag.get() ? 2 : 5);
                        }

                        if (showNetFlag.get() && showNetFlowFlag.get()
                         && theNet._topSortedVertInds != null) // TODO: can probably remove this check eventually, when I get topsort working even if only forest
                        {
                            //
                            // Figure out distance (both 2-norm and infinity-norm) from each vertex
                            // to the root-most one in its tree, in 2 dimensions
                            //
                            double norm2s[] = new double[nDualVerts]; // zeros initially
                            double normInfs[] = new double[nDualVerts]; // zeros initially
                            FORI (iiChild, theNet._topSortedVertInds.length) // roots to leaves
                            {
                                int iChild = theNet._topSortedVertInds[iiChild];
                                if (iChild == nDualVerts)
                                    continue; // it's the infinite vertex, i.e. the root
                                Mesh.Vertex child = dualMesh.getVert(iChild);
                                int parentEdgeInd = theNet._vertToParentEdgeInd[iChild];
                                if (parentEdgeInd != -1)
                                {
                                    Mesh.Edge parentEdge = dualMesh.getEdge(parentEdgeInd);
                                    Mesh.Vertex parent = parentEdge.finalVertex();
                                    if (parent != null)
                                    {
                                        int iParent = parent.myIndex();
                                        double dx = child.x() - parent.x();
                                        double dy = child.y() - parent.y();
                                        norm2s[iChild] = norm2s[iParent] + MyMath.hypot(dx,dy);
                                        normInfs[iChild] = normInfs[iParent] + MAX(dx,dy);
                                    }
                                }
                            }

                            double unitsPerPixel = 1./mg.getScaleX(); // scale is uniform
                            int period = 9; // how many redraws to get back to original state, to traverse a step
                            double step = 9 * unitsPerPixel;

                            //mg.setColor(lightBlue);
                            mg.setColor(java.awt.Color.red); // lava

                            FORI (iChild, nDualVerts)
                            {
                                Mesh.Vertex child = dualMesh.getVert(iChild);
                                int parentEdgeInd = theNet._vertToParentEdgeInd[iChild];
                                if (parentEdgeInd != -1)
                                {
                                    if (!showInsideOutDualVertsFlagValue
                                     && dualEdgeFacings[parentEdgeInd] == FACING_BACK)
                                        continue;

                                    Mesh.Edge parentEdge = dualMesh.getEdge(parentEdgeInd);
                                    Mesh.Vertex parent = parentEdge.finalVertex();
                                    // TODO: combine the following two cases, using edgeInitialCoords instead of doing the ray calculation yet again
                                    if (parent != null)
                                    {
                                        int iParent = parent.myIndex();
                                        // norm2s[parent] rounded up to multiple of step
                                        // TODO: screwy math, it works but could be made simpler probably
                                        double pos0 = Math.ceil(norm2s[iParent]/step)*step; // XXX should subtract some slack before taking ceil
                                        pos0 -= (netFlowIndex % period)/(double)period * step;
                                        if (pos0 < norm2s[iParent]-1e-6)
                                            pos0 += step;

                                        for (double pos = pos0; LEQ(pos, norm2s[iChild], 1e-6); pos += step)
                                        {
                                            double t = (pos-norm2s[iParent])/(norm2s[iChild]-norm2s[iParent]);
                                            double x = LERP(parent.x(), child.x(), t);
                                            double y = LERP(parent.y(), child.y(), t);
                                            double z = LERP(parent.z(), child.z(), t);
                                            mg.drawPoint(x, y, z, 3);
                                        }
                                    }
                                    else
                                    {
                                        double rayLength = 1.;
                                        // TODO: screwy math, it works but could be made simpler probably
                                        double pos0 = ((period-netFlowIndex)%period)/(double)period * step;
                                        while (GT(pos0, 0, 1e-6))
                                            pos0 -= step;
                                        for (double pos = pos0; GEQ(pos, -rayLength, 1e-6); pos -= step)
                                        {
                                            double x = child.x() - pos * parentEdge.direction[0];
                                            double y = child.y() - pos * parentEdge.direction[1];
                                            double z = child.z() - pos * parentEdge.direction[2];
                                            mg.drawPoint(x, y, z, 3);
                                        }
                                    }
                                }
                            }

                            netFlowIndex++;
                        }

                        //
                        // Draw center of curvature if we recorded one
                        //
                        if (avg != null)
                        {
                            mg.setColor(dualVertSelectionColor);
                            mg.drawPoint(avg[0],
                                         avg[1],
                                         avg[2],
                                         7);
                        }


                        if (lagoonCenter != null)
                        {
                            mg.setColor(dualVertSelectionColor);
                            mg.drawPoint(lagoonCenter[0],
                                         lagoonCenter[1],
                                         lagoonCenter[2],
                                         3);
                        }




                        //
                        // Now try marking the sharpest dihedral dual edge
                        // out of each dual vertex.
                        // I.e. the dual edge opposite the largest dual angle.
                        // I.e. the dual edge corresponding to the longest of the three primal
                        // triangle sides.
                        // We draw it 3 times, to make sure we get the same logic from each direction. If there are ties, it will get drawn in each place I think.
                        //
                        if (arrowsTowardsSharpestDihedralsFlag)
                        {
                            if (showNetFlag.get())
                                mg.setColor(dualColor);
                            else
                                mg.setColor(dualVertSelectionColor);
                            FORIDOWN (iEdge, mesh.edges.size())
                            {
                                Mesh.Vertex triCenterDualVert = (dualMesh.getEdge(iEdge)).finalVertex();
                                if (triCenterDualVert == null)
                                    continue; // primary face was not a triangle, or inside out
                                if (triCenterDualVert.weight < 0.)
                                    continue; // primal face is on underside (if calculated underside), i.e. inside out

                                Mesh.Edge e0 = mesh.getEdge(iEdge);
                                Mesh.Edge e1 = e0.next();
                                Mesh.Edge e2 = e1.next();
                                assert(e2.next() == e0);
                                Mesh.Vertex triVerts[] = {e0.initialVertex(),
                                                          e1.initialVertex(),
                                                          e2.initialVertex()};
                                double sideLengths[] = new double[3];
                                FORI (i, 3)
                                    sideLengths[i] = Math.sqrt(SQR(triVerts[i].Xnaive()-triVerts[(i+1)%3].Xnaive())
                                                             + SQR(triVerts[i].Ynaive()-triVerts[(i+1)%3].Ynaive()));
                                int bestSide = MAXI3(sideLengths[0], sideLengths[1], sideLengths[2]);

                                double v0[] = {triVerts[bestSide].Xnaive(), triVerts[bestSide].Ynaive()};
                                double v1[] = {triVerts[(bestSide+1)%3].Xnaive(), triVerts[(bestSide+1)%3].Ynaive()};
                                double toEdgeVec[] = VecMath.xv2(
                                                         VecMath.vmv(v0, v1));
                                VecMath.normalize(toEdgeVec, toEdgeVec);
                                // XXX be smarter!  maybe 1/3 of the way along the edge, or somethin
                                double whereToDrawMark[] = {
                                    triCenterDualVert.Xnaive() + .02 * toEdgeVec[0],
                                    triCenterDualVert.Ynaive() + .02 * toEdgeVec[1],
                                    triCenterDualVert.Hnaive() + .02 * toEdgeVec[2],
                                };
                                //VecMath.vpsxv(whereToDrawMark, whereToDrawMark, .004, VecMath.random(2));
                                mg.drawPoint(whereToDrawMark[0],
                                             whereToDrawMark[1],
                                             whereToDrawMark[2],
                                             5);
                            }
                        } // arowsTowardsSharpestDihedralsFlag
                        if (arrowsTowardsShortestEdgesFlag)
                        {
                            // XXX we do this in 3 ways, possibly getting different answer each time, in case of a tie... should fix that
                            mg.setColor(java.awt.Color.cyan);
                            FORIDOWN (iEdge, mesh.edges.size())
                            {
                                Mesh.Vertex triCenterDualVert = (dualMesh.getEdge(iEdge)).finalVertex();
                                if (triCenterDualVert == null)
                                    continue; // primary face was not a triangle, or inside out
                                if (triCenterDualVert.weight < 0.)
                                    continue; // primal face is on underside (if calculated underside), i.e. inside out

                                Mesh.Edge e0 = mesh.getEdge(iEdge);
                                Mesh.Edge e1 = e0.next();
                                Mesh.Edge e2 = e1.next();
                                assert(e2.next() == e0);
                                Mesh.Vertex triVerts[] = {e0.initialVertex(),
                                                          e1.initialVertex(),
                                                          e2.initialVertex()};
                                double triCenterDualVertCoords[] = {triCenterDualVert.Xnaive(), triCenterDualVert.Ynaive()};
                                Mesh.Vertex neighborDualVerts[] = {
                                    (dualMesh.getEdge(e0.myIndex())).initialVertex(),
                                    (dualMesh.getEdge(e1.myIndex())).initialVertex(),
                                    (dualMesh.getEdge(e2.myIndex())).initialVertex(),
                                };

                                double dualSideLengths[] = new double[3];
                                FORI (i, 3)
                                {
                                    if (neighborDualVerts[i] == null)
                                        dualSideLengths[i] = Double.POSITIVE_INFINITY;
                                    else
                                        dualSideLengths[i] = VecMath.dist(triCenterDualVertCoords,
                                                                          new double[]{neighborDualVerts[i].Xnaive(),
                                                                                       neighborDualVerts[i].Ynaive()});
                                }
                                int bestSide = MINI3(dualSideLengths[0], dualSideLengths[1], dualSideLengths[2]);
                                double v0[] = {triVerts[bestSide].Xnaive(), triVerts[bestSide].Ynaive()};
                                double v1[] = {triVerts[(bestSide+1)%3].Xnaive(), triVerts[(bestSide+1)%3].Ynaive()};
                                double toEdgeVec[] = VecMath.xv2(
                                                         VecMath.vmv(v0, v1));
                                VecMath.normalize(toEdgeVec, toEdgeVec);
                                // XXX be smarter!  maybe 1/3 of the way along the edge, or somethin
                                double whereToDrawMark[] = {
                                    triCenterDualVert.Xnaive() + .02 * toEdgeVec[0],
                                    triCenterDualVert.Ynaive() + .02 * toEdgeVec[1],
                                    triCenterDualVert.Hnaive() + .02 * toEdgeVec[2],
                                };
                                //VecMath.vpsxv(whereToDrawMark, whereToDrawMark, .005, VecMath.random(2));
                                mg.drawPoint(whereToDrawMark[0],
                                             whereToDrawMark[1],
                                             whereToDrawMark[2],
                                             5);

                            }
                        } // arrowsTowardsShortestEdgesFlag


                        if (showNetFlag.get()
                         && showFlattenedNetFlag.get()
                         && localScaleZ != 0.
                         && tilt <= Math.PI*.5) // i.e. if xy plane is in front of rest of picture
                            drawFlattenedNet(mg, mesh, dualMesh, dualEdgeInitialCoords, nVerts, nEdges, dualEdgeColors);

                    } // if (drawDualDiagramFlag)

                } // for iFacingPass


                if (primalDualVisFlag.get()
                 && primalDualVisAngles != null
                 && primalDualVisPrimalVertInds != null
                 && primalDualVisDualVertInds != null)
                {
                    if (prevP != null)
                    {
                        // Highlight closest feature

                        // not sure prevP is the right thing to use when rotated but whatever
                        double ang = Math.atan2(prevP[1], prevP[0]);
                        
                        // locate ang among primalDualVisAngles.
                        // could do binary search, but whatever.
                        int n = primalDualVisAngles.length;
                        while (ang > primalDualVisAngles[n-1])
                            ang -= 2*Math.PI;
                        while (ang < primalDualVisAngles[0])
                            ang += 2*Math.PI;
                        int i0 = 0;
                        while (i0+1 < n && primalDualVisAngles[i0+1] <= ang)
                            i0++;
                        int i1 = (i0+1) % n;
                        double ang0 = primalDualVisAngles[i0];
                        double ang1 = primalDualVisAngles[i1];
                        if (ang1 < ang0)
                            ang1 += 2*Math.PI; // wrap around
                        double frac = (ang-ang0)/(ang1-ang0);
                        try {
                            Mesh.Vertex p0vert = mesh.getVert(primalDualVisPrimalVertInds[i0]);
                            Mesh.Vertex p1vert = mesh.getVert(primalDualVisPrimalVertInds[i1]);
                            Mesh.Vertex d0vert = dualMesh.getVert(primalDualVisDualVertInds[i0]);
                            Mesh.Vertex d1vert = dualMesh.getVert(primalDualVisDualVertInds[i1]);
                            double p0[] = {p0vert.x(), p0vert.y(), p0vert.z()};
                            double p1[] = {p1vert.x(), p1vert.y(), p1vert.z()};
                            double d0[] = {d0vert.x(), d0vert.y(), d0vert.z()};
                            double d1[] = {d1vert.x(), d1vert.y(), d1vert.z()};
                            double p[] = VecMath.lerp(p0,p1,frac);
                            double d[] = VecMath.lerp(d0,d1,frac);

                            mg.setColor(java.awt.Color.white);
                            mg.drawPoint(p[0], p[1], p[2], 7);
                            mg.setColor(lightBlue);
                            mg.drawPoint(d[0], d[1], d[2], 7);
                        } catch (IndexOutOfBoundsException e) {
                            System.out.println("Oops! primal-dual visualization apparently no longer valid, throwing it away");
                            primalDualVisAngles = null;
                            primalDualVisPrimalVertInds = null;
                            primalDualVisDualVertInds = null;
                        }
                    }

                    if (true)
                    {
                        // Show tri strip of whole thing
                        mg.setColor(new java.awt.Color(255,192,192)); // pink
                        FORI (i, primalDualVisAngles.length)
                        {
                            Mesh.Vertex p = mesh.getVert(primalDualVisPrimalVertInds[i]);
                            Mesh.Vertex d = dualMesh.getVert(primalDualVisDualVertInds[i]);
                            mg.drawLine(p.X(), p.Y(), p.Z(), p.W(),
                                        d.X(), d.Y(), d.Z(), d.W(),
                                        antiAliasingFlag);
                        }
                    }
                }

                //
                // Draw the labels last...
                //
                if ((showPrimalVertsFlag.get()&&labelPrimalVertsFlag.get())
                 || (showPrimalEdgesFlag.get()&&labelPrimalEdgesFlag.get()))
                {
                    mg.setColor(java.awt.Color.white);
                    drawLabels(mg, mesh, false, showInsideOutDualVertsFlag.get(),
                            showPrimalVertsFlag.get()&&labelPrimalVertsFlag.get(),
                            showPrimalEdgesFlag.get()&&labelPrimalEdgesFlag.get(),
                            null, // primal
                            whichPrimalEdgesGotDrawn);
                }
                if ((showDualVertsFlag.get()&&labelDualVertsFlag.get())
                 || (showDualEdgesFlag.get()&&labelDualEdgesFlag.get()))
                {
                    //mg.setColor(java.awt.Color.red);
                    mg.setColor(dualColor);
                    drawLabels(mg, dualMesh, true, showInsideOutDualVertsFlag.get(),
                        showDualVertsFlag.get()&&labelDualVertsFlag.get(),
                        showDualEdgesFlag.get()&&labelDualEdgesFlag.get(),
                        dualEdgeInitialCoords, // dual
                        null);
                } // if (showLabelsFlag)

                if (showOriginFlag)
                {
                    // draw a subtle dot at the origin
                    mg.setColor(java.awt.Color.white);
                    mg.drawPoint(0., 0., 0., 1);
                }
                // if showing an optimization path, display a message about it
                if (theOptimizationIndex != -1)
                {
                    mg.setColor(java.awt.Color.white);
                    String message = "Optimization step "+theOptimizationIndex+"/"+(theOptimizationPath.length-1)+":  goodness = "+theOptimizationPathGoodnesses[theOptimizationIndex]
                        + " ([Shift] L/R arrow to advance/retreat )";
                    mg.drawString(message,
                                  -1., -1.,
                                  -1., 1.1);
                }


                // if showing a net, display a message about it
                // and a thermometer.
                if (theNet != null
                 && nOffBalanceCuts != -1
                 && mesh.edges.size() > 0)
                {
                    PRINT(nNonZeroLengthWholeEdges); // debugging a problem with DUMP.draggingNetEdgesIsFucked.off
                    int heights[] = VecMath.fillvec(nNonZeroLengthWholeEdges, 2);
                    int space = size.height+1;
                    int spaceUsed = nNonZeroLengthWholeEdges * 2;
                    if (thermometerIsLinear)
                    {
                        // roughly linear, distribute roundoff to lower part of screen
                        while (spaceUsed < space)
                            for (int i = 0; i < nNonZeroLengthWholeEdges && spaceUsed < space; ++i)
                            {
                                heights[i]++;
                                spaceUsed++;
                            }
                    }
                    else if (true)
                    {
                        // triangular numbers, larger at lower part of screen.
                        while (spaceUsed < space)
                            for (int i = 0; i < nNonZeroLengthWholeEdges && spaceUsed < space; i++)
                            {
                                for (int j = i; j >= 0 && spaceUsed < space; --j)
                                {
                                    heights[j]++;
                                    spaceUsed++;
                                }
                            }
                    }
                    else
                    {
                        // triangular numbers, larger at lower part of screen
                        for (int i = 0; spaceUsed < space; i = MIN(i+1, nNonZeroLengthWholeEdges-1))
                        {
                            for (int j = MIN(i,nNonZeroLengthWholeEdges-1); j >= 0 && spaceUsed < space; --j)
                            {
                                heights[j]++;
                                spaceUsed++;
                            }
                        }
                    }
                    // from bottom of screen (red) to top of screen (green)
                    int xIntervals[][] = {{0,thermometerWidth}, {size.width-thermometerWidth,size.width}};

                    g.setColor(java.awt.Color.black);
                    FORI (iInterval, xIntervals.length)
                        g.fillRect(xIntervals[iInterval][0], 0,
                                   xIntervals[iInterval][1]-xIntervals[iInterval][0], size.height);

                    spaceUsed = 0;
                    g.setColor(java.awt.Color.red);
                    FORI (iEdge, nNonZeroLengthWholeEdges)
                    {
                        if (iEdge == nNonZeroLengthOffBalanceCuts)
                            g.setColor(java.awt.Color.green);
                        //int x0 = size.width-width;
                        int x0 = 0;
                        FORI (iInterval, xIntervals.length)
                            g.fillRect(xIntervals[iInterval][0],                         size.height-spaceUsed-heights[iEdge]+1,
                                       xIntervals[iInterval][1]-xIntervals[iInterval][0], heights[iEdge]-1);
                        spaceUsed += heights[iEdge];
                        if (spaceUsed >= space)
                            break;
                    }

                    mg.setColor(java.awt.Color.white);
                    mg.drawString(""+nNonZeroLengthOffBalanceCuts+" / "+nNonZeroLengthWholeEdges+" off-balance cuts",
                                  size.width/minSize,-size.height/minSize,
                                  1.2, 1.5,
                                  java.awt.Color.black); // background

                } // thermometer


                //
                // Draw the rubber band last last
                //
                if (rubberBandingNewEdge)
                {
                    mg.setColor(java.awt.Color.white);
                    Mesh.Vertex v0 = mesh.getVert(beingDraggedVertIndex);
                    double projectedPrevP[] = new double[3];
                    pickPointOnSurface(prevP, vertOffset(v0, wrapAroundSphereFlag.get()), projectedPrevP, mousePressWasBackFacing);
                    //mg.drawLine(v0.Xnaive(), v0.Ynaive(),
                                //prevP[0], prevP[1], antiAliasingFlag);
                    mg.drawLine(v0.Xnaive(), v0.Ynaive(), v0.Znaive(),
                                projectedPrevP[0], projectedPrevP[1], projectedPrevP[2],
                                antiAliasingFlag);
                } // if (rubberBandingNewEdge)





                if (showPositiveOrthantnessVisualizationFlag)
                {
                    int nPoints = 5000;
                    int nLabels = 100;
                    double M[][] = new double[3][3];
                    {
                        // XXX should add a function to VecMath for random orthonormal matrix?
                        FORI (i, 2)
                        FORI (j, 3)
                            M[i][j] = 2*Math.random() - 1.;
                        VecMath.normalize(M[0], M[0]);
                        VecMath.vpsxv(M[1],
                                      M[1],
                                      -VecMath.dot(M[0], M[1]),
                                      M[0]);
                        VecMath.normalize(M[1], M[1]);
                        VecMath.vxv3(M[2], M[0], M[1]);
                    }

                    double v[] = new double[3];
                    double Mv[] = new double[3];
                    FORI (iPoint, nLabels+nPoints)
                    {
                        VecMath.random(v);

                        if (iPoint == 0 || iPoint == nLabels+nPoints-1)
                            VecMath.fillvec(v, 1.);
                        else if (iPoint == 1 || iPoint == nLabels+nPoints-2)
                            VecMath.fillvec(v, -1);


                        VecMath.normalize(v, v);
                        VecMath.mxv(Mv, M, v);
                        if (Mv[2] < 0.)
                        {
                            VecMath.sxv(v, -1., v);
                            VecMath.sxv(Mv, -1., Mv);
                        }
                        double goodness = VecMath.positiveOrthantness(v, true); // true means use "synopsis"
                        //double incrDegrees = 10.;
                        double incrDegrees = 5.;
                        double dN = goodness * 180 / Math.PI / incrDegrees;
                        int iN = (int)Math.round(dN);
                        if (iPoint <= 1
                         || iPoint >= nLabels+nPoints-2
                         || ABS(iN-dN) < .01)
                        {
                            if (iN == 0)
                                mg.setColor(java.awt.Color.red);
                            else if (iN % 2 == 0)
                                mg.setColor(java.awt.Color.green);
                            else
                                mg.setColor(java.awt.Color.blue);

                            if (iPoint == 0
                             || iPoint == nLabels+nPoints-1)
                                mg.drawString(""+(dN*incrDegrees),
                                              Mv[0],Mv[1], -1., 1.);
                            else if (iPoint < nLabels)
                                mg.drawString(""+(int)Math.round(dN*incrDegrees),
                                              Mv[0],Mv[1], -1., 1.);
                            else
                                mg.drawPoint(Mv[0],Mv[1], 0., 1);
                        }
                        else
                            iPoint--; // cancel loop iteration
                    }
                }

                nPaints++;
                mg.setColor(java.awt.Color.white);
                mg.drawString(""+nPaints+" paints", size.width/minSize,size.height/minSize,
                              1., -.5,
                              java.awt.Color.black); // background


                if (g != frontBufferGraphics)
                {
                    if (showMagFlag.get())
                    FORI (iMag, 2) // twice, so we can mag the mag somewhat
                    {
                        // can we zoom part of the image onto itself?
                        // it seems yes! (at least with javac 1.3, runtime 1.6)
                        // XXX TODO: should really do it into a different buffer, we get artifacts this way when magging over the mag

                        int bbWidth = backBufferImage.getWidth(null);
                        int bbHeight = backBufferImage.getHeight(null);

                        // odd -> center pixel, even -> a little to lower right
                        int focusX = bbWidth/2;
                        int focusY = bbHeight/2;
                        if (prevP != null)
                        {
                            // lame way of figuring out where the mouse was most recently
                            double focus[] = new double[2];
                            mg.unpick(prevP[0], prevP[1], focus);
                            focusX = (int)Math.round(focus[0]-.5);
                            focusY = (int)Math.round(focus[1]-.5);
                        }



                        assert(magWidth % 2 == 1);

                        int dx0 = bbWidth - (magFactor+1)*magWidth;
                        int dy0 = bbHeight - (magFactor+1)*magWidth;
                        int dx1 = bbWidth;
                        int dy1 = bbHeight;
                        int sx0 = focusX - (magWidth-1)/2;
                        int sy0 = focusY - (magWidth-1)/2;
                        int sx1 = focusX + (magWidth+1)/2;
                        int sy1 = focusY + (magWidth+1)/2;

                        {
                            // border around the real one (before copying,
                            // so it will get clobbered)
                            g.setColor(java.awt.Color.blue);
                            g.drawRect(focusX-(magWidth-1)/2 - 1,
                                       focusY-(magWidth-1)/2 - 1,
                                       magWidth+1,
                                       magWidth+1);
                        }


                        // TODO: can we do this using swing's back buffer as the back buffer image?
                        g.drawImage(backBufferImage,
                                    dx0,dy0,dx1,dy1,
                                    sx0,sy0,sx1,sy1,
                                    null);

                        //g.setColor(java.awt.Color.gray);
                        g.setColor(java.awt.Color.black);
                        FORI (i, magWidth+1)
                        {
                            int x = bbWidth-1 - i*(magFactor+1);
                            int y = bbHeight-1 - i*(magFactor+1);
                            g.drawLine(x,dy0-1, x,dy1);
                            g.drawLine(dx0-1,y, dx1,y);
                        }

                        {
                            // slighly bolden the grid box around the center cell
                            int x0 = bbWidth - (magWidth+1)/2 * (magFactor+1) - 1;
                            int y0 = bbHeight - (magWidth+1)/2 * (magFactor+1) - 1;
                            int boldWidth = 3;
                            java.awt.Color colors[] = {java.awt.Color.black, java.awt.Color.white, java.awt.Color.black};
                            FORI (i, boldWidth)
                            {
                                g.setColor(colors[i]);
                                g.drawRect(x0-i,y0-i, magFactor+1+2*i, magFactor+1+2*i);
                            }
                        }

                        {
                            // border around the magnified one
                            g.setColor(java.awt.Color.blue);
                            g.drawRect(dx0-1,dy0-1, dx1-dx0, dy1-dy0);
                        }

                        {

                            int[] pixels = new int[1];
                            java.awt.image.PixelGrabber pg = new java.awt.image.PixelGrabber(backBufferImage, focusX,focusY,1,1,pixels, 0, 1);
                            try
                            {
                                pg.grabPixels();
                            }
                            catch (InterruptedException e)
                            {
                                assert(false);
                            }
                            assert((pg.getStatus() & java.awt.image.ImageObserver.ABORT) == 0);
                            int alpha = (pixels[0]>>24) & 0xff;
                            int red =   (pixels[0]>>16) & 0xff;
                            int green = (pixels[0]>> 8) & 0xff;
                            int blue =  (pixels[0]    ) & 0xff;

                            mg.setColor(java.awt.Color.white);
                            mg.drawString(""+focusX+","+focusY+": "+red+","+green+","+blue+(alpha==255?"":" "+alpha),
                                          size.width/minSize,-size.height/minSize,
                                          1., 1.5,
                                          java.awt.Color.black); // background
                        }
                    }

                    frontBufferGraphics.drawImage(backBufferImage,
                                                  0, 0,
                                                  getWidth(),  // of canvas, not back buffer
                                                  getHeight(), // of canvas, not back buffer
                                                  this);
                }

                if (false) // hack-- uncomment this to mess around with crackkiller
                {
                    if (mesh.getVert(1).Xnaive()
                      < mesh.getVert(0).Xnaive())
                        exploreCrackHead(mesh, 1, 0);
                    else
                        exploreCrackHead(mesh, 0, 1);
                }

                if (eventVerbose >= 1) System.out.println("out paint");
            } // paint

            private void makeSureBackBufferIsRight()
            {
                if (doubleBufferFlag)
                {
                    java.awt.Dimension size = getSize();
                    int shouldBeWidth = (int)Math.ceil((double)size.width);
                    int shouldBeHeight = (int)Math.ceil((double)size.height);
                    if (backBufferImage == null
                     || backBufferImage.getWidth(this) != shouldBeWidth
                     || backBufferImage.getHeight(this) != shouldBeHeight)
                    {
                        if (eventVerbose >= 1)
                        {
                            System.out.println("Creating back buffer " + shouldBeWidth + "x" + shouldBeHeight);
                        }
                        backBufferImage = createImage(shouldBeWidth,
                                                      shouldBeHeight);
                    }
                }
                else
                    backBufferImage = null;
            } // makeSureBackBufferIsRight
        } // class TheCanvas

            private static final int FACING_UNKNOWN = 0;
            private static final int FACING_BACK = 1;
            private static final int FACING_SIDE = 2;
            private static final int FACING_FRONT = 3;
            private static void getFacings(double eyeInLocalSpace[],
                                           Mesh mesh, Mesh dualMesh,
                                           int faceFacings[],
                                           int edgeFacings[],
                                           int vertFacings[],
                                           boolean wrapAroundSphereFlagValue,
                                           boolean centerSphereFlagValue,
                                           double wrapSphereCurvatureValue)
            {
                VecMath.fillvec(faceFacings, FACING_UNKNOWN);
                VecMath.fillvec(edgeFacings, FACING_UNKNOWN);
                VecMath.fillvec(vertFacings, FACING_UNKNOWN);

                int nVerts = mesh.verts.size();
                int nEdges = mesh.edges.size();
                int nDualVerts = dualMesh.verts.size();

                // compute face facings...
                //System.out.println("computing face facings");
                FORI (iFace, nDualVerts)
                {
                    Mesh.Vertex dualVert = dualMesh.getVert(iFace);

                    // plane is all points p such that p dot facePlaneNormal == facePlaneOffset
                    /*
                    double facePlaneNormal[] = {dualVert.x(), dualVert.y(), 1.}; // not unit length
                    double facePlaneOffset = -dualVert.z(); // magic!  I don't know why, but this is the correct value
                    */

                    double facePlaneNormal[];
                    double facePlaneOffset;

                    if (wrapAroundSphereFlagValue)
                    {
                        // reciprocated wrt sphere.

                        // just work with frickin actual coords,
                        // homogeneous coords are too confusing
                        // and w=0 is exceedingly rare in wrapped-around-sphere case anyway.
                        // this is STILL too frickin complicated!

                        facePlaneNormal = new double[] {
                            dualVert.x(),
                            dualVert.y(),
                            centerSphereFlagValue ? dualVert.z() : dualVert.z() + 1./wrapSphereCurvatureValue
                        };
                        double dualVertDist2FromCenter = VecMath.normsqrd(facePlaneNormal);
                        double facePlaneClosestPoint[] = VecMath.vxs(facePlaneNormal, 1./dualVertDist2FromCenter);
                        if (!centerSphereFlagValue)
                            facePlaneClosestPoint[2] -= 1./wrapSphereCurvatureValue;
                        facePlaneOffset = VecMath.dot(facePlaneNormal, facePlaneClosestPoint);
                    }
                    else
                    {
                        // reciprocated wrt paraboloid
                        facePlaneNormal = new double[] {dualVert.X(), dualVert.Y(), dualVert.W()}; // i.e. x,y,1.  not unit length.
                        facePlaneOffset = -dualVert.Z(); // i.e. z.  magic!  I don't know why, but this is the correct value
                    }
                    double frontness = VecMath.dot(facePlaneNormal, eyeInLocalSpace)
                                     - facePlaneOffset;
                    // XXX not sure the epsilons make sense... maybe normalize facePlaneNormal and offset, just so we can think straight about that?
                    if (LT(frontness, 0., SQR(1e-6)))
                        faceFacings[iFace] = FACING_BACK;
                    else if (GT(frontness, 0., SQR(1e-6)))
                        faceFacings[iFace] = FACING_FRONT;
                    else
                        faceFacings[iFace] = FACING_SIDE;
                }

                // Bleah, the faces that don't have dual verts
                // need to be computed by a separate method.
                // TODO: make all faces have dual verts?  Not sure, if non-planar then maybe that will cause more damage than it fixes
                FORI (iEdge, nEdges)
                {
                    Mesh.Edge edgeI = mesh.getEdge(iEdge);
                    Mesh.Edge dualEdgeI = dualMesh.getEdge(iEdge);
                    Mesh.Vertex leftDualVert = dualEdgeI.finalVertex();
                    int iLeftFace = leftDualVert==null ? nDualVerts : leftDualVert.myIndex();
                    if (faceFacings[iLeftFace] == FACING_UNKNOWN)
                    {
                        double normal[] = {0,0,0}; // for starters
                        double moment[] = {0,0,0}; // for starters
                        double centroid[] = null;
                        // XXX TODO: centroid of verts might be more robust than area centroid? yeah I think so
                        double area = 0.;
                        {
                            Mesh.Vertex v0 = edgeI.initialVertex();
                            // XXX TODO: compute in homogeneous space
                            double v0coords[] = {v0.x(), v0.y(), v0.z()};
                            double v1coords[] = new double[3]; // scratch for loop
                            double v2coords[] = new double[3]; // scratch for loop
                            double thisCentroid[] = new double[3]; // scratch for loop
                            double thisWeightedNormal[] = new double[3]; // scratch for loop
                            for (Mesh.Edge edgeJ = edgeI.next(); edgeJ != edgeI; edgeJ = edgeJ.next())
                            {
                                Mesh.Vertex v1 = edgeJ.initialVertex();
                                Mesh.Vertex v2 = edgeJ.finalVertex();
                                v1coords[0] = v1.x();
                                v1coords[1] = v1.y();
                                v1coords[2] = v1.z();
                                v2coords[0] = v2.x();
                                v2coords[1] = v2.y();
                                v2coords[2] = v2.z();
                                VecMath.vmv(v1coords, v1coords, v0coords);
                                VecMath.vmv(v2coords, v2coords, v0coords);
                                VecMath.vxv3(thisWeightedNormal, v1coords, v2coords);
                                VecMath.vpv(normal, normal, thisWeightedNormal);
                                double thisArea = VecMath.norm(thisWeightedNormal);
                                area += thisArea;
                                VecMath.sxvpsxv(thisCentroid, 1/3., v1coords, 1/3., v2coords); // relative to v0
                                VecMath.vpsxv(moment, moment, thisArea, thisCentroid);
                            }
                            centroid = VecMath.vpsxv(v0coords, 1./area, moment);
                        }
                        double frontness = VecMath.dot(normal, eyeInLocalSpace)
                                         - VecMath.dot(normal, centroid);
                        //PRINT(frontness);
                        // XXX not sure the epsilons make sense... maybe normalize normal, just so we can think straight about that?
                        if (LT(frontness, 0., SQR(1e-6)))
                            faceFacings[iLeftFace] = FACING_BACK;
                        else if (GT(frontness, 0., SQR(1e-6)))
                            faceFacings[iLeftFace] = FACING_FRONT;
                        else
                            faceFacings[iLeftFace] = FACING_SIDE;
                        //PRINTVEC(normal);
                    }
                }

                // compute edge facings from incident face facings...
                //System.out.println("computing edge facings");
                FORI (iEdge, nEdges)
                {
                    if (edgeFacings[iEdge] == FACING_UNKNOWN) // if not already done by opposite edge
                    {
                        Mesh.Edge edgeI = mesh.getEdge(iEdge);
                        Mesh.Edge dualEdgeI = dualMesh.getEdge(iEdge);
                        Mesh.Vertex leftDualVert = dualEdgeI.finalVertex();
                        Mesh.Vertex rightDualVert = dualEdgeI.initialVertex();
                        int iLeftFace = leftDualVert==null ? nDualVerts : leftDualVert.myIndex();
                        int iRightFace = rightDualVert==null ? nDualVerts : rightDualVert.myIndex();
                        int leftFaceFacing = faceFacings[iLeftFace];
                        int rightFaceFacing = faceFacings[iRightFace];
                        // XXX not sure this is quite right-- maybe UNKNOWN should yield to all others?
                        edgeFacings[iEdge] = leftFaceFacing==rightFaceFacing ? leftFaceFacing
                                                                             : FACING_SIDE;
                        int oEdge = edgeI.opposite().myIndex();
                        edgeFacings[oEdge] = edgeFacings[iEdge];
                    }
                }
                // compute vert facings from incident edge facings...
                //System.out.println("computing vert facings");
                FORI (iEdge, nEdges)
                {
                    // only need to do initial vertex-- edge.opposite() will do final vertex
                    Mesh.Vertex v0 = mesh.getEdge(iEdge).initialVertex();
                    if (v0 == null)
                        continue;
                    int i0 = v0.myIndex();
                    if (vertFacings[i0] == FACING_UNKNOWN)
                        vertFacings[i0] = edgeFacings[iEdge];
                    else if (vertFacings[i0] != edgeFacings[iEdge])
                        vertFacings[i0] = FACING_SIDE;
                }

                if (false)
                {
                    System.out.println("--------");
                    final char facingToChar[] = {'?','-','0','+'};
                    {
                        StringBuffer sb = new StringBuffer();
                        FORI (i, faceFacings.length)
                            sb.append(facingToChar[faceFacings[i]]);
                        System.out.println("    face facings: "+sb);
                    }
                    {
                        StringBuffer sb = new StringBuffer();
                        FORI (i, edgeFacings.length)
                            sb.append(facingToChar[edgeFacings[i]]);
                        System.out.println("    edge facings: "+sb);
                    }
                    {
                        StringBuffer sb = new StringBuffer();
                        FORI (i, vertFacings.length)
                            sb.append(facingToChar[vertFacings[i]]);
                        System.out.println("    vert facings: "+sb);
                    }
                    System.out.println("--------");
                }
            } // getFacings

            private void delaunayize()
            {
                this.mesh = delaunayized(this.mesh);
            }
            private Mesh delaunayized(Mesh mesh)
            {
                //
                // Discard the mesh edges and replace it with
                // the Delaunay triangulation of the vertex set,
                // using 3d convex hull.

                int nVerts = mesh.verts.size();
                boolean wrapAroundSphereFlagValue = wrapAroundSphereFlag.get();
                double wrapSphereCurvatureValue = wrapSphereCurvature.get();


                double verts[][] = new double[nVerts][/*4*/];
                double vertsForHull[][] = new double[nVerts][/*3*/];
                double scratchVert4in[] = new double[4];
                double scratchVert4out[] = new double[4];
                double wrapMat[][] = wrapAroundSphereFlagValue ? null : getWrapAroundSphereMatrix(wrapSphereCurvatureValue, centerSphereFlag.get());
                FORI (iVert, nVerts)
                {
                    Mesh.Vertex v = mesh.getVert(iVert);
                    verts[iVert] = new double[]{v.X(), v.Y(), v.Z(), v.W()};
                    if (wrapAroundSphereFlagValue)
                        vertsForHull[iVert] = new double[]{v.x(), v.y(), v.z()};
                    else
                    {
                        // could keep related to paraboloid,
                        // but it's more stable to project to the sphere
                        // (especially if there are verts at or near infinity
                        // on the paraboloid)
                        scratchVert4in[0] = v.X();
                        scratchVert4in[1] = v.Y();
                        scratchVert4in[2] = v.Z();
                        scratchVert4in[3] = v.W();
                        VecMath.vxm(scratchVert4out,
                                    scratchVert4in, wrapMat);
                        vertsForHull[iVert] = new double[]{scratchVert4out[0]/scratchVert4out[3],
                                                           scratchVert4out[1]/scratchVert4out[3],
                                                           scratchVert4out[2]/scratchVert4out[3]};
                    }
                }

                //PRINTARRAY(verts);
                //PRINTARRAY(vertsForHull);
                // normalize to range -1..1 in all three dimensions
                double bbox[][] = VecMath.bbox(vertsForHull);
                if (bbox != null)
                {
                    FORI (iDim, 3)
                    {
                        double bboxCenter = .5*(bbox[1][iDim]+bbox[0][iDim]);
                        double bboxRadius = .5*(bbox[1][iDim]-bbox[0][iDim]);
                        if (bboxRadius == 0.)
                            bboxRadius = 1.;
                        FORI (iVert, nVerts)
                            vertsForHull[iVert][iDim] = (vertsForHull[iVert][iDim] - bboxCenter) / bboxRadius;
                    }
                }
                //System.out.println("    computing convex hull");

                //ConvexHull.debugLevel = 3;

                long t0millis = System.currentTimeMillis();

                // Notes on tolerance bounds:
                //  - <=1e-11 works, >=1e-10 gives bad geom on finest part of CrackGoesInSpiral.
                //  - at one time (f41abb7 2012/10/09) there was a comment here "1e-12 was too small, created inconsistencies" and tol was set to 1e-11, and test cases were added to ConvexHull, but ConvexHull was later made more robust, supposedly (be5def5 2012/10/17)
                // Currently I actually don't know of any bad cases in <=3d with tol=0,
                // so use it until proven otherwise.
                double tol = 0.;
                int hullStuff[/*3*/][/*nFacets*/][/*d=3*/] = ConvexHull.convexHull(vertsForHull, tol);

                int hull[/*nFacets*/][/*d=3*/] = hullStuff[0];
                long t1millis = System.currentTimeMillis();
                double calcSeconds = (t1millis-t0millis)*1e-3;
                boolean sanityCheckFlag = false; // hard coded
                if (sanityCheckFlag)
                {
                    System.out.print("    convex hull calc+check took "+calcSeconds+" + ");
                    System.out.flush();
                    ConvexHull.sanityCheckConvexHull(3, vertsForHull, hull, 1e-8);
                    long t2millis = System.currentTimeMillis();
                    double checkSeconds = (t2millis-t1millis)*1e-3;
                    System.out.println(checkSeconds+" seconds");
                }
                else
                    System.out.println("     calc convex hull took "+calcSeconds+" seconds");


                // correct it, if 2 verts
                if (nVerts == 2)
                    hull = new int[][]{{0,1},{0,1}};

                // ack! need to circumvent invalidation of selection
                boolean wasValid = (meshOfSelectedTris == mesh);

                mesh = new Mesh(verts, hull);

                if (wasValid)
                    meshOfSelectedTris = mesh;

                //
                // Now get rid of each edge
                // that separates two non-positive-area faces.
                // Analyze all the edges first before deleting any,
                // so that we are only looking at triangle areas.
                //
                if (!calcInsideOutDualVertsFlag.get())
                {
                    ArrayList edgesToDelete = new ArrayList();
                    int nEdges = mesh.edges.size();
                    for (int iEdge = 0; iEdge < nEdges; iEdge += 2) // only one of an edge and its opposite
                    {
                        Mesh.Edge edge = mesh.getEdge(iEdge);
                        if (mesh.twiceFaceArea(edge) <= SQR(1e-6)
                         && mesh.twiceFaceArea(edge.opposite()) <= SQR(1e-6))
                            edgesToDelete.add(edge);
                    }
                    int nEdgesToDelete = edgesToDelete.size();
                    //System.out.println("    removing "+nEdgesToDelete+" backside edges");
                    FORI (iEdgeToDelete, nEdgesToDelete)
                    {
                        Mesh.Edge edge = (Mesh.Edge)edgesToDelete.get(iEdgeToDelete);
                        mesh.deleteEdge(edge);
                    }
                }
                return mesh;

                // XXX should get rid of unreferenced vertices? NO! But should get rid of dups maybe
            } // delaunayize

            private void doCannedThingAlgorithm5Killer0()
            {
                if (true)
                {
                    double verts[][] = {
                        {0,0},     // 0
                        //{0,14,-1.5},    // 1
                        {0,10.5,-.8},    // 1
                        {7,7},     // 2
                        {-7,7},    // 3
                        {31,-5,10},   // 4
                        {-31,-5,10},  // 5
                        {28,-14},  // 6
                        {-28,-14}, // 7
                        {52,-26},  // 8
                        {-52,-26}, // 9
                    };
                    // XXX lame, we are scaling heights wrong... picked heights empirically for this wrongness
                    VecMath.mxs(verts, verts,
                                .02);
                    int faces[][] = {
                        {0,2,1},
                        {0,6,2},
                        {2,6,4},
                        {4,6,8},
                        {0,1,3},
                        {0,3,7},
                        {3,5,7},
                        {5,9,7},
                        {0,7,9,5,3,1,2,4,8,6},
                    };
                    mesh = new Mesh(verts, faces);
                }



                if (true)
                {
                    double scale = .05;

                    //double topTilt = DTOR(2.);
                    //double topTilt = DTOR(45.);
                    //double topTilt = Math.atan2(1,2);
                    //double topTilt = Math.atan2(1,2)/2;
                    double topTilt = Math.atan2(1,4);
                    double q = 250;
                    double qq = 300;
                    double verts[][] = {
                        {0,0},     // 0
                        {0,7+7*Math.tan(topTilt)}, // 1
                        {7,7},     // 2
                        {-7,7},    // 3
                        {14,0},  // 4
                        {-14,0}, // 5
                        {15,3},   // 6
                        {-15,3},  // 7
                        {14.5+q*Math.cos(DTOR(30.)), 1.5-q*Math.sin(DTOR(30.))},  // 8
                        {-14.5-q*Math.cos(DTOR(30.)), 1.5-q*Math.sin(DTOR(30.))},  // 9
#define DO_OUTER
#ifdef DO_OUTER
                        {14.5+qq*Math.cos(DTOR(30.)), 1.5-qq*Math.sin(DTOR(30.))},  // 10
                        {-14.5-qq*Math.cos(DTOR(30.)), 1.5-qq*Math.sin(DTOR(30.))},  // 11
                        {0,50}, // 12     (will be adjusted)
#endif // DO_OUTER
                    };
#ifdef DO_OUTER
                    verts[12][1] = verts[10][1] + Math.sqrt(3.)*verts[10][0];
#endif // DO_OUTER
                    int faces[][] = {
                        {1,0,2},
                        {0,1,3},
                        {2,0,4},
                        {0,3,5},
                        {2,4,6},
                        {5,3,7},
                        {6,4,8},
                        {5,7,9},

#ifndef DO_OUTER // if NOT doing outer
                        {0,5,9,7,3,1,2,6,8,4},
#endif // DO_OUTER

#ifdef DO_OUTER
                        {6,8,10},
                        {9,7,11},
                        {10,0,11},
                        {10,8,4},
                        {10,4,0},
                        {11,5,9},
                        {11,0,5},

                        //{10,11,5,3,1,2,4},
                        {12,11,7},
                        {12,7,3},
                        {12,3,1},
                        {12,1,2},
                        {12,2,6},
                        {12,6,10},
                        {12,10,11},
#endif // DO_OUTER
                    };
                    // corresponding to the triangular faces... (some of them)
                    double desiredDualVerts[][] = {
                        {1,3},
                        {-1,3},
                        {3,1},
                        {-3,1},
                        {9,7},
                        {-9,7},

                        //{12,6},
                        //{-12,6},

                        //{15,5},
                        //{-15,5},

                        {18,4},
                        {-18,4},

#ifdef DO_OUTER
                        {12+.5*Math.cos(RTOD(60.))/Math.sin(RTOD(60.)), 6.5}, // this one is only approximate, and will be adjusted below
                        {-12-.5*Math.cos(RTOD(60.))/Math.sin(RTOD(60.)), 6.5}, // this one is only approximate, and will be adjusted below
#endif // DO_OUTER
                    };
#ifdef DO_OUTER
                    PRINTVEC(desiredDualVerts[desiredDualVerts.length-2]);
                    PRINTVEC(desiredDualVerts[desiredDualVerts.length-1]);
                    double height = (desiredDualVerts[desiredDualVerts.length-5][1]
                                   - desiredDualVerts[desiredDualVerts.length-3][1])/2.;
                    double length = height / Math.sin(RTOD(60.));
                    desiredDualVerts[desiredDualVerts.length-1][1] =
                    desiredDualVerts[desiredDualVerts.length-2][1] =
                        desiredDualVerts[desiredDualVerts.length-3][1] + height;
                    desiredDualVerts[desiredDualVerts.length-1][0] =
                    -(desiredDualVerts[desiredDualVerts.length-2][0] =
                         desiredDualVerts[desiredDualVerts.length-4][0] + length * Math.cos(RTOD(60.)));
                    PRINTVEC(desiredDualVerts[desiredDualVerts.length-2]);
                    PRINTVEC(desiredDualVerts[desiredDualVerts.length-1]);

                    boolean doBackface = true;
                    if (doBackface)
                    {
                        verts = (double[][])Arrays.append(verts,
                                                          VecMath.bary(verts[verts.length-3],
                                                                       verts[verts.length-2], 1/3.,
                                                                       verts[verts.length-1], 1/3.));
                        verts[verts.length-1] = (double[])Arrays.append(verts[verts.length-1], -6./(scale*scale)); // shameless hardcoding
                        // Replace the last face with 3 faces
                        faces[faces.length-1] = new int[]{10,11,13};
                        faces = (int[][])Arrays.append(faces, new int[]{11,12,13});
                        faces = (int[][])Arrays.append(faces, new int[]{12,10,13});
                    }
#endif // DO_OUTER
                    // make room for heights in the array
                    FORI (iVert, verts.length)
                        if (verts[iVert].length == 2)
                            verts[iVert] = (double[])Arrays.append(verts[iVert], 0.);
                    // adjust heights to make the dual verts right
                    FORI (iVert, desiredDualVerts.length+2)
                    {
                        if (iVert == 0)
                            verts[iVert][2] = 0.;
                        else if (iVert == 1)
                        {
                            // Get the y coord of desiredDualVerts[0] right
                            double sampleResultVerts[][] = new double[2][3];
                            int iDualVert = 0;
                            double v0[] = verts[faces[iDualVert][0]];
                            double v1[] = verts[faces[iDualVert][1]];
                            double v2[] = verts[faces[iDualVert][2]];
                            FORI (iSample, 2)
                            {
                                verts[iVert][2] = (double)iSample; // 0. or 1.
                                SolveForDualPoint(v0[0],v0[1],v0[2],
                                                  v1[0],v1[1],v1[2],
                                                  v2[0],v2[1],v2[2],
                                                  sampleResultVerts[iSample],
                                                  false, // wrapAroundSphereFlag
                                                  false, // centerSphereFlag
                                                  0.); // wrapSphereCurvature
                            }
                            double toDesired[] = VecMath.vmv(2, desiredDualVerts[iDualVert], sampleResultVerts[0]);
                            double toSample1[] = VecMath.vmv(2, sampleResultVerts[1], sampleResultVerts[0]);
                            double t = toDesired[1] / toSample1[1];
                            verts[iVert][2] = t;

                            // check...
                            double finalResultVert[] = new double[3];
                            SolveForDualPoint(v0[0],v0[1],v0[2],
                                              v1[0],v1[1],v1[2],
                                              v2[0],v2[1],v2[2],
                                              finalResultVert,
                                              false, // wrapAroundSphereFlag
                                              false, // centerSphereFlag
                                              0.); // wrapSphereCurvature
                            //PRINTVEC(desiredDualVerts[iDualVert]);
                            //PRINTVEC(finalResultVert);
                            assert(Math.abs(desiredDualVerts[iDualVert][1]-finalResultVert[1]) <= 1e-6);
                        }
                        else
                        {
                            assert(faces[iVert-2][2] == iVert);
                            double sampleResultVerts[][] = new double[2][3];
                            int iDualVert = iVert-2;
                            double v0[] = verts[faces[iDualVert][0]];
                            double v1[] = verts[faces[iDualVert][1]];
                            double v2[] = verts[faces[iDualVert][2]];
                            FORI (iSample, 2)
                            {
                                verts[iVert][2] = (double)iSample; // 0. or 1.
                                SolveForDualPoint(v0[0],v0[1],v0[2],
                                                  v1[0],v1[1],v1[2],
                                                  v2[0],v2[1],v2[2],
                                                  sampleResultVerts[iSample],
                                                  false, // wrapAroundSphereFlag
                                                  false, // centerSphereFlag
                                                  0.); // wrapSphereCurvature
                            }
                            double toDesired[] = VecMath.vmv(2, desiredDualVerts[iDualVert], sampleResultVerts[0]);
                            double toSample1[] = VecMath.vmv(2, sampleResultVerts[1], sampleResultVerts[0]);
                            double t = VecMath.dot(2, toDesired,toSample1) / VecMath.dot(2, toSample1,toSample1);
                            verts[iVert][2] = t;

                            // check...
                            double finalResultVert[] = new double[3];
                            SolveForDualPoint(v0[0],v0[1],v0[2],
                                              v1[0],v1[1],v1[2],
                                              v2[0],v2[1],v2[2],
                                              finalResultVert,
                                              false, // wrapAroundSphereFlag
                                              false, // centerSphereFlag
                                              0.); // wrapSphereCurvature
                            PRINTVEC(desiredDualVerts[iDualVert]);
                            PRINTVEC(finalResultVert);
                            //assert(VecMath.dist(desiredDualVerts[iDualVert], finalResultVert) <= 1e-6);
                        }
                    }
#ifdef DO_OUTER
                    // apex height is same as other outer heights
                    PRINT(verts[10][2]);
                    PRINT(verts[11][2]);
                    assert(Math.abs(verts[11][2]-verts[10][2]) <= 1e-6);
                    verts[12][2] = verts[11][2];
#endif
                    FORI (iVert, verts.length)
                    {
                        verts[iVert][0] *= scale;
                        verts[iVert][1] *= scale;
                        if (verts[iVert].length > 2)
                            verts[iVert][2] *= scale*scale;
                    }
                    mesh = new Mesh(verts, faces);
                }
            } // doCannedThingAlgorithm5Killer

            private void doCannedThingAlgorithm5Killer1()
            {
                if (true)
                {
                    double scale = 1/60000.;

                    double q = 30; // for working
                    //double q = 100; // the real thing
                    //double q = 60; // try not so extreme
                    double qq = 90;
                    //double qq = 300; // the real thing
                    //double qq = 180; // try not so extreme
                    double fudgeUp = 0; // fraction of big triangle height to move big triangle up
                    double verts[][] = {
                        {0,0},      // 0
                        {0,7},      // 1
                        {14,28},    // 2
                        {-14,28},   // 3

                        VecMath.lerp(new double[]{7,14},new double[]{392,-98},.8), // 4
                        VecMath.lerp(new double[]{-7,14},new double[]{-392,-98},.8), // 5



                        {392,-98},  // 6
                        {-392,-98}, // 7

                        {398,-68},  // 8
                        {-398,-68}, // 9

                        {q*395, -83},  // 10
                        {-q*395, -83}, // 11
                        {q*395, -83 + .25*q*395}, // 12
                        {-q*395, -83 + .25*q*395}, // 13

                        {q*395 + qq*395, -83 - qq*395}, // 14
                        {-q*395 - qq*395, -83 - qq*395}, // 15

                        {0, 1000}, // 16 -- will be adjusted
                    };
                    verts[16][1] = verts[14][1] + Math.sqrt(3.)*verts[14][0];
                    verts[14][1] += fudgeUp * verts[14][0];
                    verts[15][1] += fudgeUp * verts[14][0];
                    verts[16][1] += fudgeUp * verts[14][0];

                    int faces[][] = {
                        {1,0,2},
                        {0,1,3},
                        {1,2,3},

                        //{2,0,6},
                        {2,0,4},
                        {4,0,6},
                        {2,4,6},

                        {0,3,7},
                        //{0,3,5},
                        //{0,5,7},
                        //{5,3,7},

                        {2,6,8},
                        {7,3,9},
                        {8,6,10},
                        {7,9,11},

                        {8,10,12},
                        {11,9,13},

                        {6,0,14},
                        {0,7,15},


                        {2,12,16}, // moved up from below so can match with a desiredDualVert




                        {10,6,14},
                        {7,11,15},

                        {12,10,14},
                        {11,13,15},

                        {0,15,14},

                        {15,13,16},

                        {13,9,3},
                        {13,3,16},

                        {3,2,16},


                        {2,8,12},
                        //{2,12,16}, // moving this up

                        {12,14,16},
                        {14,15,16},
                    };
                    // corresponding to the triangular faces... (some of them)
                    double desiredDualVerts[][] = {
                        {3,0},
                        {-3,0},
                        {0,2},

                        //{5,-1},
                        {5,-1},
                        {4.75,-2},
                        {5.25,-.25},

                        {-5,-1},
                        //{-5,-1},
                        //{-4.75,-2},
                        //{-5.25,-.25},

                        {14,26},
                        {-14,26},
                        {19,25},
                        {-19,25},

                        {19,25.5},
                        {-19,25.5},

                        {4,-4},
                        {-4,-4},

                        //{14,46}, // approx
                        //{15,42}, // approx
                        {16,38}, // approx
                    };
                    VecMath.mxs(desiredDualVerts, desiredDualVerts,
                                80.);

                    boolean doBackface = true;
                    if (doBackface)
                    {
                        verts = (double[][])Arrays.append(verts,
                                                          VecMath.bary(verts[verts.length-3],
                                                                       verts[verts.length-2], 1/3.,
                                                                       verts[verts.length-1], 1/3.));
                        verts[verts.length-1] = (double[])Arrays.append(verts[verts.length-1], -.4/(scale*scale)); // shameless hardcoding
                        // Replace the last face with 3 faces
                        int oldLastFace[] = faces[faces.length-1];
                        faces[faces.length-1] = new int[]{oldLastFace[0],oldLastFace[1],verts.length-1};
                        faces = (int[][])Arrays.append(faces, new int[]{oldLastFace[1],oldLastFace[2],verts.length-1});
                        faces = (int[][])Arrays.append(faces, new int[]{oldLastFace[2],oldLastFace[0],verts.length-1});
                    }

                    // make room for heights in the array
                    FORI (iVert, verts.length)
                        if (verts[iVert].length == 2)
                            verts[iVert] = (double[])Arrays.append(verts[iVert], 0.);
                    // adjust heights to make the dual verts right
                    verts[0][2] = 0.;
                    {
                        int iVert = 1;
                        int iDualVert = 0;
                        // Get the y coord of desiredDualVerts[0] right
                        double sampleResultVerts[][] = new double[2][3];
                        double v0[] = verts[faces[iDualVert][0]];
                        double v1[] = verts[faces[iDualVert][1]];
                        double v2[] = verts[faces[iDualVert][2]];
                        FORI (iSample, 2)
                        {
                            verts[iVert][2] = (double)iSample; // 0. or 1.
                            SolveForDualPoint(v0[0],v0[1],v0[2],
                                              v1[0],v1[1],v1[2],
                                              v2[0],v2[1],v2[2],
                                              sampleResultVerts[iSample],
                                              false, // wrapAroundSphereFlag
                                              false, // centerSphereFlag
                                              0.); // wrapSphereCurvature
                        }
                        double toDesired[] = VecMath.vmv(2, desiredDualVerts[iDualVert], sampleResultVerts[0]);
                        double toSample1[] = VecMath.vmv(2, sampleResultVerts[1], sampleResultVerts[0]);
                        double t = toDesired[1] / toSample1[1];
                        verts[iVert][2] = t;

                        // check...
                        double finalResultVert[] = new double[3];
                        SolveForDualPoint(v0[0],v0[1],v0[2],
                                          v1[0],v1[1],v1[2],
                                          v2[0],v2[1],v2[2],
                                          finalResultVert,
                                          false, // wrapAroundSphereFlag
                                          false, // centerSphereFlag
                                          0.); // wrapSphereCurvature
                        //PRINTVEC(desiredDualVerts[iDualVert]);
                        //PRINTVEC(finalResultVert);
                        assert(Math.abs(desiredDualVerts[iDualVert][1]-finalResultVert[1]) <= 1e-6);
                    }

                    FORI (iDualVert, desiredDualVerts.length)
                    {
                        int iVert = faces[iDualVert][2];
                        double sampleResultVerts[][] = new double[2][3];
                        double v0[] = verts[faces[iDualVert][0]];
                        double v1[] = verts[faces[iDualVert][1]];
                        double v2[] = verts[faces[iDualVert][2]];
                        FORI (iSample, 2)
                        {
                            verts[iVert][2] = (double)iSample; // 0. or 1.
                            SolveForDualPoint(v0[0],v0[1],v0[2],
                                              v1[0],v1[1],v1[2],
                                              v2[0],v2[1],v2[2],
                                              sampleResultVerts[iSample],
                                              false, // wrapAroundSphereFlag
                                              false, // centerSphereFlag
                                              0.); // wrapSphereCurvature
                        }
                        double toDesired[] = VecMath.vmv(2, desiredDualVerts[iDualVert], sampleResultVerts[0]);
                        double toSample1[] = VecMath.vmv(2, sampleResultVerts[1], sampleResultVerts[0]);
                        double t = VecMath.dot(2, toDesired,toSample1) / VecMath.dot(2, toSample1,toSample1);
                        verts[iVert][2] = t;

                        // check...
                        double finalResultVert[] = new double[3];
                        SolveForDualPoint(v0[0],v0[1],v0[2],
                                          v1[0],v1[1],v1[2],
                                          v2[0],v2[1],v2[2],
                                          finalResultVert,
                                          false, // wrapAroundSphereFlag
                                          false, // centerSphereFlag
                                          0.); // wrapSphereCurvature
                        PRINTVEC(desiredDualVerts[iDualVert]);
                        PRINTVEC(finalResultVert);
                        //assert(VecMath.dist(desiredDualVerts[iDualVert], finalResultVert) <= 1e-6);
                    }

                    FORI (iVert, verts.length)
                    {
                        verts[iVert][0] *= scale;
                        verts[iVert][1] *= scale;
                        if (verts[iVert].length > 2)
                            verts[iVert][2] *= scale*scale;
                    }
                    mesh = new Mesh(verts, faces);
                }
            } // doCannedThingAlgorithm5Killer

            private void doBlueNoiseThing(int n)
            {
                double stubbornness = 100;
                //double overlappingDiskRadiusX = .02;
                //double overlappingDiskRadiusY = .02;
                //double overlappingDiskRadiusX = .05;
                //double overlappingDiskRadiusY = .05;
                //double overlappingDiskRadiusX = .2;
                //double overlappingDiskRadiusY = .2;
                // heuristic to get same number of points as nxn square grid
                double magic = 1.6165;
                double overlappingDiskRadiusX = magic/n;
                double overlappingDiskRadiusY = magic/n;
                double verts[][];
                if (wrapAroundSphereFlag.get())
                {
                    verts = generateBlueNoiseOnUnitSphere(stubbornness,
                                                          overlappingDiskRadiusX);
                    if (!centerSphereFlag.get())
                        VecMath.mmv(verts, verts, new double[]{0,0,1./wrapSphereCurvature.get()});
                    FORI (iVert, verts.length)
                        verts[iVert] = (double[])Arrays.append(verts[iVert], 1.); // X,Y,Z,W, not x,y,h
                }
                else
                {
                    verts = generateBlueNoiseOnUnitSquare(stubbornness,
                                                          overlappingDiskRadiusX,
                                                          overlappingDiskRadiusY);
                    VecMath.mmv(verts, verts, new double[]{.5,.5});
                    FORI (iVert, verts.length)
                        verts[iVert] = (double[])Arrays.append(verts[iVert], 0.); // make room for heights
                }
                mesh = new Mesh(verts, new int[][]{});
            } // doBlueNoiseThing

            private void doUniformGridThing(int nX)
            {
                if (nX <= 0)
                    mesh = new Mesh(new double[0][3], new int[][]{});
                else if (nX == 1)
                    mesh = new Mesh(new double[][] {{0.,0.,0.}}, new int[][]{});
                else if (pRotationalSymmetry.get() % 3 == 0)
                {
                    // do regular tri grid, verts of {3,6}
                    double r = 1.;
                    int nRots = 6;
                    int nVerts = nX*(nX-1)/2 * nRots + 1;
                    double verts[][] = new double[nVerts][3]; // zeros initially, heights stay zero
                    int iVert = 0;
                    verts[iVert][0] = 0; verts[iVert][1] = 0; iVert++;
                    FORI (iRot, nRots)
                    {
                        double c = cosPiTimes(iRot, 3);
                        double s = sinPiTimes(iRot, 3);
                        double m[][] = {{c,s},{-s,c}};
                        FORI (iY, nX-1)
                            FORI (iX, nX-iY-1)
                            {
                                double x = ((iX+1.)/(nX-1.) + iY/2./(nX-1.)) * r;
                                double y = (Math.sqrt(3.)/2. * iY / (nX-1.)) * r;
                                VecMath.sxvpsxv(verts[iVert++], x, m[0], y, m[1]);
                            }
                    }
                    //PRINT(iVert);
                    //PRINT(verts.length);
                    assert(iVert == verts.length);
                    mesh = new Mesh(verts, new int[][]{});
                }
                else
                {
                    // do regular square grid, verts of {4,4}
                    int nY = nX;
                    double verts[][] = new double[nX*nY][3]; // zeros initially, heights stay zero
                    int iVert = 0;
                    FORI (iY, nY)
                        FORI (iX, nX)
                        {
                            double x = LERP(-.5, .5, iX/(nX-1.));
                            double y = LERP(-.5, .5, iY/(nY-1.));
                            verts[iVert][0] = x;
                            verts[iVert][1] = y;
                            iVert++;
                        }
                    assert(iVert == verts.length);
                    mesh = new Mesh(verts, new int[][]{});
                }

                if (true)
                {
                    // randomly homogeneous scale half the verts by 2.
                    // this shouldn't change anything.
                    System.out.println("randomly homogeneous scaling about half the grid verts by 2");
                    int nVerts = mesh.verts.size();
                    FORI (iVert, nVerts)
                    {
                        Mesh.Vertex vert = mesh.getVert(iVert);
                        if (Math.random() > .5)
                            vert.setXYZW(vert.X()*2.,
                                         vert.Y()*2.,
                                         vert.Z()*2.,
                                         vert.W()*2.);
                    }
                }

            } // doUniformGridThing

            //
            // (If you want to follow this, hit Far Lagoon Killer 1 and then 'W')
            // Farthest-from-center lagoon exiting goes into an endless loop:
            //     A is the upper-left almost-horizontal edge
            //     B is the lower-right edge
            //     C is the edge halfway between them
            // Only bad exit A -> farthest good exit B
            // Only bad exit C -> farthest good exit A
            // Only bad exit B -> farthest good exit C
            // and we're back to the beginning.
            //
            private void doCannedThingFarthestLagoonExitKiller()
            {
                /*
                // really simple verts, no hand-crafting-- see what happens.  hmm this sucks, it doesn't get there!
                double verts[][] = {
                    {.1, .3, 0},
                    {-.1, .1, 0},
                    {-.1, .5, 0},
                    {.1, -.1, 0},
                    {-.1, -.3, 0},
                    {.1, -.5, 0},
                };
                */

                /*
                // original hand-crafted verts: violated farthest-exit constraint for top 2-vertex lagoon
                double verts[][] = {
                    {0.254632748975815, 0.6613110539845769, 0.0},
                    {0.001985463846777679, 0.40848329048843174, 0.0050},
                    {-0.0016100400996860165, 0.8262841442469365, -0.0705},
                    {0.15968401023145556, 0.09537275064267343, -0.0050},
                    {0.053309106411296145, 0.1762210796915167, -0.01},
                    {-0.4317114578915699, -0.6837916370249981, -0.5450000000000002},
                };
                */

                /*
                // optimized 10 passes: goodness = .017256350831721664 (using VecMath.synopsis which I'm not thrilled with any more)
                double verts[][] = {
                    {0.1800525435129707, 0.4676175307461174, 0.0},
                    {0.13567357880860711, 0.42320686396714136, 0.0025000000000000022},
                    {-0.041882330900956, 0.7515699545002962, -0.03525000000000006},
                    {0.29423490241724615, -0.015297283324235564, -0.024256623978102798},
                    {0.2657663454311589, 0.0032808826682159285, -0.02535592252632536},
                    {0.027482624239009528, -0.5713757012317203, -0.09458036525466695},
                };
                */

                // optimized 50 passes: goodness = .019362280324644425 (using VecMath.synopsis which I'm not thrilled with any more)
                double verts[][] = {
                    {0.1800525435129707, 0.4676175307461174, 0.0},
                    {0.1093067590185278, 0.3968212090624114, 0.0025000000000000022},
                    {-0.3578608151777813, 1.1748461992103727, -0.03525000000000006},
                    {0.6348756548188554, -0.5552758689949323, 0.1838002721879618},
                    {0.5790169179568446, -0.523270452612108, 0.14986341969960895},
                    {0.20759453708056247, -1.6232499556679696, 0.4089344906614831},
                };


                int faces[][] = {
                    {1, 3, 0},
                    {3, 1, 4},
                    {0, 3, 5, 4, 1, 2},
                    {1, 0, 2},
                    {3, 4, 5},
                };
                mesh = new Mesh(verts, faces);

            } // doCannedThingFarthestLagoonExitKiller

            //
            // (If you want to follow this, hit Far Lagoon Killer 2 and then '\', then 'W')
            // (or, instead of the below description: A is upper-left almost-vertical, B is upper right)
            // Farthest-from-center lagoon exiting goes into an endless loop:
            //     A is the upper-left almost-horizontal edge
            //     B is the lower-*left* edge
            //     C is the edge halfway between them
            // Only bad exit A -> farthest good exit B
            // Only bad exit C -> farthest good exit A
            // Only bad exit B -> farthest good exit C
            // and we're back to the beginning.
            //
            private void doCannedThingFarthestLagoonExitKillerAltB()
            {
/*
100 passes from original hand-crafted: simple synopsis = 0.0632903084802694
OFF
6 5 0
0.1273163744879075 0.3306555269922885 -1.3877787807814457E-17
0.007466950664434855 0.21072048883775582 0.0012499999999999976
0.063927946972354 0.45166494195664725 -0.01762500000000003
0.07725274705168253 0.017764193145660596 0.039682919717938775
0.019644371916512516 0.019129114462716725 0.013473915969745336
-0.2059752055364354 -0.6388679646686696 -0.06303872265462748
3  1 3 0
3  3 1 4
6  0 3 5 4 1 2
3  1 0 2
3  3 4 5

100 passed from 50 passes on original structure: simple synopsis = 0.08830543355804742
OFF
6 5 0
0.1800525435129707 0.4676175307461174 0.0
0.08303579636398613 0.37053147976867984 0.0025000000000000022
-0.1743207145354405 1.207926317312154 -0.03525000000000006
0.5935025616828306 -0.4786092404430522 0.20709150548025163
0.5086599164177077 -0.50309546392274 0.1310302693859244
0.5788838237668292 -1.7863394875007428 0.19118475261903686
3  1 3 0
3  3 1 4
6  0 3 5 4 1 2
3  1 0 2
3  3 4 5
*/
/*
                //100 passed from 50 passes on original structure: simple synopsis = 0.08830543355804742
                double verts[][] = {
                    {0.1800525435129707, 0.4676175307461174, 0.0},
                    {0.08303579636398613, 0.37053147976867984, 0.0025000000000000022},
                    {-0.1743207145354405, 1.207926317312154, -0.03525000000000006},
                    {0.5935025616828306, -0.4786092404430522, 0.20709150548025163},
                    {0.5086599164177077, -0.50309546392274, 0.1310302693859244},
                    {0.5788838237668292, -1.7863394875007428, 0.19118475261903686},
                };
                int faces[][] = {
                    {1, 3, 0},
                    {3, 1, 4},
                    {0, 3, 5, 4, 1, 2},
                    {1, 0, 2},
                    {3, 4, 5},
                };
*/

                // and then diagonally flipped and hand neatened
                double verts[][] = {
                    {-0.4375, 0.0625, 0},
                    {-0.375, 0.125, 0},
                    {-0.78125, 0.125, 0.0812},
                    {0.125, -0.125, 0.0518},
                    {0.140625, -0.078125, 0.0328},
                    {0.9375, -0.125, 0.0478},
                };
                int faces[][] = {
                    {0, 3, 1},
                    {4, 1, 3},
                    {2, 1, 4, 5, 3, 0},
                    {2, 0, 1},
                    {5, 4, 3},
                };

                mesh = new Mesh(verts, faces);

            } // doCannedThingFarthestLagoonExitKillerAltB

            private void doCannedThingFarthestLagoonExitKillerOptimized()
            {
                doCannedThingFarthestLagoonExitKiller();
                optimizeFarthestLagoonExitKiller();
            }
            private void optimizeFarthestLagoonExitKiller()
            {
                int fromsAndTos[][/*2*/][][/*3*/] = {
                    {{{0,2,1}}, {{0,2,1},{0,1,3},{1,4,3},{3,4,5}}}, // edge A must be a bad exit of everything
                    {{{0,1,3}}, {{0,1,3},{1,4,3},{3,4,5}}}, // upper inner edge must be good exit of 3-vert lagoon under it
                    {{{1,4,3}}, {{1,4,3},{3,4,5}}}, // edge C (center) must be a good exit for 2-vert lagoon under it
                    {{{3,4,5}}, {{0,2,1},{0,1,3},{1,4,3},{3,4,5}}}, // edge B must be a good exit of whole thing
                    {{{3,4,5}}, {{0,2,1},{0,1,3},{1,4,3},{3,4,5}}}, // edge B's evil twin must be a bad exit of whole thing

                    {{{0,1,3}}, {{0,2,1},{0,1,3}}}, // edge C (center) must be bad for upper 2-vert lagoon
                    {{{0,2,1}}, {{0,2,1},{0,1,3}}}, // edge A must be good for upper 2-vert lagoon
                    {{{0,2,1}}, {{0,2,1},{0,1,3}}}, // edge A's evil twin must be bad for upper 2-vert lagoon

                    {{{3,4,5}}, {{1,4,3},{3,4,5}}}, // edge B must be bad for lower 2-vert lagoon
                    {{{1,4,3}}, {{1,4,3},{3,4,5}}}, // edge C must be good for lower 2-vert lagoon
                    {{{1,4,3}}, {{1,4,3},{3,4,5}}}, // west edge must be bad for lower 2-vert lagoon
                };

                /*
                // ORIGINAL
                int toLeftOfEdgeEndIndices[][] = {
                    {1,2}, // edge A must be a bad exit of whole thing
                    {0,1}, // upper inner edge must be good exit of 3-vert lagoon under it
                    {3,1}, // edge C (center) must be a good exit for 2-vert lagoon under it
                    {5,3}, // edge B must be a good exit of whole thing
                    {5,4}, // edge B's evil twin must be a bad exit of whole thing

                    {3,1}, // edge C (center) must be bad for upper 2-vert lagoon
                    {2,1}, // edge A must be good for upper 2-vert lagoon
                    {2,0}, // edge A's evil twin must be bad for upper 2-vert lagoon

                    {3,5}, // edge B must be bad for lower 2-vert lagoon
                    {3,1}, // edge C must be good for lower 2-vert lagoon
                    {4,1}, // west edge must be bad for lower 2-vert lagoon
                };
                */


                // ALTERNATE B-- make B be the lower-left instead of lower-right
                int toLeftOfEdgeEndIndices[][] = {
                    {1,2}, // edge A must be a bad exit of whole thing
                    {0,1}, // upper inner edge must be good exit of 3-vert lagoon under it
                    {3,1}, // edge C (center) must be a good exit for 2-vert lagoon under it
                    {4,5}, // edge B must be a good exit of whole thing
                    {3,5}, // edge B's evil twin must be a bad exit of whole thing

                    {3,1}, // edge C (center) must be bad for upper 2-vert lagoon
                    {2,1}, // edge A must be good for upper 2-vert lagoon
                    {2,0}, // edge A's evil twin must be bad for upper 2-vert lagoon

                    {5,4}, // edge B must be bad for lower 2-vert lagoon
                    {3,1}, // edge C must be good for lower 2-vert lagoon
                    {4,1}, // west edge must be bad for lower 2-vert lagoon
                };

                /*
                // ALTERNATE AB-- make B be the lower-left instead of lower-right,
                //                make A be the upper-right instead of upper-left
                // (doesn't work :-( )
                int toLeftOfEdgeEndIndices[][] = {
                    {2,0}, // edge A must be a bad exit of whole thing
                    {0,1}, // upper inner edge must be good exit of 3-vert lagoon under it
                    {3,1}, // edge C (center) must be a good exit for 2-vert lagoon under it
                    {4,5}, // edge B must be a good exit of whole thing
                    {3,5}, // edge B's evil twin must be a bad exit of whole thing

                    {3,1}, // edge C (center) must be bad for upper 2-vert lagoon
                    {0,2}, // edge A must be good for upper 2-vert lagoon
                    {1,2}, // edge A's evil twin must be bad for upper 2-vert lagoon

                    {5,4}, // edge B must be bad for lower 2-vert lagoon
                    {3,1}, // edge C must be good for lower 2-vert lagoon
                    {4,1}, // west edge must be bad for lower 2-vert lagoon
                };
                */

                /*
                // ALTERNATE A-- make A be the upper-right instead of upper-left
                //               B is still lower-right
                // (doesn't work :-( )
                int toLeftOfEdgeEndIndices[][] = {
                    {2,0}, // edge A must be a bad exit of whole thing
                    {0,1}, // upper inner edge must be good exit of 3-vert lagoon under it
                    {3,1}, // edge C (center) must be a good exit for 2-vert lagoon under it
                    {5,3}, // edge B must be a good exit of whole thing
                    {5,4}, // edge B's evil twin must be a bad exit of whole thing

                    {3,1}, // edge C (center) must be bad for upper 2-vert lagoon
                    {0,2}, // edge A must be good for upper 2-vert lagoon
                    {1,2}, // edge A's evil twin must be bad for upper 2-vert lagoon

                    {3,5}, // edge B must be bad for lower 2-vert lagoon
                    {3,1}, // edge C must be good for lower 2-vert lagoon
                    {4,1}, // west edge must be bad for lower 2-vert lagoon
                };
                */

                boolean mustBeFarthestExit[] = {
                    false,
                    false,
                    false,
                    true,
                    false,

                    false,
                    true,
                    false,

                    false,
                    true,
                    false,
                };


                /*
                nice spec might look something like:
                    CCW lagoon boundary (can be in multiple pieces),   bad exits,    good exits, farthest exits

                    {{{0,2,1,4,5,3}}, {{2,1},{4,5}}, {{5,3}}, {{5,3}} }, // whole thing: A bad, B's evil twin bad, B good,  B farthest good from cg
                    {{{0,1,4,5,3}},   {},            {{0,1}}, {} }, // lower 3 vertices: upper inner edge good
                    {{{1,4,5,3}},     {{5,3},{1,4}}, {{3,1}}, {{3,1}} }, // lower 2 vertices: B bad, west edge bad, C good,  C farthest good from cg
                    {{{0,2,1,3}},     {{1,3},{0,2}}, {{2,1}}, {{2,1}} }, // upper 2 vertices: C bad, A's evil twin bad, A good,  A farthest good from cg


                */


                // doesn't seem to ever help much to consider edge lengths... weird.  also it's the 1-edgelength thing that hurts,  edgelength itself doesn't.  But, isn't that necessary to prevent it growing without bound?? dammit.
                boolean considerEdgeLengths = false;

                int nPasses = 2;
                //int maxCallsPerPass = 10*1000;
                //int maxCallsPerPass = 1*1000;
                //int maxCallsPerPass = 500;
                //int maxCallsPerPass = 255;
                //int maxCallsPerPass = 100;
                //int maxCallsPerPass = 53;
                //int maxCallsPerPass = 10;
                int maxCallsPerPass = 1;
                double initialDelta = .0001;

                Object optimizationPathVertsAndGoodnesses[/*2*/] = GeneralOptimizationStuff.optimizeVerts(mesh,
                    fromsAndTos,
                    toLeftOfEdgeEndIndices,
                    mustBeFarthestExit,
                    considerEdgeLengths,
                    nPasses,
                    maxCallsPerPass,
                    initialDelta,
                    false, // wrapAroundSphereFlagValue
                    false, // centerSphereFlag
                    0.); // wrapSphereCurvature
                double optimizationPathVerts[][][] = (double[][][])optimizationPathVertsAndGoodnesses[0];
                double optimizationPathGoodnesses[] = (double[])optimizationPathVertsAndGoodnesses[1];
                                                                        
                PRINT(optimizationPathVerts.length);
                double verts[][] = optimizationPathVerts[optimizationPathVerts.length-1];
                assert(verts.length == 6);
                FORI (iVert, verts.length)
                {
                    Mesh.Vertex v = mesh.getVert(iVert);
                    v.setXYHnaive(verts[iVert][0],
                             verts[iVert][1],
                             verts[iVert][2]);
                }

                PRINT(optimizationPathVerts.length);
                //PRINTARRAY(optimizationPathGoodnesses);

                this.theOptimizationPath = optimizationPathVerts;
                this.theOptimizationPathGoodnesses = optimizationPathGoodnesses;
                this.theOptimizationIndex = optimizationPathVerts.length-1;
            } // optimizeFarthestLagoonExitKiller




            private void doCannedThingNetless8()
            {
                double Eps = .04;
                double slope = 1./16; // started with 1./100, 1/10 works but starts pushing outer point far away
                //     3   2
                //       1
                //      5 4
                //       0
                double verts[][] = {
                    {0*Eps, -7*Eps, 0},  // the "lowest" face, bottom point of dual
                    {0*Eps, 7*Eps, 1.64*Eps*Eps}, // empirical
                    {2*Eps, 9*Eps, 0},
                    {-2*Eps, 9*Eps, 0},
                    {7*slope*Eps, 0,  -23*Eps*Eps},
                    {-7*slope*Eps, 0, -23*Eps*Eps},
                };

                int faces[][] = {
                    {5,4,1},
                    {0,4,5},
                    {4,2,1},
                    {5,1,3},
                    {5,3,0},
                    {2,4,0},
                    {1,2,3},
                    {0,3,2},
                };

                mesh = new Mesh(verts, faces);
            } // doCannedThingNetless8

            // Counterexample to entire class of sweep algorithms
            // that cut each vertex to a higher vertex.
            // It contains two netless8's.
            private void doCannedThingSweepKiller0()
            {
                // cheap way of getting verts of netless8
                doCannedThingNetless8();
                double netless8Verts[][] = new double[mesh.verts.size()][3];
                FORI (i, netless8Verts.length)
                {
                    Mesh.Vertex vertex = mesh.getVert(i);
                    netless8Verts[i][0] = vertex.Xnaive();
                    netless8Verts[i][1] = vertex.Ynaive();
                    netless8Verts[i][2] = vertex.Hnaive();
                }

                double separation = 2;
                double verts[][] = new double[2*netless8Verts.length][3];
                FORI (i, netless8Verts.length)
                {
                    VecMath.copyvec(verts[i], netless8Verts[i]);
                    verts[i][0] -= separation/2;
                    VecMath.copyvec(verts[netless8Verts.length+i], netless8Verts[i]);
                    verts[netless8Verts.length+i][0] += separation/2;
                }

                double netless8TriHeight = verts[2][1] - verts[0][1];
                double y = verts[0][1] - netless8TriHeight;
                double Eps = .04; // same as netless8
                double h = -110*Eps*Eps; // not strictly necessary, but makes it easier to think about

                verts = (double[][])Arrays.append(verts, new double[]{verts[3][0],
                                                  y,
                                                  h});
                verts = (double[][])Arrays.append(verts, new double[]{verts[2][0],
                                                  y,
                                                  h});
                verts = (double[][])Arrays.append(verts, new double[]{verts[9][0],
                                                  y,
                                                  h});
                verts = (double[][])Arrays.append(verts, new double[]{verts[8][0],
                                                  y,
                                                  h});
                y -= (verts[2][0]-verts[3][0])*3/4;
                verts = (double[][])Arrays.append(verts, new double[]{0,
                                                  y,
                                                  0});
                verts = (double[][])Arrays.append(verts, new double[]{verts[1][0],
                                                  y,
                                                  h});
                verts = (double[][])Arrays.append(verts, new double[]{verts[7][0],
                                                  y,
                                                  h});
                y += (verts[2][0]-verts[3][0])*3/4;
                y -= netless8TriHeight;
                verts = (double[][])Arrays.append(verts, new double[]{verts[3][0]-2*(verts[2][0]-verts[3][0]),
                                                                      y,
                                                                      0});
                verts = (double[][])Arrays.append(verts, new double[]{-verts[verts.length-1][0],
                                                                      y,
                                                                      0});


                int faces[][] = new int[0][0];
                mesh = new Mesh(verts, faces);

                // temporarily fudge to prevent degenerate edges on boundary
                mesh.getVert(3).setYnaive(mesh.getVert(3).Ynaive() - 1/1024.);
                mesh.getVert(8).setYnaive(mesh.getVert(8).Ynaive() - 1/1024.);
                delaunayize();
                mesh.getVert(3).setYnaive(mesh.getVert(3).Ynaive() + 1/1024.);
                mesh.getVert(8).setYnaive(mesh.getVert(8).Ynaive() + 1/1024.);

            } // doCannedThingSweepKiller0

            // Counterexample to entire class of sweep algorithms
            // that cut each vertex to a higher vertex.
            // Slightly simpler than SweepKiller0.
            private void doCannedThingSweepKiller1()
            {
                double verts[][] = {
                    {0,0,0},
                    {9,-9,0},
                    {6,-3,0},
                    {7,24,0},
                    {-7,24,0},
                    {-6,-3,0},
                    {-9,-9,0},

                    {7,-6,0},
                    {3,-2,0},

                    {-3,-2,0},
                    {-7,-6,0},
                };
                int faces[][] = {
                    //{0,1,2},
                    {0,1,8},
                    {1,7,8},
                    {1,2,7},
                    {2,0,8},
                    {2,8,7},

                    //{6,0,5},
                    {0,5,9},
                    {0,9,6},
                    {5,10,9},
                    {5,6,10},
                    {9,10,6},

                    {1,3,2},
                    {2,3,0},
                    {0,3,4},
                    {0,4,5},
                    {4,6,5},
                    {0,6,1},
                    {1,6,4,3},
                };
                // argh, requires panning the whole picture around randomly a bit in order for it to come out symmetric...
                VecMath.mpv(verts, verts, new double[]{.1,.1,0});
                mesh = new Mesh(verts, faces);
                mesh.findAndApplyOptimalVertexHeights(OPTIMIZE_LENGTHS_INFINITY_NORM);
                // XXX argh, still requires use to set OPTIMIZE_LENGTHS_INFINITY_NORM and turn on and off Optimize, otherwise the dual picture is tiny... why??

            } // doCannedThingSweepKiller1

            // Counterexample to entire class of sweep algorithms
            // that cut each vertex to a higher vertex.
            // Slightly simpler than SweepKiller1.
            private void doCannedThingSweepKiller2()
            {
                double verts[][] = {
                    {0,0,0},
                    {9,-9,0},
                    {6,-3,0},
                    {7,24,0},
                    {-7,24,0},
                    {-6,-3,0},
                    {-9,-9,0},
                    {3,-2,0},
                    {-3,-2,0},
                };

                int faces[][] = {
                    {0,1,7},
                    {1,2,7},
                    {2,0,7},

                    {0,5,8},
                    {0,8,6},
                    {5,6,8},

                    {1,3,2},
                    {2,3,0},
                    {0,3,4},
                    {0,4,5},
                    {4,6,5},
                    {0,6,1},
                    {1,6,4,3},
                };
                // argh, requires panning the whole picture around randomly a bit in order for it to come out symmetric...
                VecMath.mpv(verts, verts, new double[]{.1,.1,0});
                mesh = new Mesh(verts, faces);
                mesh.findAndApplyOptimalVertexHeights(OPTIMIZE_LENGTHS_INFINITY_NORM);
                // XXX argh, still requires use to set OPTIMIZE_LENGTHS_INFINITY_NORM and turn on and off Optimize, otherwise the dual picture is tiny... why??

            } // doCannedThingSweepKiller2


            // VecMath.synopsis might be brain damaged, not sure... try simpler way
            static double simpleSynopsis(int n, double v[])
            {
                FORI (i, n)
                    if (v[i] <= 0) // non-strict so we do it this way if on the boundary of the positive orthant
                    {
                        //
                        // Outside the positive orthant,
                        // return minus the euclidean distance
                        // to the positive orthant.
                        //
                        double sum = 0.;
                        for (; i < n; i++)
                            if (v[i] < 0.)
                                sum += v[i]*v[i];
                        return -Math.sqrt(sum);
                    }
                //
                // Inside the positive orthant, return the min.
                //
                return VecMath.min(n, v);
            } // simpleSynopsis

            // XXX should put this into VecMath, I think?
            // For two vars, the graph should look like this
            // (the diagonals are actually quarter-circles):
            //   | | | | | |               //
            //   | | | | | +               //
            //   | | | | |  \              //
            //   | | | | |   \             //
            //   | | | | |    \            //
            //   | | | | +     \           //
            //   | | | |  \     \          //
            //   | | | |   \     +-        //
            //   | | | |    \              //
            //   | | | +     +-----        //
            //   | | |  \                  //
            //   | | |   +---------        //
            //   | | |                     //
            //   + + +-------------        //
            //    \ \                      //
            //     \ +-------------        //
            //      \                      //
            //       +-------------        //
            // It's differentiable everywhere except at 0.
            // (non-differentiability at 0 is unavoidable
            // if we want scale-invariance).
            // XXX DOESN'T WORK-- see bottom of function body
            static double synopsis(int n, double v[])
            {
                double min = Double.POSITIVE_INFINITY;
                FORI (i, n)
                {
                    double x = v[i];
                    if (x <= 0) // non-strict so we do it this way if on the boundary of the positive orthant
                    {
                        //
                        // Outside the positive orthant,
                        // return minus the euclidean distance
                        // to the positive orthant.
                        //
                        double sum2 = 0.;
                        for (; i < n; i++)
                            if (v[i] < 0.)
                                sum2 += v[i]*v[i];
                        return -Math.sqrt(sum2);
                    }
                    min = MIN(min, x);
                }

                // All are positive.
                // The ones that participate are those that are < twice the smallest.
                // Call those x0,x1,...
                // We want to solve:
                //     (2*q-x0)^2 + (2*q-x1)^2 + (2*q-x2)^2 + ... = q^2
                //     n*4*q^2 - 4*q*(x0 + x1 + ...) + (x0^2 + x1^2 + ...) = q^2
                //     (4*n-1)*q^2 - 4*q*(x0 + x1 + ...) + (x0^2 + x1^2 + ...) = 0
                // Using the quadratic formula with:
                //       a = 4*n-1
                //       b = -4*(x0+x1+...)
                //       c = x0^2 + x1^2 + ...
                // The solution is
                // (we want the bigger of the two possibilities, so + rather than -):
                //       q = (-b + sqrt(b^2 - 4*a*c) / (2*a)
                //         = (4*(x0+...) + sqrt((4*(x0+...))^2 - 4*(4*n-1)*(x0^2+...)) / (2*(4*n-1))
                //         = (2*(x0+...) + sqrt((2*(x0+...))^2 - (4*n-1)*(x0^2+...)) / (4*n-1)
                // check, if just one var (n=1), q should be x0:
                //       q = (2*x0 + sqrt(4*x0^2 - 3*x0^2)) / 3
                //         = (2*x0 + x0) / 3
                //         = x0  check.
                int nParticipants = 0;
                double sum1 = 0.;
                double sum2 = 0.;
                FORI (i, n)
                {
                    double x = v[i];
                    if (x < 2*min)
                    {
                        PRINT(x);
                        nParticipants++;
                        sum1 += x;
                        sum2 += x*x;
                    }
                }
                if (nParticipants == 1)
                    return min;
                double discr = SQR(2*sum1) - (4*nParticipants-1)*sum2;
                PRINTVEC((double[])Arrays.subarray(v,0,n));
                PRINT(min);
                PRINT(sum1);
                PRINT(sum2);
                PRINT(discr);
                PRINT(nParticipants);
                //assert(discr >= 0.); // should be safely so (should be at least sum2)... can we reformulate to make that obvious?  no wait, that's not even right :-(  may need to go back to the drawing board on this whole thing
                //assert(GEQ(discr, 0., 5.549966375204551E-4));
                //assert(GEQ(discr, 0., 5.549966375204551E-4));
                //assert(GEQ(discr, 0., 0.004241588576413768));
                assert(GEQ(discr, 0., 0.007445722649008779));
                if (discr < 0.) discr = 0.; // FUDGE

                double q = (2*sum1 + Math.sqrt(discr)) / (4*nParticipants-1);
                return q;
            } // synopsis









            // General optimization:
            // maximize the minimum over:
            //     - length of each primal edge
            //     - length of each finite dual edge
            //     - 1-length of each primal edge
            //     - 1-length of each finite dual edge
            //     - a set of specified goodness-of-balances
            //
            // can constrain three vertex heights to be zero, I think, and one vertex position
            // (and maybe one coord of a second vertex's position)
            //
            private static class GeneralOptimizationStuff
            {
                private static void getMeshVertCoords(Mesh mesh, double coords[/*nVerts*/][/*3*/])
                {
                    FORI (iVert, coords.length)
                    {
                        Mesh.Vertex v = mesh.getVert(iVert);
                        coords[iVert][0] = v.Xnaive();
                        coords[iVert][1] = v.Ynaive();
                        coords[iVert][2] = v.Hnaive();
                    }
                }

                private static void vertsToDualMomentsAndAreas(double primalCoords[/*nVerts*/][/*3*/],
                                                               int tris[/*nDualVerts*/][/*3*/],
                                                               double dualMomentsAndAreas[/*nDualVerts*/][/*3*/],
                                                               boolean wrapAroundSphereFlagValue,
                                                               boolean centerSphereFlagValue,
                                                               double wrapSphereCurvatureValue)
                {
                    FORI (iDualVert, dualMomentsAndAreas.length)
                    {
                        int tri[] = tris[iDualVert];
                        double A[] = primalCoords[tri[0]];
                        double B[] = primalCoords[tri[1]];
                        double C[] = primalCoords[tri[2]];
                        SolveForDualMomentAndArea(A[0],A[1],A[2],
                                                  B[0],B[1],B[2],
                                                  C[0],C[1],C[2],
                                                  dualMomentsAndAreas[iDualVert],
                                                  wrapAroundSphereFlagValue,
                                                  centerSphereFlagValue,
                                                  wrapSphereCurvatureValue);
                    }
                }

                private static void momentsAndAreasToCoords(double momentsAndAreas[][/*3*/],
                                                            double coordss[][/*2*/])
                {
                    FORI(i, momentsAndAreas.length)
                    {
                        double momentAndArea[/*3*/] = momentsAndAreas[i];
                        double coords[/*2*/] = coordss[i];
                        double A = momentAndArea[2];
                        if (A == 0.)
                        {
                            coords[0] = 0.;
                            coords[1] = 0.;
                        }
                        else
                        {
                            coords[0] = momentAndArea[0] / A;
                            coords[1] = momentAndArea[1] / A;
                        }
                    }
                }

                // params are:
                //     dist from x0,y0 to x1,y1
                //     x2
                //     y2
                //     x3,y3,h3
                //     x4,y4,h4
                //     ...
                // fixed:
                //     x0
                //     y0
                //     h0
                //     direction from x0,y0 to x1,y1
                //     h1
                //     h2
                private static double[] vertsToParams(double verts[][/*3*/])
                {
                    double params[] = new double[verts.length*3 - 6];
                    // verts to params...
                    int iParam = 0;
                    double x0, y0, h0, x1, y1, h1, h2; // XXX could store these so paramsToVerts doesn't have to keep looking them up
                    FORI (iVert, verts.length)
                    {
                        double v[] = verts[iVert];
                        if (iVert == 0)
                        {
                            x0 = v[0];
                            y0 = v[1];
                            h0 = v[2];
                        }
                        else if (iVert == 1)
                        {
                            params[iParam++] = MyMath.hypot(v[0]-verts[0][0], v[1]-verts[0][1]);
                            x1 = v[0];
                            y1 = v[1];
                            h1 = v[2];
                        }
                        else if (iVert == 2)
                        {
                            params[iParam++] = v[0];
                            params[iParam++] = v[1];
                            h2 = v[2];
                        }
                        else
                        {
                            params[iParam++] = v[0];
                            params[iParam++] = v[1];
                            params[iParam++] = v[2];
                        }
                    }
                    PRINT(params.length);
                    PRINT(iParam);
                    assert(iParam == params.length);
                    return params;
                }


                // needs to be fast-- no memory allocations
                private static void paramsToVerts(Mesh primal, // for verts that are fixed
                                                  double params[], double verts[][])
                {
                    PRINT(verts.length);
                    PRINT(params.length);
                    assert(params.length == verts.length*3 - 6);
                    int iParam = 0;

                    Mesh.Vertex v0 = primal.getVert(0);
                    Mesh.Vertex v1 = primal.getVert(1);
                    Mesh.Vertex v2 = primal.getVert(2);

                    verts[0][0] = v0.Xnaive();
                    verts[0][1] = v0.Ynaive();
                    verts[0][2] = v0.Hnaive();
                    double origDist01 = MyMath.hypot(v1.Xnaive()-v0.Xnaive(), v1.Ynaive()-v0.Ynaive());
                    verts[1][0] = v0.Xnaive() + (v1.Xnaive()-v0.Xnaive())/origDist01 * params[iParam];
                    verts[1][1] = v0.Ynaive() + (v1.Ynaive()-v0.Ynaive())/origDist01 * params[iParam];
                    iParam++;
                    verts[1][2] = v1.Hnaive();

                    verts[2][0] = params[iParam++];
                    verts[2][1] = params[iParam++];
                    verts[2][2] = v2.Hnaive();

                    for (int iVert = 3; iVert < verts.length; ++iVert)
                    {
                        verts[iVert][0] = params[iParam++];
                        verts[iVert][1] = params[iParam++];
                        verts[iVert][2] = params[iParam++];
                    }
                    assert(iParam == params.length);
                } // paramsToVerts

                private static String[] getParamNames(int nVerts)
                {
                    int iParam = 0;
                    String paramNames[] = new String[nVerts * 3 - 6];
                    paramNames[iParam++] = "dist01";
                    paramNames[iParam++] = "x2";
                    paramNames[iParam++] = "y2";
                    for (int iVert = 3; iVert < nVerts; ++iVert)
                    {
                        paramNames[iParam++] = "x"+iVert;
                        paramNames[iParam++] = "y"+iVert;
                        paramNames[iParam++] = "h"+iVert;
                    }
                    assert(iParam == paramNames.length);
                    return paramNames;
                } // getParamNames




                // Returns the optimization path, better and better verts,
                // and the associated goodnesses.
                public static Object[/*2*/] optimizeVerts(
                    final Mesh primal,
                    final int fromsAndTosTris[][/*2*/][][/*3*/],
                    final int toLeftOfEdgeEndIndices[][/*2*/],
                    final boolean mustBeFarthestExit[],
                    final boolean considerEdgeLengths, // XXX we don't handle this correctly-- we hard-code ignoring the 1-edgelength thing. need to figure out why, I thought that was necessary to prevent edge lengths from growing without bound???
                    final int nPasses,
                    final int maxCallsPerPass,
                    final double initialDelta,
                    final boolean wrapAroundSphereFlagValue,
                    final boolean centerSphereFlagValue,
                    final double wrapSphereCurvatureValue)
                {
                    assert(fromsAndTosTris.length        == toLeftOfEdgeEndIndices.length);
                    assert(mustBeFarthestExit.length == toLeftOfEdgeEndIndices.length);

                    final Mesh dual = makeDualMesh(primal,
                                                   false, // includeNonArity3
                                                   false, // includeInsideOut
                                                   wrapAroundSphereFlagValue,
                                                   centerSphereFlagValue,
                                                   wrapSphereCurvatureValue);
                    final int nVerts = primal.verts.size();
                    final int nDualVerts = dual.verts.size();
                    final int nEdges = primal.edges.size();
                    assert(nEdges == dual.edges.size());

                    final int tris[][/*3*/] = new int[nDualVerts][3];
                    {
                        FORI (iEdge, nEdges)
                        {
                            Mesh.Edge dualEdge = dual.getEdge(iEdge);
                            Mesh.Vertex dualVert = dualEdge.finalVertex();
                            if (dualVert != null)
                            {
                                int iDualVert = dualVert.myIndex();

                                // Only do it if initial vertex is smallest indexed on the triangle.
                                // This avoids calculating the same vertex 3 times,
                                // and it also guarantees that the triangle will be in canonical order
                                // (smallest index first).
                                Mesh.Edge primalEdge = primal.getEdge(iEdge);
                                int i = primalEdge.initialVertex().myIndex();
                                int j = primalEdge.next().initialVertex().myIndex();
                                int k = primalEdge.prev().initialVertex().myIndex();
                                if (i < j && i < k)
                                {
                                    int tri[] = tris[iDualVert];
                                    assert(tri[0] == 0 && tri[1] == 0 && tri[2] == 0);
                                    tri[0] = i;
                                    tri[1] = j;
                                    tri[2] = k;
                                }
                            }
                        }
                        FORI (iTri, tris.length)
                            assert(tris[iTri][1] != 0 && tris[iTri][2] != 0);
                    }

                    java.util.HashMap triToIndex = new java.util.HashMap();
                    FORI (iTri, tris.length)
                    {
                        int tri[] = tris[iTri];
                        // really only first two are necessary, but third is sanity check
                        triToIndex.put(""+tri[0]+" "+tri[1]+" "+tri[2], new Integer(iTri));
                    }

                    final int fromsAndTosInds[][/*2*/][] = new int[fromsAndTosTris.length][2][];
                    FORI (iFromAndTo, fromsAndTosTris.length)
                        FORI (iFromOrTo, 2)
                        {
                            int fromOrToTris[][] = fromsAndTosTris[iFromAndTo][iFromOrTo];
                            int fromOrToInds[] = new int[fromOrToTris.length];
                            FORI(iTri, fromOrToTris.length)
                            {
                                int tri[] = fromOrToTris[iTri];
                                Integer ind = (Integer)triToIndex.get(""+tri[0]+" "+tri[1]+" "+tri[2]);
                                assert(ind != null);
                                fromOrToInds[iTri] = ind.intValue();
                            }
                            fromsAndTosInds[iFromAndTo][iFromOrTo] = fromOrToInds;
                        }


                    final double scratchVerts[][] = new double[nVerts][3];
                    final double scratchDualMomentsAndAreas[][] = new double[nDualVerts][3]; // x*A,y*A,A
                    final double scratchDualVerts[][] = new double[nDualVerts][2]; // x,y

                    getMeshVertCoords(primal, scratchVerts);
                    vertsToDualMomentsAndAreas(scratchVerts, tris, scratchDualMomentsAndAreas, wrapAroundSphereFlagValue, centerSphereFlagValue, wrapSphereCurvatureValue);


                    double initialGuessParams[] = vertsToParams(scratchVerts);
                    int nParams = initialGuessParams.length;

                    {
                        // Sanity check-- convert back to verts, should get original verts again
                        double shouldBeScratchVerts[][] = new double[nVerts][3];
                        paramsToVerts(primal, initialGuessParams, shouldBeScratchVerts);
                        PRINTMAT(scratchVerts);
                        PRINTVEC(initialGuessParams);
                        PRINTMAT(shouldBeScratchVerts);
                        PRINTMAT(VecMath.mmm(shouldBeScratchVerts, scratchVerts));
                        assert(VecMath.equals(shouldBeScratchVerts, scratchVerts, 1e-6));
                    }

                    final double saveBestParams[] = new double[nParams];
                    final double saveBestValue[] = {Double.POSITIVE_INFINITY};
                    final ArrayList optimizationPathList = new ArrayList();
                    final DoubleArrayList optimizationPathGoodnessesList = new DoubleArrayList();
                    final int iPassFinal[] = new int[1]; // just so fun can see iPass

                    Minimizer.VectorFunction fun = new Minimizer.VectorFunction() {
                        // VectorFunction interface
                        public double apply(double params[])
                        {
                            System.out.println("    in apply()");
                            System.out.println("        iPass="+iPassFinal[0]+"/"+nPasses);
                            paramsToVerts(primal, params, scratchVerts);
                            vertsToDualMomentsAndAreas(scratchVerts, tris, scratchDualMomentsAndAreas, wrapAroundSphereFlagValue, centerSphereFlagValue, wrapSphereCurvatureValue);
                            momentsAndAreasToCoords(scratchDualMomentsAndAreas, scratchDualVerts);


                            int nGoodness = 2*primal.edges.size()
                                          + 2*primal.edges.size() // at most this many dual edge constraints
                                          + fromsAndTosTris.length;
                            double goodnessVector[] = new double[nGoodness];
                            int iGoodness = 0;

                            System.out.println("    -----------------------");

                            if (considerEdgeLengths) // considering edge lengths seems to prevent some nice optimization paths.  hmm.  (it might be just the 1-edgelength component though)
                            {
                                // Edge lengths...
                                FORI (iEdge, nEdges)
                                {
                                    Mesh.Edge edge = primal.getEdge(iEdge);
                                    int i0 = edge.initialVertex().myIndex();
                                    int i1 = edge.finalVertex().myIndex();
                                    if (i0 < i1) // canonical order only
                                    {
                                        double edgeLength = MyMath.hypot(scratchVerts[i1][0]-scratchVerts[i0][0],
                                                                         scratchVerts[i1][1]-scratchVerts[i0][1]);
                                        System.out.println("        primal edge "+i0+"->"+i1+": "+edgeLength+"");
                                        goodnessVector[iGoodness++] = edgeLength;
                                        //goodnessVector[iGoodness++] = 1. - edgeLength; // XXX needs to be a legit parameter
                                    }
                                }
                            }

                            if (true)
                            {
                                // Dual edge lengths...
                                FORI (iEdge, nEdges)
                                {
                                    Mesh.Edge dualEdge = dual.getEdge(iEdge);
                                    Mesh.Vertex dv0 = dualEdge.initialVertex();
                                    Mesh.Vertex dv1 = dualEdge.finalVertex();
                                    if (dv0 == null || dv1 == null)
                                        continue; // not a finite edge
                                    int dv0i = dv0.myIndex();
                                    int dv1i = dv1.myIndex();
                                    if (dv1i < dv0i)
                                        continue; // not in canonical order
                                    double dualEdgeVecX = scratchDualVerts[dv1i][0] - scratchDualVerts[dv0i][0];
                                    double dualEdgeVecY = scratchDualVerts[dv1i][1] - scratchDualVerts[dv0i][1];


                                    Mesh.Edge primalEdge = primal.getEdge(iEdge);
                                    int pv0i = primalEdge.initialVertex().myIndex();
                                    int pv1i = primalEdge.finalVertex().myIndex();
                                    double edgeDirX = scratchVerts[pv1i][0] - scratchVerts[pv0i][0];
                                    double edgeDirY = scratchVerts[pv1i][1] - scratchVerts[pv0i][1];
                                    double edgeLength = MyMath.hypot(edgeDirX, edgeDirY);
                                    assert(edgeLength != 0.);
                                    double invEdgeLength = 1./edgeLength;
                                    edgeDirX *= invEdgeLength;
                                    edgeDirY *= invEdgeLength;
                                    double dualEdgeDirX = -edgeDirY;
                                    double dualEdgeDirY =  edgeDirX;

                                    double dualEdgeLength = dualEdgeVecX*dualEdgeDirX
                                                          + dualEdgeVecY*dualEdgeDirY;

                                    System.out.println("        dual edge "+pv0i+"->"+pv1i+": "+dualEdgeLength+"");
                                    double dualEdgeMinLength = .05; // setting to > 0 keeps dual edge length constraints from jamming into corner with other constraints
                                    goodnessVector[iGoodness++] = dualEdgeLength - dualEdgeMinLength;
                                    goodnessVector[iGoodness++] = 1. - dualEdgeLength;
                                }
                            }

                            if (true)
                            {
                                // General froms and tos...

                                FORI (iFromAndTo, fromsAndTosTris.length)
                                {
                                    int fromAndTo[/*2*/][] = fromsAndTosInds[iFromAndTo];

                                    double v0[] = scratchVerts[toLeftOfEdgeEndIndices[iFromAndTo][0]];
                                    double v1[] = scratchVerts[toLeftOfEdgeEndIndices[iFromAndTo][1]];
                                    double edgeDirX = v1[0] - v0[0];
                                    double edgeDirY = v1[1] - v0[1];
                                    double edgeLength = MyMath.hypot(edgeDirX, edgeDirY);
                                    assert(edgeLength != 0.);
                                    double invEdgeLength = 1./edgeLength;
                                    edgeDirX *= invEdgeLength;
                                    edgeDirY *= invEdgeLength;
                                    double dualEdgeDirX = -edgeDirY;
                                    double dualEdgeDirY =  edgeDirX;


                                    double fromCenterX = 0.;
                                    double fromCenterY = 0.;
                                    double toCenterX = 0.;
                                    double toCenterY = 0.;
                                    FORI (iFromOrTo, 2)
                                    {
                                        int fromOrTo[] = fromAndTo[iFromOrTo];
                                        double totalMomentX = 0.;
                                        double totalMomentY = 0.;
                                        double totalArea = 0.;
                                        FORI (i, fromOrTo.length)
                                        {
                                            double dualVertMomentAndArea[/*3*/] = scratchDualMomentsAndAreas[fromOrTo[i]];
                                            totalMomentX += dualVertMomentAndArea[0];
                                            totalMomentY += dualVertMomentAndArea[1];
                                            totalArea += dualVertMomentAndArea[2];
                                        }
                                        if (iFromOrTo == 0)
                                        {
                                            fromCenterX = totalMomentX / totalArea;
                                            fromCenterY = totalMomentY / totalArea;
                                        }
                                        else
                                        {
                                            toCenterX = totalMomentX / totalArea;
                                            toCenterY = totalMomentY / totalArea;
                                        }
                                    }
                                    double goodness = (toCenterX-fromCenterX)*dualEdgeDirX
                                                    + (toCenterY-fromCenterY)*dualEdgeDirY;
                                    System.out.println("        another goodness: "+goodness);
                                    goodnessVector[iGoodness++] = goodness;

                                    if (true)
                                    {
                                        if (mustBeFarthestExit[iFromAndTo])
                                        {
                                            int from[] = fromAndTo[0];
                                            assert(from.length == 1);
                                            int desiredFarthestDualVertIndex = from[0];

                                            double thisDist2fromCenter = -1.;
                                            double largestOtherDist2fromCenter = -1.;
                                            int to[] = fromAndTo[1];
                                            FORI (iTo, to.length)
                                            {
                                                int iDualVert = to[iTo];
                                                double dualVert[] = scratchDualVerts[iDualVert];
                                                double dist2fromCenter = SQR(dualVert[0]-toCenterX)
                                                                       + SQR(dualVert[1]-toCenterY);
                                                if (iDualVert == desiredFarthestDualVertIndex)
                                                    thisDist2fromCenter = dist2fromCenter;
                                                else
                                                    largestOtherDist2fromCenter = MAX(largestOtherDist2fromCenter, dist2fromCenter);
                                            }
                                            assert(thisDist2fromCenter >= 0.);
                                            assert(largestOtherDist2fromCenter >= 0.); // i.e. lagoon size must be >= 2
                                            goodness = Math.sqrt(thisDist2fromCenter) - Math.sqrt(largestOtherDist2fromCenter);
                                            System.out.println("        yet another goodness: "+goodness);
                                            goodnessVector[iGoodness++] = goodness;
                                        }
                                    }
                                }
                            }


                            PRINT(nGoodness);
                            PRINT(iGoodness);
                            //double synopsis = VecMath.synopsis(iGoodness, goodnessVector);
                            double synopsis = simpleSynopsis(iGoodness, goodnessVector);
                            //double synopsis = synopsis(iGoodness, goodnessVector);
                            System.out.println("        synopsis = "+synopsis);
                            double answer = -synopsis; // trying to maximize synopsis, trying to minimize answer

                            if (answer < saveBestValue[0])
                            {
                                System.out.println("            improvement!");
                                saveBestValue[0] = answer;
                                optimizationPathList.add(Arrays.copy(scratchVerts, 2));
                                optimizationPathGoodnessesList.add(synopsis);
                            }
                            else
                            {
                                System.out.println("            (not an improvement, best is still "+-saveBestValue[0]+")");
                            }
                            System.out.println("    -----------------------");
                            System.out.println("    out apply()");
                            return answer;
                        }
                    }; // fun

                    PRINT(fun.apply(initialGuessParams));
                    String paramNames[] = getParamNames(primal.verts.size());
                    FORI (iPass, nPasses)
                    {
                        iPassFinal[0] = iPass;

                        System.out.println("-------------------------------------");
                        PRINT(iPass);

                        double answerParams[] = Minimizer.minimize(fun,
                                                                   initialGuessParams,
                                                                   initialDelta,
                                                                   maxCallsPerPass,
                                                                   true, // returnNullOnMaxCallsReached
                                                                   paramNames);
                        if (true)
                        {
                            // See if we can get better by randomly jumping out of
                            // where we've wedged into
                            double bestParams[] = vertsToParams((double[][])optimizationPathList.get(optimizationPathList.size()-1));
                            double bestGoodness = optimizationPathGoodnessesList.get(optimizationPathList.size()-1);
                            double params0[] = VecMath.copyvec(bestParams);
                            double scratchParams[] = new double[bestParams.length];
                            FORI (iJump, 100)
                            {
                                // pick a random (infinity norm) distance between 1e-17 and 1
                                double a = Math.log(1e-17);
                                double b = Math.log(1);
                                double distance = Math.random();
                                distance = LERP(a,b,distance);
                                distance = Math.exp(distance);
                                PRINT(distance);
                                FORI (iParam, scratchParams.length)
                                {
                                    scratchParams[iParam] = params0[iParam] + (Math.random()*2-1)*distance;
                                }
                                double thisGoodness = -fun.apply(scratchParams);
                                // automatically appended to optimizationPathList if it's better
                                if (thisGoodness > bestGoodness)
                                {
                                    bestGoodness = thisGoodness;
                                    VecMath.copyvec(bestParams, scratchParams);
                                    System.out.println("    BETTER!");
                                }
                                else
                                {
                                    System.out.println("    not better");
                                }
                            }
                        }

                        // we don't really use answerParams
                        initialGuessParams = vertsToParams((double[][])optimizationPathList.get(optimizationPathList.size()-1));

                        PRINT(optimizationPathList.size());
                        //PRINTARRAY(optimizationPathGoodnessesList);
                        PRINT(iPass);
                        System.out.println("-------------------------------------");
                    }
                    double optimizationPath[][][] = new double[optimizationPathList.size()][][];
                    optimizationPathList.toArray(optimizationPath);
                    double optimizationPathGoodnesses[] = new double[optimizationPathGoodnessesList.size()];
                    optimizationPathGoodnessesList.toArray(optimizationPathGoodnesses);
                    PRINT(optimizationPath.length);
                    System.out.println("    out optimizeVerts");
                    return new Object[] {optimizationPath, optimizationPathGoodnesses};
                } // GeneralOptimizationStuff.optimizeVerts
            } // class GeneralOptimizationStuff


            // Solid example symmetric:
            //           n=36 after=12 before=12 slope=1/2
            //           n=36 after=12 before=12 slope=1/1
            //           n=36 after=12 before=12 slope=5/4
            // Solid examples of cc having y<0:
            //           n=27.6 after=0 before=20 slope=1/3 (looks same synth and not, so reliable)
            //           n=13.8 after=0 before=10 slope=1/3 (looks same synth and not, so reliable)
            //           n=13.7 after=0 before=10 slope=1/4 (looks same synth and not, so reliable... woops no it doesn't)
            //           n=10.9 after=0 before=8 slope=1/4 (looks *almost* same synth and not)
            // Example where apex does NOT suffice:
            //  n=32  pointApexUp=yes
            //  nAfter=0 nBefore=13     quill slope: 1/10
            //  nAAfter=3 nBBefore=3    quill slope: 1.414213
            private void doCannedThingSingleExitLagoonPolygon(double nVirtual,

                                                              int nBeforeApex,
                                                              int nAfterApex,
                                                              double quillSlopeNumerator,
                                                              double quillSlopeDenominator,
                                                              int nBeforeBeforeApex,
                                                              int nAfterAfterApex,
                                                              double quillSlopeNumeratorNumerator,
                                                              double quillSlopeDenominatorDenominator,
                                                              boolean pointApexUpFlag,

                                                              boolean synthesizeExactDualFlag)
            {
                int n = nBeforeBeforeApex + nBeforeApex + 1 + nAfterApex + nAfterAfterApex;
                // convert quill slope to angle in range [0,pi/2]
                // and then rescale to range [(2pi/n)/2, pi/2 - (2pi/n)/2]
                // and then subtract pi/2 - (2pi/n)/2...
                // i.e. scale to [0, pi/2 - 2pi/n].
                double quillLiftAngle = Math.atan2(quillSlopeNumerator,
                                                   quillSlopeDenominator)
                                      * (Math.PI/2-2*Math.PI/nVirtual)/(Math.PI/2);
                PRINT(quillLiftAngle);
                double quillLiftAngle0 = Math.atan2(quillSlopeNumeratorNumerator,
                                                    quillSlopeDenominatorDenominator)
                                      * (Math.PI/2-2*Math.PI/nVirtual)/(Math.PI/2);
                PRINT(quillLiftAngle0);
                double quillLiftAngles[] = new double[n];
                PRINT(nBeforeBeforeApex);
                PRINT(nBeforeApex);
                PRINT(nAfterApex);
                PRINT(nAfterAfterApex);
                FORI (i, nBeforeBeforeApex)
                    quillLiftAngles[i] = quillLiftAngle0;
                FORI (i, nBeforeApex)
                    quillLiftAngles[nBeforeBeforeApex+i] = quillLiftAngle;
                // skip apex
                FORI (i, nAfterApex)
                    quillLiftAngles[nBeforeBeforeApex+nBeforeApex+1+i] = quillLiftAngle;
                FORI (i, nAfterAfterApex)
                    quillLiftAngles[nBeforeBeforeApex+nBeforeApex+1+nAfterApex+i] = quillLiftAngle0;


                double allButApexTurn = 2*Math.PI/nVirtual;
                double apexTurn = 2*Math.PI - (n-1)*allButApexTurn;
                double vertTurns[] = VecMath.fillvec(n, allButApexTurn);
                vertTurns[nBeforeBeforeApex+nBeforeApex] = apexTurn;
                if (nBeforeApex >= 1)
                {
                    vertTurns[nBeforeBeforeApex] += quillLiftAngle0 - quillLiftAngle; // worked out on paper
                    vertTurns[nBeforeBeforeApex+nBeforeApex] -= quillLiftAngle0 - quillLiftAngle;
                }
                if (nAfterApex >= 1)
                {
                    vertTurns[n-1-nAfterAfterApex] += quillLiftAngle0 - quillLiftAngle; // worked out on paper
                    vertTurns[nBeforeBeforeApex+nBeforeApex] -= quillLiftAngle0 - quillLiftAngle;
                }





                double answer[][][] = SingleExitLagoonPolygonOptimizationStuff.constructSingleExitLagoonPolygon(nBeforeBeforeApex+nBeforeApex, quillLiftAngles, vertTurns);
                double polyVerts[][] = answer[0];
                double trisVerts[][] = answer[1];
                double quillDirs[][] = answer[2];
                /*
                PRINT(radiusScaleQuantum);
                PRINTVEC(polyVerts[0]);
                PRINTVEC(polyVerts[2]);
                PRINTVEC(trisVerts[2]);
                PRINTVEC(trisVerts[3]);
                */
                if (true)
                {
                    // worked this out on paper
                    double predictedScale = Math.cos(quillLiftAngle)/Math.cos(2*Math.PI/nVirtual + quillLiftAngle);
                    PRINT(predictedScale);
                    // analagous thing for tris diagram should just be the mirror image of that
                    // XXX TODO: argh, this is wrong for some reason
                    double predictedTrisScale = Math.cos(Math.PI/4-(Math.PI/4-quillLiftAngle))
                                              / Math.cos(2*Math.PI/nVirtual + Math.PI/4-(Math.PI/4-quillLiftAngle));
                    PRINT(predictedTrisScale);
                }
                PRINT(VecMath.norm(2,polyVerts[1])/VecMath.norm(2,polyVerts[0]));
                PRINT(VecMath.norm(2,trisVerts[3])/VecMath.norm(2,trisVerts[2]));
                PRINT(Math.log(VecMath.norm(2,polyVerts[1])/VecMath.norm(2,polyVerts[0]))/(2*Math.PI/nVirtual));
                PRINT(Math.log(VecMath.norm(2,trisVerts[3])/VecMath.norm(2,trisVerts[2]))/(2*Math.PI/nVirtual));

                if (pointApexUpFlag)
                {
                    assert(polyVerts[0].length == 2);
                    assert(trisVerts[0].length == 3);
                    assert(quillDirs[0].length == 2);
                    int apex = nBeforeBeforeApex+nBeforeApex;
                    double apexDir[] = VecMath.vpv(
                                         VecMath.normalize(VecMath.vmv(polyVerts[apex],polyVerts[MOD(apex-1,n)])),
                                         VecMath.normalize(VecMath.vmv(polyVerts[apex],polyVerts[(apex+1)%n])));
                    VecMath.normalize(apexDir, apexDir);
                    apexDir = Arrays.append(apexDir, 0.);
                    double m33[][] = parallelTransport(apexDir, new double[] {0,1,0});
                    double m22[][] = {{m33[0][0],m33[0][1]},
                                      {m33[1][0],m33[1][1]}};
                    polyVerts = VecMath.mxm(polyVerts, m22);
                    trisVerts = VecMath.mxm(trisVerts, m33);
                    quillDirs = VecMath.mxm(quillDirs, m22);
                }


                if (true)
                {
                    // scale by a power of 2 til y range of primal fits in the window
                    double scale = 1.;
                    double maxY = 0.;
                    FORI (i, polyVerts.length)
                        maxY = MAX(maxY, ABS(polyVerts[i][1]));
                    //PRINT(maxY);
                    if (maxY != 0. && maxY != Double.POSITIVE_INFINITY)
                    {
                        while (scale*maxY <= .5)
                            scale *= 2;
                        while (scale*maxY > 1.)
                            scale *= .5;
                        //PRINT(scale);
                        VecMath.mxs(polyVerts, polyVerts, scale);
                        VecMath.mxs(trisVerts, trisVerts, scale);
                        FORI (i, trisVerts.length)
                            trisVerts[i][2] *= scale; // so that h gets scaled by scale*scale
                    }
                }


                int tris[][];
                if (true)
                {
                    //
                    // See if I got the tris right.
                    //
                    tris = new int[n+1][];
                    FORI (i, n)
                        tris[i] = new int[] {0, i+1, (i+1)%n+1};
                    tris[n] = new int[n];
                    FORI (i, n)
                        tris[n][i] = (n-1-i)+1;
                    //PRINTARRAY(trisVerts);
                    //PRINTARRAY(tris);
                    mesh = new Mesh(trisVerts, tris);
                }
                if (synthesizeExactDualFlag)
                {
                    // see if I got the polygon right.
                    // force our idea of what the polygon should look like
                    // into the dual.
                    // NOTE, if experimenting with liftAngle=0, this is necessary-- dual becomes infinite!
                    double finalVerts[][] = new double[2*n][];
                    int finalFaces[][] = {new int[3*n], new int[n]};
                    FORI (i, n)
                    {
                        finalVerts[2*i] = polyVerts[i];
                        finalVerts[2*i+1] = VecMath.vpv(polyVerts[i], quillDirs[i]);
                        finalFaces[0][3*i+0] = 2*i;
                        finalFaces[0][3*i+1] = 2*i+1;
                        finalFaces[0][3*i+2] = 2*i;
                        finalFaces[1][i] = 2*(n-1-i);
                    }

                    // if we just pass in the x,y's,
                    // they will get interpreted as h=0,
                    // i.e. projected onto paraboloid, which isn't what we want;
                    // we want the polygon to lie completely in the xy (z=0) plane.
                    // so change to X,Y,Z,W representation.
                    // Note that the quill ends won't be right
                    // (they shouldn't be in the xy plane) but whatever...
                    // that's actually a good thing since the whole reason for doing this
                    // is for the case when curvatures are growing too quickly
                    // or infinitely, in which case all the quills will point straight down anyway so that's not interesting.
                    FORI (iDualVert, finalVerts.length)
                    {
                        if (iDualVert % 2 == 0)
                        {
                            int i = iDualVert / 2;
                            int tri[] = tris[i];
                            double area = .5*twiceTriangleArea(trisVerts[tri[0]][0], trisVerts[tri[0]][1],
                                                               trisVerts[tri[1]][0], trisVerts[tri[1]][1],
                                                               trisVerts[tri[2]][0], trisVerts[tri[2]][1]);
                            finalVerts[iDualVert] = new double[] {finalVerts[iDualVert][0]*area,
                                                                  finalVerts[iDualVert][1]*area,
                                                                  0.*area,
                                                                  1.*area};
                        }
                        else
                        {
                            finalVerts[iDualVert] = new double[] {finalVerts[iDualVert][0],
                                                                  finalVerts[iDualVert][1],
                                                                  0.,
                                                                  1.};
                        }
                    }

                    //PRINTARRAY(finalVerts);
                    //PRINTARRAY(finalFaces);

                    _dualMesh = new Mesh(finalVerts, finalFaces);

                    FORI (iDualVert, finalVerts.length)
                    {
                        // try to hack the dual vertex into something that looks as legit as possible.
                        Mesh.Vertex dualVert = _dualMesh.getVert(iDualVert);
                        assert(dualVert.weight == 1.);
                        assert(dualVert.momentAndArea == null);
                        if (iDualVert % 2 == 0)
                        {
                            dualVert.momentAndArea = VecMath.copyvec(finalVerts[iDualVert]);
                        }
                        else
                        {
                            dualVert.weight = 0.;
                            dualVert.momentAndArea = new double[] {0., 0., 0., 0.};
                        }
                    }

                    _primalMeshOfDualMesh = mesh; // counter-counter-espionage, prevents dual from thinking it's dirty
                }

                if (true)
                {
                    // Figure out visualization of primal-dual correspondence.
                    // This will be a map from angle
                    // to a point on primal and point on dual.
                    // What we store is a list of tiepoints:
                    // angles, and corresponding indices into primal verts and dual verts.
                    primalDualVisAngles = new double[2*n];
                    primalDualVisPrimalVertInds = new int[2*n];
                    primalDualVisDualVertInds = new int[2*n];

                    Mesh dualMesh = getDualMesh();
                    // First, get our bearings in the dual mesh--
                    // we're going to walk CCW around the big polygon.
                    // Find an edge of that polygon.
                    // Note however that, in the dual mesh, edges walk CW instead of CCW,
                    // so we'll be following prev instead of next.
                    Mesh.Edge dualEdge;
                    {
                        int nEdges = dualMesh.edges.size();
                        int iDualEdge = 0;
                        dualEdge = dualMesh.getEdge(iDualEdge);
                        while (dualEdge.next().next().next() == dualEdge)
                        {
                            iDualEdge++;
                            dualEdge = dualMesh.getEdge(iDualEdge);
                        }
                        //PRINT(iDualEdge);
                    }

                    Mesh.Edge primalEdge = mesh.getEdge(dualEdge.myIndex());

                    FORI (i, n)
                    {
                        // emit dualEdge.initialVertex(), primalEdge.initialVertex()

                        primalDualVisAngles[2*i+0] = 2*Math.PI/(2*n) * (.5+2*i+0) - Math.PI/2;
                        primalDualVisDualVertInds[2*i+0] = dualEdge.initialVertex().myIndex(); // the CW-most of the two verts of dualEdge
                        primalDualVisPrimalVertInds[2*i+0] = primalEdge.initialVertex().myIndex();

                        // advance dualEdge and primalEdge
                        dualEdge = dualEdge.prev();
                        primalEdge = mesh.getEdge(dualEdge.myIndex());

                        // emit dualEdge.finalVertex() (same as previous dualEdge.initialVertex()),
                        // primalEdge.initialVertex()

                        primalDualVisAngles[2*i+1] = 2*Math.PI/(2*n) * (.5+2*i+1) - Math.PI/2;
                        primalDualVisDualVertInds[2*i+1] = dualEdge.finalVertex().myIndex();
                        primalDualVisPrimalVertInds[2*i+1] = primalEdge.initialVertex().myIndex();
                    }
                    //PRINTVEC(primalDualVisAngles);
                    //PRINTVEC(primalDualVisDualVertInds);
                    //PRINTVEC(primalDualVisPrimalVertInds);
                }
            } // doCannedThingSingleExitLagoonPolygon

            private static class SingleExitLagoonPolygonOptimizationStuff {

                // answer[0] is the vertex positions
                // answer[1] is trisVerts
                // answer[2] is the quill directions (unit vectors)
                public static double[/*2*/][][] constructSingleExitLagoonPolygon(int nBeforeApex, // callers beforeBefore+before
                                                                                 double quillLiftAngles[],
                                                                                 double vertTurns[]) // should sum to 2*pi, with each turn (other than apex) < pi/2.
                {
                    System.out.println("    in constructSingleExitLagoonPolygon");
                    int n = vertTurns.length;
                    int nAfterApex = n-1-nBeforeApex;
                    int apex = nBeforeApex;

                    PRINT(n);
                    PRINT(apex);
                    //PRINTARRAY(quillLiftAngles);
                    //PRINTARRAY(vertTurns);

                    double origin[] = {0,0};

                    double answerVerts[][] = new double[n][2];
                    double answerQuillDirs[][] = new double[n][2]; // we'll expand to [3] at end
                    double answerTriVerts[][] = new double[n+1][2]; // actually becomes primal... confusing

                    answerTriVerts[0][0] = 0.;
                    answerTriVerts[0][1] = 0.;
                    answerTriVerts[1][0] = 0.;
                    answerTriVerts[1][1] = -1.;

                    double beforeApexToApexDir[];
                    {
                        // compute the verts and quill dirs before the apex
                        double prevEdgeDirAng = 0.;
                        double prevEdgeDir[] = {1.,0.};
                        double prevVert[] = {-1.,-1.}; // fake
                        FORI (iVert, apex)
                        {
                            double nextEdgeDirAng = prevEdgeDirAng + vertTurns[iVert];
                            double nextEdgeDir[] = {Math.cos(nextEdgeDirAng),Math.sin(nextEdgeDirAng)};
                            double quillDirAng = nextEdgeDirAng - Math.PI + quillLiftAngles[iVert];
                            answerQuillDirs[iVert][0] = Math.cos(quillDirAng);
                            answerQuillDirs[iVert][1] = Math.sin(quillDirAng);
                            double originToVertDirAng = quillDirAng + Math.PI/2;
                            double originToVertDir[] = {Math.cos(originToVertDirAng),Math.sin(originToVertDirAng)};

                            // want to intersect the line from origin to vert
                            // with the previous edge line.
                            intersectLines(answerVerts[iVert],
                                           prevVert, prevEdgeDir,
                                           origin, originToVertDir);


                            double originToDualVertDir[] = VecMath.xv2(nextEdgeDir); // actually reversed, but it doesn't matter
                            double dualEdgeDir[] = VecMath.xv2(answerQuillDirs[iVert]); // actually reversed, but it doesn't matter
                            intersectLines(answerTriVerts[iVert+2],
                                           answerTriVerts[iVert+1], dualEdgeDir,
                                           origin, originToDualVertDir);


                            // prepare for next iteration
                            prevVert = answerVerts[iVert];
                            prevEdgeDirAng = nextEdgeDirAng;
                            prevEdgeDir = nextEdgeDir;
                        }
                        beforeApexToApexDir = prevEdgeDir;
                    }

                    double afterApexToApexDir[];
                    {
                        // compute the verts after the apex.
                        // do it using left-right-flipped angles,
                        // so that in the case of mirror symmetry we'll get *exactly*
                        // mirror images on left and right.
                        // (this actually matters for nice display,
                        // since if the top triangle edge is ever so slightly non-horizontal,
                        // its dual vertex can be ever-so-slightly negative,
                        // which, if canvas size is odd,
                        // can end up to left of center line while grid y axis
                        // is to right of center line.

                        double prevEdgeDirAngBackwards = 0.;
                        double prevEdgeDir[] = {-1.,0.};
                        double prevVert[] = {1.,-1.}; // fake
                        for (int iVert = n-1; iVert > apex; --iVert)
                        {
                            double nextEdgeDirAngBackwards = prevEdgeDirAngBackwards + vertTurns[iVert]; // + instead of -, since backwards
                            double nextEdgeDir[] = {-Math.cos(nextEdgeDirAngBackwards),Math.sin(nextEdgeDirAngBackwards)};
                            double quillDirAngBackwards = nextEdgeDirAngBackwards - Math.PI + quillLiftAngles[iVert];
                            answerQuillDirs[iVert][0] = -Math.cos(quillDirAngBackwards);
                            answerQuillDirs[iVert][1] = Math.sin(quillDirAngBackwards);
                            double originToVertDirAngBackwards = quillDirAngBackwards + Math.PI/2;
                            double originToVertDir[] = {-Math.cos(originToVertDirAngBackwards),Math.sin(originToVertDirAngBackwards)};

                            intersectLines(answerVerts[iVert],
                                           prevVert, prevEdgeDir,
                                           origin, originToVertDir);


                            double originToDualVertDir[] = VecMath.xv2(nextEdgeDir);
                            double dualEdgeDir[] = VecMath.xv2(answerQuillDirs[iVert]); // actually reversed, but it doesn't matter, we only use it for intersection
                            intersectLines(answerTriVerts[iVert+1],
                                           answerTriVerts[((iVert+2)-1)%n+1], dualEdgeDir,
                                           origin, originToDualVertDir);

                            // prepare for next iteration
                            prevVert = answerVerts[iVert];
                            prevEdgeDirAngBackwards = nextEdgeDirAngBackwards;
                            prevEdgeDir = nextEdgeDir;
                        }
                        afterApexToApexDir = prevEdgeDir;
                    }

                    // compute the apex
                    intersectLines(answerVerts[apex],
                                   answerVerts[MOD(apex-1,n)],beforeApexToApexDir,
                                   answerVerts[(apex+1)%n],afterApexToApexDir);

                    // Since we have the dual,
                    // we can now compute the apex quill direction
                    // as the perpendicular of the final dual edge.
                    if (quillLiftAngles[0] != 0. || quillLiftAngles[quillLiftAngles.length-1] != 0.) // TODO: not sure this is quite right
                    {
                        answerQuillDirs[apex] = VecMath.normalize(VecMath.xv2(VecMath.vmv(answerTriVerts[apex+1], answerTriVerts[((apex+2)-1)%n+1])));
                    }
                    else
                    {
                        // dual is degenerate and useless,
                        // but in this case we can just pull the answer out of our hat.
                        if (nBeforeApex > nAfterApex)
                            answerQuillDirs[apex] = beforeApexToApexDir;
                        else if (nAfterApex > nBeforeApex)
                            answerQuillDirs[apex] = afterApexToApexDir;
                        else // nBeforeApex == nAfterApex
                            answerQuillDirs[apex] = new double[] {0,1}; // straight up
                    }


                    //
                    // Now reverse-engineer the heights of the tri verts
                    // (other than [0]),
                    // to give exactly the polygon verts.
                    //
                    if (true)
                    {
                        answerTriVerts[0] = Arrays.append(answerTriVerts[0], 0.);
                        answerTriVerts[1] = Arrays.append(answerTriVerts[1], -.5); // magic value to make edge lie on the horizontal line y=-1
                        FORI (iTriVertOrder, answerTriVerts.length-2) // == n-1
                        {
                            int iVert,iTriVert,jTriVert,kTriVert;
                            if (iTriVertOrder < apex)
                            {
                                iVert = iTriVertOrder;
                                iTriVert = 2+iTriVertOrder;
                                jTriVert = 0;
                                kTriVert = 1+iTriVertOrder;
                            }
                            else
                            {
                                iVert = n-1 - (iTriVertOrder-apex);
                                iTriVert = n - (iTriVertOrder-apex);
                                jTriVert = ((iTriVert+1)-1)%n+1;
                                kTriVert = 0;
                            }
                            assert(answerTriVerts[iTriVert].length == 2); // not calculated yet
                            assert(answerTriVerts[jTriVert].length == 3); // calculated already
                            assert(answerTriVerts[kTriVert].length == 3); // calculated already

                            // given:
                            //     tri verts i,j,k (j,k already with heights assigned)
                            //     target vert position v
                            // figure out the proper height to give tri vert i.
                            double v[] = answerVerts[iVert];

                            double v0[] = new double[2];
                            double v1[] = new double[2];
                            double xi = answerTriVerts[iTriVert][0];
                            double yi = answerTriVerts[iTriVert][1];
                            double xj = answerTriVerts[jTriVert][0];
                            double yj = answerTriVerts[jTriVert][1];
                            double hj = answerTriVerts[jTriVert][2];
                            double xk = answerTriVerts[kTriVert][0];
                            double yk = answerTriVerts[kTriVert][1];
                            double hk = answerTriVerts[kTriVert][2];
                            SolveForDualPoint(xi,yi,0.,
                                              xj,yj,hj,
                                              xk,yk,hk,
                                              v0, // put answer here
                                              false, // wrapAroundSphereFlag
                                              false, // centerSphereFlag
                                              0.); // wrapSphereCurvature
                            SolveForDualPoint(xi,yi,1.,
                                              xj,yj,hj,
                                              xk,yk,hk,
                                              v1, // put answer here
                                              false, // wrapAroundSphereFlag
                                              false, // centerSphereFlag
                                              0.); // wrapSphereCurvature
                            double dv_dh[] = VecMath.vmv(2,v1,v0);
                            double dv[] = VecMath.vmv(v,v0);
                            double h = VecMath.dot(dv,   dv_dh)
                                     / VecMath.dot(dv_dh,dv_dh);
                            //PRINT(h);

                            // If h is very far from 0, then it probably sucks.
                            // try again, using h instead of 1.
                            // This actually improves things a lot!
                            if (ABS(h) >= 2.)
                            {
                                FORI (iPass, 10) // probably severe overkill but whatever, this code doesn't need to be fast
                                {
                                    // re-estimate dv_dh based on bigger finite difference
                                    double shouldBeV[] = new double[2];
                                    SolveForDualPoint(xi,yi,h,
                                                      xj,yj,hj,
                                                      xk,yk,hk,
                                                      shouldBeV, // put answer here
                                                      false, // wrapAroundSphereFlag
                                                      false, // centerSphereFlag
                                                      0.); // wrapSphereCurvature
                                    double dv_dh_again[] = VecMath.vmv(2,shouldBeV,v0); // and divide by h...
                                        VecMath.vxs(dv_dh_again, dv_dh_again, 1./h);
                                    double h_again = VecMath.dot(dv,          dv_dh_again)
                                                   / VecMath.dot(dv_dh_again, dv_dh_again);
                                    //PRINT(h_again);
                                    h = h_again;
                                }
                            }
                            answerTriVerts[iTriVert] = Arrays.append(answerTriVerts[iTriVert], h);
                        }
                    }


                    System.out.println("    out constructSingleExitLagoonPolygon");
                    return new double[][][] {answerVerts, answerTriVerts, answerQuillDirs};
                }
            } // SingleExitLagoonPolygonOptimizationStuff

            private static class Netless8OptimizationStuff
            {
                // Returns the optimization path, better and better verts
                public static Object[/*2*/] optimizeNetless8Verts(
                    double initialGuessVerts[][])
                {
                    System.out.println("    in optimizeNetless8Verts");

                    double initialGuessParams[] = vertsToParams(initialGuessVerts);
                    PRINTARRAY(initialGuessVerts);
                    PRINTVEC(initialGuessVerts[4]);
                    PRINTARRAY(initialGuessParams);
                    PRINTARRAY(paramsToVerts(initialGuessParams));
                    PRINTARRAY(VecMath.mmm(paramsToVerts(initialGuessParams),initialGuessVerts));

                    final String paramNames[] = {
                        "y1",
                        "h1",
                        "x2",
                        "y2",
                        "x4",
                        "y4",
                    };

                    final double saveBestParams[] = new double[5];
                    final double saveBestValue[] = {Double.POSITIVE_INFINITY};
                    final ArrayList optimizationPathList = new ArrayList();
                    final DoubleArrayList optimizationPathGoodnessesList = new DoubleArrayList();

                    Minimizer.VectorFunction fun = new Minimizer.VectorFunction() {
                        // VectorFunction interface
                        public double apply(double params[])
                        {
                            double verts[][] = paramsToVerts(params);
                            double leftDualVerts[][] = vertsToDualVertsInNetless8(verts);
                            double dualEdgeLengths[] = vertsAndDualVertsToDualEdgeLengths(verts, leftDualVerts);

                            double dualEdgeLengthExponent = 2.;
                            double triAreaExponent = 1.;
                            double angleExponent = 2.;


                            double answer = 0.;
                            FORI (iDualEdge, dualEdgeLengths.length)
                            {
                                if (dualEdgeLengths[iDualEdge] <= 0.)
                                    return Double.POSITIVE_INFINITY;
                                answer += 1./Math.pow(dualEdgeLengths[iDualEdge], dualEdgeLengthExponent);
                            }

                            FORI (iTri, tris.length)
                            {
                                double area = twiceTriangleArea(
                                              verts[tris[iTri][0]],
                                              verts[tris[iTri][1]],
                                              verts[tris[iTri][2]]);
                                if (area <= 0.)
                                    return Double.POSITIVE_INFINITY;
                                answer += 1./Math.pow(area, triAreaExponent);
                            }

                            // Also add in a penalty for being too close
                            // to violating the alpha-beta thing
                            if (true)
                            {
                                int dualVertsBeingAveraged[] = {0, 2, 3};
                                double totalArea = 0.;
                                double center[] = {0.,0.};
                                FORI (i, 3)
                                {
                                    double area = twiceTriangleArea(
                                        verts[tris[dualVertsBeingAveraged[i]][0]],
                                        verts[tris[dualVertsBeingAveraged[i]][1]],
                                        verts[tris[dualVertsBeingAveraged[i]][2]]);
                                    PRINTSUB(dualVertsBeingAveraged,i);
                                    PRINT(area);
                                    if (area <= 0.)
                                        return Double.POSITIVE_INFINITY;
                                    totalArea += area;
                                    VecMath.vpsxv(center,
                                                  center, area, leftDualVerts[dualVertsBeingAveraged[i]]);
                                }
                                VecMath.vxs(center, center, 1./totalArea);

                                double height = VecMath.dot(
                                    2,
                                    VecMath.normalize(VecMath.vmv(leftDualVerts[4],
                                                                  leftDualVerts[1])),
                                    VecMath.vmv(center, leftDualVerts[1]));
                                if (height <= 0.)
                                    return Double.POSITIVE_INFINITY;
                                answer += 1./Math.pow(height, angleExponent);
                            }

                            if (answer < saveBestValue[0])
                            {
                                saveBestValue[0] = answer;
                                optimizationPathList.add(paramsToVerts(params)); // XXX TODO: um, why aren't we just adding verts?
                                optimizationPathGoodnessesList.add(-answer); // answer is thing we're trying to minimize, so goodness is in the opposite direction
                            }
                            return answer;
                        }
                    }; // fun

                    double initialDelta = .0001;
                    //int maxCalls = 10*1000;
                    int maxCalls = 1*1000;
                    //int maxCalls = 500;
                    //int maxCalls = 100;
                    //int maxCalls = 53;
                    PRINT(fun.apply(initialGuessParams));
                    double answerParams[] = Minimizer.minimize(fun,
                                                               initialGuessParams,
                                                               initialDelta,
                                                               maxCalls,
                                                               true, // returnNullOnMaxCallsReached
                                                               paramNames);
                    // we don't really use that
                    double optimizationPath[][][] = new double[optimizationPathList.size()][][];
                    optimizationPathList.toArray(optimizationPath);
                    double optimizationPathGoodnesses[] = new double[optimizationPathGoodnessesList.size()];
                    optimizationPathGoodnessesList.toArray(optimizationPathGoodnesses);
                    System.out.println("    out optimizeNetless8Verts");
                    return new Object[] {optimizationPath, optimizationPathGoodnesses};
                } // optimizeNetless8Verts

                private static double[] vertsToParams(double verts[][])
                {
                    double params[] = new double[6];
                    params[0] = verts[1][1];
                    params[1] = verts[1][2];
                    params[2] = verts[2][0];
                    params[3] = verts[2][1];
                    params[4] = verts[4][0];
                    params[5] = verts[4][1];
                    return params;
                } // vertsToParams

                private static double[][] paramsToVerts(double params[])
                {
                    //System.out.println("            in paramsToVerts");
                    //PRINTVEC(params);
                    double tol = 1e-6;
                    double verts[][] = new double[6][3];

                    //     3   2
                    //       1
                    //      5 4
                    //       0
                    verts[0][0] = 0;
                    verts[0][1] = 0;
                    verts[0][2] = 0;

                    verts[1][0] = 0;
                    verts[1][1] = params[0];
                    verts[1][2] = params[1];

                    verts[2][0] = params[2];
                    verts[2][1] = params[3];
                    verts[2][2] = 0;

                    verts[3][0] = -verts[2][0];
                    verts[3][1] = verts[2][1];
                    verts[3][2] = 0;

                    verts[4][0] = params[4];
                    verts[4][1] = params[5];
                    // verts[4][2] filled in below

                    verts[5][0] = -verts[4][0];
                    verts[5][1] = verts[4][1];
                    // verts[5][2] = verts[4][2] whenever we set it

                    verts[5][2] = verts[4][2] = 0;
                    double xradius0 = vertsToDualVertsInNetless8(verts)[0][0];
                    verts[5][2] = verts[4][2] = 1;
                    double xradius1 = vertsToDualVertsInNetless8(verts)[0][0];
                    verts[5][2] = verts[4][2] = (1.-xradius0)/(xradius1-xradius0);
                    assert(Math.abs(vertsToDualVertsInNetless8(verts)[0][0]-1.) < tol);

                    //System.out.println("            out paramsToVerts");
                    return verts;
                } // paramsToVerts

                private static int tris[][] = {
                    {0,2,4}, // 0: right
                    {4,2,1}, // 1: the vertex with the angle we care about
                    {5,4,1}, // 2: top of seg we care about
                    {0,4,5}, // 3: bottom of seg we care about
                    {1,2,3}, // 4: top
                    {0,5,3}, // 5: left
                    {5,1,3}, // 6: top left
                };
                private static double[][] vertsToDualVertsInNetless8(double verts[][])
                {
                    // Could optimize the hell out of this,
                    // by caching the linear transform
                    double leftDualVerts[][] = new double[tris.length][3];
                    FORI (iDualVert, leftDualVerts.length)
                    {
                        int tri[] = tris[iDualVert];
                        double x0 = verts[tri[0]][0];
                        double y0 = verts[tri[0]][1];
                        double h0 = verts[tri[0]][2];
                        double x1 = verts[tri[1]][0];
                        double y1 = verts[tri[1]][1];
                        double h1 = verts[tri[1]][2];
                        double x2 = verts[tri[2]][0];
                        double y2 = verts[tri[2]][1];
                        double h2 = verts[tri[2]][2];
                        SolveForDualPoint(x0,y0,h0,
                                          x1,y1,h1,
                                          x2,y2,h2,
                                          leftDualVerts[iDualVert],
                                          false, // wrapAroundSphereFlag
                                          false, // centerSphereFlag
                                          0.); // wrapSphereCurvature
                    }
                    return leftDualVerts;
                } // vertsToDualVertsInNetless8


                private static int edge2verts[/*9*/][/*2*/] = null; // from, to
                private static int edge2tris[/*9*/][/*2*/] = null; // left, right

                private static double[] vertsAndDualVertsToDualEdgeLengths(double verts[][], double leftDualVerts[][])
                {
                    if (edge2verts == null)
                    {
                        edge2verts = new int[9][2]; // from, to
                        edge2tris = new int[9][2]; // left, right
                        {
                            int nEdges = 0;
                            FORI (iTri, tris.length)
                                FORI (jTri, iTri)
                                {
                                    // If they have two things in common...
                                    FORI (ii, 3)
                                        FORI (jj, 3)
                                            if (tris[iTri][ii] == tris[jTri][jj]
                                             && tris[iTri][(ii+1)%3] == tris[jTri][MOD(jj-1,3)])
                                            {
                                                edge2verts[nEdges][0] = tris[iTri][ii]; // from
                                                edge2verts[nEdges][1] = tris[iTri][(ii+1)%3]; // to
                                                edge2tris[nEdges][0] = iTri; // left
                                                edge2tris[nEdges][1] = jTri; // right
                                                nEdges++;
                                            }
                                }
                            PRINT(nEdges);
                            assert(nEdges == edge2verts.length);
                            assert(nEdges == edge2tris.length);
                            PRINTARRAY(edge2verts);
                            PRINTARRAY(edge2tris);
                        }
                    }

                    double dualEdgeLengths[] = new double[9];
                    FORI (iEdge, 9)
                    {
                        double fromVert[] = verts[edge2verts[iEdge][0]];
                        double toVert[] = verts[edge2verts[iEdge][1]];
                        double leftDualVert[] = leftDualVerts[edge2tris[iEdge][0]];
                        double rightDualVert[] = leftDualVerts[edge2tris[iEdge][1]];
                        assert(fromVert != toVert);
                        assert(leftDualVert != rightDualVert);
                        dualEdgeLengths[iEdge] = VecMath.dist(2,
                                                              leftDualVert,
                                                              rightDualVert);
                        // Test whether it's negative.
                        if (VecMath.vxv2(VecMath.vmv(rightDualVert,leftDualVert),
                                         VecMath.vmv(toVert,fromVert)) < 0.)
                            dualEdgeLengths[iEdge] *= -1;
                    }
                    return dualEdgeLengths;
                } // vertsToDualEdgeLengths

            } // class Netless8OptimizationStuff

            private void doCannedThingNetless8Optimized()
            {
                doCannedThingNetless8();

                double initialGuessVerts[][] = new double[6][3];
                {
                    double x0 = mesh.getVert(0).Xnaive();
                    double y0 = mesh.getVert(0).Ynaive();
                    double h0 = mesh.getVert(0).Hnaive();
                    FORI (iVert, initialGuessVerts.length)
                    {
                        initialGuessVerts[iVert][0] = mesh.getVert(iVert).Xnaive() - x0;
                        initialGuessVerts[iVert][1] = mesh.getVert(iVert).Ynaive() - y0;
                        initialGuessVerts[iVert][2] = mesh.getVert(iVert).Hnaive() - h0;
                    }
                }
                PRINT("before scaling");
                PRINTARRAY(initialGuessVerts);
                PRINTVEC(initialGuessVerts[4]);

                if (false)
                {
                    // XXX TODO: why can't I put a fairly large number here?  not much of an optimization it seems :-(
                    initialGuessVerts[2][0] += .01; // WRENCH-- see what happens
                    initialGuessVerts[3][0] -= .02; // WRENCH-- see what happens
                }

                {
                    // scale so initial guess has radius 1
                    double xradius = Netless8OptimizationStuff.vertsToDualVertsInNetless8(initialGuessVerts)[0][0];
                    double scale = 1./xradius;
                    FORI (iVert, initialGuessVerts.length)
                    {
                        initialGuessVerts[iVert][0] *= scale;
                        initialGuessVerts[iVert][1] *= scale;
                        initialGuessVerts[iVert][2] *= (scale*scale);
                    }
                    assert(Math.abs(Netless8OptimizationStuff.vertsToDualVertsInNetless8(initialGuessVerts)[0][0] - 1.) < 1e-9);
                }
                PRINT("after scaling");
                PRINTARRAY(initialGuessVerts);
                PRINTVEC(initialGuessVerts[4]);

                PRINTVEC(Netless8OptimizationStuff.vertsToDualVertsInNetless8(initialGuessVerts));

                double initialGuessDualVerts[][] = Netless8OptimizationStuff.vertsToDualVertsInNetless8(initialGuessVerts);

                Object optimizationPathVertsAndGoodnesses[/*2*/] = Netless8OptimizationStuff.optimizeNetless8Verts(
                    initialGuessVerts);
                double optimizationPathVerts[][][] = (double[][][])optimizationPathVertsAndGoodnesses[0];
                double optimizationPathGoodnesses[] = (double[])optimizationPathVertsAndGoodnesses[1];
                double verts[][] = optimizationPathVerts[optimizationPathVerts.length-1];
                FORI (iVert, 6)
                {
                    mesh.getVert(iVert).setXYHnaive(verts[iVert][0],
                                               verts[iVert][1],
                                               verts[iVert][2]);
                }

                PRINT(optimizationPathVerts.length);

                theOptimizationPath = optimizationPathVerts;
                theOptimizationIndex = optimizationPathVerts.length-1;
                theOptimizationPathGoodnesses = optimizationPathGoodnesses;
            } // doCannedThingNetless8Optimized

            private static double[][] generateVertices(double vertGenerators[][],
                                                       double xforms[][][])
            {
                double tol = 1e-9;
                double verts[][] = vertGenerators; // make this an arraylist if we ever do a lot
                double vert4in[] = {0,0,0,1};
                double vert4out[] = new double[4];
                double vert3out[] = new double[3];
                FORI (iVert, verts.length) // while verts is growing
                {
                    FORI (ixform, xforms.length)
                    {
                        assert(verts[iVert].length == 3);
                        // TODO: really need homogeneous stuff
                        VecMath.copyvec(3, vert4in, verts[iVert]);
                        VecMath.vxm(vert4out,
                                    vert4in,
                                    xforms[ixform]);
                        VecMath.vxs(3, vert3out, vert4out, 1./vert4out[3]);

                        int jVert;
                        FOR (jVert, verts.length)
                            if (VecMath.equals(vert3out, verts[jVert], tol))
                                break;
                        if (jVert == verts.length)
                            verts = (double[][])Arrays.append(verts, VecMath.copyvec(vert3out));
                    }
                }
                return verts;
            } // generateVertices

            private void doCannedThingNetless8Symmetric()
            {
                double vertsGenerators[][] = new double[][] {
                    {0,-1, 0.},
                    //{0,1/5., 0.}, // looks nice but doesn't work well
                    {0,3/8., 0.},
                };
                double xforms[][][] = {
                    // left-right reflection
                    {
                        {-1,0,0,0},
                        {0,1,0,0},
                        {0,0,1,0},
                        {0,0,0,1},
                    },
                    // rotation by 120 degrees, row-oriented
                    {
                       { Math.cos(DTOR(120)), Math.sin(DTOR(120)), 0, 0},
                       {-Math.sin(DTOR(120)), Math.cos(DTOR(120)), 0, 0},
                       {0, 0, 1, 0},
                       {0, 0, 0, 1},
                    },
                };
                double verts[][] = generateVertices(vertsGenerators,
                                                    xforms);

                if (true)
                {
                    // hack to make the order the same as for netless8
                    double temp[] = verts[3];
                    verts[3] = verts[4];
                    verts[4] = verts[5];
                    verts[5] = temp;
                }

                if (false)
                {
                    // Hack to see what happens... maybe have key for this
                    FORI (iVert, verts.length)
                        verts[iVert][1] *= .1;
                }

                int faces[][] = {};
                mesh = new Mesh(verts, faces);
                delaunayize();
            } // doCannedThingNetless8Symmetric

            // Make the mesh into netless9
            private void doCannedThingNetless9()
            {
                if (true)
                {
                    // s = how much bigger each edge is from the previous
                    double s = 1.05;
                    //double s = 1.001;
                    double sliceAngle;
                    {
                        // In the initial 6 slice pie,
                        // the southwest triangle has sides a=1, b=s^5, c=s^6.
                        // what are its angles?
                        // http://www.teacherschoice.com.au/Maths_Library/Trigonometry/solve_trig_SSS.htm
                        double a = 1;
                        double b = s*s*s*s*s;
                        double c = s*s*s*s*s*s;
                        double C = triangleAngle(a, b, c);
                        // All right, the southwest angle at the center
                        // is C, a bit more than pi/3.
                        // Distribute the rest of the spokes evenly.
                        sliceAngle = (2*Math.PI-C) / 5;
                    }
                    PRINT(RTOD(sliceAngle));
                    int nVerts = 19;
                    //int nVerts = 40;
                    //int nVerts = 1000;
                    double verts[][] = new double[nVerts][3];
                    int nNeighbors[] = new int[nVerts]; // zeros
                    ArrayList/*<int[]>*/ facesList = new ArrayList();

                    // Seed with verts 0 and 1, and an edge between them.
                    verts[0][0] = 0;
                    verts[0][1] = 0;
                    verts[0][2] = 0;
                    // Had the seed on the -y axis, changing it to +x axis for the hell of it
                    verts[1][0] = 1;
                    verts[1][1] = 0;
                    verts[1][2] = 0;
                    nNeighbors[0] = 1;
                    nNeighbors[1] = 1;

                    PRINT(VecMath.dist(verts[1], verts[6]));
                    PRINT(Math.pow(s, 6));

                    int oldestPerimeterEdge[] = {0,1};

                    for (int i = 2; i < nVerts; ++i)
                    {
                        //PRINT(i);
                        int arity = nNeighbors[oldestPerimeterEdge[0]];
                        assert(arity < 6);
                        double angFrac = 1./(6-arity);
                        //PRINT(1./angFrac);
                        double largestEdge = VecMath.dist(verts[i-1], verts[oldestPerimeterEdge[0]]);
                        //PRINT(largestEdge);
                        //PRINT(Math.pow(s, facesList.size()));

                        double c = VecMath.dist(verts[oldestPerimeterEdge[0]],
                                                verts[oldestPerimeterEdge[1]]);
                        double a = largestEdge * Math.pow(s, 1./angFrac);
                        double b = a*s;
                        //PRINT(a);
                        //PRINT(b);
                        double target[] = completeTriangle(verts[oldestPerimeterEdge[1]],
                                                           verts[oldestPerimeterEdge[0]],
                                                           a, b);
                        double ang0 = Math.atan2(verts[i-1][1]-verts[oldestPerimeterEdge[0]][1],
                                                 verts[i-1][0]-verts[oldestPerimeterEdge[0]][0]);
                        double ang1 = Math.atan2(target[1]-verts[oldestPerimeterEdge[0]][1],
                                                 target[0]-verts[oldestPerimeterEdge[0]][0]);
                        //PRINT(RTOD(ang0));
                        //PRINT(RTOD(ang1));
                        //PRINT(angFrac);
                        while (ang1 < ang0) ang1 += 2*Math.PI;
                        double ang = LERP(ang0, ang1, angFrac);
                        double length = largestEdge * s;
                        verts[i][0] = verts[oldestPerimeterEdge[0]][0] + length*Math.cos(ang);
                        verts[i][1] = verts[oldestPerimeterEdge[0]][1] + length*Math.sin(ang);
                        facesList.add(new int[]{oldestPerimeterEdge[0], i-1, i});
                        nNeighbors[oldestPerimeterEdge[0]]++;
                        nNeighbors[i-1]++;
                        nNeighbors[i] = 2;
                        if (nNeighbors[oldestPerimeterEdge[0]] == 6)
                        {
                            //System.out.println("COMPLETING at "+i);
                            facesList.add(new int[]{oldestPerimeterEdge[1], oldestPerimeterEdge[0], i});
                            nNeighbors[oldestPerimeterEdge[1]]++;
                            nNeighbors[i]++;
                            oldestPerimeterEdge[0]++;
                            oldestPerimeterEdge[1]++;
                        }
                    }

                    {
                        int nPerimeterVerts = 0;
                        FORI (i, nVerts)
                            if (nNeighbors[i] < 6)
                                nPerimeterVerts++;
                        int perimeterVerts[] = new int[nPerimeterVerts];
                        nPerimeterVerts = 0;
                        FORI (i, nVerts)
                            if (nNeighbors[i] < 6)
                                perimeterVerts[perimeterVerts.length-1-nPerimeterVerts++] = i;
                        facesList.add(perimeterVerts);
                        PRINT(nPerimeterVerts);
                    }


                    int faces[][] = new int[facesList.size()][];
                    facesList.toArray(faces);
                    mesh = new Mesh(verts, faces);
                    //PRINTARRAY(nNeighbors);
                    //PRINTARRAY(verts);
                    //PRINTARRAY(faces);
                }
                FORIDOWN (iVert, mesh.verts.size())
                {
                    double scale = .2;
                    Mesh.Vertex vert = mesh.getVert(iVert);
                    vert.setXYHnaive(vert.Xnaive() * scale,
                                vert.Ynaive() * scale,
                                vert.Hnaive() * (scale*scale));
                }
            } // doCannedThingNetless9

            // Argh, short-lived brilliant idea
            // that's going nowhere, since a zig-zag
            // through the cornea is always possible.
            private void doCannedThingEyeball()
            {
                int n = 72;
                int nRows = 15;
                double r0 = .25;
                double aspect = 2;

                // empirically, fudges to make it kind of right for n=72, r0=.25, aspect=2
                double incr = .005;
                incr *= .25; // XXX argh! up and down arrows depend on current view scale! squared!

                double rowHeightFudges[] = {
                    -0*incr,
                               // +3
                     3*incr,          // -1
                               // +2         // -1
                     5*incr,          // -2
                               // +0         // -1
                     5*incr,          // -3
                               // -3         // -2
                     2*incr,          // -5
                               // -8         // -2.5
                    -6*incr,         // -7.5
                               // -15.5      // -4
                    -21.5*incr,       // -11.5
                               // -27        // -5.5
                    -48.5*incr,       // -17
                               // -44        // -8
                    -92.5*incr,       // -25
                               // -69        // -11
                    -161.5*incr,      // -36
                               // -105       // -16
                    -266.5*incr,      // -52
                               // -157       // -22
                    -423.5*incr,      // -74
                               // -231       // -31
                    -654.5*incr,      // -105
                               // -336       // -43
                    -990.5*incr,      // -148
                               // -484
                    -1474.5*incr,
                };  

                ArrayList vertsList = new ArrayList();
                ArrayList facesList = new ArrayList();

                vertsList.add(new double[]{0,0,0});
                FORI (iRow, nRows)
                {
                    double multiplier = 1 + aspect*2*Math.PI/n; // magic
                    double r = r0 * Math.pow(multiplier, iRow);
                    FORI (i, n)
                    {
                        double theta = 2*Math.PI*(i+iRow*.5)/n;
                        vertsList.add(new double[]{r*Math.cos(theta),
                                                   r*Math.sin(theta),
                                                   rowHeightFudges[iRow],
                                                   });
                        if (iRow == 0)
                            facesList.add(new int[]{1 + iRow*n + i,
                                                    1 + iRow*n + (i+1)%n,
                                                    0});
                        else
                        {
                            facesList.add(new int[]{1 + iRow*n + i,
                                                    1 + iRow*n + (i+1)%n,
                                                    1 + (iRow-1)*n + (i+1)%n});
                            facesList.add(new int[]{1 + iRow*n + i,
                                                    1 + (iRow-1)*n + (i+1)%n,
                                                    1 + (iRow-1)*n + i});
                        }
                        /*
                        else
                        {
                            facesList.add(new int[]{1 + iRow*n + i,
                                                    1 + (iRow-1)*n + (i+1)%n,
                                                    1 + (iRow-2)*n + (i+1)%n});
                            facesList.add(new int[]{1 + iRow*n + i,
                                                    1 + (iRow-2)*n + (i+1)%n,
                                                    1 + (iRow-1)*n + i});
                        }
                        if (iRow == nRows-1)
                            facesList.add(new int[]{1 + iRow*n + i,
                                                    1 + iRow*n + (i+1)%n,
                                                    1 + (iRow-1)*n + (i+1)%n});
                        */
                    }
                }
                int insideOutFace[] = new int[n];
                FORI (i, n)
                    insideOutFace[i] = vertsList.size()-1-i;
                facesList.add(insideOutFace);


                double verts[][] = new double[vertsList.size()][];
                vertsList.toArray(verts);
                int faces[][] = new int[facesList.size()][];
                facesList.toArray(faces);
                mesh = new Mesh(verts, faces);
            } // doCannedThingEyeball

            // XXX unused?
            private static double[] triangleApex(double v0[], double ang0,
                                                 double v1[], double ang1)
            {
                double e01ang = Math.atan2(v1[1]-v0[1], v1[0]-v0[0]);
                double e02ang = e01ang + ang0;
                double e21ang = e01ang - ang1;
                double normal02[] = new double[]{Math.cos(e02ang+Math.PI/2),
                                                 Math.sin(e02ang+Math.PI/2)};
                double normal21[] = new double[]{Math.cos(e21ang+Math.PI/2),
                                                 Math.sin(e21ang+Math.PI/2)};
                // Find v2 satisfying:
                //    v2 dot normal02 == v0 dot normal02
                //    v2 dot normal21 == v1 dot normal21
                double A[][] = {normal02,
                                normal21};
                double b[] = {VecMath.dot(v0, normal02),
                              VecMath.dot(v1, normal21)};
                // Solve A v2 == b
                return VecMath.invmxv(A, b);
            } // triangleApex

            // Starting in middle and following crack, there's only one legal way to go
            // and it goes in a spiral.
            private void doCannedThingCrackGoesInSpiral()
            {
                OUT("    in doCannedThingCrackGoesInSpiral");


                // magPerCircle has to be big enough so that the big triangles are substantially obtuse.

                #if 0
                double gonality = 6.;
                double magPerCircle = 256.;
                //double magPerCircle = 128.; // too small
                #endif

                #if 1
                double gonality = 8.;
                //double magPerCircle = 100;
                double magPerCircle = 90; // barely
                //double magPerCircle = 80; // too small
                // huh, can I arrange it so the two edge lengths are equal?  would be nice. 90 is pretty close.
                // oh hmm, maybe even nicer would be if quills become aligned with opposites.
                #endif

                #if 0
                double gonality = 16.;
                double magPerCircle = 64.;
                #endif

                double angleIncrDegrees = 360./gonality;
                double angleIncr = DTOR(angleIncrDegrees);
                double magIncr = Math.pow(magPerCircle, 1./gonality);
                Complex incr = new Complex(magIncr*Math.cos(angleIncr), magIncr*Math.sin(angleIncr));
                Complex decr = incr.inverse();

                int nVerts = (int)(gonality * 3);
                Complex cverts[] = new Complex[nVerts];

                //cverts[0] = Complex.ONE;
                cverts[0] = new Complex(Math.sqrt(.5),Math.sqrt(.5));

                for (int i = 1; i < nVerts; ++i)
                    cverts[i] = cverts[i-1].times(decr);

                double verts[][] = new double[nVerts][2];
                for (int i = 0; i < nVerts; ++i)
                    verts[i] = new double[]{cverts[i].x, cverts[i].y};

                int faces[][] = new int[0][];
                this.mesh = new Mesh(verts, faces);
                this.delaunayize();

                if (true)
                {
                    // Doesn't look so great because vert 0 has too many edges out of it.
                    // Get rid of them til it has apparent arity 3 (i.e. 3 frontface edges).
                    // How do we find the ones to keep?
                    // Well, first find any edge out of it,
                    // then walk round the vertex til we find the most CCW edge,
                    // then retain it and the 2 previous.
                    Mesh.Vertex v0 = mesh.getVert(0);
                    int v0arity = 0; // and counting
                    Mesh.Edge someEdgeStartingAtV0 = null;
                    FORI (iEdge, mesh.edges.size())
                    {
                        Mesh.Edge e = mesh.getEdge(iEdge);
                        if (e.initialVertex() == v0)
                        {
                          someEdgeStartingAtV0 = e;
                          v0arity++;
                        }
                    }
                    assert(someEdgeStartingAtV0 != null);

                    // walk around edges, logically CCW (but CW when backfacing),
                    // looking for the most actually CCW one
                    Mesh.Edge mostCCWedge = null;
                    for (Mesh.Edge e = someEdgeStartingAtV0;; e = e.prev().opposite())
                    {
                        assert(e.initialVertex() == v0);
                        Mesh.Vertex vPrev = e.opposite().next().finalVertex();
                        Mesh.Vertex vThis = e.finalVertex();
                        Mesh.Vertex vNext = e.prev().opposite().finalVertex();
                        double prevArea = twiceTriangleArea(v0.Xnaive(), v0.Ynaive(),
                                                            vPrev.Xnaive(), vPrev.Ynaive(),
                                                            vThis.Xnaive(), vThis.Ynaive());
                        double nextArea = twiceTriangleArea(v0.Xnaive(), v0.Ynaive(),
                                                            vThis.Xnaive(), vThis.Ynaive(),
                                                            vNext.Xnaive(), vNext.Ynaive());
                        if (prevArea > 0. && nextArea <= 0.)
                        {
                            mostCCWedge = e;
                            break;
                        }
                    }
                    assert(mostCCWedge != null);

                    if (false)
                    {
                        // Delete edges until we've only got the three remaining ones left.
                        while (v0arity > 3)
                        {
                           mesh.deleteEdge(mostCCWedge.prev().opposite());
                           --v0arity;
                        }
                    }
                    else
                    {
                        // Do diagonal swaps on the others until we've only got the three remaining ones left.
                        Mesh.Edge firstEdgeToKeep = mostCCWedge;
                        Mesh.Edge secondEdgeToKeep = firstEdgeToKeep.opposite().next();
                        Mesh.Edge thirdEdgeToKeep = secondEdgeToKeep.opposite().next();
                        while (v0arity > 3)
                        {
                            Mesh.Edge edgeToKill = thirdEdgeToKeep.opposite().next();
                            mesh.swapDiagonal(edgeToKill, false, false);
                            --v0arity;
                        }
                    }
                }
                OUT("    out doCannedThingCrackGoesInSpiral");
            }

            // I *think* this was supposed to be an example where exploring a crack
            // didn't lead to infinity... but ultimately not sure this is interesting
            private void doCannedThingCrackKiller()
            {
                // any of the following sets of choices work

                int nSpokes = 9;
                double angle0 = DTOR(180.);
                double angleIncr = DTOR(-(360./(nSpokes-1) - .01));
                double length0 = .1;
                double lengthMultiplier = 2; // would be nice to be more scientific

                /*
                int nSpokes = 7;
                double angle0 = DTOR(180.);
                double angleIncr = DTOR(-(360/(nSpokes-1) - .01));
                double length0 = .1;
                double lengthMultiplier = 3; // would be nice to be more scientific
                */

                /*
                int nSpokes = 6;
                double angle0 = DTOR(180.);
                double angleIncr = DTOR(-(360/(nSpokes-1) - .001)); // argh, needs finer and finer apparently... although .01 works if we manually adjust the height of one of the faces
                double length0 = .1;
                double lengthMultiplier = 5; // would be nice to be more scientific
                */


                double verts[][] = new double[nSpokes+1][];

                verts[0] = new double[]{0,0};
                FORI (i, nSpokes)
                {
                    double length = length0 * Math.pow(lengthMultiplier, i);
                    double ang = angle0 + i*angleIncr;
                    verts[i+1] = new double[]{length*Math.cos(ang),
                                              length*Math.sin(ang)};
                }
                int faces[][] = new int[nSpokes+1][];
                FORI (i, nSpokes)
                {
                    faces[i] = new int[] {
                        1+i,
                        0,
                        1+(i+1)%nSpokes,
                    };
                }
                faces[nSpokes] = new int[nSpokes];
                FORI (i, nSpokes)
                    faces[nSpokes][i] = 1+i;

                PRINTARRAY(faces);

                mesh = new Mesh(verts, faces);

                // optimize
                mesh.findAndApplyOptimalVertexHeights(OPTIMIZE_LENGTHS_LEAST_SQUARES);

                exploreCrackHead(mesh, 1, 0);
            } // doCannedThingCrackKiller

                // little private utility
                // TODO: this is from the old days before I realized moments are the way to go
                private static double getTriCenterAndArea(Mesh.Edge edge,
                                                          double triCenter[])
                {
                    assert(edge.next().next().next() == edge);
                    Mesh.Vertex v0 = edge.initialVertex();
                    Mesh.Vertex v1 = edge.finalVertex();
                    Mesh.Vertex v2 = edge.next().finalVertex();
                    double twiceTriArea = twiceTriangleArea(v0.Xnaive(),v0.Ynaive(),
                                                            v1.Xnaive(),v1.Ynaive(),
                                                            v2.Xnaive(),v2.Ynaive());
                    assert(twiceTriArea > 0);
                    SolveForDualPoint(v0.Xnaive(), v0.Ynaive(), v0.Hnaive(),
                                      v1.Xnaive(), v1.Ynaive(), v1.Hnaive(),
                                      v2.Xnaive(), v2.Ynaive(), v2.Hnaive(),
                                      triCenter,
                                      false, // wrapAroundSphereFlag
                                      false, // centerSphereFlag
                                      0.); // wrapSphereCurvature
                    return .5*twiceTriArea;
                } // getTriCenterAndArea

            // Test whether the crack killer is really a crack killer
            private static boolean exploreCrackHead(Mesh mesh,
                                                    int i0, int i1) // from and to of tri edge that goes from left to right of first crack edge
            {
                System.out.println("    Exploring crack head, starting with left->right "+i0+"->"+i1+"");
                // Find the initial edge
                Mesh.Edge firstTriEdge = null;
                FORI (iEdge, mesh.edges.size())
                {
                    Mesh.Edge edge = mesh.getEdge(iEdge);
                    if (edge.initialVertex().myIndex() == i0
                     && edge.finalVertex().myIndex() == i1)
                    {
                        assert(firstTriEdge == null);
                        firstTriEdge = edge;
                    }
                }
                assert(firstTriEdge != null);

                double totalCenter[] = {0.,0.};
                double totalArea = 0.;
                Mesh.Edge thisTriEdge = firstTriEdge;

                java.util.HashMap seenVerts = new java.util.HashMap();
                {
                    int inds[] = {thisTriEdge.initialVertex().myIndex(),
                                  thisTriEdge.finalVertex().myIndex(),
                                  thisTriEdge.opposite().next().finalVertex().myIndex()};
                    SortStuff.sort(inds);
                    int item = (inds[0]*mesh.verts.size()+inds[1])*mesh.verts.size()+inds[2];
                    seenVerts.put(new Integer(item), "");
                }

                while (true)
                {
                    double prevTriCenter[] = new double[3]; // SolveForDualPoint needs 3
                    double prevTriArea = getTriCenterAndArea(thisTriEdge.opposite(),
                                                             prevTriCenter);
                    // Update totalCenter and totalArea
                    VecMath.lerp(2, totalCenter,
                                 totalCenter, prevTriCenter,
                                 prevTriArea / (totalArea + prevTriArea));
                    totalArea += prevTriArea;

                    // gag, duplicate work, whatever
                    double nextTriCenter[] = new double[3]; // SolveForDualPoint needs 3
                    getTriCenterAndArea(thisTriEdge,
                                        nextTriCenter);
                    //PRINTVEC(nextTriCenter);

                    // totalCenter and totalArea are now the total
                    // for all crack vertices BEFORE this tri edge.

                    Mesh.Vertex v0 = thisTriEdge.initialVertex();
                    Mesh.Vertex v1 = thisTriEdge.finalVertex();
                    Mesh.Vertex v2 = thisTriEdge.next().finalVertex();

                    {
                        int inds[] = {v0.myIndex(), v1.myIndex(), v2.myIndex()};
                        SortStuff.sort(inds);
                        int item = (inds[0]*mesh.verts.size()+inds[1])*mesh.verts.size()+inds[2];
                        if (seenVerts.put(new Integer(item), "") != null)
                            System.out.println("        HEY! saw this dual vertex "+v0.myIndex()+","+v1.myIndex()+","+v2.myIndex()+" before!");
                    }


                    System.out.println("    at tri edge "+v0.myIndex()+"->"+v1.myIndex()+"");
                    System.out.println("        left next tri edge: "+v0.myIndex()+"->"+v2.myIndex()+"");
                    System.out.println("        right next tri edge: "+v2.myIndex()+"->"+v1.myIndex()+"");
                    assert(thisTriEdge.next().next().next() == thisTriEdge);
                    double leftNextTriEdgeNormal[] = VecMath.normalize(VecMath.xv2(new double[]{v2.Xnaive()-v0.Xnaive(), v2.Ynaive()-v0.Ynaive()}));
                    double rightNextTriEdgeNormal[] = VecMath.normalize(VecMath.xv2(new double[]{v1.Xnaive()-v2.Xnaive(), v1.Ynaive()-v2.Ynaive()}));
                    //PRINTVEC(leftNextTriEdgeNormal);
                    //PRINTVEC(rightNextTriEdgeNormal);
                    double leftHeight = VecMath.dot(VecMath.vmv(totalCenter, nextTriCenter), leftNextTriEdgeNormal);
                    double rightHeight = VecMath.dot(VecMath.vmv(totalCenter, nextTriCenter), rightNextTriEdgeNormal);
                    //PRINT(leftHeight);
                    //PRINT(rightHeight);
                    assert(leftHeight != 0.);
                    assert(rightHeight != 0.);
                    assert(leftHeight < 0 || rightHeight < 0);
                    if (leftHeight < 0 && rightHeight > 0)
                    {
                        System.out.println("        left is good, right is bad, choosing left");
                        thisTriEdge = thisTriEdge.next().next().opposite();
                        assert(thisTriEdge.initialVertex() == v0);
                        assert(thisTriEdge.finalVertex() == v2);
                    }
                    else if (rightHeight < 0 && leftHeight > 0)
                    {
                        System.out.println("        right is good, left is bad, choosing right");
                        thisTriEdge = thisTriEdge.next().opposite();
                        assert(thisTriEdge.initialVertex() == v2);
                        assert(thisTriEdge.finalVertex() == v1);
                    }
                    else
                    {
                        System.out.println("    NO CLEAR CHOICE");
                        return false; // failure
                    }
                }

            } // exploreCrackHead

            // Generalization of netless9.
            // counterexample to "there is an unfolding
            // that uses the sharpest edge at each vertex"
            private void doCannedThingHexesSpiral()
            {
                if (true)
                {
                    // s = how much bigger each edge is from the previous
                    //double s = 1.05;
                    //double s = 1.01;
                    double s = 1.005;
                    //double s = 1.001;
                    //double s = 1.;
                    double sliceAngle;
                    {
                        // In the initial 6 slice pie,
                        // the southwest triangle has sides a=1, b=s^5, c=s^6.
                        // what are its angles?
                        // http://www.teacherschoice.com.au/Maths_Library/Trigonometry/solve_trig_SSS.htm
                        double a = 1;
                        double b = s*s*s*s*s;
                        double c = s*s*s*s*s*s;
                        double C = triangleAngle(a, b, c);
                        // All right, the southwest angle at the center
                        // is C, a bit more than pi/3.
                        // Distribute the rest of the spokes evenly.
                        sliceAngle = (2*Math.PI-C) / 5;
                    }
                    PRINT(RTOD(sliceAngle));
                    //int nVerts = 19;
                    //int nVerts = 18;
                    //int nVerts = 100;
                    int nVerts = 300;
                    //int nVerts = 500;
                    //int nVerts = 1000;
                    double verts[][] = new double[nVerts][3];
                    int nNeighbors[] = new int[nVerts]; // zeros
                    ArrayList/*<int[]>*/ facesList = new ArrayList();

                    // Seed with verts 0 and 1, and an edge between them.
                    verts[0][0] = 0;
                    verts[0][1] = 0;
                    verts[0][2] = 0;
                    // Had the seed on the -y axis, changing it to +x axis for the hell of it
                    verts[1][0] = 1;
                    verts[1][1] = 0;
                    verts[1][2] = 0;
                    nNeighbors[0] = 1;
                    nNeighbors[1] = 1;

                    PRINT(VecMath.dist(verts[1], verts[6]));
                    PRINT(Math.pow(s, 6));

                    int oldestPerimeterEdge[] = {0,1};

                    for (int i = 2; i < nVerts; ++i)
                    {
                        //PRINT(i);
                        int arity = nNeighbors[oldestPerimeterEdge[0]];
                        assert(arity < 6);
                        double angFrac = 1./(6-arity);
                        //PRINT(1./angFrac);
                        double largestEdge = VecMath.dist(verts[i-1], verts[oldestPerimeterEdge[0]]);
                        //PRINT(largestEdge);
                        //PRINT(Math.pow(s, facesList.size()));

                        double c = VecMath.dist(verts[oldestPerimeterEdge[0]],
                                                verts[oldestPerimeterEdge[1]]);
                        double a = largestEdge * Math.pow(s, 1./angFrac);
                        double b = a*s;
                        //PRINT(a);
                        //PRINT(b);
                        double target[] = completeTriangle(verts[oldestPerimeterEdge[1]],
                                                           verts[oldestPerimeterEdge[0]],
                                                           a, b);
                        double ang0 = Math.atan2(verts[i-1][1]-verts[oldestPerimeterEdge[0]][1],
                                                 verts[i-1][0]-verts[oldestPerimeterEdge[0]][0]);
                        double ang1 = Math.atan2(target[1]-verts[oldestPerimeterEdge[0]][1],
                                                 target[0]-verts[oldestPerimeterEdge[0]][0]);
                        //PRINT(RTOD(ang0));
                        //PRINT(RTOD(ang1));
                        //PRINT(angFrac);
                        while (ang1 < ang0) ang1 += 2*Math.PI;
                        double ang = LERP(ang0, ang1, angFrac);
                        double length = largestEdge * s;
                        verts[i][0] = verts[oldestPerimeterEdge[0]][0] + length*Math.cos(ang);
                        verts[i][1] = verts[oldestPerimeterEdge[0]][1] + length*Math.sin(ang);
                        facesList.add(new int[]{oldestPerimeterEdge[0], i-1, i});
                        nNeighbors[oldestPerimeterEdge[0]]++;
                        nNeighbors[i-1]++;
                        nNeighbors[i] = 2;
                        if (nNeighbors[oldestPerimeterEdge[0]] == 6)
                        {
                            //System.out.println("COMPLETING at "+i);
                            facesList.add(new int[]{oldestPerimeterEdge[1], oldestPerimeterEdge[0], i});
                            nNeighbors[oldestPerimeterEdge[1]]++;
                            nNeighbors[i]++;
                            oldestPerimeterEdge[0]++;
                            oldestPerimeterEdge[1]++;
                        }
                    }

                    {
                        int nPerimeterVerts = 0;
                        FORI (i, nVerts)
                            if (nNeighbors[i] < 6)
                                nPerimeterVerts++;
                        int perimeterVerts[] = new int[nPerimeterVerts];
                        nPerimeterVerts = 0;
                        FORI (i, nVerts)
                            if (nNeighbors[i] < 6)
                                perimeterVerts[perimeterVerts.length-1-nPerimeterVerts++] = i;
                        facesList.add(perimeterVerts);
                        PRINT(nPerimeterVerts);
                    }


                    int faces[][] = new int[facesList.size()][];
                    facesList.toArray(faces);
                    mesh = new Mesh(verts, faces);
                    //PRINTARRAY(nNeighbors);
                    //PRINTARRAY(verts);
                    //PRINTARRAY(faces);
                }
                FORIDOWN (iVert, mesh.verts.size())
                {
                    double scale = .2;
                    Mesh.Vertex vert = mesh.getVert(iVert);
                    vert.setXYHnaive(vert.Xnaive() * scale,
                                vert.Ynaive() * scale,
                                vert.Hnaive() * (scale*scale));
                }
                //double heightIncr = .005*.14;
                double heightIncr = .005*.01;
                FORIDOWN (iVert, mesh.verts.size())
                {
                    Mesh.Vertex vert = mesh.getVert(iVert);
                    vert.setHnaive(vert.Hnaive() - heightIncr * iVert);
                }
            } // doCannedThingHexesSpiral

            // counterexample to "there is an unfolding
            // that uses the dullest edge on each face", // almost... needs some height adjustments... just hit O to optimize?
            private void doCannedThingHexesSpiralOther()
            {
                int nVerts = 50;
                double r = .7; // XXX actually this would have to gradually increase or decrease each time, to get a consistent direction
                double R = 1.;

                ArrayList vertsList = new ArrayList();
                vertsList.add(new double[]{0,0});
                vertsList.add(new double[]{r,0});
                vertsList.add(completeTriangle((double[])vertsList.get(0),
                                           (double[])vertsList.get(1), r, R));

                ArrayList facesList = new ArrayList();
                facesList.add(new int[]{0,1,2});


                int oldestOnBoundary = 0;
                while (vertsList.size() < nVerts)
                {
                    double newVertex[] = completeTriangle((double[])vertsList.get(oldestOnBoundary),
                                                          (double[])vertsList.get(vertsList.size()-1),
                                                          r, R);
                    if (VecMath.distsqrd((double[])vertsList.get(oldestOnBoundary+1),
                                         newVertex) <= R*R)
                    {
                        facesList.add(new int[]{oldestOnBoundary+1,
                                           oldestOnBoundary,
                                           vertsList.size()-1});
                        oldestOnBoundary++;
                    }
                    else
                    {
                        vertsList.add(newVertex);
                        facesList.add(new int[]{oldestOnBoundary,
                                           vertsList.size()-2,
                                           vertsList.size()-1});
                    }
                }
                // Now add the inside out one
                int insideOutFace[] = new int[vertsList.size() - oldestOnBoundary];
                FORI (i, insideOutFace.length)
                    insideOutFace[i] = vertsList.size()-1-i;
                facesList.add(insideOutFace);

                double verts[][] = new double[vertsList.size()][];
                vertsList.toArray(verts);
                int faces[][] = new int[facesList.size()][];
                facesList.toArray(faces);

                VecMath.mxs(verts, verts,
                            .75/VecMath.norm(verts[verts.length-1]));

                mesh = new Mesh(verts, faces);
                delaunayize(); // so faces were unnecessary, oh well
            } // doCannedThingHexesSpiralOther


    //
    // Definition of stuff for this particular app...
    //
        private static class Mesh
        {
            public String toString()
            {
                StringBuffer sb = new StringBuffer();
                sb.append(""+verts.size()+" verts:\n");
                FORI (iVert, verts.size())
                {
                    Vertex vert = (Vertex)verts.get(iVert);
                    sb.append("    "+vert.Xnaive()+" "+vert.Ynaive()+" "+vert.Hnaive());
                    if (vert.weight != 1.)
                        sb.append("  * "+vert.weight);

                    sb.append("\n");
                }
                sb.append(""+edges.size()+" edges:\n");
                FORI (iEdge, edges.size())
                {
                    Edge edge = (Edge)edges.get(iEdge);
                    Vertex v0 = edge.initialVertex();
                    Vertex v1 = edge.finalVertex();
                    sb.append("    "
                            + (v0==null ? "null" : "v"+v0.myIndex())
                            + " -> "
                            + (v1==null ? "null" : "v"+v1.myIndex())
                            + "\n");
                }
                return sb.toString();
            }

            public class Vertex
            {
                /*
                   X,Y,Z,W homo
                   x,y,z actual
                   h = z + (x^2+y^2)/2 = height above paraboloid z=-(x^2+y^2)/2 which has curvature 1 at origin

                   x = X/W
                   y = Y/W
                   z = Z/W
                   h = H/W^2
                   X = x*W
                   Y = y*W
                   Z = z*W
                   H = h*W^2

                   migration strategy:
                   a zillion callers assumed w=1 before and not clear
                   whether they really want x or X.
                   those have all been changed to:
                        Xnaive()
                        setXnaive()
                   and should be consciously changed to x()/setx() or X()/setXnaive()
                   as desired.
                */
                        
                private double _X;
                private double _Y;
                private double _Z;
                private double _W; // homogeneous "thing to divide by"
                private double _H; // height above the paraboloid z = -(x^2+y^2)/2 (has curvature 1 at origin). not all that meaningful when reference surface is sphere instead of that paraboloid.

                // TODO: can weight be merged with w?  I think currently they are always the same for dual verts, but maybe not for primals sometimes, when unwrapped/unwrapped from sphere. in that case w can convey infinite position
                public double weight = 1.; // optional, if this is a computed dual vertex, this should be the original triangle area (projected to xy plane I think)
                public double momentAndArea[/*4*/] = null; // optional... similar to weight. x*A,y*A,h*A^2,A where A is twice tri area (projected to xy plane I think)
                public int arity = 0; // number of edges having this vertex as initial vertex

                private int _myIndex = -1;
                public Vertex(double x, double y, double h)
                {
                    _W = 1.;
                    this.setXYHnaive(x,y,h);
                    verts.add(this);
                    fixVertIndices(verts.size()-1);
                }
                public Vertex(double X, double Y, double Z, double W)
                {
                    this.setXYZW(X,Y,Z,W);
                    verts.add(this);
                    fixVertIndices(verts.size()-1);
                }
                public Vertex(double X, double Y, double Zignored, double W, double H) // Zignored is just to distinguish prototype from others
                {
                    this.setXYHW(X,Y,H,W);
                    verts.add(this);
                    fixVertIndices(verts.size()-1);
                }

                // A Vertex can belong to only one Mesh.
                // myIndex() returns the index into the Mesh's edges.
                public int myIndex()
                {
                    //return Arrays.indexOfUsingEqualsSymbol(verts, this);
                    return _myIndex;
                }

                public double X() { return _X; }
                public double Y() { return _Y; }
                public double Z() { return _Z; }
                public double H() { return _H; }
                public double W() { return _W; }

                // XXX TODO: but what about when _W is 0? isn't that a legit case?  I think that shows we shouldn't really ever be calling these!  or, protect with W()!=0. first or something
                public double x() { return _X/_W; }
                public double y() { return _Y/_W; }
                public double z() { return _Z/_W; }
                public double h() { return _H/SQR(_W); } // seems to work, not quite sure of the logic


#ifdef NEVER
                //
                // Accessors for adjusting physical coords
                // even when W might not be 1.
                // TODO: not sure these are needed at all
                //       but I'm not sure...
                //       what if we just unwrapped from sphere (so some w's are not 1)
                //       and we then scale? that shouldn't require normalization, should it?
                //
                // in physical space:
                //      h = z + (x^2+y^2)/2
                //      z = h - (x^2+y^2)/2
                // in hom space:
                //      H = h*W^2
                //        = (z + (x^2+y^2)/2) * W^2
                //        = Z*W + (X^2+Y^2)/2
                //      Z = z*W
                //        = (h - (x^2+y^2)/2)*W
                //        = (h*W - (x^2*W+y^2*W)/2)
                //        = (H/W - (X^2/W+Y^2/W)/2)
                //        = (H - (X^2+Y^2)/2)/W
                // idea: when manipulating stuff in physical space, we *know* W can't be 0,
                //       so maybe setx can start by just normalizing so W=1?
                public void setx(double x) // y,h fixed, adjust z
                {
                    assert(_W == 1.);
                    _X = x*_W;
                    _Z = _H/_W - .5 * (x*x*_W + _Y*_Y/_W);
                }
                public void sety(double y) // x,h fixed, adjust z
                {
                    assert(_W == 1.);
                    _Y = y*_W;
                    _Z = _H/_W - .5 * (_X*_X/_W + y*y*_W);
                }
                public void setz(double z) // leave x,y fixed, adjust h
                {
                    assert(_W == 1.);
                    _Z = z*_W;
                    _H = _Z*_W + (_X*_X+_Y*_Y)/2;
                }
                public void seth(double h) // leave x,y fixed, adjust z
                {
                    assert(_W == 1.);
                    _H = h * (_W*_W);
                    _Z = (h*_W - .5 * (_X*_X + _Y*_Y)/_W);
                }
                public void setxy(double x, double y) // h fixed, adjust z
                {
                    assert(_W == 1.);
                    _X = x*_W;
                    _Y = y*_W;
                    _Z = (_H/_W - .5 * (x*x + y*y)*_W)
                }
                public void setxyz(double x, double y, double z) // calculate h
                {
                    _W = 1.;
                    _X = x;
                    _Y = y;
                    _Z = z;
                    _H = z + .5 * (x*x + y*y);
                }
#endif // NEVER
                public void setxyh(double x, double y, double h) // calculate z
                {
                    _W = 1.;
                    _X = x;
                    _Y = y;
                    _H = h;
                    _Z = h - .5 * (x*x + y*y);
                }

                public void setXYZW(double X, double Y, double Z, double W) // calculate H
                {
                    _X = X;
                    _Y = Y;
                    _Z = Z;
                    _W = W;
                    _H = _Z*_W + .5 * (_X*_X+_Y*_Y);
                }
                public void setXYHW(double X, double Y, double H, double W) // calculate Z; unfortunate divide
                {
                    _X = X;
                    _Y = Y;
                    _H = H;
                    _W = W;
                    _Z = (_H - .5 * (_X*_X+_Y*_Y)) / _W;
                }

                //
                // "Naive" setting functions,
                // that set h in terms of z or vice versa.
                // These require _W is 1.
                //
                public void setXYHnaive(double X, double Y, double H) // infer Z
                {
                    assert(_W == 1.);
                    _X = X;
                    _Y = Y;
                    _H = H;
                    _Z = _H - .5 * (_X*_X + _Y*_Y);
                }
                public void setXYZnaive(double X, double Y, double Z) // infer H
                {
                    assert(_W == 1.);
                    _X = X;
                    _Y = Y;
                    _Z = Z;
                    _H = _Z + .5 * (_X*_X + _Y*_Y);
                }
                public void setXYnaive(double X, double Y) // leave H fixed, adjust Z
                {
                    assert(_W == 1.);
                    _X = X;
                    _Y = Y;
                    _Z = _H - .5 * (_X*_X + _Y*_Y);
                }
                public void setXnaive(double X) // leave Y,H fixed, adjust Z
                {
                    assert(_W == 1.);
                    _X = X;
                    _Z = _H - .5 * (_X*_X + _Y*_Y);
                }
                public void setYnaive(double X) // leave X,H fixed, adjust Z
                {
                    assert(_W == 1.);
                    _X = X;
                    _Z = _H - .5 * (_X*_X + _Y*_Y);
                }
                public void setHnaive(double H) // leave X,Y fixed, adjust Z
                {
                    assert(_W == 1.);
                    _H = H;
                    _Z = _H - .5 * (_X*_X + _Y*_Y);
                }
                public void setZnaive(double Z) // leave X,Y fixed, adjust H
                {
                    assert(_W == 1.);
                    _Z = Z;
                    _H = _Z + .5 * (_X*_X + _Y*_Y);
                }


                public double Xnaive()
                {
                    assert(_W == 1.);
                    return X();
                }
                public double Ynaive()
                {
                    assert(_W == 1.);
                    return Y();
                }
                public double Znaive()
                {
                    assert(_W == 1.);
                    return Z();
                }
                public double Hnaive()
                {
                    assert(_W == 1.);
                    return H();
                }
                public double Wnaive()
                {
                    assert(_W == 1.);
                    return W();
                }

                public String toString()
                {
                    // not too attached to this format
                    return "v"+myIndex()+" = ("+X()+" "+Y()+" "+Z()+" "+W()+" H="+H()+")" 
                         + " = "
                         + "("+x()+" "+y()+" "+z()+" h="+h()+")" ;
                }
            } // public class Vertex
            public class Edge
            {
                private Vertex _initialVertex;
                private Edge _opposite; // opposite edge
                private Edge _next; // next edge CCW around the face to my left
                private Edge _prev; // prev edge (next edge CW) around the face to my left
                private int _myIndex = -1;
                public double direction[] = null; // optional, not kept up to date by mesh editing operations, only really used in dual, which is constructed and not edited

                public Edge(boolean andBack)
                {
                    this._myIndex = -1; // will get fixed
                    edges.add(this);
                    fixEdgeIndices(edges.size()-1);
                    if (andBack)
                    {
                        Edge opposite = new Edge(false);
                        setOpposite(opposite, true);
                    }
                }

                //
                // Accessor methods...
                //
                public Vertex initialVertex()
                {
                    return _initialVertex;
                }
                public Edge opposite()
                {
                    return _opposite;
                }
                // next edge CCW around the face to my left
                public Edge next()
                {
                    return _next;
                }
                // prev edge (next edge CW) around the face to my left
                public Edge prev()
                {
                    return _prev;
                }

                //
                // Helper methods...
                // From the caller's point of view,
                // these are just like the accessor methods
                //
                public Vertex finalVertex()
                {
                    return _opposite._initialVertex;
                }


                // An Edge can belong to only one Mesh.
                // myIndex() returns the index into the Mesh's edges.
                public int myIndex()
                {
                    //return Arrays.indexOfUsingEqualsSymbol(edges, this);
                    return _myIndex;
                }


                public void setInitialVertex(Vertex v)
                {
                    assert(_initialVertex == null); // initial vertex can't be changed
                    _initialVertex = v;
                    _initialVertex.arity++;
                }

                public void setOpposite(Edge opposite, boolean andBack)
                {
                    _opposite = opposite;
                    if (andBack)
                        _opposite.setOpposite(this, false);
                }
                public void setNext(Edge next, boolean andBack)
                {
                    _next = next;
                    if (andBack)
                        next.setPrev(this, false);
                }
                public void setPrev(Edge prev, boolean andBack)
                {
                    _prev = prev;
                    if (andBack)
                        prev.setNext(this, false);
                }

                public String toString()
                {
                    StringBuffer sb = new StringBuffer();
                    sb.append("e");
                    sb.append(myIndex());
                    sb.append(" (");

                    if (initialVertex() != null)
                    {
                        sb.append("v");
                        sb.append(initialVertex().myIndex());
                    }
                    else
                        sb.append("null");
                    sb.append("->");
                    if (finalVertex() != null)
                    {
                        sb.append("v");
                        sb.append(finalVertex().myIndex());
                    }
                    else
                        sb.append("null");

                    sb.append(")");
                    return sb.toString();
                }

            } // public class Edge

            // Called whenever verts array changes
            private void fixVertIndices(int i0)
            {
                for (int iVert = i0; iVert < verts.size(); ++iVert)
                    ((Vertex)verts.get(iVert))._myIndex = iVert;
            }
            // Called whenever edges array changes
            private void fixEdgeIndices(int i0)
            {
                for (int iEdge = i0; iEdge < edges.size(); ++iEdge)
                    ((Edge)edges.get(iEdge))._myIndex = iEdge;
            }

            public void sanityCheck()
            {
                int nVerts = this.verts.size();
                int nEdges = this.edges.size();

                Vertex verts[] = new Vertex[nVerts];
                Edge edges[] = new Edge[nEdges];

                FORI (iVert, nVerts)
                {
                    Vertex vert = (Vertex)this.getVert(iVert);
                    assert(vert.myIndex() == iVert);
                    verts[iVert] = vert;
                }
                FORI (iEdge, nEdges)
                {
                    Edge edge = (Edge)this.getEdge(iEdge);
                    assert(edge.myIndex() == iEdge);
                    edges[iEdge] = edge;
                }

                int nTimesSawVertAsInitial[] = new int[nVerts]; // all zero
                boolean sawEdgeAsOpposite[] = new boolean[nEdges]; // all false
                boolean sawEdgeAsNext[] = new boolean[nEdges]; // all false
                boolean sawEdgeAsPrev[] = new boolean[nEdges]; // all false
                FORI (iEdge, nEdges)
                {
                    Edge e = edges[iEdge];
                    Vertex initialVertex = e.initialVertex();
                    Edge opposite = e.opposite();
                    Edge next = e.next();
                    Edge prev = e.prev();

                    assert(initialVertex != null);
                    assert(opposite != null);
                    assert(next != null);
                    assert(prev != null);

                    int initialVertIndex = initialVertex.myIndex();
                    int oppositeIndex = opposite.myIndex();
                    int nextIndex = next.myIndex();
                    int prevIndex = prev.myIndex();

                    assert(verts[initialVertIndex] == initialVertex);
                    assert(edges[oppositeIndex] == opposite);
                    assert(edges[nextIndex] == next);
                    assert(edges[prevIndex] == prev);

                    assert(initialVertex != e.finalVertex());
                    assert(opposite != e);
                    assert(next != e);
                    assert(prev != e);
                    assert(opposite.opposite() == e);
                    assert(next.prev() == e);
                    assert(prev.next() == e);


                    // Okay for a vert to be initial more than once...
                    nTimesSawVertAsInitial[initialVertIndex]++;

                    // But not the others...
                    assert(!sawEdgeAsOpposite[oppositeIndex]);
                    sawEdgeAsOpposite[oppositeIndex] = true;
                    assert(!sawEdgeAsNext[nextIndex]);
                    sawEdgeAsNext[nextIndex] = true;
                    assert(!sawEdgeAsPrev[prevIndex]);
                    sawEdgeAsPrev[prevIndex] = true;
                }

                FORI (iVert, nVerts)
                {
                    assert(nTimesSawVertAsInitial[iVert] == verts[iVert].arity);
                }
                FORI (iEdge, nEdges)
                {
                    assert(sawEdgeAsOpposite[iEdge]);
                    assert(sawEdgeAsNext[iEdge]);
                    assert(sawEdgeAsPrev[iEdge]);
                }
            } // sanityCheck




            /*                    ^
                 insertThisEdge   | beforeThisEdge
                <-----------------*
                                 /|\
                                / | \
            */
            public void insertEdgeBefore(Edge insertThisEdge, Edge beforeThisEdge)
            {
                if (nonEventVerbose >= 1)
                    System.out.println("        In insertEdgeBefore(insertThisEdge="+insertThisEdge.myIndex()+", beforeThisEdge="+beforeThisEdge.myIndex()+"");
                beforeThisEdge.prev().setNext(insertThisEdge, true);
                insertThisEdge.opposite().setNext(beforeThisEdge, true);
                insertThisEdge.setInitialVertex(beforeThisEdge.initialVertex());
                if (nonEventVerbose >= 1)
                    System.out.println("        Out insertEdgeBefore(insertThisEdge="+insertThisEdge.myIndex()+", beforeThisEdge="+beforeThisEdge.myIndex()+"");
            }
            public void addWhisker(Edge beforeThisEdge,
                                   Vertex v) // to this vertex
            {
                Edge e = new Edge(true);
                e.opposite().setInitialVertex(v);
                e.setNext(e.opposite(), true);
                insertEdgeBefore(e, beforeThisEdge);
            }
            public void addDiagonal(Edge beforeThisEdge, Edge beforeThatEdge)
            {
                if (nonEventVerbose >= 1)
                    System.out.println("    In addDiagonal(beforeThisEdge="+beforeThisEdge.myIndex()+", beforeThatEdge="+beforeThatEdge.myIndex()+"");
                Edge e = new Edge(true);
                insertEdgeBefore(e, beforeThisEdge);
                insertEdgeBefore(e.opposite(), beforeThatEdge);
                if (nonEventVerbose >= 1)
                    System.out.println("    Out addDiagonal(beforeThisEdge="+beforeThisEdge.myIndex()+", beforeThatEdge="+beforeThatEdge.myIndex()+"");
            }
            // returns true iff did something
            public boolean swapDiagonal(Edge e, boolean onlyIfMoreDelaunay, boolean verbose)
            {
                if (e.next().next().next() != e
                 || e.opposite().next().next().next() != e.opposite())
                {
                    if (verbose)
                        System.out.println("    Can't swap diagonal, it's not on a quad");
                    return false;
                }

                Edge beforeThisEdge = e.prev();
                Edge beforeThatEdge = e.opposite().prev();

                //
                // Another subtle thing to check...
                // Make sure the other diagonal doesn't
                // already exist.
                //
                {
                    Vertex v0 = beforeThisEdge.initialVertex();
                    Vertex v1 = beforeThatEdge.initialVertex();
                    // Could do this faster by walking around the vert,
                    // but this is more complete since it checks for some pathological cases
                    FORIDOWN (iEdge, edges.size())
                    {
                        Edge edge = (Edge)edges.get(iEdge);
                        if (edge.initialVertex() == v0
                         && edge.finalVertex() == v1)
                        {
                            if (verbose)
                                System.out.println("    Can't swap diagonal, the other diagonal already exists");
                            return false;
                        }
                    }
                }

                if (onlyIfMoreDelaunay)
                {
                    Vertex a = beforeThisEdge.finalVertex();
                    Vertex b = beforeThatEdge.initialVertex();
                    Vertex c = beforeThatEdge.finalVertex();
                    Vertex d = beforeThisEdge.initialVertex();
                    // comfort of ac relative to bd
                    double comfort = TriangulationOptimizer.calcQuadComfort(new double[]{a.Xnaive(),a.Ynaive()},
                                                                            new double[]{b.Xnaive(),b.Ynaive()},
                                                                            new double[]{c.Xnaive(),c.Ynaive()},
                                                                            new double[]{d.Xnaive(),d.Ynaive()},
                                                                            0, 1);
                    // XXX TODO: take height into account!!!!!
                    if (verbose)
                        System.out.println("    comfort = "+comfort);
                    if (comfort >= 0) // should this be fuzzy? I won't worry about it for now
                    {
                        if (verbose)
                            System.out.println("    Swapping diagonal would not improve it");
                        return false;
                    }
                }

                if (true)
                {
                    // This works, but leaves dual verts in a different order
                    deleteEdge(e);
                    addDiagonal(beforeThisEdge, beforeThatEdge);
                }
                else
                {
                    // TODO: why did this work in temp branch but fails here?
                    // OH, it's because the assertion in setInitialVertex is new.
                    // hmm, can try to fix it, or just get rid of this case since it was somewhat ill-advised anyway.

                    // Aww fooey, still in different order :-(
                    beforeThatEdge.setNext(beforeThisEdge.prev(), true);
                    beforeThisEdge.setNext(beforeThatEdge.prev(), true);
                    insertEdgeBefore(e, beforeThisEdge);
                    insertEdgeBefore(e.opposite(), beforeThatEdge);
                    // no need to fix up edge indices
                }
                return true;
            } // swapDiagonal
            public void addEdgeBetweenTwoIsolatedVertices(Vertex v0, Vertex v1)
            {
                Edge e = new Edge(true);
                e.setInitialVertex(v0);
                e.opposite().setInitialVertex(v1);
                e.setNext(e.opposite(), true);
                e.setPrev(e.opposite(), true);
            }
            public void addEdgeBetweenTwoVertices(Vertex v0, Vertex v1)
            {
                assert(v0 != v1);
                int nEdges = edges.size();

                // First find any edge beginning at v0,
                // and any beginning at v1
                Edge someEdgeStartingAtV0 = null;
                Edge someEdgeStartingAtV1 = null;
                FORI (iEdge, nEdges)
                {
                    Edge e = (Edge)edges.get(iEdge);
                    if (e.initialVertex() == v0)
                    {
                        someEdgeStartingAtV0 = e;
                        if (e.finalVertex() == v1)
                            return; // v0,v1 already connected-- definitely don't do anything!
                    }
                    else if (e.initialVertex() == v1)
                    {
                        someEdgeStartingAtV1 = e;
                        // no need to check whether final is v0, we'll catch it in the other direction
                    }
                }

                // Then walk around ccw to find the *best* place to insert the edge
                // among v0's edges and among v1's edges

                if (someEdgeStartingAtV1 != null)
                {
                    // figure out the best place among v1's edges
                    // to add v0.
                    double bestGoodness = Double.NEGATIVE_INFINITY;
                    Edge bestBeforeThisEdge = null;
                    double ang = Math.atan2(v0.Ynaive()-v1.Ynaive(), v0.Xnaive()-v1.Xnaive());
                    // for each edge out of v1, ccw
                    Edge nextEdgeOutOfV1 = null;
                    for (Edge thisEdgeOutOfV1 = someEdgeStartingAtV1; ; thisEdgeOutOfV1 = nextEdgeOutOfV1)
                    {
                        // XXX dup code!
                        nextEdgeOutOfV1 = thisEdgeOutOfV1.prev().opposite();
                        //PRINT(thisEdgeOutOfV1);
                        //PRINT(nextEdgeOutOfV1);
                        Vertex thisNeighbor = thisEdgeOutOfV1.finalVertex();
                        Vertex nextNeighbor = nextEdgeOutOfV1.finalVertex();
                        double thisAng = Math.atan2(thisNeighbor.Ynaive()-v1.Ynaive(),
                                                    thisNeighbor.Xnaive()-v1.Xnaive());
                        // change thisAng by multiples of 2*Math.PI
                        // so that it's >= ang by as little as possible
                        // XXX not sure this is robust... can something fall between the cracks?
                        while (thisAng < ang) thisAng += 2*Math.PI;
                        while (thisAng > ang) thisAng -= 2*Math.PI;

                        double thisGoodness = -(ang-thisAng); // want to minimize ang-thisAng, so maximize -(ang-thisAng)
                        //PRINT(RTOD(thisGoodness));
                        if (thisGoodness > bestGoodness)
                        {
                            bestBeforeThisEdge = thisEdgeOutOfV1;
                            bestGoodness = thisGoodness;
                        }

                        if (nextEdgeOutOfV1 == someEdgeStartingAtV1)
                            break;
                    }
                    assert(bestBeforeThisEdge != null);
                    System.out.println("    Sticking v"+v0.myIndex()+" between v"+bestBeforeThisEdge.finalVertex().myIndex()+" and v"+bestBeforeThisEdge.prev().opposite().finalVertex().myIndex()+" in v"+v1.myIndex()+"'s neighbors");
                    someEdgeStartingAtV1 = bestBeforeThisEdge;
                }
                if (someEdgeStartingAtV0 != null)
                {
                    // figure out the best place among v0's edges
                    // to add v1.
                    double bestGoodness = Double.NEGATIVE_INFINITY;
                    Edge bestBeforeThisEdge = null;
                    double ang = Math.atan2(v1.Ynaive()-v0.Ynaive(), v1.Xnaive()-v0.Xnaive());
                    // for each edge out of v0, ccw
                    Edge nextEdgeOutOfV0 = null;
                    for (Edge thisEdgeOutOfV0 = someEdgeStartingAtV0; ; thisEdgeOutOfV0 = nextEdgeOutOfV0)
                    {
                        // XXX dup code!
                        nextEdgeOutOfV0 = thisEdgeOutOfV0.prev().opposite();
                        //PRINT(thisEdgeOutOfV0);
                        //PRINT(nextEdgeOutOfV0);
                        Vertex thisNeighbor = thisEdgeOutOfV0.finalVertex();
                        Vertex nextNeighbor = nextEdgeOutOfV0.finalVertex();
                        double thisAng = Math.atan2(thisNeighbor.Ynaive()-v0.Ynaive(),
                                                    thisNeighbor.Xnaive()-v0.Xnaive());
                        // change thisAng by multiples of 2*Math.PI
                        // so that it's >= ang by as little as possible
                        // XXX not sure this is robust... can something fall between the cracks? think about it
                        while (thisAng < ang) thisAng += 2*Math.PI;
                        while (thisAng > ang) thisAng -= 2*Math.PI;

                        double thisGoodness = -(ang-thisAng); // want to minimize ang-thisAng, so maximize -(ang-thisAng)
                        //PRINT(RTOD(thisGoodness));
                        if (thisGoodness > bestGoodness)
                        {
                            bestBeforeThisEdge = thisEdgeOutOfV0;
                            bestGoodness = thisGoodness;
                        }

                        if (nextEdgeOutOfV0 == someEdgeStartingAtV0)
                            break;
                    }
                    assert(bestBeforeThisEdge != null);
                    System.out.println("    Sticking v"+v1.myIndex()+" between v"+bestBeforeThisEdge.finalVertex().myIndex()+" and v"+bestBeforeThisEdge.prev().opposite().finalVertex().myIndex()+" in v"+v0.myIndex()+"'s neighbors");
                    someEdgeStartingAtV0 = bestBeforeThisEdge;
                }


                if (someEdgeStartingAtV0 != null)
                    if (someEdgeStartingAtV1 != null)
                        addDiagonal(someEdgeStartingAtV0,
                                    someEdgeStartingAtV1);
                    else
                        addWhisker(someEdgeStartingAtV0, v1);
                else
                    if (someEdgeStartingAtV1 != null)
                        addWhisker(someEdgeStartingAtV1, v0);
                    else
                        addEdgeBetweenTwoIsolatedVertices(v0, v1);
            } // addEdgeBetweenTwoVertices

            // twice area (of projection in XY plane) of the face obtained by walking around the edge.
            public double twiceFaceArea(Edge e0)
            {
                double sum = 0;
                Vertex v0 = e0.initialVertex();
                // All edges e not containing v0...
                for (Edge e = e0.next(); e.finalVertex() != v0; e = e.next())
                {
                    Vertex v1 = e.initialVertex();
                    Vertex v2 = e.finalVertex();
                    // TODO: this dangerous. should be using a different method to show what's inside out!
                    sum += twiceTriangleArea(v0.x(), v0.y(),
                                             v1.x(), v1.y(),
                                             v2.x(), v2.y());
                }
                return sum;
            } // twiceFaceArea

            public void addIsolatedVertex(double x, double y, double h)
            {
                new Vertex(x,y,h); // adds itself to verts
            }
            public void addIsolatedVertex(double X, double Y, double Z, double W)
            {
                new Vertex(X,Y,Z,W); // adds itself to verts
            }
            // This is the "kis" operation, the dual of truncating a vertex.
            public void kisIsolatedVertex(Vertex v, Edge someEdgeOnFace)
            {
                if (nonEventVerbose >= 1)
                    System.out.println("In kis(v="+v.myIndex()+", someEdgeOnFac="+someEdgeOnFace.myIndex()+"");
                //
                // Start by attaching a single whisker to the new vertex...
                //
                if (nonEventVerbose >= 1)
                    System.out.println("    adding a whisker from edge "+someEdgeOnFace.myIndex()+" to vert "+v.myIndex());
                addWhisker(someEdgeOnFace, v);
                if (nonEventVerbose >= 1)
                {
                    System.out.println("    did that at least.");
                    PRINT(this);
                }

                //
                // Now fill in with triangles,
                // connecting everything to the new vertex v.
                //
                while (someEdgeOnFace.next()
                                     .next()
                                     .next() != someEdgeOnFace)
                {
                    if (nonEventVerbose >= 1)
                        System.out.println("    adding diagonal from start of edge "+someEdgeOnFace.prev().myIndex()+" to start of edge "+someEdgeOnFace.prev().prev().prev().myIndex()+"");
                    addDiagonal(someEdgeOnFace.prev(),
                                someEdgeOnFace.prev()
                                              .prev()
                                              .prev());
                    if (nonEventVerbose >= 1)
                    {
                        System.out.println("    did that diagonal.");
                        PRINT(this);
                    }
                }
                if (nonEventVerbose >= 1)
                    System.out.println("Out kis(v="+v.myIndex()+", someEdgeOnFac="+someEdgeOnFace.myIndex()+"");
            }
            public void deleteEdge(Edge e)
            {
                // TODO: use totally generic splice operation?
                e.prev().setNext(e.opposite().next(), true);
                e.opposite().prev().setNext(e.next(), true);

                // these don't hold, currently, but might if we use splice
                //assert(e.next() == e.opposite());
                //assert(e.prev() == e.opposite());

                int i = e.myIndex();
                edges.remove(i);
                fixEdgeIndices(i);

                int j = e.opposite().myIndex();
                edges.remove(j);
                fixEdgeIndices(j);

                e._initialVertex.arity--;
                e._initialVertex = null;

                e.opposite()._initialVertex.arity--;
                e.opposite()._initialVertex = null;
            }
            public void deleteVertex(Vertex v, int oldToNew[], int newToOld[])
            {
                FORI (iEdge, edges.size())
                {
                    Edge edge = (Edge)edges.get(iEdge);
                    if (edge.initialVertex() == v
                     || edge.finalVertex() == v)
                    {
                        deleteEdge(edge);
                        iEdge--; // so when we increment we get back to here
                    }
                }
                assert(v.arity == 0);
                int iVert = v.myIndex();
                verts.remove(iVert);
                fixVertIndices(iVert);

                // XXX should we do the fast remove, moving the last one into the slot?  well, is there an advantage to keeping the vertices in order?  Probably.

                // adjust oldToNew and newToOld, assuming *not* fastRemove
                if (oldToNew != null)
                {
                    assert(newToOld != null);
                    int nVertsNew = verts.size();
                    oldToNew[newToOld[iVert]] = -1; // using previous newToOld values
                    for (int jVert = iVert; jVert < nVertsNew; ++jVert)
                        oldToNew[newToOld[jVert+1]] = jVert; // using previous newToOld values
                }
                if (newToOld != null)
                {
                    int nVertsNew = verts.size();
                    for (int jVert = iVert; jVert < nVertsNew; ++jVert)
                        newToOld[jVert] = newToOld[jVert+1];
                    newToOld[nVertsNew] = -1;
                }
            } // deleteVertex

            // XXX TODO: this shouldn't need graphics, just the xform
            public int indexOfClosestVert(double x, double y, MyGraphics3D mg)
            {
                double closestDistSqrd = Double.POSITIVE_INFINITY;
                int closestVertIndex = -1;
                double scratch[] = new double[3];
                FORI (iVert, verts.size()) // beginning to end, so we choose first of equal
                {
                    Vertex vert = (Vertex)verts.get(iVert);
                    mg.xform(vert.X(), vert.Y(), vert.Z(), vert.W(), scratch);
                    double thisDistSqrd = SQR(scratch[0]-x)
                                        + SQR(scratch[1]-y);
                    if (thisDistSqrd < closestDistSqrd)
                    {
                        closestDistSqrd = thisDistSqrd;
                        closestVertIndex = iVert;
                    }
                }
                return closestVertIndex; // -1 if none
            } // indexOfClosestVert

            public int indexOfClosestEdge(double point[/*2*/], boolean isDualMesh)
            {
                double x = point[0], y = point[1];
                double closestDistSqrd = Double.POSITIVE_INFINITY;
                int closestEdgeIndex = -1;
                FORI (iEdge, edges.size()) // beginning to end, so we choose first of equal
                {
                    Edge edge = (Edge)edges.get(iEdge);
                    double thisDistSqrd =
                        edge.initialVertex() == null ? Double.POSITIVE_INFINITY : // no need to deal with edges whose initial vertex is NULL and final vertex isn't, since we'll encounter its opposite anyway
                        edge.finalVertex() == null ? distSqrdFromPointToRay(x,y,
                                                                            edge.initialVertex().x(),
                                                                            edge.initialVertex().y(),
                                                                            edge.direction[0],
                                                                            edge.direction[1]) :
                        edge.initialVertex().myIndex() > edge.finalVertex().myIndex() ? Double.POSITIVE_INFINITY
                                                    : distSqrdFromPointToSeg(x,y,
                                                                             edge.initialVertex().x(),
                                                                             edge.initialVertex().y(),
                                                                             edge.finalVertex().x(),
                                                                             edge.finalVertex().y());
                    if (thisDistSqrd < closestDistSqrd)
                    {
                        closestDistSqrd = thisDistSqrd;
                        closestEdgeIndex = iEdge;
                    }
                }
                if (closestEdgeIndex != -1)
                {
                    // Make sure point is on left side of edge.
                    // If not, choose edge's opposite instead.
                    Edge edge = (Edge)edges.get(closestEdgeIndex);
                    double edgeDirection[] = edge.direction;
                    if (edgeDirection == null) // currently it's null for the primal, non-null for dual
                    {
                        Vertex v0 = edge.initialVertex();
                        Vertex v1 = edge.finalVertex();
                        edgeDirection = new double[]{v1.x()-v0.x(), v1.y()-v0.y()};
                    }
                    Vertex v = edge.initialVertex();
                    if (v == null) v = edge.finalVertex();
                    double vToPoint[] = {point[0]-v.x(), point[1]-v.y()};
                    if (VecMath.vxv2(edgeDirection, vToPoint) * (isDualMesh ? -1. : 1.) < 0.)
                    {
                        closestEdgeIndex = edge.opposite().myIndex();
                    }
                }
                return closestEdgeIndex; // -1 if none
            } // indexOfClosestEdge

            public double[] findOptimalVertexHeights(int optimizationType)
            {
                if (verts.size() < 3)
                    return new double[verts.size()]; // zeros

                if (nonEventVerbose >= 1)
                    System.out.println("in findOptimalVertexHeights");

                int nDependentVerts = 3;
                int dependentVertIndices[] = {0,1,2};
                // Prefer the triangle that contains the origin...
                {
                    FORI (iEdge, edges.size())
                    {
                        Edge edge = (Edge)edges.get(iEdge);
                        if (edge.next().next().next() != edge)
                            continue;
                        Vertex v0 = edge.initialVertex();
                        Vertex v1 = edge.next().initialVertex();
                        Vertex v2 = edge.next().next().initialVertex();
                        if (twiceTriangleArea(0,0,
                                              v0.Xnaive(),v0.Ynaive(),
                                              v1.Xnaive(),v1.Ynaive()) >= 0
                         && twiceTriangleArea(0,0,
                                              v1.Xnaive(),v1.Ynaive(),
                                              v2.Xnaive(),v2.Ynaive()) >= 0
                         && twiceTriangleArea(0,0,
                                              v2.Xnaive(),v2.Ynaive(),
                                              v0.Xnaive(),v0.Ynaive()) >= 0)
                        {
                            dependentVertIndices[0] = v0.myIndex();
                            dependentVertIndices[1] = v1.myIndex();
                            dependentVertIndices[2] = v2.myIndex();
                            break; // origin is inside this tri CCW
                        }
                    }
                }

                // Figure out the desired dualEdgeLength...
                // XXX just hard code for now
                double desiredDualEdgeLength = .25;

                // edge2dualVert[iEdge] will be the dual vert on the left of edges[iEdge]
                int edge2dualVert[] = VecMath.fillvec(edges.size(), -1);
                int nDualVerts;
                {
                    nDualVerts = 0;
                    FORI (iEdge, edges.size())
                    {
                        if (edge2dualVert[iEdge] != -1)
                            continue; // already saw some other edge on this tri
                        Edge e0 = (Edge)edges.get(iEdge);
                        Edge e1 = e0.next();
                        Edge e2 = e1.next();
                        boolean thisIsATri = (e2.next() == e0);
                        if (!thisIsATri)
                            continue;

                        Mesh.Vertex v0 = e0.initialVertex();
                        Mesh.Vertex v1 = e1.initialVertex();
                        Mesh.Vertex v2 = e2.initialVertex();

                        double dualVertArea = twiceTriangleArea(v0.Xnaive(),v0.Ynaive(),
                                                                v1.Xnaive(),v1.Ynaive(),
                                                                v2.Xnaive(),v2.Ynaive());
                        if (dualVertArea < 0.)
                            continue; // triangle is inside out

                        edge2dualVert[iEdge] = nDualVerts;
                        edge2dualVert[e1.myIndex()] = nDualVerts;
                        edge2dualVert[e2.myIndex()] = nDualVerts;
                        nDualVerts++;
                    }
                }
                if (nonEventVerbose >= 1)
                    PRINT(nDualVerts);

                // there is only one dual edge per pair (edge,edge.opposite()).
                int edge2dualEdge[] = VecMath.fillvec(edges.size(), -1);
                int nDualEdges;
                {
                    nDualEdges = 0;
                    FORI (iEdge, edges.size())
                    {
                        if (edge2dualEdge[iEdge] != -1)
                            continue; // already seen it from the opposite edge

                        Edge edge = (Edge)edges.get(iEdge);
                        if (edge2dualVert[iEdge] != -1
                         && edge2dualVert[edge.opposite().myIndex()] != -1)
                        {
                            // Opposite edge is also on a tri
                            // that we haven't counted yet
                            edge2dualEdge[iEdge] = nDualEdges;
                            edge2dualEdge[edge.opposite().myIndex()] = nDualEdges;
                            nDualEdges++;
                        }
                    }
                }
                if (nonEventVerbose >= 1)
                    PRINT(nDualEdges);

                int dualVert2verts[][] = VecMath.fillmat(nDualVerts, 3, -1);
                int dualEdge2edge[] = VecMath.fillvec(nDualEdges, -1); // XXX not used?
                int dualEdge2dualVerts[][] = VecMath.fillmat(nDualEdges, 2, -1);
                {
                    FORI (iEdge, edges.size())
                    {
                        Edge edge = (Edge)edges.get(iEdge);
                        int iDualEdge = edge2dualEdge[iEdge];
                        if (iDualEdge != -1 // if it has a dual edge
                         && dualEdge2dualVerts[iDualEdge][0] == -1) // if we didn't already do this dual edge from the opposite
                        {
                            dualEdge2edge[iDualEdge] = iEdge;
                            dualEdge2dualVerts[iDualEdge][0] = edge2dualVert[iEdge];
                            dualEdge2dualVerts[iDualEdge][1] = edge2dualVert[edge.opposite().myIndex()];
                        }

                        int iDualVert = edge2dualVert[iEdge];
                        if (iDualVert != -1 // if this edge is on a triangle
                         && dualVert2verts[iDualVert][0] == -1) // if we didn't already do this dual vert
                        {
                            dualVert2verts[iDualVert][0] = edge.initialVertex().myIndex();
                            dualVert2verts[iDualVert][1] = edge.next().initialVertex().myIndex();
                            dualVert2verts[iDualVert][2] = edge.next().next().initialVertex().myIndex();
                        }
                    }
                    FORI (iDualVert, nDualVerts)
                        FORI (j, 3)
                            assert(dualVert2verts[iDualVert][j] != -1);

                    FORI (iDualEdge, nDualEdges)
                    {
                        assert(dualEdge2edge[iDualEdge] != -1);
                        assert(dualEdge2dualVerts[iDualEdge][0] != -1);
                        assert(dualEdge2dualVerts[iDualEdge][1] != -1);
                    }
                }


                // can optimize positions or lengths.  I think optimizing positions is more robust.
                boolean optimizingBarycentrics = optimizationType == OPTIMIZE_BARYCENTRICS_LEAST_SQUARES
                                              || optimizationType == OPTIMIZE_BARYCENTRICS_MAX_MIN
                                              || optimizationType == OPTIMIZE_BARYCENTRICS_INFINITY_NORM;
                if (optimizingBarycentrics)
                {
                    nDependentVerts = 1; // XXX not right in general, should be number of connected components maybe
                    dependentVertIndices = new int[] {0};
                }

                if (nonEventVerbose >= 1)
                {
                    PRINTVEC(dependentVertIndices);
                }


                int nIndependentVerts = verts.size() - nDependentVerts;

                if (nIndependentVerts > (optimizingBarycentrics ? 2*nDualVerts : nDualEdges))
                {
                    //PRINT((optimizingBarycentrics ? 2*nDualVerts : nDualEdges));
                    System.out.println("Out findOptimalVertexHeights (too many independent verts, it's underconstrained)");
                    return new double[verts.size()]; // zeros
                }

                int vert2independentVert[] = new int[verts.size()];
                int independentVert2verts[] = new int[nIndependentVerts];
                {
                    int iIndependentVert = 0;
                    FORIDOWN (iVert, verts.size())
                    {
                        if (Arrays.indexOf(dependentVertIndices, iVert) == -1)
                        {
                            vert2independentVert[iVert] = iIndependentVert;
                            independentVert2verts[iIndependentVert] = iVert;
                            iIndependentVert++;
                        }
                        else
                            vert2independentVert[iVert] = -1;
                    }
                    assert(iIndependentVert == nIndependentVerts);
                }
                if (nonEventVerbose >= 1)
                {
                    PRINTVEC(vert2independentVert);
                    PRINTVEC(independentVert2verts);
                }


                int nSamples = nIndependentVerts+1;
                double sampleResultVerts[][][] = new double[nSamples][nDualVerts][2]; // SolveForDualPoint actually only needs 2, contrary to all the other comments
                {
                    double sampleHeights[][] = new double[nIndependentVerts+1][nIndependentVerts];
                    VecMath.identitymat(sampleHeights); // the unit basis vectors, and a row of zeros at the end

                    FORI (iSample, nSamples)
                    {
                        //
                        // Input sampleHeights[iSample]
                        // and get out sampleResultVerts[iSample]
                        //
                        FORI (iDualVert, nDualVerts)
                        {
                            int iVert0 = dualVert2verts[iDualVert][0];
                            int iVert1 = dualVert2verts[iDualVert][1];
                            int iVert2 = dualVert2verts[iDualVert][2];
                            int iIndependentVert0 = vert2independentVert[iVert0];
                            int iIndependentVert1 = vert2independentVert[iVert1];
                            int iIndependentVert2 = vert2independentVert[iVert2];
                            double h0 = (iIndependentVert0 == -1 ? 0. : sampleHeights[iSample][iIndependentVert0]);
                            double h1 = (iIndependentVert1 == -1 ? 0. : sampleHeights[iSample][iIndependentVert1]);
                            double h2 = (iIndependentVert2 == -1 ? 0. : sampleHeights[iSample][iIndependentVert2]);
                            Vertex v0 = (Vertex)verts.get(iVert0);
                            Vertex v1 = (Vertex)verts.get(iVert1);
                            Vertex v2 = (Vertex)verts.get(iVert2);
                            SolveForDualPoint(v0.Xnaive(),v0.Ynaive(),h0,
                                              v1.Xnaive(),v1.Ynaive(),h1,
                                              v2.Xnaive(),v2.Ynaive(),h2,
                                              sampleResultVerts[iSample][iDualVert], // dimension 2-- last coord is simply ignored
                                              false, // wrapAroundSphereFlagValue
                                              false, // centerSphereFlag
                                              0.); // wrapCurvatureValue
                        }
                    }
                    //PRINTMAT(sampleHeights);
                }

                double solvedHeights[];

                if (optimizingBarycentrics)
                {
                    // We want to maximize the minimum barycentric occurring
                    // anywhere in the result.
                    double sampleBarycentrics[][][] = new double[nSamples][nDualVerts][3];
                    FORI (iSample, nSamples)
                    {
                        FORI (iDualVert, nDualVerts)
                        {
                            int tri[] = dualVert2verts[iDualVert];
                            double wholeArea = twiceTriangleArea(((Vertex)verts.get(tri[0])).Xnaive(), ((Vertex)verts.get(tri[0])).Ynaive(),
                                                                 ((Vertex)verts.get(tri[1])).Xnaive(), ((Vertex)verts.get(tri[1])).Ynaive(),
                                                                 ((Vertex)verts.get(tri[2])).Xnaive(), ((Vertex)verts.get(tri[2])).Ynaive());
                            double dualVert[] = sampleResultVerts[iSample][iDualVert];
                            FORI (iVertOnTri, 3)
                            {
                                sampleBarycentrics[iSample][iDualVert][iVertOnTri] =
                                        twiceTriangleArea(dualVert[0], dualVert[1],
                                                          ((Vertex)verts.get(tri[(iVertOnTri+1)%3])).Xnaive(),
                                                          ((Vertex)verts.get(tri[(iVertOnTri+1)%3])).Ynaive(),
                                                          ((Vertex)verts.get(tri[(iVertOnTri+2)%3])).Xnaive(),
                                                          ((Vertex)verts.get(tri[(iVertOnTri+2)%3])).Ynaive())
                                      / wholeArea;
                            }
                        }
                    }
                    double sampleResultVectors[][] = (double[][])Arrays.flatten(sampleBarycentrics, 1, 2);
                    double desiredResultVector[] = VecMath.fillvec(sampleResultVectors[0].length,
                                        optimizationType==OPTIMIZE_BARYCENTRICS_MAX_MIN ? 0. : 1./3.);

                    //
                    // Find C and d
                    // such that x -> C x - d
                    // maps heights to barycentrics.
                    //

                    //
                    // Column i of C is the result from the i'th basis sample,
                    // minus the result from the 0 vector.
                    //
                    double C[][] = new double[sampleResultVectors.length-1][sampleResultVectors[0].length]; // start transposed...
                    FORI (iSample, sampleResultVectors.length-1)
                        VecMath.vmv(C[iSample],
                                    sampleResultVectors[iSample],
                                    sampleResultVectors[sampleResultVectors.length-1]);
                    C = VecMath.transpose(C);

                    //
                    // d is the desired result minus the result from the zero vector.
                    //
                    double d[] = VecMath.vmv(desiredResultVector,
                                             sampleResultVectors[sampleResultVectors.length-1]);

                    // XXX could get clean up the dependent/intependent lookup tables if we want by expressing the independent vertex's constraints here...
                    double A[][] = {}; // no equality constraints
                    double b[] = {}; // no equality constraints

                    LinearProgramming.debugLevel = 0;

                    if (optimizationType == OPTIMIZE_BARYCENTRICS_LEAST_SQUARES)
                    {
                        if (nonEventVerbose >= 1)
                        {
                            System.out.print("    Solving barycentrics least squares from all 1/3's...");
                            System.out.flush();
                        }
                        solvedHeights = VecMath.invmxv(C,d);
                        if (nonEventVerbose >= 1)
                            System.out.println("    done.");
                    }
                    else if (optimizationType == OPTIMIZE_BARYCENTRICS_INFINITY_NORM)
                    {
                        solvedHeights = new double[sampleResultVectors.length-1];
                        if (nonEventVerbose >= 1)
                        {
                            System.out.print("    Solving barycentrics infinity norm from all 1/3's...");
                            System.out.flush();
                        }
                        int result = LinearProgramming.LInfinitySolve(solvedHeights, C,d);
                        if (nonEventVerbose >= 1)
                            System.out.println("    done.");
                        if (result != 0)
                            System.out.println("WARNING: LPSolve returned "+result);
                    }
                    else if (optimizationType == OPTIMIZE_BARYCENTRICS_MAX_MIN)
                    {
                        solvedHeights = new double[sampleResultVectors.length-1];
                        if (nonEventVerbose >= 1)
                        {
                            System.out.print("    Solving barycentrics maximizing minimal element...");
                            System.out.flush();
                        }
                        int result = LinearProgramming.maximizeMinimum(solvedHeights,
                                                                       A, b,
                                                                       C, d);
                        if (nonEventVerbose >= 1)
                            System.out.println("    done.");
                        if (false)
                        {
                            PRINTMAT(A);
                            PRINTVEC(b);
                            PRINTMAT(C);
                            PRINTVEC(d);
                            PRINT(result);
                            PRINTVEC(solvedHeights);
                        }
                        if (result != 0)
                            System.out.println("WARNING: LPSolve returned "+result);
                    }
                    else
                    {
                        assert(false);
                    }
                }
                else // optimize lengths
                {
                    double sampleResultVectors[][];
                    double desiredResultVector[];

                    {
                        double sampleResultLengths[][] = new double[nSamples][nDualEdges];
                        FORI (iSample, nSamples)
                        {
                            //
                            // Calculate sampleResultLengths[iSample]
                            // from sampleResultVerts[iSample]
                            //
                            FORI (iDualEdge, nDualEdges)
                            {
                                sampleResultLengths[iSample][iDualEdge] =
                                    VecMath.dist(2,
                                                 sampleResultVerts[iSample][dualEdge2dualVerts[iDualEdge][0]],
                                                 sampleResultVerts[iSample][dualEdge2dualVerts[iDualEdge][1]]);
                                // Need to figure out the sign.
                                // If dual edge length is positive,
                                // it will point from the original edge's left face
                                // to the original edge's right face.
                                // So the dual edge dir cross the original edge dir
                                // should be > 0.
                                double dualEdgeDir[] = VecMath.vmv(2,
                                                                  sampleResultVerts[iSample][dualEdge2dualVerts[iDualEdge][1]],
                                                                   sampleResultVerts[iSample][dualEdge2dualVerts[iDualEdge][0]]);
                                double originalEdgeDir[] = VecMath.vmv(
                                    new double[] {((Edge)edges.get(dualEdge2edge[iDualEdge])).finalVertex().Xnaive(),
                                                  ((Edge)edges.get(dualEdge2edge[iDualEdge])).finalVertex().Ynaive()},
                                    new double[] {((Edge)edges.get(dualEdge2edge[iDualEdge])).initialVertex().Xnaive(),
                                                  ((Edge)edges.get(dualEdge2edge[iDualEdge])).initialVertex().Ynaive()}
                                );
                                if (VecMath.vxv2(dualEdgeDir, originalEdgeDir) < 0)
                                {
                                    sampleResultLengths[iSample][iDualEdge] *= -1;
                                }
                            }
                        }
                        sampleResultVectors = sampleResultLengths;
                    }
                    desiredResultVector = VecMath.fillvec(nDualEdges, desiredDualEdgeLength);

                    // the following is general, could optimize something else if desired
                    {

                        //
                        // Row i of A is the result from the i'th basis sample,
                        // minus the result from the 0 vector.
                        //
                        double A[][] = new double[sampleResultVectors.length-1][sampleResultVectors[0].length];
                        FORI (iSample, sampleResultVectors.length-1)
                            VecMath.vmv(A[iSample],
                                        sampleResultVectors[iSample],
                                        sampleResultVectors[sampleResultVectors.length-1]);
                        //
                        // b is the desired result
                        // minus the result from the 0 vector.
                        //
                        double b[] = VecMath.vmv(desiredResultVector,
                                                 sampleResultVectors[sampleResultVectors.length-1]);

                        //PRINTMAT(A);
                        //PRINTVEC(b);

                        double leastSquaresSolution[];
                        if (optimizationType == OPTIMIZE_LENGTHS_LEAST_SQUARES)
                        {
                            if (nonEventVerbose >= 1)
                            {
                                System.out.print("    Solving for lengths least squares from all "+desiredDualEdgeLength+" ...");
                                System.out.flush();
                            }
                            leastSquaresSolution = VecMath.vxinvm(b, A);
                            if (nonEventVerbose >= 1)
                                System.out.println("    done.");
                        }
                        else if (optimizationType == OPTIMIZE_LENGTHS_INFINITY_NORM)
                        {
                            leastSquaresSolution = new double[sampleResultVectors.length-1];
                            if (nonEventVerbose >= 1)
                            {
                                assert(desiredDualEdgeLength == .25);
                                System.out.print("    Solving lengths infinity norm from all .25's...");
                                System.out.flush();
                            }
                            int result = LinearProgramming.LInfinitySolve(leastSquaresSolution, VecMath.transpose(A),b);
                            if (nonEventVerbose >= 1)
                                System.out.println("    done.");
                            if (result != 0)
                                System.out.println("WARNING: LPSolve returned "+result);
                        }
                        else if (optimizationType == OPTIMIZE_LENGTHS_MAX_MIN)
                        {
                            double[] result0 = sampleResultVectors[sampleResultVectors.length-1];

                            leastSquaresSolution = new double[sampleResultVectors.length-1];
                            if (nonEventVerbose >= 1)
                            {
                                System.out.print("    Solving lengths maximizing minimum with sum 1...");
                                System.out.flush();
                            }

                            // Set desired sum to be the sum of the primal edge lengths
                            // (to get something roughly commensurate, that scales with the original)
                            double desiredSum = 0.;
                            FORI (iEdge, edges.size())
                            {
                                Edge edge = (Edge)edges.get(iEdge);
                                if (edge.myIndex() > edge.opposite().myIndex())
                                    continue; // only use canonical one of the two
                                Vertex v0 = edge.initialVertex();
                                Vertex v1 = edge.finalVertex();
                                desiredSum += Math.sqrt(SQR(v1.Xnaive()-v0.Xnaive()) + SQR(v1.Ynaive()-v0.Ynaive()));
                            }
                            if (nonEventVerbose >= 1)
                                PRINT(desiredSum);

                            if (true)
                            {
                                // Empirically, it's a bit bigger than I want,
                                // especially if there are a lot of infinite edges in the dual
                                // (i.e. much fewer finite edges in the dual than in primal).
                                // So scale down desiredSum by nDualEdges/nEdges.
                                // (nEdges is actually half of edges.size())
                                //PRINT(nDualEdges);
                                //PRINT(edges.size());
                                desiredSum *= ((double)nDualEdges/
                                               (double)(edges.size()/2));
                                // and, final hack... seems to work better scaled by 1/2 anyway
                                desiredSum /= 2.;
                            }




                            // Want solution column vector x
                            // that satisfies [1,1,...,1] (transpose(A) x + result0) = desiredSum
                            //           i.e. [1,1,...,1] (transpose(A) x) + sum(result0) = desiredSum
                            //           i.e. [1,1,...,1] (transpose(A) x) = desiredSum - sum(result0)
                            // and maximizes the minimum element of transpose(A) x + result0.

                            double AA[][] = {VecMath.mxv(A, VecMath.fillvec(nDualEdges, 1.))};
                            double bb[] = {desiredSum - VecMath.sum(result0)};
                            double CC[][] = VecMath.transpose(A);
                            double dd[] = VecMath.sxv(-1.,result0);
                            int result =
                                         leastSquaresSolution.length == 0 ? 0 : // XXX TODO: FIX maximizeMiniumum so it returns 0 instead of -1 in this case!
                                         LinearProgramming.maximizeMinimum(leastSquaresSolution,
                                                                           AA, bb, // AA x = bb
                                                                           CC, dd); // maximize min of CC x - dd, i.e. A^T x + result0
                            if (nonEventVerbose >= 1)
                                System.out.println("    done.");
                            if (result != 0)
                                System.out.println("WARNING: maximizeMinumum returned "+result);

                            if (nonEventVerbose >= 1)
                            {
                                PRINTMAT(AA);
                                PRINTVEC(bb);
                                PRINTVEC(VecMath.vmv(VecMath.mxv(AA, leastSquaresSolution), bb));
                                PRINTVEC(leastSquaresSolution);
                                PRINTVEC(VecMath.vxm(leastSquaresSolution, A));
                                PRINTVEC(VecMath.vpv(VecMath.vxm(leastSquaresSolution,A), result0));
                                PRINT(VecMath.sum(VecMath.vpv(VecMath.vxm(leastSquaresSolution,A), result0)));
                            }

                        }
                        else if (optimizationType == OPTIMIZE_LENGTHS_SUM)
                        {
                            if (nonEventVerbose >= 1)
                            {
                                assert(desiredDualEdgeLength == .25);
                                System.out.print("    Solving lengths minimizing sum with each length >= .25...");
                                System.out.flush();
                            }
                            // XXX not implemented yet
                            assert(false);
                        }
                        else
                            assert(false);

                        //PRINTVEC(leastSquaresSolution);
                        double gotLengths[] = VecMath.vxm(leastSquaresSolution, A);
                        //PRINTVEC(gotLengths);

                        boolean checkLeastSquaresSolutionFlag = false; // I'm convinced it works
                        if (checkLeastSquaresSolutionFlag)
                        {
                            System.out.print("    Checking");
                            System.out.flush();

                            int nTests = 100;
                            FORI (iTest, nTests)
                            {
                                System.out.print(".");

                                //
                                // Perturb each element of the solution
                                // by a random amount
                                //
                                double foo[] = VecMath.copyvec(leastSquaresSolution);
                                double dir[] = VecMath.random(leastSquaresSolution.length);
                                VecMath.normalize(dir);
                                double fudges[] = {.01, -.01};
                                FORI (iFudge, fudges.length)
                                {
                                    VecMath.vpsxv(foo, leastSquaresSolution, fudges[iFudge], dir);
                                    double bar[] = VecMath.vxm(foo, A);
                                    //PRINT(VecMath.dist(bar, b));
                                    if (foo.length > 0)
                                        assert(VecMath.dist(gotLengths, b) < VecMath.dist(bar, b));
                                }
                            }
                            System.out.println("    done.");
                        }
                        solvedHeights = leastSquaresSolution;
                    }
                } // optimize lengths

                assert(solvedHeights.length == independentVert2verts.length);
                double optimalVertexHeights[] = new double[verts.size()];
                FORI (iIndex, independentVert2verts.length)
                {
                    optimalVertexHeights[independentVert2verts[iIndex]] = solvedHeights[iIndex];
                }
                FORI (iDependentVert, dependentVertIndices.length)
                    optimalVertexHeights[dependentVertIndices[iDependentVert]] = 0.;


                if (true)
                {
                    // Now we want to adjust the solution
                    // so that the dual verts are shifted in the plane
                    // so that the average of the dual verts
                    // is equal to the average of the original verts.
                    // (This is somewhat arbitrary,
                    // but at least it makes the dual translate with the primal)
                    double[] avgPrimal = new double[2]; // zero initially
                    {
                        FORI (iVert, verts.size())
                        {
                            Vertex vert = (Vertex)verts.get(iVert);
                            avgPrimal[0] += vert.Xnaive();
                            avgPrimal[1] += vert.Ynaive();
                        }
                        VecMath.vxs(avgPrimal, avgPrimal, 1./verts.size());
                    }
                    double[] avgDual = new double[2]; // zero initially
                    {
                        double scratchDualVert[] = new double[3];
                        FORI (iDualVert, nDualVerts)
                        {
                            int iVert0 = dualVert2verts[iDualVert][0];
                            int iVert1 = dualVert2verts[iDualVert][1];
                            int iVert2 = dualVert2verts[iDualVert][2];
                            Vertex v0 = (Vertex)verts.get(iVert0);
                            Vertex v1 = (Vertex)verts.get(iVert1);
                            Vertex v2 = (Vertex)verts.get(iVert2);
                            double h0 = optimalVertexHeights[iVert0];
                            double h1 = optimalVertexHeights[iVert1];
                            double h2 = optimalVertexHeights[iVert2];
                            SolveForDualPoint(v0.Xnaive(),v0.Ynaive(),h0,
                                              v1.Xnaive(),v1.Ynaive(),h1,
                                              v2.Xnaive(),v2.Ynaive(),h2,
                                              scratchDualVert,
                                              false, // wrapAroundSphereFlag
                                              false, // centerSphereFlag
                                              0.); // wrapSphereCurvature
                            VecMath.vpv(2, avgDual, avgDual, scratchDualVert); // only 2 of 3
                        }
                        VecMath.vxs(avgDual, avgDual, 1./nDualVerts);
                    }
                    double[] desiredDelta = VecMath.vmv(avgPrimal, avgDual);
                    //PRINTVEC(avgPrimal);
                    //PRINTVEC(avgDual);
                    //PRINTVEC(desiredDelta);
                    FORI (iVert, optimalVertexHeights.length)
                    {
                        Vertex vert = (Vertex)verts.get(iVert);
                        optimalVertexHeights[iVert] -= vert.Xnaive() * desiredDelta[0]
                                                     + vert.Ynaive() * desiredDelta[1];
                    }
                }


                if (nonEventVerbose >= 1)
                    System.out.println("out findOptimalVertexHeights");

                return optimalVertexHeights;
            } // findOptimalVertexHeights

            public void findAndApplyOptimalVertexHeights(int optimizationType)
            {
                double optimalVertexHeights[] = findOptimalVertexHeights(
                                optimizationType);
                FORIDOWN (iVert, verts.size())
                {
                    //PRINTSUB(optimalVertexHeights,iVert);
                    ((Mesh.Vertex)verts.get(iVert)).setHnaive(optimalVertexHeights[iVert]);
                }
            } // findAndApplyOptimalVertexHeights

            private void flipLeftRight()
            {
                FORIDOWN (iVert, verts.size())
                {
                    Mesh.Vertex vert = (Mesh.Vertex)verts.get(iVert);
                    vert.setXYZW(-vert.X(),
                                 vert.Y(),
                                 vert.Z(),
                                 vert.W());
                }
                // XXX rest is dup code
                Mesh.Vertex finalInitials[] = new Mesh.Vertex[edges.size()];
                FORIDOWN(iEdge, edges.size())
                {
                    Mesh.Edge edge = (Mesh.Edge)edges.get(iEdge);
                    finalInitials[iEdge] = edge.finalVertex();
                }
                FORIDOWN(iEdge, edges.size())
                {
                    Mesh.Edge edge = (Mesh.Edge)edges.get(iEdge);
                    edge._initialVertex.arity--;
                    edge._initialVertex = null;
                }
                FORIDOWN(iEdge, edges.size())
                {
                    Mesh.Edge edge = (Mesh.Edge)edges.get(iEdge);
                    Mesh.Edge tempEdge;
                    SWAP(edge._next, edge._prev, tempEdge);
                    assert(edge._initialVertex == null);
                    edge._initialVertex = finalInitials[iEdge];
                    edge._initialVertex.arity++;
                }
                sanityCheck();
            } // flipLeftRight
            private void flipUpDown()
            {
                FORIDOWN (iVert, verts.size())
                {
                    Mesh.Vertex vert = (Mesh.Vertex)verts.get(iVert);
                    vert.setXYZW(vert.X(),
                                 -vert.Y(),
                                 vert.Z(),
                                 vert.W());
                }
                // XXX rest is dup code
                Mesh.Vertex finalInitials[] = new Mesh.Vertex[edges.size()];
                FORIDOWN(iEdge, edges.size())
                {
                    Mesh.Edge edge = (Mesh.Edge)edges.get(iEdge);
                    finalInitials[iEdge] = edge.finalVertex();
                }
                FORIDOWN(iEdge, edges.size())
                {
                    Mesh.Edge edge = (Mesh.Edge)edges.get(iEdge);
                    edge._initialVertex.arity--;
                    edge._initialVertex = null;
                }
                FORIDOWN(iEdge, edges.size())
                {
                    Mesh.Edge edge = (Mesh.Edge)edges.get(iEdge);
                    Mesh.Edge tempEdge;
                    SWAP(edge._next, edge._prev, tempEdge);
                    assert(edge._initialVertex == null);
                    edge._initialVertex = finalInitials[iEdge];
                    edge._initialVertex.arity++;
                }
                sanityCheck();
            } // flipUpDown
            private void flipUpperLeftLowerRight()
            {
                FORIDOWN (iVert, verts.size())
                {
                    Mesh.Vertex vert = (Mesh.Vertex)verts.get(iVert);
                    vert.setXYZW(vert.Y(), // switch X and Y
                                 vert.X(),
                                 vert.Z(),
                                 vert.W());
                }
                // XXX rest is dup code
                Mesh.Vertex finalInitials[] = new Mesh.Vertex[edges.size()];
                FORIDOWN(iEdge, edges.size())
                {
                    Mesh.Edge edge = (Mesh.Edge)edges.get(iEdge);
                    finalInitials[iEdge] = edge.finalVertex();
                }
                FORIDOWN(iEdge, edges.size())
                {
                    Mesh.Edge edge = (Mesh.Edge)edges.get(iEdge);
                    edge._initialVertex.arity--;
                    edge._initialVertex = null;
                }
                FORIDOWN(iEdge, edges.size())
                {
                    Mesh.Edge edge = (Mesh.Edge)edges.get(iEdge);
                    Mesh.Edge tempEdge;
                    SWAP(edge._next, edge._prev, tempEdge);
                    assert(edge._initialVertex == null);
                    edge._initialVertex = finalInitials[iEdge];
                    edge._initialVertex.arity++;
                }
                sanityCheck();
            } // flipUpperLeftLowerRight
            private void flipLowerLeftUpperRight()
            {
                FORIDOWN (iVert, verts.size())
                {
                    Mesh.Vertex vert = (Mesh.Vertex)verts.get(iVert);
                    vert.setXYZW(-vert.Y(), // switch X and Y and negate them
                                 -vert.X(),
                                 vert.Z(),
                                 vert.W());
                }
                // XXX rest is dup code
                Mesh.Vertex finalInitials[] = new Mesh.Vertex[edges.size()];
                FORIDOWN(iEdge, edges.size())
                {
                    Mesh.Edge edge = (Mesh.Edge)edges.get(iEdge);
                    finalInitials[iEdge] = edge.finalVertex();
                }
                FORIDOWN(iEdge, edges.size())
                {
                    Mesh.Edge edge = (Mesh.Edge)edges.get(iEdge);
                    edge._initialVertex.arity--;
                    edge._initialVertex = null;
                }
                FORIDOWN(iEdge, edges.size())
                {
                    Mesh.Edge edge = (Mesh.Edge)edges.get(iEdge);
                    Mesh.Edge tempEdge;
                    SWAP(edge._next, edge._prev, tempEdge);
                    assert(edge._initialVertex == null);
                    edge._initialVertex = finalInitials[iEdge];
                    edge._initialVertex.arity++;
                }
                sanityCheck();
            } // flipLowerLeftUpperRight

            private Mesh()
            {
            }

            private Mesh(double vertPositions[][],
                         int faceIndices[][])
            {
                {
                    // Sanity check face indices,
                    // since it's really hard to debug later
                    // if they are insane...
                    java.util.HashSet boundary = new java.util.HashSet();
                    FORI (iFace, faceIndices.length)
                        FORI (iVertThisFace, faceIndices[iFace].length)
                        {
                            int v0 = faceIndices[iFace][iVertThisFace];
                            int v1 = faceIndices[iFace][(iVertThisFace+1)%faceIndices[iFace].length];
                            assert(INRANGE(0 <=, v0, < vertPositions.length));
                            assert(INRANGE(0 <=, v1, < vertPositions.length));
                            String v0_v1 = ""+v0+"_"+v1;
                            String v1_v0 = ""+v1+"_"+v0;
                            if (boundary.contains(v0_v1))
                            {
                                System.out.println("ERROR in Mesh ctor: "+v0_v1+" appears twice");
                                assert(false);
                            }
                            if (!boundary.remove(v1_v0))
                                boundary.add(v0_v1);
                        }
                    if (!boundary.isEmpty())
                    {
                        System.out.println("ERROR in Mesh ctor: unmatched edge(s):");
                        java.util.Iterator iter = boundary.iterator();
                        while (iter.hasNext())
                        {
                            String v0_v1 = (String)iter.next();
                            System.out.println("    "+v0_v1);
                        }
                        assert(false);
                    }
                }

                FORI (i, vertPositions.length)
                {
                    // Vertex ctor adds itself to verts...
                    double vertPosition[] = vertPositions[i];
                    if (vertPosition.length == 2)
                        new Vertex(vertPosition[0],  // x
                                   vertPosition[1],  // y
                                   0); // h
                    else if (vertPosition.length == 3)
                        new Vertex(vertPosition[0],  // x
                                   vertPosition[1],  // y
                                   vertPosition[2]); // h
                    else if (vertPosition.length == 4)
                        new Vertex(vertPosition[0],  // X
                                   vertPosition[1],  // Y
                                   vertPosition[2],  // Z
                                   vertPosition[3]); // W
                    else
                        assert(false);
                }
                java.util.HashMap vertIndsToEdge = new java.util.HashMap();
                FORI (i, faceIndices.length)
                FORI (j, faceIndices[i].length)
                {
                    int v0 = faceIndices[i][j];
                    int v1 = faceIndices[i][(j+1)%faceIndices[i].length];
                    assert(INRANGE(0 <=, v0, < vertPositions.length));
                    assert(INRANGE(0 <=, v1, < vertPositions.length));
                    String v0_v1 = ""+v0+"_"+v1;
                    String v1_v0 = ""+v1+"_"+v0;
                    if (vertIndsToEdge.get(v0_v1) == null)
                    {
                        Edge edge = new Edge(true); // adds itself, and opposite, to verts
                        vertIndsToEdge.put(v0_v1, edge);
                        vertIndsToEdge.put(v1_v0, edge.opposite());
                        edge.setInitialVertex((Vertex)verts.get(v0));
                        edge.opposite().setInitialVertex((Vertex)verts.get(v1));
                    }
                }
                FORI (i, faceIndices.length)
                FORI (j, faceIndices[i].length)
                {
                    int v0 = faceIndices[i][j];
                    int v1 = faceIndices[i][(j+1)%faceIndices[i].length];
                    int v2 = faceIndices[i][(j+2)%faceIndices[i].length];
                    String v0_v1 = ""+v0+"_"+v1;
                    String v1_v2 = ""+v1+"_"+v2;
                    Edge e01 = (Edge)vertIndsToEdge.get(v0_v1);
                    Edge e12 = (Edge)vertIndsToEdge.get(v1_v2);
                    e01.setNext(e12, true);
                }
                sanityCheck();
            } // Mesh from vertex positions and face indices

            // copy ctor
            private Mesh(Mesh original)
            {
                int nVerts = original.verts.size();
                FORI (iVert, nVerts)
                {
                    Vertex originalVert = (Vertex)original.getVert(iVert);
                    Vertex newVert = new Vertex(originalVert.X(),
                                                originalVert.Y(),
                                                originalVert.Z(),
                                                originalVert.W()); // adds itself to verts
                    newVert.weight = originalVert.weight;
                    if (originalVert.momentAndArea != null)
                        newVert.momentAndArea = VecMath.copyvec(originalVert.momentAndArea);
                }
                int nEdges = original.edges.size();
                FORI (iEdge, nEdges)
                    new Edge(false); // adds itself to edges
                assert(verts.size() == nVerts);
                assert(edges.size() == nEdges);

                FORI (iEdge, nEdges)
                {
                    Edge edge = (Edge)edges.get(iEdge);
                    Edge originalEdge = (Edge)original.getEdge(iEdge);
                    assert(edge._initialVertex == null);
                    edge._initialVertex = (Vertex)verts.get(originalEdge._initialVertex._myIndex);
                    edge._initialVertex.arity++;
                    edge._opposite = (Edge)edges.get(originalEdge._opposite._myIndex);
                    edge._prev = (Edge)edges.get(originalEdge._prev._myIndex);
                    edge._next = (Edge)edges.get(originalEdge._next._myIndex);
                }
            } // Mesh copy constructor

            public ArrayList/*<Vertex>*/ verts = new ArrayList();
            public ArrayList/*<Edge>*/ edges = new ArrayList();

            // Convenience functions to get a particular vertex or edge without casting,
            // since this is done a kajillion times
            public final Vertex getVert(int iVert) { return (Vertex)verts.get(iVert); }
            public final Edge   getEdge(int iEdge) { return (Edge)edges.get(iEdge); }


            // Accessors for construction of inner class objects
            // XXX not sure this is the right way to do it
            Edge newEdge(boolean andBack)
            {
                return new Edge(andBack);
            }
            Vertex newVertex(double x, double y, double h)
            {
                return new Vertex(x, y, h);
            }
            Vertex newVertex(double X, double Y, double Z, double W)
            {
                return new Vertex(X, Y, Z, W);
            }
            Vertex newVertex(double X, double Y, double Zignored, double W, double H)
            {
                return new Vertex(X, Y, Zignored, W, H);
            }


        } // class Mesh

        //
        // Assumes mesh is topologically a polyhedron,
        // The dual vertex is well defined iff the corresponding primal face
        // is a non-degenerate triangle.
        // Otherwise the primal face will be triangulated arbitrarily
        // and the dual vertex will be set to the weighted average
        // of the vertices computed from each triangle.
        // Indexing of dual edges is same as indexing of original edges.
        // The dual edge points from right to left,
        // with respect to the forward direction of the primal edge.
        //
        public static Mesh makeDualMesh(Mesh primal,
                                        boolean includeNonArity3,
                                        boolean includeInsideOut,  // always true these days
                                        boolean wrapAroundSphereFlagValue,
                                        boolean centerSphereFlagValue,
                                        double wrapSphereCurvatureValue)
        {
            //System.out.println("    in makeDualMesh(wrapAroundSphereFlagValue="+wrapAroundSphereFlagValue+")");
            Mesh dual = new Mesh();
            int nEdges = primal.edges.size();
            FORI (iEdge, nEdges)
                dual.newEdge(false); // adds itself to dual.edges
            assert(dual.edges.size() == nEdges);
            FORI (iEdge, nEdges)
            {
                Mesh.Edge dualEdge = dual.getEdge(iEdge);
                Mesh.Edge primalEdge = primal.getEdge(iEdge);
                dualEdge._opposite = dual.getEdge(primalEdge._opposite._myIndex);
                if (false)
                {
                    // CCW faces in primal
                    // produce CCW faces in dual.
                    // If we do this, then applying makeDualMesh twice
                    // will reverse all the edges,
                    // I think.
                    // (assumimg calcInsideOutDualVertsFlag is true)
                    dualEdge._next = dual.getEdge(primalEdge._prev._opposite._myIndex);
                    dualEdge._prev = dual.getEdge(primalEdge._opposite._next._myIndex);
                }
                else
                {
                    // CCW faces in primal
                    // produce CW faces in dual.
                    // If we do this, then makeDualMesh(makeDualMesh(mesh))
                    // should return something identical to the original,
                    // I think.
                    // (assumimg calcInsideOutDualVertsFlag is true)
                    // XXX Odd, this seems to behave better all around (I expected rays to go in wrong direction,
                    // but it works better than the other way... should think about why)
                    dualEdge._next = dual.getEdge(primalEdge._next._opposite._myIndex);
                    dualEdge._prev = dual.getEdge(primalEdge._opposite._prev._myIndex);
                }
            }

            //
            // Find all the dual vertices.
            // These correspond to primal faces.
            // Include inside-out ones for starters,
            // to avoid lots of redundant calculation.  We'll remove them afterwards.
            //
            double vertCoords3d[][] = null;
            if (wrapAroundSphereFlagValue)
            {
                int nVerts = primal.verts.size();
                vertCoords3d = new double[nVerts][3];
                FORI (iVert, nVerts)
                {
                    double coord[] = vertCoords3d[iVert];
                    Mesh.Vertex v = primal.getVert(iVert);
                    coord[0] = v.x();
                    coord[1] = v.y();
                    coord[2] = v.z();

                }
            }
            FORI (iEdge, nEdges)
            {
                Mesh.Edge dualEdge0 = dual.getEdge(iEdge);
                if (dualEdge0._opposite._initialVertex != null)
                    continue; // did this one already

                Mesh.Vertex dualVert; // TODO: merge this back when ported to new way

                if (wrapAroundSphereFlagValue)
                {
                    // Triangulate,
                    // using primalEdge0's initial vertex as the hub.

                    double totalWeightedNormal[] = new double[3]; // zero initially

                    {
                        // TODO: move these more outward
                        double edgeVec1[] = new double[3]; // scratch for loop
                        double edgeVec2[] = new double[3]; // scratch for loop
                        double edgeCenter[] = new double[3]; // scratch for loop

                        Mesh.Edge primalEdge0 = primal.getEdge(iEdge);
                        Mesh.Vertex v0 = primalEdge0._initialVertex;
                        double v0coords[] = {v0.x(), v0.y(), v0.z()};
                        for (Mesh.Edge primalEdge = primalEdge0.next();
                             primalEdge.finalVertex() != v0;
                             primalEdge = primalEdge.next())
                        {
                            double v1coords[] = vertCoords3d[primalEdge.initialVertex().myIndex()];
                            double v2coords[] = vertCoords3d[primalEdge.finalVertex().myIndex()];

                            VecMath.vmv(edgeVec1, v1coords, v0coords);
                            VecMath.vmv(edgeVec2, v2coords, v0coords);

                            VecMath.vpvxv3(totalWeightedNormal,
                                           totalWeightedNormal,
                                           edgeVec1,
                                           edgeVec2);
                        }
                    }

                    // want triangulation-independent representative point--
                    // use the perimeter center.
                    double perimeterMomentAndLength[] = new double[4]; // zero initially
                    {
                        Mesh.Edge primalEdge0 = primal.getEdge(iEdge);
                        Mesh.Edge primalEdge = primalEdge0;
                        do {
                            double v1coords[] = vertCoords3d[primalEdge.initialVertex().myIndex()];
                            double v2coords[] = vertCoords3d[primalEdge.finalVertex().myIndex()];
                            double edgeLength = VecMath.dist(v1coords, v2coords);
                            VecMath.vpsxvpsxv(3, perimeterMomentAndLength,
                                                 perimeterMomentAndLength, .5*edgeLength, v1coords,
                                                                           .5*edgeLength, v2coords);
                            perimeterMomentAndLength[3] += edgeLength;
                        } while ((primalEdge=primalEdge.next()) != primalEdge0);
                    }

                    // working with unit normal simplifies things, though I'm not sure it's really necessary
                    double unitNormal[] = VecMath.normalize(totalWeightedNormal);

                    // take dot product of normal with perimeter center
                    double dotProd = VecMath.dot(3, perimeterMomentAndLength, unitNormal) / perimeterMomentAndLength[3];
                    if (!centerSphereFlagValue)
                        dotProd += unitNormal[2]/wrapSphereCurvatureValue; // TODO: can we get rid of the divide and make it a multiply somewhere else?

                    // want length of answer to be r^2 / dotProd.
                    // so, could just return unitNormalOut scaled by r^2/dotProd,
                    // but now we can be clever and stick the denominator in the W part,
                    // so that the answer is correct and robust even if dotProd is 0 or close to it.
                    // We also put wrapSphereCurvature in there too-- not sure whether this matters,
                    // but it makes the XYZ part be the unit normal (if centerSphereFlag), which is nice maybe.
                    double X = unitNormal[0];
                    double Y = unitNormal[1];
                    double Z = unitNormal[2];
                    double W = dotProd * SQR(wrapSphereCurvatureValue);
                    if (!centerSphereFlagValue)
                        Z -= dotProd*wrapSphereCurvatureValue; // wrapSphereRadius*W but more robust when curvature is close to 0

                    double weight = dotProd; // times SQR(wrapSphereCurvature)? or not?

                    dualVert = dual.newVertex(X,Y,Z,W);
                    dualVert.weight = weight;
                    dualVert.momentAndArea = new double[] {X,Y,Z,W}; // seems redundant at this point, at least for sphere... maybe try to get rid
                }
                else // paraboloid
                {
                    //
                    // Triangulate,
                    // using primalEdge0's initial vertex as the hub.
                    // The final dual vertex will be the triangle-area-weighted average
                    // of the circumcenters of the triangles.
                    // (the answer is the same regardless of triangulation...
                    // at least for the x,y part.  not sure what this does to the h part.)
                    // XXX TODO: don't we already do this in some version of SolveForDualPoint or SolveForDualMomentAndArea or something?
                    //
                    double totalMomentAndArea[] = new double[4]; // zero initially

                    double triMomentAndArea[] = new double[4]; // scratch for loop
                    Mesh.Edge primalEdge0 = primal.getEdge(iEdge);
                    Mesh.Vertex v0 = primalEdge0._initialVertex;
                    for (Mesh.Edge primalEdge = primalEdge0.next();
                         primalEdge.finalVertex() != v0;
                         primalEdge = primalEdge.next())
                    {
                        Mesh.Vertex v1 = primalEdge.initialVertex();
                        Mesh.Vertex v2 = primalEdge.finalVertex();

                        // We intentionally use 3d primal verts
                        // rather than homo coords--
                        // this is because the homo coords may have come from
                        // unwrapping around sphere,
                        // in which case the interpretation of the w coord isn't really
                        // relevant to us here.
                        SolveForDualMomentAndArea(v0.x(), v0.y(), v0.h(),
                                                  v1.x(), v1.y(), v1.h(),
                                                  v2.x(), v2.y(), v2.h(),
                                                  triMomentAndArea,
                                                  wrapAroundSphereFlagValue, // TODO: doesn't need to take this any more, we're paraboloid at this point.  oh fooey, still needed for other call to SolveForDualMomentAndArea, in optimization stuff
                                                  centerSphereFlagValue,
                                                  wrapSphereCurvatureValue); // TODO: doesn't need to take this any more, we're paraboloid at this point.  oh fooey, still needed for other call to SolveForDualMomentAndArea, in optimization stuff
                        accumulateMomentAndArea(totalMomentAndArea, triMomentAndArea);
                    }

                    {
                        double xa = totalMomentAndArea[0];
                        double ya = totalMomentAndArea[1];
                        double haa = totalMomentAndArea[2];
                        double a = totalMomentAndArea[3];
                        if (false)
                        {
                            // this produces normalized coords, with w=1.
                            dualVert = dual.newVertex(xa/a,
                                                      ya/a,
                                                      haa/(a*a));
                            //PRINT(dualVert);
                        }
                        if (true)
                        {
                            // this keens it homogeneous, with w = twice tri area
                            dualVert = dual.newVertex(xa,
                                                      ya,
                                                      0., // ignored
                                                      a,
                                                      haa);
                            //PRINT(dualVert);
                        }
                    }

                    double twiceTotalArea = totalMomentAndArea[3]; // TODO: fix up
                    dualVert.weight = .5 * twiceTotalArea;
                    dualVert.momentAndArea = totalMomentAndArea;

                    // TODO REGARDING NEGATIVE WEIGHTS: don't do this, I don't think. at this point I think maybe i should be making all W's non-negative, retaining inside-outedness in weight?  not sure
                    // haphazard fixup
                    if ((dualVert.weight < 0.) != (dualVert.W() < 0.))
                    {
                        assert(false); // doesn't happen any more... should maybe be making W positive instead? hmm actually I don't think so, maybe it's all good now?  not sure
                        dualVert.setXYZW(-dualVert.X(),
                                         -dualVert.Y(),
                                         -dualVert.Z(),
                                         -dualVert.W());
                    }

                }

                // Set dualVert to be the *final* vertex (i.e. initial vertex of opposite)
                // of each dual edge ending at it.
                for (Mesh.Edge dualEdge = dualEdge0;
                     dualEdge._opposite._initialVertex == null;
                     dualEdge = dualEdge._next._opposite)
                {
                    assert(dualEdge._opposite._initialVertex == null);
                    dualEdge._opposite._initialVertex = dualVert;
                    dualEdge._opposite._initialVertex.arity++;
                }
            }

            // Delete all verts that don't satisfy the criteria.
            // Any edges beginning or ending at such verts
            // will end up with null as their initial or final vertex instead.
            FORI (iEdge, nEdges)
            {
                Mesh.Edge dualEdge0 = dual.getEdge(iEdge);
                Mesh.Vertex initialDualVert = dualEdge0._initialVertex;
                if (initialDualVert == null)
                    continue; // initial dual vertex is already gone
                if ((!includeNonArity3 && initialDualVert.arity != 3)
                 || (!includeInsideOut && initialDualVert.momentAndArea[3] < 0.))
                {
                    for (Mesh.Edge dualEdge = dualEdge0;
                         dualEdge._initialVertex != null;
                         dualEdge = dualEdge._opposite._next)
                    {
                        assert(dualEdge._initialVertex == initialDualVert);
                        dualEdge._initialVertex = null;
                        --initialDualVert.arity;
                    }
                    assert(initialDualVert.arity == 0);
                    int iDualVert = initialDualVert.myIndex();
                    Mesh.Vertex lastDualVert = (Mesh.Vertex)dual.verts.remove(dual.verts.size()-1);
                    if (lastDualVert != initialDualVert)
                    {
                        lastDualVert._myIndex = iDualVert;
                        dual.verts.set(iDualVert, lastDualVert);
                    }
                }
            }
            
            //
            // Give each dual edge a direction.
            //
            fixDualDirections(primal, dual, wrapAroundSphereFlagValue, centerSphereFlagValue, wrapSphereCurvatureValue);
            //System.out.println("    out makeDualMesh(wrapAroundSphereFlagValue="+wrapAroundSphereFlagValue+")");
            return dual;
        } // makeDualMesh()

        // called at end of makeDualMesh,
        // and also after rescaling or tweaking
        public static void fixDualDirections(Mesh primal,
                                             Mesh dual,
                                             boolean wrapAroundSphereFlagValue,
                                             boolean centerSphereFlagValue,
                                             double wrapSphereCurvatureValue)
        {
            int nEdges = dual.edges.size();
            FORI (iEdge, nEdges)
                dual.getEdge(iEdge).direction = null;
            FORI (iEdge, nEdges)
            {
                Mesh.Edge dualEdge = dual.getEdge(iEdge);
                if (dualEdge.direction != null)
                    continue; // did this one already


                // We want a consistent method that works even if the edge is "external"
                // (i.e. direction is opposite the direction from initial to final vertex),
                // and that works even if initial or final vertex is null.

// TODO: remove this after it's been tested for a while
#if 0
                if (dualEdge._initialVertex != null
                 && dualEdge.finalVertex() != null)
                {
                    // it's a usual edge... get the direction by subtracting vertices
                    // XXX but this is not robust? but it may be better in some senses, especially if we're doing non-triangles too
                    // XXX TODO: compute in homogeneous space
                    dualEdge.direction = VecMath.normalize(VecMath.vmv(
                        new double[]{dualEdge.finalVertex().x(),
                                     dualEdge.finalVertex().y(),
                                     dualEdge.finalVertex().z()},
                        new double[]{dualEdge._initialVertex.x(),
                                     dualEdge._initialVertex.y(),
                                     dualEdge._initialVertex.z()}));
                }
                else
#endif
                {
                    // We want a consistent method that works even if the edge is "external"
                    // (i.e. direction is opposite the direction from initial to final vertex),
                    // and that works even if initial or final vertex is null.
                    // We compute the direction
                    // as the perpendicular to the corresponding primal edge.
                    // In 2d, this is easy-- its direction is just the primal edge dir
                    // rotated 90 degrees.
                    // But in 3d, what should it be?
                    // Well, the line is the intersection of two dual face planes,
                    // corresponding to two primal vertices.
                    // So the line direction is the cross product
                    // of the two plane normal dirs.

                    if (wrapAroundSphereFlagValue)
                    {
                        Mesh.Edge primalEdge = primal.getEdge(iEdge);
                        Mesh.Vertex v0 = primalEdge.initialVertex();
                        Mesh.Vertex v1 = primalEdge.finalVertex();
                        double v0Coords[] = {v0.x(), v0.y(), v0.z()};
                        double v1Coords[] = {v1.x(), v1.y(), v1.z()};
                        double center[] = {0,0,centerSphereFlagValue?0:-1./wrapSphereCurvatureValue};
                        VecMath.vmv(v0Coords, v0Coords, center);
                        VecMath.vmv(v1Coords, v1Coords, center);
                        double dir[] = VecMath.vxv3(v0Coords, v1Coords);
                        VecMath.normalize(dir, dir);
                        dualEdge.direction = dir;
                    }
                    else
                    {
                        // Luckily, the plane normal dirs are functions
                        // of the primal xy's (the h's don't matter; they just push the plane in or out).
                        // So, what is the surface normal (not necessarily unit length)
                        // of the paraboloid at x,y,(x^2+y^2)/2?
                        // It's x,y,1.
                        // That was easy.
                        //
                        Mesh.Edge primalEdge = primal.getEdge(iEdge);
                        Mesh.Vertex v0 = primalEdge.initialVertex();
                        Mesh.Vertex v1 = primalEdge.finalVertex();
                        // XXX TODO: compute in homogeneous space?
                        double n0[] = {v0.x(), v0.y(), 1};
                        double n1[] = {v1.x(), v1.y(), 1};
                        double dir[] = VecMath.vxv3(n0, n1);
                        VecMath.normalize(dir,dir);
                        dualEdge.direction = dir;
                    }
                }

                assert(dualEdge._opposite.direction == null);
                dualEdge._opposite.direction = VecMath.sxv(-1., dualEdge.direction);
            }
        } // fixDualDirections

        // XXX move this somewhere else
        double vertOffset(Mesh.Vertex vert, boolean wrapAroundSphereFlagValue)
        {
            if (wrapAroundSphereFlag.get())
            {
                double p[] = {vert.x(), vert.y(), vert.z()};
                return theSurface.offset(p);
            }
            else
            {
                // Mathematically this is theSurface.offset(p),
                // but we want to do it more directly
                // so that when it's exactly zero we'll get exactly zero.
                double p[] = {vert.x(), vert.y(), vert.z()};
                return vert.h();
            }
        } // vertOffset

        public static class Net
        {
            // note that our mesh,dualMesh is the reverse of the applet's
            // (since we want a net of the applet's dual mesh).
            public Net(Mesh mesh, Mesh dualMesh)
            {
                int nEdges = mesh.edges.size();
                int nVerts = mesh.verts.size();
                int nFaces = dualMesh.verts.size();

                this._mesh = mesh;
                this._dualMesh = dualMesh;
                this._edgeStatuses = Arrays.fill(nEdges, UNDECIDED);
                this._nFolds = 0;
                this._nCuts = 0;
                this._nUndecideds = nEdges;
                this._vertComponents = new SizeTrackingMergeFind(nVerts+1); // last may or may not be used
                this._faceComponents = new SizeTrackingMergeFind(nFaces+1); // last may or may not be used

                this._vertToParentEdgeInd = null; // only makes sense when net is complete
                this._topSortedVertInds = null; // only makes sense when net is complete
            }

            public Net(Mesh mesh, Mesh dualMesh, int edgeStatuses[])
            {
                this(mesh, dualMesh);

                assert(edgeStatuses.length == mesh.edges.size());

                FORI (iEdge, edgeStatuses.length)
                    if (edgeStatuses[iEdge] == CUT)
                        cut(iEdge, true);
                FORI (iEdge, edgeStatuses.length)
                    if (edgeStatuses[iEdge] == FOLD)
                        fold(iEdge, true);

                if (_nUndecideds == 0)
                    chooseDirections(mesh.verts.size());
            }

            // This can be called after all edges
            // have been cut or folded.
            // Sets and populates _vertToParentEdgeInd and _topSortedVertInds.
            // _vertToParentEdgeInd[iVert] will point from iVert towards the root vertex.
            // _topSortedVertInds is in order from root to leafs.
            // root==mesh.verts.size() means root is the infinite end of all the infinite edges.
            public void chooseDirections(int root)
            {
                System.out.println("    in chooseDirections");
                PRINT(root);
                assert(_nUndecideds == 0);

                int nEdges = _mesh.edges.size();
                int nVerts = _mesh.verts.size();
                Mesh.Edge cutsOut[][] = new Mesh.Edge[nVerts+1][]; // cut edges leading out of each vertex
                {
                    int nCutsOut[] = new int[cutsOut.length]; // zeros initially
                    FORI (iEdge, nEdges)
                        if (_edgeStatuses[iEdge] == CUT)
                        {
                            Mesh.Edge edge = _mesh.getEdge(iEdge);
                            Mesh.Vertex v0 = edge.initialVertex();
                            int i0 = (v0!=null&&v0.weight>0 ? v0.myIndex() : nVerts);
                            nCutsOut[i0]++;
                        }
                    FORI (iVert, cutsOut.length)
                    {
                        cutsOut[iVert] = new Mesh.Edge[nCutsOut[iVert]];
                        nCutsOut[iVert] = 0; // reset for filling step
                    }
                    FORI (iEdge, nEdges)
                        if (_edgeStatuses[iEdge] == CUT)
                        {
                            Mesh.Edge edge = _mesh.getEdge(iEdge);
                            Mesh.Vertex v0 = edge.initialVertex();
                            int i0 = (v0!=null&&v0.weight>0 ? v0.myIndex() : nVerts);
                            cutsOut[i0][nCutsOut[i0]++] = edge;
                        }
                    FORI (iVert, cutsOut.length)
                        assert(nCutsOut[iVert] == cutsOut[iVert].length);
                }

                _topSortedVertInds = new int[nVerts+1];
                _vertToParentEdgeInd = Arrays.fill(nVerts+1, -1);

                boolean isSorted[] = new boolean[nVerts+1]; // all false initially
                int nSorted = 0;
                _topSortedVertInds[nSorted++] = root;
                isSorted[root] = true;
                FORI (iSorted, nSorted) // while nSorted is growing!
                {
                    int iVert = _topSortedVertInds[iSorted];
                    FORI (iCutOut, cutsOut[iVert].length)
                    {
                        Mesh.Edge edge = cutsOut[iVert][iCutOut];
                        Mesh.Vertex finalVertex = edge.finalVertex();
                        int jVert = (finalVertex!=null ? finalVertex.myIndex() : nVerts);
                        if (!isSorted[jVert])
                        {
                            isSorted[jVert] = true;
                            _topSortedVertInds[nSorted++] = jVert;
                            _vertToParentEdgeInd[jVert] = edge.opposite().myIndex();
                        }
                    }
                }
                PRINTARRAY(isSorted);
                PRINTARRAY(_topSortedVertInds);
                PRINTARRAY(_vertToParentEdgeInd);
                PRINT(nVerts);
                PRINT(nSorted);
                assert(nSorted == nVerts+1);

                System.out.println("    out chooseDirections");
            } // chooseDirections

            // Walk around the boundary of the tree,
            // traversing both tree edges and things sticking out.
            public Mesh.Edge nextInTreeOrExit(int treeType, Mesh.Edge edge)
            {
                int iEdge = edge.myIndex();
                Mesh originalMesh = (_mesh.getEdge(iEdge) == edge ? _mesh : _dualMesh);
                assert(originalMesh.getEdge(iEdge) == edge);

                Mesh meshToUse = (treeType==CUT ? _mesh : _dualMesh);
                edge = meshToUse.getEdge(iEdge); // switch from _mesh to meshToUse

                // advance edge (its index will no longer be iEdge)
                if (_edgeStatuses[iEdge] == treeType)
                    edge = edge.next();
                else
                    edge = edge.opposite().next(); // next spoke

                // switch back from meshToUse to original mesh
                edge = originalMesh.getEdge(edge.myIndex());

                return edge;
            }

            // next in either cut tree or fold tree.
            // tree need not be complete.
            // if edge is from dual mesh, return something from dual mesh.
            public Mesh.Edge nextInTree(Mesh.Edge edge)
            {
                int treeType = _edgeStatuses[edge.myIndex()];
                do {
                    edge = nextInTreeOrExit(treeType, edge);
                } while (_edgeStatuses[edge.myIndex()] != treeType);
                return edge;
            }

            // If iEdge is a cut, return a list of all the folds
            // that are alternate exits out of the same lagoon (in same direction).
            // If iEdge is a fold, do the dual thing in the dual mesh.
            public Mesh.Edge[] alternatives(int iEdge)
            {
                assert(_nUndecideds == 0);
                Mesh meshToUse = (_edgeStatuses[iEdge]==CUT ? _mesh : _dualMesh);
                int nVerts = meshToUse.verts.size();
                int nEdges = meshToUse.edges.size();

                Mesh.Edge edge = meshToUse.getEdge(iEdge);
                Mesh.Vertex v0 = edge.initialVertex();
                Mesh.Vertex v1 = edge.finalVertex();
                int i0 = (v0!=null ? v0.myIndex() : nVerts);
                int i1 = (v1!=null ? v1.myIndex() : nVerts);

                int oEdge = edge.opposite().myIndex();
                assert(_edgeStatuses[oEdge] == _edgeStatuses[iEdge]);


                // could do it in O(n) instead of O(n alpha(n))... whatever
                MergeFind mergeFind = new MergeFind(nVerts+1);
                FORI (jEdge, nEdges)
                {
                    if (_edgeStatuses[jEdge] == _edgeStatuses[iEdge]
                     && jEdge != iEdge
                     && jEdge != oEdge)
                    {
                        Mesh.Edge edgeJ = meshToUse.getEdge(jEdge);
                        Mesh.Vertex w0 = edgeJ.initialVertex();
                        Mesh.Vertex w1 = edgeJ.finalVertex();
                        int j0 = (w0!=null ? w0.myIndex() : meshToUse.verts.size());
                        int j1 = (w1!=null ? w1.myIndex() : meshToUse.verts.size());
                        mergeFind.merge(j0, j1);
                    }
                }
                Mesh.Edge results[] = new Mesh.Edge[nEdges];
                int nResults = 0;

                int treeType = _edgeStatuses[iEdge];
                for (Mesh.Edge edgeJ = edge.opposite(); // just before entering lagoon
                     edgeJ != edge;
                     edgeJ = nextInTreeOrExit(treeType, edgeJ))
                {
                    int jEdge = edgeJ.myIndex();
                    if (_edgeStatuses[jEdge] != treeType) // if it's an exit rather than a tree edge
                    {
                        Mesh.Vertex w0 = meshToUse.getEdge(jEdge).initialVertex();
                        Mesh.Vertex w1 = meshToUse.getEdge(jEdge).finalVertex();
                        int j0 = (w0!=null ? w0.myIndex() : meshToUse.verts.size());
                        int j1 = (w1!=null ? w1.myIndex() : meshToUse.verts.size());
                        if (mergeFind.find(j0) == mergeFind.find(i0)
                         && mergeFind.find(j1) == mergeFind.find(i1))
                        {
                            // result is NOT necessarily edgeJ since meshToUse isn't necessarily _mesh.
                            results[nResults++] = (meshToUse==_mesh ? edgeJ
                                                                    : _mesh.getEdge(jEdge));
                        }
                    }
                }

                results = (Mesh.Edge[])Arrays.subarray(results, 0, nResults);
                return results;
            } // alternatives()

            // Make the cut a fold, and vice-versa.
            // The result must still be a tree.
            // In the worst case this has to be O(n),
            // so we don't think too hard, we just do it in O(n) (actually O(n alpha(n))).
            public void swapCutAndFold(int iCut, int iFold)
            {
                if (_edgeStatuses[iCut] == FOLD)
                {
                    int temp;
                    SWAP(iCut, iFold, temp);
                }
                Mesh.Edge cut = _mesh.getEdge(iCut);
                Mesh.Edge fold = _mesh.getEdge(iFold);
                int oCut = cut.opposite().myIndex();
                int oFold = fold.opposite().myIndex();
                assert(_edgeStatuses[iCut] == CUT);
                assert(_edgeStatuses[oCut] == CUT);
                assert(_edgeStatuses[iFold] == FOLD);
                assert(_edgeStatuses[oFold] == FOLD);

                // must have called chooseDirections already...
                assert(_vertToParentEdgeInd != null);
                assert(_topSortedVertInds != null);

                {
                    // check that the fold connects the same two components
                    // that are disconnected by removing the cut.
                    // Don't think too hard, just do this with a simple merge-find thing
                    // (even though we could do it in O(n)... whatever)

                    int nVerts = _mesh.verts.size();
                    int nEdges = _mesh.edges.size();
                    MergeFind mergeFind = new MergeFind(nVerts+1);
                    FORI (iEdge, nEdges)
                    {
                        if (_edgeStatuses[iEdge] == CUT
                         && iEdge != iCut
                         && iEdge != oCut)
                        {
                            Mesh.Edge edge = _mesh.getEdge(iEdge);
                            Mesh.Vertex v0 = edge.initialVertex();
                            Mesh.Vertex v1 = edge.finalVertex();
                            int i0 = (v0!=null ? v0.myIndex() : nVerts);
                            int i1 = (v1!=null ? v1.myIndex() : nVerts);
                            mergeFind.merge(i0, i1);
                        }
                    }

                    {
                        Mesh.Vertex v0 = cut.initialVertex();
                        Mesh.Vertex v1 = cut.finalVertex();
                        int i0 = (v0!=null ? v0.myIndex() : nVerts);
                        int i1 = (v1!=null ? v1.myIndex() : nVerts);
                        assert(mergeFind.find(i0) != mergeFind.find(i1)); // logically true since we're starting with a tree
                    }
                    {
                        Mesh.Vertex v0 = fold.initialVertex();
                        Mesh.Vertex v1 = fold.finalVertex();
                        int i0 = (v0!=null ? v0.myIndex() : nVerts);
                        int i1 = (v1!=null ? v1.myIndex() : nVerts);
                        assert(mergeFind.find(i0) != mergeFind.find(i1)); // make sure it's a legal alternative
                    }
                }

                _edgeStatuses[iCut] = FOLD;
                _edgeStatuses[oCut] = FOLD;
                _edgeStatuses[iFold] = CUT;
                _edgeStatuses[oFold] = CUT;

                // nCuts,nFolds stay the same
                
                int root = _topSortedVertInds[0];
                chooseDirections(root);
            } // swapCutAndFold

            // XXX TODO: is this necessary? should be automatically tracking cuttability now using the andForcedFolds stuff
            public boolean cuttable(int iEdge)
            {
                if (_edgeStatuses[iEdge] != UNDECIDED)
                    return false;
                Mesh.Edge edge = _mesh.getEdge(iEdge);
                Mesh.Vertex v0 = edge.initialVertex();
                Mesh.Vertex v1 = edge.finalVertex();
                int i0 = (v0!=null ? v0.myIndex() : _mesh.verts.size());
                int i1 = (v1!=null ? v1.myIndex() : _mesh.verts.size());
                return _vertComponents.find(i0)
                    != _vertComponents.find(i1);
            }
            public boolean foldable(int iEdge)
            {
                if (_edgeStatuses[iEdge] != UNDECIDED)
                    return false;
                Mesh.Edge edge = _dualMesh.getEdge(iEdge);
                Mesh.Vertex f0 = edge.initialVertex();
                Mesh.Vertex f1 = edge.finalVertex();
                int i0 = (f0!=null ? f0.myIndex() : _dualMesh.verts.size());
                int i1 = (f1!=null ? f1.myIndex() : _dualMesh.verts.size());
                return _faceComponents.find(i0)
                    != _faceComponents.find(i1);
            }
            // O(n), has to rebuild everything
            public void uncut(int iEdge)
            {
                assert(_edgeStatuses[iEdge] == CUT);
                
                // Unfortunately, need to tear everything down
                // and rebuild the merge-find structures.
                {
                    int nEdges = _mesh.edges.size();
                    int nVerts = _mesh.verts.size();
                    int nFaces = _dualMesh.verts.size();

                    int newEdgeStatuses[] = VecMath.copyvec(_edgeStatuses);
                    newEdgeStatuses[iEdge] = UNDECIDED;
                    newEdgeStatuses[_mesh.getEdge(iEdge).opposite().myIndex()] = UNDECIDED;

                    VecMath.fillvec(_edgeStatuses, UNDECIDED);
                    _nFolds = 0;
                    _nCuts = 0;
                    _nUndecideds = nEdges;
                    _vertComponents = new SizeTrackingMergeFind(nVerts+1);
                    _faceComponents = new SizeTrackingMergeFind(nFaces+1);

                    // now it's all clear (maybe need a clear() or reset()?)

                    FORI (jEdge, newEdgeStatuses.length)
                        if (newEdgeStatuses[jEdge] == CUT)
                            cut(jEdge, true);
                }

                _vertToParentEdgeInd = null; // only makes sense when net is complete
                _topSortedVertInds = null; // only makes sense when net is complete
            }
            public void cut(int iEdge, boolean andForcedFolds)
            {
                if (_edgeStatuses[iEdge] == CUT)
                    return;

                assert(cuttable(iEdge)); // redundant with checks below, but exercises it

                Mesh.Edge edge = _mesh.getEdge(iEdge);
                int oEdge = edge.opposite().myIndex();

                assert(_edgeStatuses[iEdge] == UNDECIDED);
                assert(_edgeStatuses[oEdge] == UNDECIDED);
                _edgeStatuses[iEdge] = CUT;
                _edgeStatuses[oEdge] = CUT;
                _nUndecideds -= 2;
                _nCuts += 2;

                Mesh.Vertex v0 = edge.initialVertex();
                Mesh.Vertex v1 = edge.finalVertex();
                int i0 = (v0!=null ? v0.myIndex() : _mesh.verts.size());
                int i1 = (v1!=null ? v1.myIndex() : _mesh.verts.size());
                assert(_vertComponents.find(i0)
                    != _vertComponents.find(i1));

                if (andForcedFolds)
                {
                    // After setting status
                    // but before merging,
                    // walk around the *smaller* of the two vert components
                    // and fold any edges (other than iEdge itself)
                    // between the two components we're about to merge.
                    // Choosing the smaller guarantees time O(n log(n))
                    // for constructing the whole tree
                    // (well, maybe more in the case of a very-large-arity vert).
                    // 
                    Mesh.Edge towardsSmaller;
                    int biggerComponentLeader;
                    int smallerComponentLeader;
                    if (_vertComponents.size(i0) < _vertComponents.size(i1))
                    {
                        towardsSmaller = edge.opposite();
                        biggerComponentLeader = _vertComponents.find(i1);
                        smallerComponentLeader = _vertComponents.find(i0);
                    }
                    else
                    {
                        towardsSmaller = edge;
                        biggerComponentLeader = _vertComponents.find(i0);
                        smallerComponentLeader = _vertComponents.find(i1);
                    }
                    for (Mesh.Edge nextEdge = nextInTreeOrExit(CUT, towardsSmaller);
                         nextEdge != towardsSmaller.opposite();
                         nextEdge = nextInTreeOrExit(CUT, nextEdge))
                    {
                        if (_edgeStatuses[nextEdge.myIndex()] == UNDECIDED) // it's an exit, and it hasn't already been decided to be a fold
                        {
                            int jEdge = nextEdge.myIndex();
                            Mesh.Vertex w0 = nextEdge.initialVertex();
                            Mesh.Vertex w1 = nextEdge.finalVertex();
                            int j0 = (w0!=null ? w0.myIndex() : _mesh.verts.size());
                            int j1 = (w1!=null ? w1.myIndex() : _mesh.verts.size());
                            assert(_vertComponents.find(j0) == smallerComponentLeader);
                            if (_vertComponents.find(j1) == biggerComponentLeader)
                            {
                                fold(jEdge, false);
                            }
                        }
                    }
                }

                _vertComponents.merge(i0, i1);

                // TODO:
                // for each undecided edge out of v0 or v1
                //     if it's to same component
                //         fold it
                // eek, need to do this for entire component! argh!
                // or, at least, entire smaller of the two components before the merge.
                // total O(n log n)

            } // cut
            public void fold(int iEdge, boolean andForcedCuts)
            {
                if (_edgeStatuses[iEdge] == FOLD)
                    return;

                assert(foldable(iEdge)); // redundant with checks below, but exercises it

                Mesh.Edge dualEdge = _dualMesh.getEdge(iEdge);
                int oEdge = dualEdge.opposite().myIndex();

                assert(_edgeStatuses[iEdge] == UNDECIDED);
                _edgeStatuses[iEdge] = FOLD;
                _edgeStatuses[oEdge] = FOLD;
                _nUndecideds -= 2;
                _nFolds += 2;

                Mesh.Vertex f0 = dualEdge.initialVertex();
                Mesh.Vertex f1 = dualEdge.finalVertex();
                int i0 = (f0!=null ? f0.myIndex() : _dualMesh.verts.size());
                int i1 = (f1!=null ? f1.myIndex() : _dualMesh.verts.size());
                assert(_faceComponents.find(i0)
                    != _faceComponents.find(i1));

                if (andForcedCuts)
                {
                    // Note, I'm just doing this blindly,
                    // using the code copied from cut() with cut changed to fold and vice-versa

                    // After setting status
                    // but before merging,
                    // walk around the *smaller* of the two face components
                    // and fold any edges (other than iEdge itself)
                    // between the two components we're about to merge.
                    // Choosing the smaller guarantees time O(n log(n))
                    // for constructing the whole tree
                    // (well, maybe more in the case of a very-large-arity vert).
                    // 
                    Mesh.Edge towardsSmaller;
                    int biggerComponentLeader;
                    int smallerComponentLeader;
                    if (_faceComponents.size(i0) < _faceComponents.size(i1))
                    {
                        towardsSmaller = dualEdge.opposite();
                        biggerComponentLeader = _faceComponents.find(i1);
                        smallerComponentLeader = _faceComponents.find(i0);
                    }
                    else
                    {
                        towardsSmaller = dualEdge;
                        biggerComponentLeader = _faceComponents.find(i0);
                        smallerComponentLeader = _faceComponents.find(i1);
                    }
                    for (Mesh.Edge nextEdge = nextInTreeOrExit(FOLD, towardsSmaller);
                         nextEdge != towardsSmaller.opposite();
                         nextEdge = nextInTreeOrExit(FOLD, nextEdge))
                    {
                        if (_edgeStatuses[nextEdge.myIndex()] == UNDECIDED) // it's an exit, and it hasn't already been decided to be a fold
                        {
                            int jEdge = nextEdge.myIndex();
                            Mesh.Vertex w0 = nextEdge.initialVertex();
                            Mesh.Vertex w1 = nextEdge.finalVertex();
                            int j0 = (w0!=null ? w0.myIndex() : _mesh.verts.size());
                            int j1 = (w1!=null ? w1.myIndex() : _mesh.verts.size());
                            assert(_faceComponents.find(j0) == smallerComponentLeader);
                            if (_faceComponents.find(j1) == biggerComponentLeader)
                            {
                                cut(jEdge, false);
                            }
                        }
                    }
                }

                _faceComponents.merge(i0, i1);
            } // fold



            private Mesh _mesh;
            private Mesh _dualMesh;

            private static final int UNDECIDED = -1;
            private static final int FOLD = 0;
            private static final int CUT = 1;
            private int _nFolds, _nCuts, _nUndecideds;
            private int _edgeStatuses[];
            private SizeTrackingMergeFind _vertComponents;
            private SizeTrackingMergeFind _faceComponents;
            private int _vertToParentEdgeInd[];
            private int _topSortedVertInds[];

        } // class Net

        // MergeFind that keeps track of component sizes
        public static class SizeTrackingMergeFind extends MergeFind
        {
            private int sizes[];
            public SizeTrackingMergeFind(int n)
            {
                super(n);
                sizes = VecMath.fillvec(n, 1);
            }
            // override's base class's
            public void merge(int i, int j)
            {
                i = find(i);
                j = find(j);
                if (i != j)
                {
                    int combinedSize = sizes[i] + sizes[j];
                    sizes[i] = 0;
                    sizes[j] = 0;
                    super.merge(i, j);
                    sizes[find(i)] = combinedSize;
                }
            }
            public int size(int i)
            {
                return sizes[find(i)];
            }
        } // class SizeTrackingMergeFind





        private static java.util.Random randomNumberGenerator = new java.util.Random(0); // not good form to share this
        private static double[][] generateBlueNoiseOnUnitSphere(double stubbornness,
                                                                double overlappingDiskRadius) // radius of disks that half-overlap.  this is twice the radius of disks that don't overlap.
        {
            // disk radius is in radians, on surface of unit sphere.
            // convert to linear separation.
            double minSeparation = 2*Math.sin(.5*overlappingDiskRadius);
            double minSeparationSqrd = SQR(minSeparation);

            double samples[][] = new double[10][];
            double sample[] = new double[3];
            int nSuccesses = 0;
            int nTries;
            for (nTries = 0;
                 nTries==0
              || nTries < nSuccesses * stubbornness; // first one is guaranteed to be a success
                 ++nTries)
            {
                do
                    VecMath.random(sample, randomNumberGenerator);
                while (VecMath.normsqrd(sample) > .5*.5);
                VecMath.normalize(sample, sample);

                // is it within minSeparation of any previous sample?
                // TODO: use an octree instead of linear search!
                int iSample;
                FOR (iSample, nSuccesses)
                {
                    if (VecMath.distsqrd(sample, samples[iSample]) < minSeparationSqrd)
                        break; // no good
                }

                if (iSample == nSuccesses)
                {
                    // it's good!
                    if (samples.length == nSuccesses)
                    {
                        double newSamples[][] = new double[samples.length*2][];
                        FORI (jSample, nSuccesses)
                            newSamples[jSample] = samples[jSample];
                        samples = newSamples;
                    }
                    samples[nSuccesses++] = VecMath.copyvec(sample);
                }
            }
            return (double[][])Arrays.subarray(samples, 0, nSuccesses);
        } // generateBlueNoiseOnUnitSphere

        private static double[][] generateBlueNoiseOnUnitSquare(double stubbornness,
                                                                double overlappingDiskRadiusX,
                                                                double overlappingDiskRadiusY) // radius of disks that half-overlap.  this is twice the radius of disks that don't overlap.
        {
            System.out.println("    in generateBlueNoiseOnUnitSquare");
            long t0millis = System.currentTimeMillis();
            // adding margin of 2*overlappingDiskRadius and then throwing it away afterwards
            // should be enough to avoid any boundary artifacts.
            // XXX add another 2 so we don't need to check... ?
            double minX = -2*overlappingDiskRadiusX;
            double maxX = 1+2*overlappingDiskRadiusX;
            double minY = -2*overlappingDiskRadiusY;
            double maxY = 1+2*overlappingDiskRadiusY;

            // we work with cells of size 1, in which overlappingDiskRadius is .5 (nonoverlapping disk radius is 1)
            int nWorkCellsX = (int)Math.ceil((maxX-minX)/overlappingDiskRadiusX);
            int nWorkCellsY = (int)Math.ceil((maxY-minY)/overlappingDiskRadiusY);
            PRINT(nWorkCellsX);
            PRINT(nWorkCellsY);
            double cells[][][][] = new double[nWorkCellsY][nWorkCellsX][6][2];
            int cellSizes[][] = new int[nWorkCellsY][nWorkCellsX]; // zeros initially
            int nSuccesses = 0;
            int nTries;
            for (nTries = 0;
                 nTries==0
              || nTries < nSuccesses * stubbornness;  // first one is guaranteed to be a success
                 ++nTries)
            {
                double x = Math.random() * nWorkCellsX;
                double y = Math.random() * nWorkCellsY;
                int iX1 = (int)(x+.5);
                int iX0 = iX1-1;
                int iY1 = (int)(y+.5);
                int iY0 = iY1-1;
                iX0 = CLAMP(iX0, 0, nWorkCellsX-1);
                iX1 = CLAMP(iX1, 0, nWorkCellsX-1);
                iY0 = CLAMP(iY0, 0, nWorkCellsY-1);
                iY1 = CLAMP(iY1, 0, nWorkCellsY-1);
                boolean bad = false;
                for (int iY = iY0; iY <= iY1 && !bad; ++iY)
                {
                    for (int iX = iX0; iX <= iX1 && !bad; ++iX)
                    {
                        double cell[][] = cells[iY][iX];
                        double cellSize = cellSizes[iY][iX];
                        for (int i = 0; i < cellSize; ++i)
                        {
                            double q[] = cell[i];
                            // if distance from q to new point < .5
                            if (SQR(x-q[0])+SQR(y-q[1]) < .25)
                            {
                                bad = true;
                                break;
                            }
                        }
                    }
                }
                if (!bad)
                {
                    int iX = (int)x;
                    int iY = (int)y;
                    iX = CLAMP(iX, 0, nWorkCellsX-1);
                    iY = CLAMP(iY, 0, nWorkCellsY-1);
                    double entry[] = cells[iY][iX][cellSizes[iY][iX]++];
                    entry[0] = x;
                    entry[1] = y;
                    nSuccesses++;
                }
            }

            PRINT(nTries);
            PRINT(nSuccesses);

            double answer[][] = new double[nSuccesses][];
            int iInCells = 0;
            int iAnswer = 0;
            int margin = 1; // should be 1, can set to 0 to see the margin too
            FORI (iX, nWorkCellsX-2*margin)
            FORI (iY, nWorkCellsY-2*margin)
            {
                double cell[][] = cells[iY+margin][iX+margin];
                double cellSize = cellSizes[iY+margin][iX+margin];
                for (int i = 0; i < cellSize; ++i)
                {
                    double scratch[] = cell[i]; 
                    answer[iAnswer] = scratch;
                    scratch[0] = LERP(minX, maxX, scratch[0]/nWorkCellsX);
                    scratch[1] = LERP(minY, maxY, scratch[1]/nWorkCellsY);
                    if (INRANGE(0 <=, scratch[0], <= 1)
                     && INRANGE(0 <=, scratch[1], <= 1))
                        iAnswer++;
                    iInCells++;
                }
            }
            if (margin == 0)
                assert(iInCells == answer.length);
            answer = (double[][])Arrays.subarray(answer, 0, iAnswer);
            long t1millis = System.currentTimeMillis();
            double seconds = (t1millis-t0millis) * 1e-3;
            System.out.println("    out generateBlueNoiseOnUnitSquare ("+seconds+" seconds)");
            return answer;
        } // generateBlueNoiseOnUnitSquare

        // See paper "Generating Random Spanning Trees
        // More Quickly than the Cover Time" by David Bruce Wilson.
        // But, can't I do it in O(n) time,
        // by simply growing the tree and picking a random new edge out of it on every step?
        // (answer: no, the next edge out of the spanning tree can't be picked uniformly)
        private static void analyzeRandomSpanningTrees(Mesh mesh)
        {
            System.out.println("    in analyzeRandomSpanningTrees");
            int nEdges = mesh.edges.size();
            PRINT(nEdges);
            if (nEdges > 24)
            {
                System.out.println("too many edges, bailing");
                return;
            }

            // convert to simpler data structure...

            int nVerts = mesh.verts.size();
            int e2v[][] = new int[nEdges][2]; // edge to verts
            int e2opposite[] = new int[nEdges];
            int e2next[] = new int[nEdges];

            boolean infiniteVertexUsed = false; // until proven otherwise
            FORI (iEdge, nEdges)
            {
                Mesh.Edge edge = mesh.getEdge(iEdge);
                Mesh.Vertex v0 = edge.initialVertex();
                Mesh.Vertex v1 = edge.finalVertex();
                int i0 = v0==null ? nVerts : v0.myIndex();
                int i1 = v1==null ? nVerts : v1.myIndex();
                e2v[iEdge][0] = i0;
                e2v[iEdge][1] = i1;
                if (v0 == null || v1 == null)
                    infiniteVertexUsed = true;
                e2opposite[iEdge] = edge.opposite().myIndex();
                Mesh.Edge next = edge.next();
                if (next == null)
                {
                    // final vertex is the infinite one; to find next, need to walk backwards around the face
                    next = edge;
                    while (next.prev() != null)
                        next = next.prev();
                }
                e2next[iEdge] = next.myIndex();
            }
            PRINTARRAY(e2v);
            PRINTARRAY(e2opposite);
            PRINTARRAY(e2next);
            PRINT(nVerts);
            PRINT(infiniteVertexUsed);
            if (infiniteVertexUsed)
                nVerts++;
            PRINT(nVerts);

            int v2e[][] = new int[nVerts][];
            {
                int arities[] = new int[nVerts]; // zeros initially
                FORI (iEdge, nEdges)
                    arities[e2v[iEdge][0]]++;
                FORI (iVert, nVerts)
                {
                    v2e[iVert] = new int[arities[iVert]];
                    arities[iVert] = 0;
                }
                FORI (iEdge, nEdges)
                {
                    int iVert = e2v[iEdge][0];
                    if (arities[iVert] == 0)
                    {
                        v2e[iVert][0] = iEdge; // arbitrary edge out of the vertex
                        arities[iVert] = 1;
                    }
                }
                FORI (iVert, nVerts)
                {
                    if (arities[iVert] == 1)
                    {
                        while (arities[iVert] < v2e[iVert].length)
                        {
                            v2e[iVert][arities[iVert]] = e2next[e2opposite[v2e[iVert][arities[iVert]-1]]]; // next one CW around the vertex
                            arities[iVert]++;
                        }
                        assert(e2next[e2opposite[v2e[iVert][arities[iVert]-1]]] == v2e[iVert][0]);
                    }
                    assert(arities[iVert] == v2e[iVert].length);
                    FORI (iEdgeOut, v2e[iVert].length)
                        assert(e2v[v2e[iVert][iEdgeOut]][0] == iVert);
                }
            }
            PRINTARRAY(v2e);

            java.util.Random generator = new java.util.Random();

            int counts[] = new int[1<<nEdges];

            int nTries = 1000*1000;
            FORI (iTry, nTries)
            {
                // Make a random spanning tree, and increment its count.

                int whichTree;

                if (false)
                {
                    // wilson's algorithm with r=0
                    boolean inTree[] = new boolean[nVerts]; // false initially
                    int next[] = new int[nVerts]; // vertex to next *edge*, not vertex
                    int r = 0; // arbitrarily
                    next[r] = -1;
                    inTree[r] = true;
                    FORI (i, nVerts)
                    {
                        int u = i;
                        while (!inTree[u])
                        {
                            next[u] = v2e[u][generator.nextInt(v2e[u].length)];
                            u = e2v[next[u]][1];
                        }
                        u = i;
                        while (!inTree[u])
                        {
                            inTree[u] = true;
                            u = e2v[next[u]][1];
                        }
                    }
                    whichTree = 0;
                    FORI (iVert, nVerts)
                    {
                        int iEdge = next[iVert];
                        if (iEdge != -1)
                        {
                            whichTree |= (1 << iEdge);
                            whichTree |= (1 << e2opposite[iEdge]);
                        }
                    }
                }
                else if (false)
                {
                    // random walk from 0,
                    // keeping *last* edge to each new vertex.
                    // This apparently isn't uniform!
                    boolean inTree[] = new boolean[nVerts]; // false initially
                    int prev[] = VecMath.fillvec(nVerts, -1); // vertex to prev *edge*, not vertex
                    int r = 0; // arbitrarily

                    inTree[r] = true;
                    int nVertsInTree = 1;
                    int u = r;
                    while (nVertsInTree < nVerts)
                    {
                        int iEdge = v2e[u][generator.nextInt(v2e[u].length)];
                        u = e2v[iEdge][1];
                        prev[u] = iEdge; // clobber old value if any, so we retain last edge to u
                        if (!inTree[u])
                        {
                            inTree[u] = true;
                            nVertsInTree++;
                        }
                    }

                    whichTree = 0;
                    FORI (iVert, nVerts)
                    {
                        int iEdge = prev[iVert];
                        if (iEdge != -1)
                        {
                            whichTree |= (1 << iEdge);
                            whichTree |= (1 << e2opposite[iEdge]);
                        }
                    }
                }
                else if (false)
                {
                    // random walk from 0,
                    // keeping *first* edge to each new vertex.
                    // This seems to be uniform.
                    boolean inTree[] = new boolean[nVerts]; // false initially
                    int prev[] = VecMath.fillvec(nVerts, -1); // vertex to prev *edge*, not vertex
                    int r = 0; // arbitrarily

                    inTree[r] = true;
                    int nVertsInTree = 1;
                    int u = r;
                    while (nVertsInTree < nVerts)
                    {
                        int iEdge = v2e[u][generator.nextInt(v2e[u].length)];
                        u = e2v[iEdge][1];
                        if (!inTree[u])
                        {
                            prev[u] = iEdge; // only record first edge to u
                            inTree[u] = true;
                            nVertsInTree++;
                        }
                    }

                    whichTree = 0;
                    FORI (iVert, nVerts)
                    {
                        int iEdge = prev[iVert];
                        if (iEdge != -1)
                        {
                            whichTree |= (1 << iEdge);
                            whichTree |= (1 << e2opposite[iEdge]);
                        }
                    }
                }
                else if (true)
                {
                    // my method--
                    // start at vertex 0 and grow the tree randomly.
                    // Oh damn, it's not uniform after all-- try it on a triangle:
                    // the probabilities are 1/4,1/4,1/2.
                    // Can it be fixed?
                    boolean inTree[] = new boolean[nVerts]; // false initially
                    int prev[] = VecMath.fillvec(nVerts, -1);

                    int nPotentialNextEdges = 0;
                    int potentialNextEdges[] = new int[nEdges];
                    int e2indexInPotentialNextEdges[] = VecMath.fillvec(nEdges, -1);

                    int u = 0;
                    inTree[u] = true;
                    FORI (iEdgeOut, v2e[u].length)
                    {
                        int iEdge = v2e[u][iEdgeOut];
                        if (!inTree[e2v[iEdge][1]])
                        {
                            e2indexInPotentialNextEdges[iEdge] = nPotentialNextEdges;
                            potentialNextEdges[nPotentialNextEdges] = iEdge;
                            nPotentialNextEdges++;
                        }
                    }
                    while (nPotentialNextEdges > 0)
                    {
                        int iPotentialNextEdge = generator.nextInt(nPotentialNextEdges);
                        int iEdge = potentialNextEdges[iPotentialNextEdge];
                        u = e2v[iEdge][1];
                        assert(!inTree[u]);
                        inTree[u] = true;
                        prev[u] = iEdge;

                        // For each edge out of u:
                        // if it's back to the tree (which includes iEdge itself),
                        // remove that edge from the boundary.
                        // otherwise, add that edge to the boundary.
                        FORI (iEdgeOut, v2e[u].length)
                        {
                            int jEdge = v2e[u][iEdgeOut];
                            boolean isBackToTree = inTree[e2v[jEdge][1]];
                            assert(isBackToTree == (e2indexInPotentialNextEdges[e2opposite[jEdge]] != -1));
                            if (isBackToTree)
                            {
                                // remove (opposite of) jEdge from boundary.
                                int index = e2indexInPotentialNextEdges[e2opposite[jEdge]];
                                assert(index != -1);
                                e2indexInPotentialNextEdges[e2opposite[jEdge]] = -1;
                                if (index != nPotentialNextEdges-1)
                                {
                                    // move the last one into the gap
                                    int kEdge = potentialNextEdges[nPotentialNextEdges-1];
                                    potentialNextEdges[index] = kEdge;
                                    e2indexInPotentialNextEdges[kEdge] = index;
                                }
                                --nPotentialNextEdges;
                            }
                            else
                            {
                                // add edge to boundary
                                e2indexInPotentialNextEdges[jEdge] = nPotentialNextEdges;
                                potentialNextEdges[nPotentialNextEdges] = jEdge;
                                nPotentialNextEdges++;
                            }
                        }
                    }
                    FORI (iVert, nVerts)
                        assert(inTree[iVert]);

                    whichTree = 0;
                    FORI (iVert, nVerts)
                    {
                        int iEdge = prev[iVert];
                        if (iEdge != -1)
                        {
                            whichTree |= (1 << iEdge);
                            whichTree |= (1 << e2opposite[iEdge]);
                        }
                    }
                }

                //PRINT(whichTree);

                counts[whichTree]++;

            }
            //PRINTARRAY(counts);

            SortStuff.sort(counts);
            int nZeros = 0;
            while (nZeros < counts.length && counts[nZeros] == 0)
                nZeros++;
            counts = (int[])Arrays.subarray(counts, nZeros, counts.length-nZeros);
            PRINTARRAY(counts);

            System.out.println("    out analyzeRandomSpanningTrees");
        } // analyzeRandomSpanningTrees


        // Holds the information needed to undo and redo a mesh editing operation.
        // This implementation is very simple and inefficient;
        // it just stores a complete copy of the mesh before and after
        // the editing operation.
        private static class UndoItem
        {
            public static class State
            {
                public Mesh mesh;
                public boolean continuouslyDelaunayizeFlag;
                public boolean optimizeFlag;
                public int optimizationTypeIndex;
                public int selectedTris[][];
                public int selectedDualVertIndices[];
                public boolean allDualVertsAreSelected;
                public int netEdgeStatuses[];
                public State(Mesh mesh, boolean continuouslyDelaunayizeFlag, boolean optimizeFlag, int optimizationTypeIndex, int selectedTris[][], int selectedDualVertIndices[], boolean allDualVertsAreSelected, Net net)
                {
                    this.mesh = new Mesh(mesh);
                    this.continuouslyDelaunayizeFlag = continuouslyDelaunayizeFlag;
                    this.optimizeFlag = optimizeFlag;
                    this.optimizationTypeIndex = optimizationTypeIndex;
                    this.selectedTris = (int[][])Arrays.copy(selectedTris, 2);
                    this.selectedDualVertIndices = VecMath.copyvec(selectedDualVertIndices);
                    this.allDualVertsAreSelected = allDualVertsAreSelected;
                    this.netEdgeStatuses = (net==null ? null : VecMath.copyvec(net._edgeStatuses));
                }
            }
            public State before;
            public State after;
            public UndoItem(State before, State after)
            {
                this.before = before;
                this.after = after;
            }
        } // class UndoItem

        private UndoItem.State newUndoItemState()
        {
            return new UndoItem.State(mesh,
                                      continuouslyDelaunayizeFlag.get(),
                                      optimizeFlag.get(),
                                      optimizationTypeIndex.get(),
                                      selectedTris,
                                      selectedDualVertIndices,
                                      allDualVertsAreSelected,
                                      theNet);
        } // newUndoItemState


        /*
            Note, the h given here are the "actual" positions v.h - .5 * (x^2 + y^2).
            where v.h is the offset stored in the vertex.

            Given:
                x0,y0,h0
                x1,y1,h1
                x2,y2,h2
            representing an infinitesimal triangle
            whose vertices are infinitesimally-squared away from the unit sphere
            at the tangent plane z=1:
                x0 eps, y0 eps, 1 + h0 eps^2
                x1 eps, y1 eps, 1 + h1 eps^2
                x2 eps, y2 eps, 1 + h2 eps^2
            we want to find x,y,h
            representing the point:
                x eps, y eps, 1 + h eps^2
            that is the intersection point of the 3 planes
            whose closest-points-to-origin are the reciprocals of the original 3 points.
            That is,
                [x0 eps, y0 eps, 1 + h0 eps^2] [x eps      ]   [1]
                [x1 eps, y1 eps, 1 + h1 eps^2] [y eps      ] = [1]
                [x2 eps, y2 eps, 1 + h2 eps^2] [1 + h eps^2]   [1]
            i.e.
                [ x x0 eps^2 + y y0 eps^2 + 1 + (h+h0)eps^2 + h h0 eps^4]   [1]
                [ x x1 eps^2 + y y1 eps^2 + 1 + (h+h1)eps^2 + h h1 eps^4] = [1]
                [ x x2 eps^2 + y y2 eps^2 + 1 + (h+h2)eps^2 + h h2 eps^4]   [1]
            the eps^4 terms are insignificant, so drop them:
                [ x x0 eps^2 + y y0 eps^2 + 1 + (h+h0)eps^2]   [1]
                [ x x1 eps^2 + y y1 eps^2 + 1 + (h+h1)eps^2] = [1]
                [ x x2 eps^2 + y y2 eps^2 + 1 + (h+h2)eps^2]   [1]
            i.e.
                [ x x0 eps^2 + y y0 eps^2 + (h+h0)eps^2]   [0]
                [ x x1 eps^2 + y y1 eps^2 + (h+h1)eps^2] = [0]
                [ x x2 eps^2 + y y2 eps^2 + (h+h2)eps^2]   [0]
            Divide both sides by eps^2:
                [ x x0 + y y0 + (h+h0)]   [0]
                [ x x1 + y y1 + (h+h1)] = [0]
                [ x x2 + y y2 + (h+h2)]   [0]
            i.e.
                [ x x0 + y y0 + h]   [-h0]
                [ x x1 + y y1 + h] = [-h1]
                [ x x2 + y y2 + h]   [-h2]
            i.e.
                [ x0 y0 1] [x]   [-h0]
                [ x1 y1 1] [y] = [-h1]
                [ x2 y2 1] [h]   [-h2]
            Easy!

            Alternate way of thinking about it:
            Given verts of a triangle:
                x0,y0,h0
                x1,y1,h1
                x2,y2,h2
            we want to find x,y,h that is the intersection point
            of the 3 planes that are the polars of the original 3 points
            with respect to the paraboloid z=-.5*(x^2+y^2).
            Or, equivalently, the pole of the plane passing through the original 3 points.

        */
        private static void SolveForDualPointActual(double x0, double y0, double h0,
                                                    double x1, double y1, double h1,
                                                    double x2, double y2, double h2,
                                                    double result[])
        {
            double M[][] = {
                {x0,y0,1},
                {x1,y1,1},
                {x2,y2,1},
            };
            double b[] = {
                -h0,
                -h1,
                -h2,
            };

            if (result.length == 3)
                VecMath.invmxv(result,M,b);
            else // result.length == 2, just copy the first two
                VecMath.copyvec(result, VecMath.invmxv(M,b));
        } // SolveForDualPointActual

        // TODO: isn't this defunct at this point? maybe not, but shouldn't use SolveForDualPointActual, should always use the moment method?  hmm except when wrapped?  hmm.
        private static void SolveForDualPoint(double x0, double y0, double h0,
                                              double x1, double y1, double h1,
                                              double x2, double y2, double h2,
                                              double result[],
                                              boolean wrapAroundSphereFlagValue,
                                              boolean centerSphereFlagValue,
                                              double wrapSphereCurvatureValue)
        {
            if ((result.length == 2 || result.length == 3)
             && !wrapAroundSphereFlagValue)
            {
                if (result.length > 2)
                    result[2] += .5 * (SQR(result[0]) + SQR(result[1]));

                double dualMomentAndArea[] = new double[4];
                SolveForDualMomentAndArea(x0,y0,h0,
                                          x1,y1,h1,
                                          x2,y2,h2,
                                          dualMomentAndArea,
                                          wrapAroundSphereFlagValue,
                                          centerSphereFlagValue,
                                          wrapSphereCurvatureValue);
                double A = dualMomentAndArea[3];
                double shouldBeResult[] = {
                    dualMomentAndArea[0] / A,
                    dualMomentAndArea[1] / A,
                    dualMomentAndArea[2] / (A*A),
                };
                VecMath.copyvec(result.length, result, shouldBeResult);
            }
            else
            {
                // paraboloid
                SolveForDualPointActual(x0, y0, h0 - .5 * (SQR(x0) + SQR(y0)),
                                        x1, y1, h1 - .5 * (SQR(x1) + SQR(y1)),
                                        x2, y2, h2 - .5 * (SQR(x2) + SQR(y2)),
                                        result);
            }
        } // SolveForDualPoint


        // Optimized robust version of SolveForDualPoint.
        // Moments can be used in robust center-of-mass calculations
        // even if individual weights are tiny (or zero).
        // Works in local *virtual* coord space of x0,y0,h0.
        // That is, the h's are heights above parabola.
        private static void SolveForDualMomentAndArea(double x0, double y0, double h0,
                                                      double x1, double y1, double h1,
                                                      double x2, double y2, double h2,
                                                      double result[], // x*A, y*A, A, or
                                                                       // x*A, y*A, h*A^2, A
                                                      boolean wrapAroundSphereFlagValue,
                                                      boolean centerSphereFlagValue,
                                                      double wrapSphereCurvatureValue)
        {
            double iSmallest = MINI3(SQR(x0)+SQR(y0),
                                     SQR(x1)+SQR(y1),
                                     SQR(x2)+SQR(y2));
            if (iSmallest == 0)
                _SolveForDualMomentAndArea(x0, y0, h0,
                                           x1, y1, h1,
                                           x2, y2, h2,
                                           result,
                                           wrapAroundSphereFlagValue,
                                           centerSphereFlagValue,
                                           wrapSphereCurvatureValue);
            else if (iSmallest == 1)
                _SolveForDualMomentAndArea(x1, y1, h1,
                                           x2, y2, h2,
                                           x0, y0, h0,
                                           result,
                                           wrapAroundSphereFlagValue,
                                           centerSphereFlagValue,
                                           wrapSphereCurvatureValue);
            else
                _SolveForDualMomentAndArea(x2, y2, h2,
                                           x0, y0, h0,
                                           x1, y1, h1,
                                           result,
                                           wrapAroundSphereFlagValue,
                                           centerSphereFlagValue,
                                           wrapSphereCurvatureValue);
        }
        private static void _SolveForDualMomentAndArea(double x0, double y0, double h0,
                                                       double x1, double y1, double h1,
                                                       double x2, double y2, double h2,
                                                       double result[], // x*A, y*A, A, or
                                                                        // x*A, y*A, h*A^2, A
                                                       boolean wrapAroundSphereFlagValue,
                                                       boolean centerSphereFlagValue,
                                                       double wrapSphereCurvatureValue)
        {
            if (wrapAroundSphereFlagValue)
            {
                //System.out.println("            in SolveForDualMomentAndArea(wrap=true, curvature="+wrapSphereCurvatureValue+")");
                // reciprocate with respect to the wrap sphere,
                // which has radius wrapSphereRadius
                // and is centered at (0,0,-wrapSphereRadius).

                double wrapSphereRadius = 1./wrapSphereCurvatureValue;


                // convert to actual (from somewhat nonsensical virtual, for wrapped case)
                double z0 = h0 -= .5 * (SQR(x0) + SQR(y0));
                double z1 = h1 -= .5 * (SQR(x1) + SQR(y1));
                double z2 = h2 -= .5 * (SQR(x2) + SQR(y2));

                if (!centerSphereFlagValue)
                {
                    z0 += wrapSphereRadius;
                    z1 += wrapSphereRadius;
                    z2 += wrapSphereRadius;
                }

                double e01[] = new double[] {x1-x0,y1-y0,z1-z0};
                double e02[] = new double[] {x2-x0,y2-y0,z2-z0};

                VecMath.vxv3(result, e01, e02);
                // result is now the normal, some length
                //double A = VecMath.norm(3, result); // XXX TODO: doesn't exist in VecMath yet
                double A = Math.sqrt(VecMath.dot(3, result, result));
                if (A == 0.)
                    VecMath.zerovec(result);
                else
                {
                    // result is now unit normal times A
                    double offsetTimesA = x0*result[0] + y0*result[1] + z0*result[2]; // result dot v0
                    double reciprocationMultiplier = SQR(wrapSphereRadius)/offsetTimesA*A;
                    VecMath.vxs(3, result, result, reciprocationMultiplier);
                    if (!centerSphereFlagValue)
                        result[2] -= wrapSphereRadius*A;
                    // convert from actual to somewhat nonsensical virtual, for wrapped case
                    result[2] += (.5 * (SQR(result[0])+SQR(result[1]))) / A;

                    if (result.length == 3)
                    {
                        // return x*A, y*A, A
                        // XXX wait a minute, we're not doing this right! shouldn't divide, I don't think?
                        // XXX I think this is done in GeneralOptimizationStuff
                        // XXX probably should not offer length=3, it confuses things... maybe
                        assert(false);
                        result[0] /= A;
                        result[1] /= A;
                        result[2] = A;
                    }
                    else // result.length == 4
                    {
                        // return x*A, y*A, h*A^2, A
                        result[3] = A;
                    }
                }

                //System.out.println("            out SolveForDualMomentAndArea(wrap=true)");
                return;
            }

            //System.out.println("            in SolveForDualMomentAndArea(wrap=false)");


            // convert from global virtual coord space to local virtual coord space
            // (local relative to v0)
            double X1 = x1 - x0;
            double Y1 = y1 - y0;
            double H1 = h1 - h0;
            double X2 = x2 - x0;
            double Y2 = y2 - y0;
            double H2 = h2 - h0;

            // convert from virtual to actual...
            H1 -= .5 * (SQR(X1) + SQR(Y1));
            H2 -= .5 * (SQR(X2) + SQR(Y2));

            // We're solving:
            //    0  0  1     X =   0
            //    X1 Y1 1  *  Y    -H1
            //    X2 Y2 1     H    -H2
            // I.e. H = 0 and:
            //    X1 Y1  *  X  =  -H1
            //    X2 Y2     Y  =  -H2
            //
            //    X  =  Y2 -Y1  *  -H1
            //    Y    -X2  X1     -H2
            //         ---------------
            //          X1*Y2 - X2*Y1

            double A = X1*Y2 - X2*Y1;
            double XA = -Y2*H1 + Y1*H2;
            double YA =  X2*H1 - X1*H2;

            // to convert from local actual coord space to global actual coord space:
            //         x = x0 + X
            //           = x0 + XA/A
            //   so  x*A = (x0 + XA/A)*A
            //           = x0*A + XA
            // etc.

            result[0] = XA + x0*A;
            result[1] = YA + y0*A;

            if (result.length == 3)
                result[2] = A;
            else
            {
                // convert from actual (H=0) to virtual...
                double HAA = .5 * (SQR(XA) + SQR(YA));
                result[2] = HAA - h0*(A*A);  // - instead of +, because raising features in the primal corresponds to lowering them in the dual (I think that's why)
                result[3] = A;
            }
            //System.out.println("            out SolveForDualMomentAndArea(wrap=false)");
        } // SolveForDualMomentAndArea


        // Calculate the angle C, opposite side c,
        // given side lengths a, b, c,
        // using c^2 = a^2 + b^2 - 2*a*b*cos(C)
        private static double triangleAngle(double a, double b, double c)
        {
            return Math.acos((a*a + b*b - c*c) / (2*a*b));
        }

        // Find vertex v2 that completes the triangle with given edge lengths,
        // such that v0,v1,v2 are CCW.
        private static double[] completeTriangle(double v0[],
                                                 double v1[],
                                                 double dist12,
                                                 double dist20)
        {
            // Make sure has only 2 entries
            v0 = new double[]{v0[0],v0[1]};
            v1 = new double[]{v1[0],v1[1]};
            double ang0 = triangleAngle(VecMath.dist(v0,v1), dist20, dist12);
            double dir01[] = VecMath.normalize(VecMath.vmv(v1,v0));
            double v2[] = VecMath.sxvpsxvpsxv(
                1.,                    v0,
                dist20*Math.cos(ang0), dir01,
                dist20*Math.sin(ang0), VecMath.xv2(dir01));
            return v2;
        } // completeTriangle

        private static double twiceTriangleArea(double x0, double y0,
                                                double x1, double y1,
                                                double x2, double y2)
        {
            return (x1-x0)*(y2-y0) - (x2-x0)*(y1-y0);
        }
        private static double twiceTriangleArea(double v0[],
                                           double v1[],
                                           double v2[])
        {
            return twiceTriangleArea(v0[0], v0[1],
                                     v1[0], v1[1],
                                     v2[0], v2[1]);
        }

        // tol is in linear units
        private static boolean edgesCrossOrCloseToIt(double a0x, double a0y,
                                                     double a1x, double a1y,
                                                     double b0x, double b0y,
                                                     double b1x, double b1y,
                                                     double tol)
        {
            return twiceTriangleArea(a0x,a0y,
                                     a1x,a1y,
                                     b1x,b1y)
                 * twiceTriangleArea(a1x,a1y,
                                     a0x,a0y,
                                     b0x,b0y) >= -(tol*tol)*(tol*tol)
                && twiceTriangleArea(b0x,b0y,
                                     b1x,b1y,
                                     a0x,a0y)
                 * twiceTriangleArea(b1x,b1y,
                                     b0x,b0y,
                                     a1x,a1y) >= -(tol*tol)*(tol*tol);
        } // edgesCrossOrCloseToIt

        private static double distSqrdFromPointToSeg(double x, double y,
                                                     double x0, double y0,
                                                     double x1, double y1)
        {
            double v[] = {x-x0,y-y0};
            double v1[] = {x1-x0,y1-y0};
            if (VecMath.normsqrd(v1) == 0.)
                return VecMath.normsqrd(v);
            double t = VecMath.dot(v,v1)
                     / VecMath.dot(v1,v1);
            t = CLAMP(t, 0., 1.);
            double vprojectedOntoV1[] = VecMath.sxv(t, v1);
            return VecMath.distsqrd(v, vprojectedOntoV1);
        }
        private static double distSqrdFromPointToRay(double x, double y,
                                                     double x0, double y0,
                                                     double xDir, double yDir) // need not be unit length
        {
            double v[] = {x-x0,y-y0};
            double v1[] = {xDir, yDir};
            if (VecMath.normsqrd(v1) == 0.)
                return VecMath.normsqrd(v);
            double t = VecMath.dot(v,v1)
                     / VecMath.dot(v1,v1);
            t = MAX(t, 0.);
            double vprojectedOntoV1[] = VecMath.sxv(t, v1);
            return VecMath.distsqrd(v, vprojectedOntoV1);
        }

        // XXX unused... but should it be in VecMath or something?
        private static double[][] axisAngleRotationMatrix(double axis[], double radians)
        {
            double invAxisLength = 1./VecMath.norm(axis);
            double x = axis[0]*invAxisLength;
            double y = axis[1]*invAxisLength;
            double z = axis[2]*invAxisLength;
            double c = Math.cos(radians);
            double s = Math.sin(radians);
            double C = 1. - c;
            // http://en.wikipedia.org/wiki/Rotation_matrix,
            // but transposed since we are using row-oriented transforms
            double M[][] = {
                {x*x*C+c, x*x*C+z*s, x*z*C-y*s},
                {x*y*C-z*s, y*y*C+c, y*z*C+x*s},
                {z*x*C+y*s, z*y*C-x*s, z*z*C+c},
            };
            return M;
        }



        // Find the row-oriented 3x3 rotation matrix that rotates unit vectors u to v,
        // using householder reflections.
        double[][] parallelTransport(double u[], double v[])
        {
            // reflect u to -v,
            // then reflect -v to v.
            double h[] = VecMath.vpv(u,v);
            // H = I - 2 (h h^T) / (h^T h)
            double H[][] = VecMath.mmm(VecMath.identitymat(h.length),
                                       VecMath.mxs(VecMath.outerProduct(h,h),
                                                   2/VecMath.normsqrd(h)));
            // V = I - 2 (v v^T) / (v^T v)
            //   = I - 2 (v v^T)  since v has unit length
            // XXX actually in the case we use this, v is the +z axis,
            // XXX in which case V just negates the z coord, trivial.
            // XXX should probably have a special version of this function
            // XXX for which v is a coord axis, or something
            double V[][] = VecMath.mmm(VecMath.identitymat(v.length),
                                       VecMath.mxs(VecMath.outerProduct(v,v),
                                                   2.));
            double answer[][] = VecMath.mxm(H,V);
            return answer;
        }

        private static void accumulateMomentAndArea(double accumulator[/*3 or 4*/],
                                                    double increment[/*3 or 4*/])
        {
            accumulator[0] += increment[0]; // x*A
            accumulator[1] += increment[1]; // y*A
            if (accumulator.length == 4
             && increment.length == 4)
                accumulator[2] += increment[2]; // h*A^2, or z*A
            accumulator[accumulator.length-1] += increment[increment.length-1]; // A
        }

        // 3d symmetry groups.
        // Rotation of order p around z axis,
        // and rotation of order q around some point between the +z and +y axis.
        // Note, we don't return a minimal set;
        // rather, we add in mathematically redundant generators
        // for all powers of p and q, since the math for generating them
        // is a bit more accurate than we'd get by products of the minimal set of generators.
        //
        // Instead of returning a flat list, we return a list of sub-lists;
        // each of the sub-lists are assumed to be powers of a single generator,
        // so there's no need to try more than one thing out of a given sub-list consecutively.
        //
        private static double[][][/*4*/][/*4*/] computeSymmetryGroupGenerators3d(int p, int q, boolean leftRightSymmetry, boolean centralSymmetry)
        {
            double genGroups[][][][] = new double[0][][][];

            // add reflection first, so it will get favored when generating,
            // since multiplying by it doesn't add any roundoff error.
            if (leftRightSymmetry)
                genGroups = (double[][][][])Arrays.append(genGroups, new double[][][]{{{-1,0,0,0},{0,1,0,0},{0,0,1,0},{0,0,0,1}}});

            if (centralSymmetry)
                genGroups = (double[][][][])Arrays.append(genGroups, new double[][][]{{{-1,0,0,0},{0,-1,0,0},{0,0,-1,0},{0,0,0,1}}});



            if (p > 1)
            {
                genGroups = (double[][][][])Arrays.append(genGroups, new double[p-1][][]);
                double subGens[][][] = genGroups[genGroups.length-1];

                for (int i = 1; i < p; ++i) // skip 0
                {
                    double c = cosPiTimes(2*i,p); // cos(2*pi * i/p)
                    double s = sinPiTimes(2*i,p); // sin(2*pi * i/p)
                    double gen[][] = {
                        { c,s,0,0},
                        {-s,c,0,0},
                        { 0,0,1,0},
                        { 0,0,0,1},
                    };
                    subGens[i-1] = gen;
                }
            }
            if (q > 1)
            {
                genGroups = (double[][][][])Arrays.append(genGroups, new double[q-1][][]);
                double subGens[][][] = genGroups[genGroups.length-1];

                // The rotation of order p is centered on the z axis;
                // where do we want to center the rotation of order q?
                // Figure out the cosine and sine of the tilt,
                // that is, distance from vert to face center of spherical {p,q}.
                double cosSqrdTilt = MIN(p,q)==1 ? 1. : // angle = 0; just produce identity matrix so no effect   XXX think about this again
                                     cotSquaredPiTimes(1,p)*cotSquaredPiTimes(1,q);
                double cosTilt = Math.sqrt(cosSqrdTilt);
                double sinTilt = Math.sqrt(1.-cosSqrdTilt);
                // tilt from +z towards +y
                double tiltMat[][] = {
                    {1,      0,       0,0},
                    {0,cosTilt,-sinTilt,0},
                    {0,sinTilt, cosTilt,0},
                    {0,      0,       0,1},
                };
                for (int i = 1; i < q; ++i) // skip 0
                {
                    double c = cosPiTimes(2*i,q); // cos(2*pi * i/q)
                    double s = sinPiTimes(2*i,q); // sin(2*pi * i/q)
                    double gen[][] = {
                        { c,s,0,0},
                        {-s,c,0,0},
                        { 0,0,1,0},
                        { 0,0,0,1},
                    };
                    gen = VecMath.mxmxm(VecMath.transpose(tiltMat), gen, tiltMat);
                    subGens[i-1] = gen;
                }
            }

            return genGroups;
        } // computeSymmetryGroupGenerators3d

        // 3d symmetry groups that hold origin fixed.
        // rotation of order p around z axis,
        // and rotation of order q around some point between the +z and +y axis.
        private static double[][/*4*/][/*4*/] computeSymmetryGroup3d(int p, int q, boolean leftRightSymmetry, boolean centralSymmetry)
        {
            double gens[][][][] = computeSymmetryGroupGenerators3d(p, q, leftRightSymmetry, centralSymmetry);

            if (false)
                System.out.println("gens = "+Arrays.toStringNonCompact(gens,
                                                                       "", // indentString
                                                                       "    "));  // indentIncr

            int nExpected = (MIN(p,q) == 1 ? MAX(p,q) :
                             MIN(p,q) == 2 ? 2*MAX(p,q) :
                             MIN(p,q)==3 && MAX(p,q)==3 ? 12 :
                             MIN(p,q)==3 && MAX(p,q)==4 ? 24 :
                             MIN(p,q)==3 && MAX(p,q)==5 ? 60 : -1);
            assert(nExpected != -1);
            if (leftRightSymmetry)
                nExpected *= 2;
            if (centralSymmetry)
                nExpected *= 2;
            // In some cases, leftRightSymmetry is redundant with centralSymmetry.
            // I don't know of any rhyme or reason to this, it just is.
            if (leftRightSymmetry && centralSymmetry)
                if ((MIN(p,q)==2 && MAX(p,q)%2==0) || MIN(p,q)==3&&MAX(p,q)>=4)
                {
                    nExpected /= 2;
                }

            double group[][][] = new double[nExpected][4][4];
            int lastSubgroupIndex[] = new int[group.length];

            int n = 0;
            VecMath.identitymat(group[n]);
            lastSubgroupIndex[n] = -1; // so nothing will match it
            n++;

            double scratch[][] = new double[4][4];
            FORI (i, n) // while n is growing
            {
                FORI (iSubgroup, gens.length)
                {
                    if (iSubgroup == lastSubgroupIndex[i])
                        continue; // no need to look at two in a row from the same subgroup
                    double subgroupGens[][][] = gens[iSubgroup];
                    FORI (iGen, subgroupGens.length)
                    {
                        VecMath.mxm(scratch, subgroupGens[iGen], group[i]); // or other order? not sure it matters
                        int j;
                        FOR (j, n)
                            if (VecMath.equals(scratch, group[j], 1e-3))
                                break;
                        if (j == n) // if didn't find it
                        {
                            VecMath.copymat(group[n], scratch);
                            lastSubgroupIndex[n] = iSubgroup;
                            n++;
                        }
                    }
                }
            }
            assert(n == group.length);
            return group;
        } // computeSymmetryGroup3d

        // Uses:
        //     pRotationalSymmetry
        //     qRotationalSymmetry
        //     leftRightSymmetry
        //     centralSymmetry
        //     wrapAroundSphereFlag
        //     wrapSphereCurvature
        private double[][/*4*/][/*4*/] getTheSymmetryGroup()
        {
            double group[][][] = computeSymmetryGroup3d(this.pRotationalSymmetry.get(), this.qRotationalSymmetry.get(), this.leftRightSymmetry.get(), this.centralSymmetry.get());

            if (!centerSphereFlag.get()) // XXX TODO: wait a minute, this test can't be right when not wrapped, can it?
            {
                // un-center the symmetry group
                double wrapSphereRadius = 1./wrapSphereCurvature.get();
                double originToSphereCenter[][] = {
                    {1,0,0,0},
                    {0,1,0,0},
                    {0,0,1,0},
                    {0,0,-wrapSphereRadius,1},
                };
                double sphereCenterToOrigin[][] = {
                    {1,0,0,0},
                    {0,1,0,0},
                    {0,0,1,0},
                    {0,0,wrapSphereRadius,1},
                };
                FORI (iGroup, group.length)
                {
                    group[iGroup] = VecMath.mxmxm(sphereCenterToOrigin,
                                                  group[iGroup],
                                                  originToSphereCenter);
                }
            }
            if (!wrapAroundSphereFlag.get())
            {
                // unwrap the symmetry group
                double wrapMat[][] = getWrapAroundSphereMatrix(wrapSphereCurvature.get(), centerSphereFlag.get());
                double unwrapMat[][] = getUnwrapAroundSphereMatrix(wrapSphereCurvature.get(), centerSphereFlag.get());
                FORI (iGroup, group.length)
                    group[iGroup] = VecMath.mxmxm(wrapMat,
                                                  group[iGroup],
                                                  unwrapMat);
            }
            return group;
        } // getTheSymmetryGroup
        private double[][/*4*/][/*4*/] getTheSymmetryGroupGenerators()
        {
            // XXX TODO: smaller set?
            return getTheSymmetryGroup();
        } // getTheSymmetryGroupGenerators


        // find intersection point of p0+t*v0
        //                        and p1+t*v1
        private static void intersectLines(double answer[/*2*/],
                                           double p0[/*2*/], double v0[/*2*/],
                                           double p1[/*2*/], double v1[/*2*/])
        {
            // want point p such that:
            //     perpdot(v0) dot p = perpdot(v0) dot p0
            //     perpdot(v1) dot p = perpdot(v1) dot p1
            double M[][] = {
                {-v0[1],v0[0]}, // perpdot(v0)
                {-v1[1],v1[0]}, // perpdot(v1)
            };
            double v[] = {VecMath.dot(2,M[0],p0),
                          VecMath.dot(2,M[1],p1)};

            VecMath.invmxv(answer, M, v);

            if (true)
            {
                // Blech, even if p0,v0 are exact mirror images of p1,v1,
                // sometimes the x coord of the answer comes out nonzero!
                // TODO: why? is there a more robust way to do it?
                // Apply evil fudge in this case.
                // TODO: could do same in y case, but only the x case is embarrassingly evident in the current usage
                //
                // To reproduce: n=7 before=3 after=3 quillSlope=1/10  synthesized??
                //    p0 = <2.120151391373195,5.8239002062807765>
                //    p1 = <-2.120151391373195,5.8239002062807765>
                //    v0 = <-0.900968867902419,0.43388373911755823>
                //    v1 = <0.900968867902419,0.43388373911755823>
                if (p1[0]==-p0[0]
                 && v1[0]==-v0[0]
                 && p1[1]==p0[1]
                 && v1[1]==v0[1])
                {
                    if (answer[0] != 0.)
                    {
                        if (false)
                        {
                            PRINTVEC(p0);
                            PRINTVEC(p1);
                            PRINTVEC(v0);
                            PRINTVEC(v1);
                            PRINTVEC(M);
                            PRINTVEC(v);
                            PRINTVEC(answer);
                            PRINTVEC(VecMath.invertmat(M));
                            PRINTVEC(VecMath.mxv(VecMath.invertmat(M), v));
                        }

                        System.out.println("HEY! fixing nonzero x coord of symmetric intersectionfrom "+answer[0]+" to 0!");
                        answer[0] = 0.;
                    }
                }
            }
        } // intersectLines

        // I seem to have set the bar too high on using VecMath for this... make private utility function instead
        private static double[] v3xm44(double v[/*3*/], double m[/*4*/][/*4*/])
        {
            int three = v.length;
            assert(m.length == three+1 && m[0].length == three+1);
            double scratch[] = Arrays.append(v, 1.);
            scratch = VecMath.vxm(scratch, m);
            if (scratch[three] == 1.)
                return (double[])Arrays.subarray(scratch, 0, three);
            else
                return VecMath.vxs(three, scratch, scratch[three]);
        }

        private static Mesh.Vertex[] findAllVertsThatAreImages(Mesh mesh, double v[/*2*/], double group[][/*2*/][/*2*/], double tol)
        {
            int nVerts = mesh.verts.size();
            boolean foundVert[] = new boolean[nVerts];
            int nFound = 0;
            FORI (iGroup, group.length)
            {
                assert(v.length == 3);
                double image[] = v3xm44(v,group[iGroup]);
                assert(image.length == 3);
                FORI (iVert, nVerts)
                {
                    if (!foundVert[iVert])
                    {
                        Mesh.Vertex vertI = mesh.getVert(iVert);
                        // TODO: compute in homo
                        if (EQ(image[0], vertI.x(), tol)
                         && EQ(image[1], vertI.y(), tol)
                         && EQ(image[2], vertI.z(), tol))
                        {
                            foundVert[iVert] = true;
                            nFound++;
                        }
                    }
                }
            }
            Mesh.Vertex answer[] = new Mesh.Vertex[nFound];
            nFound = 0;
            FORI (iVert, nVerts)
                if (foundVert[iVert])
                    answer[nFound++] = mesh.getVert(iVert);
            assert(nFound == answer.length);
            return answer;
        } // findAllVertsThatAreImages

        // =============== BEGIN: stolen from CSG.prejava

            // greatest common divisor
            private static int gcd(int a, int b)
            {
                return b==0 ? a : gcd(b, a%b);
            }

            // sin(pi*n/d) squared times sign, but do it without trig if it's a nice angle
            private static double sinSquaredPiTimes(int n, int d)
            {
                assert(d != 0);
                int sign = 1;
                if (n < 0)
                {
                    n *= -1;
                    sign *= -1;
                }
                if (d < 0)
                {
                    d *= -1;
                    sign *= -1;
                }
                int gcd = gcd(n,d);
                n /= gcd;
                d /= gcd;
                n %= 2*d;
                // so now 0 <= n/d < 2, i.e. in [0..360] degrees
                if (n > d)
                {
                    n = 2*d - n;
                    sign *= -1;
                }
                // so now 0 <= n/d <= 1, i.e. in [0..180] degrees
                if (2*n > d)
                {
                    n = d - n;
                }
                // so now 0 <= n/d <= 1/2, i.e. in [0..90] degrees
                if (4*n > d)
                    return sign*(1 - cosSquaredPiTimes(n, d));
                // so now 0 <= n/d <= 1/4, i.e. in [0..45] degrees
                assert(0 <= n && 4*n <= d);
                //System.out.println("    "+n+"/"+d+"");
                if (true)
                {
                    // http://mathworld.wolfram.com/TrigonometryAngles.html
                    // TODO: lots more linked from there
                    // TODO: now there's a bunch more on http://en.wikipedia.org/wiki/Exact_trigonometric_constants
                    // http://mathworld.wolfram.com/TrigonometryAnglesPi5.html
                    //     2/5
                    // http://mathworld.wolfram.com/TrigonometryAnglesPi8.html
                    //     3/8
                    // http://mathworld.wolfram.com/TrigonometryAnglesPi10.html
                    //     3/10
                    // http://mathworld.wolfram.com/TrigonometryAnglesPi12.html
                    //     5/12
                    //     5/12
                    // http://mathworld.wolfram.com/TrigonometryAnglesPi15.html
                    //     1/15
                    //     2/15
                    //     4/15
                    //     7/15
                    // http://mathworld.wolfram.com/TrigonometryAnglesPi16.html
                    //     1/16
                    //     3/16
                    //     5/16
                    //     7/16
                    // http://mathworld.wolfram.com/TrigonometryAnglesPi17.html
                    //     1/17
                    //     2/17
                    //     4/17
                    //     8/17
                    //     (what about 3,5,6,7? hmm)
                    // http://mathworld.wolfram.com/TrigonometryAnglesPi20.html
                    //     1/20
                    //     3/20
                    //     7/20
                    //     9/20
                    // http://mathworld.wolfram.com/TrigonometryAnglesPi24.html
                    //     1/24
                    //     5/24
                    //     7/24
                    //     11/24
                    // http://mathworld.wolfram.com/TrigonometryAnglesPi30.html
                    //     1/30
                    //     7/30
                    //     11/30
                    //     13/30
                    // http://mathworld.wolfram.com/TrigonometryAnglesPi32.html
                    //     1/32
                    //     3/32
                    //     5/32
                    //     7/32
                    //     9/32
                    //     11/32
                    //     13/32
                    //     15/32
                    // hey, what about 1/60??
                    // even the mathematica calculator doesn't get it,
                    // but sin(pi/60) = sqrt((1-cos(pi/30))/2)
                    //                = sqrt((1-  sqrt(7+sqrt(5)+sqrt(6*(5+sqrt(5))))/4.  )/2.)
                    // hmm, maybe can do a lot of these recursively using the half-angle
                    // formula?
                    if (n==0)          // 0 degrees
                        return sign * 0;
                    if (n==1 && d==12) // 15 degrees
                        return sign * ((2.-Math.sqrt(3.))/4.);
                    if (n==1 && d==10) // 18 degrees
                        return sign * ((3.-Math.sqrt(5.))/8.);
                    if (n==1 && d==8) // 22.5 degrees
                        return sign * ((2.-Math.sqrt(2.))/4.);
                    if (n==1 && d==6)  // 30 degrees
                        return sign * (1./4.);
                    if (n==1 && d==5)  // 36 degrees
                        return sign * ((5.-Math.sqrt(5.))/8.);
                    if (n==1 && d==4)  // 45 degrees
                        return sign * (1./2.);
                }
                if (true)
                {
                    // half-assed attempt at patching up some of the holes...
                    // XXX none of this has been tested
                    // XXX shouldn't do this unless denominator is of form that can prevent a trig call at the end... not sure how to predict that easily
                    if (d % 2 == 0)
                    {
                        // use half-angle formula sin(a/2) = sqrt((1-cos(a))/2)
                        // this is recursively calling with a bigger angle pi*n/(d/2),
                        // but it's sign-safe since we know pi*n/d < 45 degrees
                        // which implies pi*n/(d/2) < 90 degrees.
                        return sign * ((1.-Math.sqrt(cosSquaredPiTimes(n, d/2))) / 2.);
                    }
                    else if (n % 2 == 0)
                    {
                        // use double-angle formula sin(2a) = 2 sin(a) cos(a)
                        double s = sinSquaredPiTimes(n/2, d);
                        return sign * (4 * s * (1-s));
                    }
                    else if (n % 3 == 0)
                    {
                        // use triple-angle formula sin(3a) = 3 sin a - 4 sin^3 a
                        double s = sinSquaredPiTimes(n/3, d);
                        return sign * (s * SQR(4*s-3));
                    }
                    else if (n > 3)
                    {
                        // use angle-sum identity: sin(a+b) = sin(a)cos(b) + cos(a)sin(b)
                        int a = (n+1)/2;
                        int b = (n-1)/2;
                        double s2a = sinSquaredPiTimes(a,d);
                        double s2b = sinSquaredPiTimes(b,d);
                        double s = Math.sqrt(s2a*(1-s2b)) + Math.sqrt((1-s2a)*s2b);
                        return sign * (s*s);
                    }
                }
                //System.out.println("    "+n+"/"+d+" !!!");
                double s = Math.sin(Math.PI*n/d);
                return sign*s*s;
            } // sinSquaredPiTimes

            // cos(pi*n/d) squared times sign, but do it without trig if it's a nice angle
            private static double cosSquaredPiTimes(int n, int d)
            {
                // cos(pi*n/d) = sin(pi/2 - pi*n/d)
                //             = sin(pi * (1/2 - n/d))
                //             = sin(pi * (d/(2*d) - 2*n/(2*d)))
                //             = sin(pi * (d-2*n)/(2*d))
                return sinSquaredPiTimes(d-2*n, 2*d);
            }

            // tan(pi*n/d) squared, but do it without trig if it's a nice angle
            private static double tanSquaredPiTimes(int n, int d)
            {
                double s = sinSquaredPiTimes(n, d);
                return s / (1 - s); // XXX pretty sure sign is wrong if anything negative
            }
            // cot(pi*n/d) squared, but do it without trig if it's a nice angle
            private static double cotSquaredPiTimes(int n, int d)
            {
                double s = sinSquaredPiTimes(n, d);
                return (1 - s) / s; // XXX pretty sure sign is wrong if anything negative
            }
        // =============== END: stolen from CSG.prejava
        private static double sinPiTimes(int n, int d)
        {
            double temp = sinSquaredPiTimes(n, d);
            return temp<0 ? -Math.sqrt(-temp)
                          :  Math.sqrt(temp);
        }
        private static double cosPiTimes(int n, int d)
        {
            double temp = cosSquaredPiTimes(n, d);
            return temp<0 ? -Math.sqrt(-temp)
                          :  Math.sqrt(temp);
        }
        private static double tanPiTimes(int n, int d)
        {
            double temp = tanSquaredPiTimes(n, d);
            return temp<0 ? -Math.sqrt(-temp)
                          :  Math.sqrt(temp);
        }
        private static double cotPiTimes(int n, int d)
        {
            double temp = cotSquaredPiTimes(n, d);
            return temp<0 ? -Math.sqrt(-temp)
                          :  Math.sqrt(temp);
        }


        // not used any more, but it's a nice little utility
        public static void drawBitmapCentered(java.awt.Graphics g,
                                              java.awt.Dimension size,
                                              String[] rows)
        {
            int x0 = (size.width - rows[0].length())/2;
            int y0 = (size.height - rows.length)/2;
            FORI (iRow, rows.length)
            {
                String row = rows[iRow];
                int nCols = row.length();
                FORI (iCol, nCols)
                {
                    char c = row.charAt(iCol);
                    if (c != ' ')
                        g.fillRect(x0+iCol, y0+iRow, 1, 1);
                }
            }
        } // drawBitmapCentered
        public static void drawPixmapCentered(java.awt.Graphics g,
                                              java.awt.Dimension size,
                                              java.awt.Color asciiToColor[],
                                              String[] rows)
        {
            if (false)
            {
                // hack-- pad with the color at 0,0
                g.setColor(asciiToColor[rows[0].charAt(0)]);
                PRINT(size.width);
                PRINT(size.height);
                g.fillRect(0,0, size.width,size.height);
            }

            if (hidpimag != 1)
            {
                int mag = hidpimag;
                String[] newRows = new String[rows.length*mag];
                FORI (iRow, rows.length)
                {
                    String row = rows[iRow];
                    int nCols = row.length();
                    char chars[] = new char[nCols*mag];
                    FORI (i, nCols)
                        FORI (j, mag)
                          chars[i*mag+j] = row.charAt(i);
                    String newRow = new String(chars);
                    FORI (iMag, mag)
                        newRows[iRow*mag + iMag] = newRow;
                }
                rows = newRows;
            }

            int x0 = (size.width - rows[0].length())/2;
            int y0 = (size.height - rows.length)/2;
            java.awt.Color prevColor = null;
            FORI (iRow, rows.length)
            {
                String row = rows[iRow];
                int nCols = row.length();
                FORI (iCol, nCols)
                {
                    char c = row.charAt(iCol);
                    java.awt.Color color = asciiToColor[c];
                    if (color != prevColor)
                    {
                        g.setColor(color);
                        prevColor = color;
                    }
                    g.fillRect(x0+iCol, y0+iRow, 1, 1);
                }
            }
        } // drawPixmapCentered


    //
    // App-specific variables...
    //
        public static int hidpimag = 1; // automagically follows setting of controlFont from java command line
        private UndoTreeSquirrel undoTreeSquirrel = new UndoTreeSquirrel();
        private Mesh mesh = new Mesh();
        private Net theNet = null; // computed on demand
        private Mesh _dualMesh = null; // computed on demand
        private Mesh _primalMeshOfDualMesh = null; // possibly ill-advised attempt to automatically invalidate dualMesh when mesh gets replaced in various ways
        public Mesh getDualMesh()
        {
            if (_dualMesh == null
             || _primalMeshOfDualMesh != mesh)
            {
                _dualMesh = makeDualMesh(mesh,
                                         false,  // includeNonArity3
                                         calcInsideOutDualVertsFlag.get(), // includeInsideOut
                                         wrapAroundSphereFlag.get(),
                                         centerSphereFlag.get(),
                                         wrapSphereCurvature.get());
                _primalMeshOfDualMesh = mesh;
                theNet = null;
            }
            return _dualMesh;
        }
        public void dirtyDualMesh()
        {
            _dualMesh = null;
            _primalMeshOfDualMesh = null; // no sense keeping a ref to it
            theNet = null;
        }
        private int beingDraggedVertIndex = -1;
        private double[] beingDraggedVertUnsnappedXY = null;
        private int beingDraggedNetEdgeIndex = -1;
        private double[] beingDraggedNetEdgeDelta = null;
        private boolean rubberBandingNewEdge = false;
        private boolean mousePressWasBackFacing = false;
        private int[][] selectedTris = {};
        private int[] selectedDualVertIndices = {};
        private boolean allDualVertsAreSelected = false; // misnomer-- it really means "all dual verts are selected intentionally" or something
        private Mesh meshOfSelectedTris = mesh; // possibly ill-advised attempt to invalidate selectedTris and selectedDualVertIndices automatically so people can just reset mesh without having to remember

        // XXX is there an easier way to associate that stuff with a certain object? maybe be able to just pass this object to addListener, and make it automatically remove the listener when I go away?  OH, just add it as a member variable in the object, I think?
        private Listenable.Listener continuouslyDelaunayizeFlagListener = null;
        private Listenable.Listener wrapAroundSphereFlagListener = null;
        private Listenable.Listener centerSphereFlagListener = null;
        private Listenable.Listener wrapSphereCurvatureListener = null;
        private Listenable.Listener wrapSphereSymbolicRadiusListener = null;
        private Listenable.Listener gridBrightnessListener = null;
        private Listenable.Listener backfaceBrightnessListener = null;
        private Listenable.Listener optimizeFlagListener = null;
        private Listenable.Listener optimizationTypeIndexListener = null;
        private Listenable.Listener showMagFlagListener = null;
        private Listenable.Listener showNetFlagListener = null;
        private Listenable.Listener showNetFlagListener2 = null;
        private Listenable.Listener showNetFlowFlagListener = null;
        private Listenable.Listener netMethodListener = null;
        private Listenable.Listener calcInsideOutDualVertsFlagListener = null;
        private Listenable.Listener showInsideOutDualVertsFlagListener = null;
        private Listenable.Listener showFlatPrimalEdgesFlagListener = null;
        private Listenable.Listener showPrimalVertsFlagListener = null;
        private Listenable.Listener showPrimalEdgesFlagListener = null;
        private Listenable.Listener showDualVertsFlagListener = null;
        private Listenable.Listener showDualEdgesFlagListener = null;
        private Listenable.Listener labelPrimalVertsFlagListener = null;
        private Listenable.Listener labelPrimalEdgesFlagListener = null;
        private Listenable.Listener labelDualVertsFlagListener = null;
        private Listenable.Listener labelDualEdgesFlagListener = null;
        private Listenable.Listener primalDualVisFlagListener = null;
        private Listenable.Listener naiveDualEdgesFlagListener = null;
        private Listenable.Listener windowTitleListener = null;

        private Listenable.Boolean continuouslyDelaunayizeFlag = new Listenable.Boolean(false); // has to be false, or it may alter stuff on load
        private Listenable.Boolean optimizeFlag = new Listenable.Boolean(false);
            private static final int OPTIMIZE_BARYCENTRICS_LEAST_SQUARES = 0;
            private static final int OPTIMIZE_BARYCENTRICS_INFINITY_NORM = 1;
            private static final int OPTIMIZE_BARYCENTRICS_MAX_MIN = 2;
            private static final int OPTIMIZE_LENGTHS_LEAST_SQUARES = 3;
            private static final int OPTIMIZE_LENGTHS_INFINITY_NORM = 4;
            private static final int OPTIMIZE_LENGTHS_MAX_MIN = 5;
            private static final int OPTIMIZE_LENGTHS_SUM = 6;
            private static final String optimizationTypeNames[] = {
                "BARYCENTRICS_LEAST_SQUARES from all 1/3's",
                "BARYCENTRICS_INFINITY_NORM from all 1/3's",
                "BARYCENTRICS_MAX_MIN",
                "LENGTHS_LEAST_SQUARES from all .25's",
                "LENGTHS_INFINITY_NORM from all .25's",
                "LENGTHS_MAX_MIN with fixed sum",
                //"LENGTHS_SUM with every edge length >= .25",
            };
            private static final int availableOptimizationTypes[] = {
                OPTIMIZE_BARYCENTRICS_LEAST_SQUARES,
                OPTIMIZE_BARYCENTRICS_INFINITY_NORM,
                OPTIMIZE_BARYCENTRICS_MAX_MIN,
                OPTIMIZE_LENGTHS_LEAST_SQUARES,
                OPTIMIZE_LENGTHS_INFINITY_NORM,
                OPTIMIZE_LENGTHS_MAX_MIN,
                //OPTIMIZE_LENGTHS_SUM,
            };
        private Listenable.Int optimizationTypeIndex = new Listenable.Int(0, availableOptimizationTypes.length-1, OPTIMIZE_LENGTHS_MAX_MIN); // min, max, default
        int optimizationType = availableOptimizationTypes[optimizationTypeIndex.get()];


            private static final int NETMETHOD_MANUAL = 0;
            private static final int NETMETHOD_RANDOM = 1;
            private static final int NETMETHOD_UPWARD = 2;
            private static final int NETMETHOD_OUTWARD = 3;
            private static final int NETMETHOD_CUT_SHARPEST = 4;
            private static final int NETMETHOD_CUT_DULLEST = 5;
            private static final int NETMETHOD_CUT_LONGEST = 6;
            private static final int NETMETHOD_CUT_SHORTEST = 7;
            private static final int NETMETHOD_FOLD_SHARPEST = 8;
            private static final int NETMETHOD_FOLD_DULLEST = 9;
            private static final int NETMETHOD_FOLD_LONGEST = 10;
            private static final int NETMETHOD_FOLD_SHORTEST = 11;
            private static final String netMethodNames[] = {
                "Manual",
                "Random",
                "Upward",
                "Outward",
                "Cut Sharpest at each vert",
                "Cut Dullest at each vert",
                "Cut Longest at each vert",
                "Cut Shortest at each vert",
                "Fold Sharpest at each face",
                "Fold Dullest at each face",
                "Fold Longest at each face",
                "Fold Shortest at each face",
            };
        private Listenable.Int netMethod = new Listenable.Int(0, netMethodNames.length-1, NETMETHOD_OUTWARD);

        private java.awt.Component theCanvas = null;
        //private java.awt.Component theHelpWindow = null;
        private JFrame theMainAppletWindow = null;
        private JFrame theControlPanelWindow = null;
        private JFrame theHelpWindow = null;
        private Listenable.String windowTitle = new Listenable.String("Shephards Play Applet");

        // hack
        private int theOptimizationIndex = -1;
        private double theOptimizationPath[][][] = null;
        private double theOptimizationPathGoodnesses[] = null;

        private boolean arrowsTowardsSharpestDihedralsFlag = false;
        private boolean arrowsTowardsShortestEdgesFlag = false;

        private Listenable.Boolean labelPrimalVertsFlag = new Listenable.Boolean(false);
        private Listenable.Boolean labelPrimalEdgesFlag = new Listenable.Boolean(false);
        private Listenable.Boolean labelDualVertsFlag = new Listenable.Boolean(false);
        private Listenable.Boolean labelDualEdgesFlag = new Listenable.Boolean(false);
        private Listenable.Boolean calcInsideOutDualVertsFlag = new Listenable.Boolean(true);
        private Listenable.Boolean showInsideOutDualVertsFlag = new Listenable.Boolean(false);

        private Listenable.Boolean showFlatPrimalEdgesFlag = new Listenable.Boolean(false);

        private boolean showPositiveOrthantnessVisualizationFlag = false; // XXX total hack-- it's cool but put it somewhere else!!
        private Listenable.Boolean showPrimalVertsFlag = new Listenable.Boolean(true);
        private Listenable.Boolean showPrimalEdgesFlag = new Listenable.Boolean(true);
        private Listenable.Boolean showDualVertsFlag = new Listenable.Boolean(true);
        private Listenable.Boolean showDualEdgesFlag = new Listenable.Boolean(true);
        private Listenable.Boolean naiveDualEdgesFlag = new Listenable.Boolean(false);
        private Listenable.Boolean showNetFlag = new Listenable.Boolean(false);
        private Listenable.Boolean showFlattenedNetFlag = new Listenable.Boolean(true);
        private Listenable.Boolean showNetFlowFlag = new Listenable.Boolean(true);
        private boolean pointOutRedNetEdges = false;
        private int netFlowIndex = 0;
        private int highlightedDualEdgeIndex = -1;
        private boolean showOriginFlag = false;
        private boolean showGridFlag = true;
        private Listenable.Double gridBrightness = new Listenable.Double(0.,1.,.09); // tweaked til I like it
        private boolean showSmallestEnclosingDisk = false; // no way to change, currently
        private double gridSnapQuantum = 1./64; // no way to change, currently
        private boolean thermometerIsLinear = false;
        private int thermometerWidth = 10;

        // symmetry to try to use when clicking or dragging with ctrl down
        private Listenable.Int pRotationalSymmetry = new Listenable.Int(1,10, 1);
        private Listenable.Int qRotationalSymmetry = new Listenable.Int(1,10, 1);
        private Listenable.Boolean leftRightSymmetry = new Listenable.Boolean(false);
        private Listenable.Boolean centralSymmetry = new Listenable.Boolean(false);
        private Listenable.Boolean remapFundamentalRegionWhenChangingSymmetry = new Listenable.Boolean(true);
        private Listenable.Boolean replicateVertsWhenChangingSymmetry = new Listenable.Boolean(false);
        private Listenable.Boolean deleteNonReplicatedVertsWhenChangingSymmetry = new Listenable.Boolean(false);

        private Listenable.Boolean wrapAroundSphereFlag = new Listenable.Boolean(false);
        private Listenable.Boolean centerSphereFlag = new Listenable.Boolean(false);
        private Listenable.Double wrapSphereCurvature = new Listenable.Double(.001,2., 1.);
        private Listenable.Double wrapSphereSymbolicRadius = new Listenable.Double(.001,1.999, 1.);
        private Listenable.Double backfaceBrightness = new Listenable.Double(0.,1., .25);
        private Listenable.Int gridN = new Listenable.Int(0,1000,10);
        private Listenable.Int blueNoiseN = new Listenable.Int(0,1000,10);
        private Listenable.Double singleExitLagoonVirtualN = new Listenable.Double(0.,100.,16);
        private Listenable.Int singleExitLagoonNBeforeApex = new Listenable.Int(0,100,3);
        private Listenable.Int singleExitLagoonNBeforeBeforeApex = new Listenable.Int(0,100,3);
        private Listenable.Int singleExitLagoonNAfterApex = new Listenable.Int(0,100,3);
        private Listenable.Int singleExitLagoonNAfterAfterApex = new Listenable.Int(0,100,3);
        private Listenable.Double singleExitLagoonQuillSlopeNumerator = new Listenable.Double(0.,1000.,1.);
        private Listenable.Double singleExitLagoonQuillSlopeDenominator = new Listenable.Double(1.,1000.,1.);
        private Listenable.Double singleExitLagoonQuillSlopeNumeratorNumerator = new Listenable.Double(0.,1000.,1.);
        private Listenable.Double singleExitLagoonQuillSlopeDenominatorDenominator = new Listenable.Double(1.,1000.,1.);
        private Listenable.Boolean singleExitLagoonPointApexUpFlag = new Listenable.Boolean(false);
        private Listenable.Boolean singleExitLagoonSynthesizeExactDualFlag = new Listenable.Boolean(false);

        private Surface.Sphere theSphereSurface = new Surface.Sphere(new double[]{0,0,centerSphereFlag.get() ? 0. : -1./wrapSphereCurvature.get()}, 1./wrapSphereCurvature.get());
        private Surface.Paraboloid theParaboloidSurface = new Surface.Paraboloid(-.5);
        private Surface theSurface = (wrapAroundSphereFlag.get() ? (Surface)theSphereSurface
                                                                 : (Surface)theParaboloidSurface);


        // very special case visualization... if these are set,
        // highlight the primal/dual feature corresponding to the mouse angle.
        private double primalDualVisAngles[] = null;
        private int primalDualVisPrimalVertInds[] = null;
        private int primalDualVisDualVertInds[] = null;
        private Listenable.Boolean primalDualVisFlag = new Listenable.Boolean(true);


        // when middle-mouse is emulated by alt-left-mouse,
        // releasing alt in the middle of the drag looks like releasing middle, which is unfriendly...
        // so instead, we store draggingRotation.
        // but, have to remember to turn it off on mouse up,
        // whether or not alt is still down.
        private boolean draggingRotation = false;

        private double localScaleZ;
        private double twirl; // x->y
        private double tilt; // z->y
        private double eye[];
        private double localToWorld[][]; // product of matrices of the above 4
        { resetLocalToWorld(); }
        private void resetLocalToWorld()
        {
            localScaleZ = 0.; // yes, zero-- we flatten when parked at tilt=0 or tilt=Math.PI
            twirl = 0.;
            tilt = 0.;
            eye = new double[] {0.,0.,4.}; // XXX doesn't work if not on z axis
        }
        private double[][] getRotMat()
        {
            double cx = Math.cos(twirl);
            double sx = Math.sin(twirl);
            double cy = Math.cos(tilt);
            double sy = Math.sin(tilt);
            double twirlMat[][] = {
                { cx, sx, 0, 0},
                {-sx, cx, 0, 0},
                { 0,   0, 1, 0},
                { 0,   0, 0, 1},
            };
            double tiltMat[][] = {
                {1, 0,  0,  0},
                {0, cy,-sy, 0},
                {0, sy, cy, 0},
                {0, 0, 0,   1},
            };
            return VecMath.mxm(twirlMat, tiltMat);
        }
        private double[][] getLocalToWorld()
        {
            double localScaleMat[][] = {
                {1,0,0,0},
                {0,1,0,0},
                {0,0,wrapAroundSphereFlag.get()?1.:localScaleZ,0},
                {0,0,0,1},
            };
            double rotMat[][] = getRotMat();
            // XXX the following assumes the eye is on the Z axis
            double perspMat[][] = new double[][] {
                {1,0,0,0},
                {0,1,0,0},
                {0,0,1,-1./eye[2]},
                {0,0,-eye[2],1},
            };
            return VecMath.mxmxm(localScaleMat, rotMat, perspMat);
        }
        // Uses:
        //  localScaleZ
        //  getRotMat()
        //  eye
        //  wrap
        private void pickPointOnSurface(double thisP[], double offset, double resultPointOnSurface[/*3*/], boolean preferBackFacing)
        {
            assert(resultPointOnSurface.length == 3); // TODO: change to 4 at some point
            double eyeInLocalSpace[] = VecMath.mxv(getRotMat(), eye); // multiply on wrong side, i.e. apply transpose i.e. inverse
            if (!wrapAroundSphereFlag.get())
                eyeInLocalSpace[2] /= MAX(localScaleZ, 1e-6); // XXX aren't we doing this below too?
            double towardsPointInLocalSpace[] = VecMath.mxv(getRotMat(), new double[]{thisP[0],thisP[1],0.});

            // gag, that returned a 4d vector
            eyeInLocalSpace = (double[])Arrays.subarray(eyeInLocalSpace, 0, 3);
            towardsPointInLocalSpace = (double[])Arrays.subarray(towardsPointInLocalSpace, 0, 3);

            if (!wrapAroundSphereFlag.get())
            {
                if (localScaleZ == 0)
                {
                    resultPointOnSurface[0] = thisP[0];
                    resultPointOnSurface[1] = thisP[1];
                    resultPointOnSurface[2] = -.5*(SQR(thisP[0])+SQR(thisP[1]));
                    return;
                }
                eyeInLocalSpace[2] /= localScaleZ;
                towardsPointInLocalSpace[2] /= localScaleZ; // XXX didn't we do this above too?

                eyeInLocalSpace[2] -= offset;
                towardsPointInLocalSpace[2] -= offset;
                // for paraboloid with parameter -.5, always
            }

            double scratch[][] = new double[2][4];
            int nAnswers = theSurface.rayIntersect(scratch,
                                                   offset,
                                                   eyeInLocalSpace,
                                                   VecMath.vmv(towardsPointInLocalSpace, eyeInLocalSpace),
                                                   Surface.MISS_REFLECT);
            assert(nAnswers >= 1); // 1 if inside, 2 if outside
            double whichScratch[] = scratch[preferBackFacing ? (nAnswers-1) : 0];
            VecMath.vxs(3, resultPointOnSurface, whichScratch, 1./whichScratch[3]); // TODO: what if infinite?
        } // pickPointOnSurface

        private boolean pickedPointIsBackFacingOnSurface(double pointOnSurface[])
        {
            double eyeInLocalSpace[] = VecMath.mxv(getRotMat(), eye); // multiply on wrong side, i.e. apply transpose i.e. inverse
            if (!wrapAroundSphereFlag.get())
                eyeInLocalSpace[2] /= MAX(localScaleZ, 1e-6);
            // gag, that returned a 4d vector
            eyeInLocalSpace = (double[])Arrays.subarray(eyeInLocalSpace, 0, 3);
            double towardsPointInLocalSpace[] = VecMath.copyvec(pointOnSurface);

            double offset = theSurface.offset(pointOnSurface);

            if (!wrapAroundSphereFlag.get())
            {
                if (localScaleZ == 0)
                {
                    return eyeInLocalSpace[2] < 0;
                }
                eyeInLocalSpace[2] /= localScaleZ;
                towardsPointInLocalSpace[2] /= localScaleZ;

                eyeInLocalSpace[2] -= offset;                   // XXX is this right?
                towardsPointInLocalSpace[2] -= offset;                  // XXX is this right?
                // for paraboloid with parameter -.5, always
            }

            double scratch[][] = new double[2][4];
            int nAnswers = theSurface.rayIntersect(scratch,
                                                   offset,
                                                   eyeInLocalSpace,
                                                   VecMath.vmv(towardsPointInLocalSpace, eyeInLocalSpace),
                                                   Surface.MISS_FORCE);

            assert(nAnswers >= 1); // 1 if inside, 2 if outside
            FORI (iAnswer, nAnswers)
                VecMath.vxs(3, scratch[iAnswer], scratch[iAnswer], 1./scratch[iAnswer][3]); // TODO: what if infinite?

            if (nAnswers == 1)
                return false; // not really clear, but doesn't matter I don't think


            // which answer? the one closest to the query point (and it should be at it exactly, in fact, modulo roundoff error)
            assert(nAnswers == 2);

            double d0 = VecMath.distsqrd(3, towardsPointInLocalSpace, scratch[0]);
            double d1 = VecMath.distsqrd(3, towardsPointInLocalSpace, scratch[1]);
            return d1<d0;
        } // pickedPointIsBackFacingOnSurface


    //
    // Applet-generic member variables...
    //
        private GraphicsAntiAliasingSetter graphicsAntiAliasingSetter;
        private int eventVerbose = 0; // can set with eventVerbose=1 on command line
        private static int nonEventVerbose = 0; // so static classes can refer to it
        private boolean antiAliasingFlag = false;
        private boolean implementAntiAliasingInHardware = true; // XXX should have a better name for this-- really mean let java runtime do it
        private boolean doubleBufferFlag = false; // TODO: swing does this for us... can get rid of it, as soon as I figure out how to do the magnifying glass without it
        private java.awt.Image backBufferImage = null;
        private MyGraphics3D mostRecentGraphics = null;
        private Listenable.Boolean showMagFlag = new Listenable.Boolean(false);
        private int magFactor = 9;
        private int magWidth = 25;
        private int nPaints = 0;


        private double prevP[] = null;
        private double origP[] = null;
        // "effective" position is position of the thing being dragged. might be a few pixels away from actual position of mouse cursor.
        private double prevPeffective[] = null;
        private double origPeffective[] = null;

    //
    // Track mouse state...
    // (I think java newer versions of java (XXX starting when?)
    // let you query from the events themselves,
    // but e.g. in 1.1 there is no way to tell whether button1
    // is down during a drag without keeping state
    //
        private boolean button1IsDown = false;
        private boolean button2IsDown = false;
        private boolean button3IsDown = false;
        private boolean controlIsDown = false;
        private UndoItem.State stateWhenPressed = null;




    public static class JTextFieldForString extends JValidatingTextField
    {
        private Listenable.Listener listener; // need to keep a strong ref to it for as long as I'm alive
        public JTextFieldForString(final Listenable.String s)
        {
            super(s.get());
            s.addListener(listener = new Listenable.Listener() {
                public void valueChanged()
                {
                    setText(s.get());
                }
            });
            addActionListener(new java.awt.event.ActionListener() {
                public void actionPerformed(java.awt.event.ActionEvent e)
                {
                    s.set(getText());
                }
            });
        }
    } // JTextFieldForString
    // Stolen from MC4DControlPanel.java
    public static class JTextFieldForNumber extends JValidatingTextField
    {
        private Listenable.Listener listener; // need to keep a strong ref to it for as long as I'm alive
        private Listenable.Number f;

        // override super's
        public boolean validate(String text)
        {
            try {
                // attempt to parse, ignore return value
                if (f instanceof Listenable.Int)
                    Integer.parseInt(text);
                else
                    Double.parseDouble(text);
                return true;
            } catch (Exception e) {
                return false;
            }
        }

        private void updateText(Listenable.Number f)
        {
            if (f instanceof Listenable.Int)
                setText(""+((Listenable.Int)f).get());
            else if (f instanceof Listenable.Float)
                setText(""+((Listenable.Float)f).get());
            else
                setText(""+(float)((Listenable.Double)f).get()); // XXX ARGH! we lose precision with this (float) cast, but if we don't do it, we can get, for example, 37.092999999999996 which looks lame.  should figure out another way to prevent that.
        }

        public JTextFieldForNumber(final Listenable.Number f)
        {
            super(f instanceof Listenable.Int ? ""+((Listenable.Int)f).max() // XXX not quite right, min may be longer string than max
                   : "99.99"); // give it enough space for 99.999 (on my computer, always seems to give an extra space, which we don't need)
            this.f = f;
            updateText(f);
            f.addListener(listener = new Listenable.Listener() {
                public void valueChanged()
                {
                    updateText(f);
                }
            });
            addActionListener(new java.awt.event.ActionListener() {
                public void actionPerformed(java.awt.event.ActionEvent e)
                {
                    try
                    {
                        f.setDouble(Double.valueOf(getText()).doubleValue());
                    }
                    catch (java.lang.NumberFormatException nfe)
                    {
                        // maybe should print an error message or something
                        updateText(f);
                    }
                }
            });
        }
        public java.awt.Dimension getPreferredSize()
        {
            //System.out.println("in JTextFieldForNumber.getPreferredSize()");
            // default seems taller than necessary
            // on my computer... and in recent VMs it's even worse
            // (changed from 29 to 31).
            // Fudge it a bit...
            // XXX not sure this will look good on all systems... if it doesn't, we can just remove it
            // XXX hmm, actually makes things mess up when growing and shrinking, that's weird
            java.awt.Dimension preferredSize = super.getPreferredSize();
            //System.out.println("textfield.super.preferredSize() = "+preferredSize);
            if (true)
                preferredSize.height -= 2;

            // XXX another hack, wtf?
            if (true)
            {
                if (f instanceof Listenable.Int)
                    preferredSize.width = 50;
                else
                    preferredSize.width = 100;
            }

            //System.out.println("out JTextFieldForNumber.getPreferredSize(), returning "+preferredSize);
            return preferredSize;
        }
        // weird, the following is called during horizontal shrinking
        // but not during horizontal expanding... if we don't do this too
        // then it looks wrong when shrinking.  what a hack...
        public java.awt.Dimension getMinimumSize()
        {
            //System.out.println("in JTextFieldForNumber.getMinimumSize()");
            java.awt.Dimension minimumSize = super.getMinimumSize();
            //System.out.println("textfield.super.minimumSize() = "+minimumSize);
            if (true)
                minimumSize.height -= 2;

            // XXX another hack, wtf?
            if (true)
            {
                if (f instanceof Listenable.Int)
                    minimumSize.width = 50;
                else
                    minimumSize.width = 100;
            }

            //System.out.println("out JTextFieldForNumber.getMinimumSize(), returning "+minimumSize);
            return minimumSize;
        }
    } // JTextFieldForNumber


    public static class JCheckBoxForBoolean extends JCheckBox
    {
        private Listenable.Listener listener; // need to keep a strong ref to it for as long as I'm alive
        public JCheckBoxForBoolean(String name, final Listenable.Boolean b)
        {
            super(name);
            setSelected(b.get());
            addItemListener(new java.awt.event.ItemListener() {
                public void itemStateChanged(java.awt.event.ItemEvent e)
                {
                    b.set(isSelected());
                }
            });
            b.addListener(listener = new Listenable.Listener() {
                public void valueChanged()
                {
                    setSelected(b.get());
                }
            });
        }
    } // JCheckBoxForBoolean

    public static class JSliderForFloat extends JSlider
    {
        private Listenable.Listener listener; // need to keep a strong ref to it for as long as I'm alive

        // private helper function
        private void updateThumb(Listenable.Number f)
        {
            double value = f.getDouble();
            double defaultValue = f.defaultDouble();
            double frac = (value-f.minDouble())/(f.maxDouble()-f.minDouble());

            //setValue((int)(getMinimum() + ((getMaximum()-getVisibleAmount())-getMinimum())*frac));
            setValue((int)(getMinimum() + (getMaximum()-getMinimum())*frac));
        }

        public JSliderForFloat(final Listenable.Number f)
        {
            // 3 significant digits seems reasonable...
            /*
            super(JSlider.HORIZONTAL,
                  (int)Math.round(f.minDouble()*1000),
                  (int)Math.round(f.maxDouble()*1000),
                  (int)Math.round(f.getDouble())*1000);
            */
            super(JSlider.HORIZONTAL, 0, 1000, 500);

            if (false)
            {
                PRINT(getMinimum());
                PRINT(getMaximum());
                PRINT(getValue());
            }

            setMinorTickSpacing(1);  // .001 units
            setMajorTickSpacing(10); // .01 units
            f.addListener(listener = new Listenable.Listener() {
                public void valueChanged()
                {
                    updateThumb(f);
                }
            });
            addChangeListener(new javax.swing.event.ChangeListener() {
                public void stateChanged(javax.swing.event.ChangeEvent e)
                {
                    if (false)
                    {
                        System.out.println("==================");
                        System.out.println("    min = "+getMinimum());
                        System.out.println("    max = "+getMaximum());
                        System.out.println("    max-min = "+(getMaximum()-getMinimum()));
                        System.out.println("    getValue() = "+getValue());
                        System.out.println("    getMinorTickSpacing() = "+getMinorTickSpacing());
                        System.out.println("    getMajorTickSpacing() = "+getMajorTickSpacing());
                        System.out.println("    getSize() = "+getSize());
                        System.out.println("    getPreferredSize() = "+getPreferredSize());
                    }
                    // Doing the following in double precision makes a difference;
                    // if we do it in float, we get ugly values in the textfield
                    double frac = (double)(getValue()-getMinimum())
                                / (double)(getMaximum()-getMinimum());
                    f.setDouble(f.minDouble() + frac*(f.maxDouble()-f.minDouble()));
                    // will trigger valueChanged()
                    // which will call updateThumb()
                }
            });
            updateThumb(f); // because we fucked it up in the contructor?
        }
    } // JSliderForFloat


    // Stolen from MC4DControlPanel.java  TODO: replace with JSliderForFloat
    public static class OldSliderForFloat extends java.awt.Scrollbar
    {
        private Listenable.Listener listener; // need to keep a strong ref to it for as long as I'm alive

        // private helper function
        private void updateThumb(Listenable.Number f)
        {
            double value = f.getDouble();
            double defaultValue = f.defaultDouble();
            double frac = (value-f.minDouble())/(f.maxDouble()-f.minDouble());
            setValue((int)(getMinimum() + ((getMaximum()-getVisibleAmount())-getMinimum())*frac));
        }

        public OldSliderForFloat(final Listenable.Number f)
        {
            super(java.awt.Scrollbar.HORIZONTAL);

            // 3 significant digits seems reasonable...
            int min = (int)Math.round(f.minDouble()*1000);
            int max = (int)Math.round(f.maxDouble()*1000);
            int vis = (int)Math.round(.1*(max-min));
            setValues(0,   // value (we'll set it right later)
                      vis,
                      min,
                      max+vis);
            setUnitIncrement(1);   // .001 units
            setBlockIncrement(10); // .01 units

            f.addListener(listener = new Listenable.Listener() {
                public void valueChanged()
                {
                    updateThumb(f);
                }
            });
            addAdjustmentListener(new java.awt.event.AdjustmentListener() {
                public void adjustmentValueChanged(java.awt.event.AdjustmentEvent e)
                {
                    if (false)
                    {
                        System.out.println("==================");
                        System.out.println("    min = "+getMinimum());
                        System.out.println("    max = "+getMaximum());
                        System.out.println("    visible = "+getVisibleAmount());
                        System.out.println("    max-vis-min = "+(getMaximum()-getVisibleAmount()-getMinimum()));
                        System.out.println("    e.getValue() = "+e.getValue());
                        System.out.println("    getValue() = "+getValue());
                        System.out.println("    getUnitIncrement() = "+getUnitIncrement());
                        System.out.println("    getBlockIncrement() = "+getBlockIncrement());
                        System.out.println("    getSize() = "+getSize());
                        System.out.println("    getPreferredSize() = "+getPreferredSize());
                    }
                    // Doing the following in double precision makes a difference;
                    // if we do it in float, we get ugly values in the textfield
                    double frac = (double)(e.getValue()-getMinimum())
                                / (double)((getMaximum()-getVisibleAmount())-getMinimum());
                    f.setDouble(f.minDouble() + frac*(f.maxDouble()-f.minDouble()));
                    // will trigger valueChanged()
                    // which will call updateThumb()
                }
            });
            updateThumb(f);
        }
        public java.awt.Dimension getPreferredSize()
        {
            // default seems to be 50x18 on my computer...
            // give it more horizontal space than that
            java.awt.Dimension preferredSize = super.getPreferredSize();
            //System.out.println("scrollbar.super.preferredSize() = "+preferredSize);
            preferredSize.width = 200;
            return preferredSize;
        }
    } // OldSliderForFloat

    //public static class SliderForFloat extends OldSliderForFloat
    public static class SliderForFloat extends JSliderForFloat
    {
        public SliderForFloat(final Listenable.Number f)
        {
            super(f);
        }
    }

    //
    // From Tom Davis's paper "Homogeneous Coordinates and Computer Graphics"
    // Except it's of no use to us whatsoever.
    // TODO: maybe move this to VecMath
    //

    //
    // Find homogeneous row matrix that takes
    // an augmented identity matrix to (some multiples of) out:
    //     1 0 0 0  p00 p01 p02 p03  =  k0 x0  k0 y0  k0 z0  k0 w0
    //     0 1 0 0  p10 p11 p12 p13     k1 x1  k1 y1  k1 z1  k1 w1
    //     0 0 1 0  p20 p21 p22 p23     k2 x2  k2 y2  k2 z2  k2 w2
    //     0 0 0 1  p30 p31 p32 p33     k3 x3  k3 y3  k3 z3  k3 w3
    //     1 1 1 1                         x4     y4     z4     w4
    // Multiplying out the matrix on the left:
    //           p00             p01             p02             p03
    //           p10             p11             p12             p13
    //           p20             p21             p22             p23
    //           p30             p31             p32             p33
    //     p00+p10+p20+p30 p01+p11+p21+p31 p02+p12+p22+p32 p03+p13+p23+p33
    // Equating the top 4x4 matrix on left and right
    // lets us express all the pij's in terms of k's and x,y,z's.
    // Equating the last row on the left to the last row on the right:
    //     k0 x0 + k1 x1 + k2 x2 + k3 x3 = x4
    //     k0 y0 + k1 y1 + k2 y2 + k3 y3 = y4
    //     k0 z0 + k1 z1 + k2 z2 + k3 z3 = z4
    //     k0 w0 + k1 w1 + k2 w2 + k3 w3 = w4
    // In other words,
    //     x0 x1 x2 x3 * k0 = x4
    //     y0 y1 y2 y3   k1   y4
    //     z0 z1 z2 z3   k2   z4
    //     w0 w1 w2 w3   k3   w4
    // i.e.
    //    k0 k1 k2 k3 * x0 y0 z0 w0 = x4 y4 z4 w4
    //                  x1 y1 z1 w1
    //                  x2 y2 z2 w2
    //                  x3 y3 z3 w3
    //
    private static double[/*d+1*/][/*d+1*/] rowProjectiveMatrixFromTiePointsHelper(double out[/*d+2*/][/*d+1*/])
    {
        int d = out.length - 2;
        double allButLastOut[][] = (double[][])Arrays.subarray(out, 0, d+1);
        double lastOut[] = out[d+1];
        double k[] = VecMath.vxinvm(lastOut, allButLastOut);
        double answer[][] = new double[d+1][d+1];
        FORI (i, d+1)
            VecMath.sxv(answer[i], k[i], out[i]);
        return answer;
    } // rowProjectiveMatrixFromTiePointsHelper

    public static double[/*d+1*/][/*d+1*/] rowProjectiveMatrixFromTiePoints(double in[/*d+2*/][/*d+1*/],
                                                              double out[/*d+2*/][/*d+1*/])
    {
        // answer is P^-1 Q where
        // P is matrix that takes "identity" to in
        // Q is matrix that takes "identity" to out
        double P[][] = rowProjectiveMatrixFromTiePointsHelper(in);
        double Q[][] = rowProjectiveMatrixFromTiePointsHelper(out);
        return VecMath.invmxm(P,Q);
    } // projectiveMatrixFromTiePoints

    private static void testRowProjectiveMatrixFromTiePoints(double in[][], double out[][])
    {
        System.out.println("===================================");
        PRINTMAT(in);
        PRINTMAT(out);
        double answer[][] = rowProjectiveMatrixFromTiePoints(in, out);
        PRINTMAT(answer);
        double shouldBeMultiplesOfOut[][] = VecMath.mxm(in, answer);
        PRINTMAT(shouldBeMultiplesOfOut);
        double outNormalized[][] = new double[out.length][out.length-1];
        double shouldBeOutNormalized[][] = new double[out.length][out.length-1];
        FORI (i, out.length)
        {
            VecMath.normalize(outNormalized[i], out[i]);
            VecMath.normalize(shouldBeOutNormalized[i], shouldBeMultiplesOfOut[i]);
            if (VecMath.dot(outNormalized[i], shouldBeOutNormalized[i]) < 0.)
                VecMath.sxv(shouldBeOutNormalized[i], -1., shouldBeOutNormalized[i]);
        }
        PRINTMAT(outNormalized);
        PRINTMAT(shouldBeOutNormalized);
        FORI (i, out.length)
        {
            double dist = VecMath.dist(outNormalized[i], shouldBeOutNormalized[i]);
            PRINT(dist);
            assert(dist <= 1e-12);
        }
        System.out.println("===================================");
    } // testRowProjectiveMatrixFromTiePoints



    //
    // Half-assed clone.
    // just runs main again,
    // and copies the original mesh to the new one.
    //
    public void cloneApplet()
    {
        System.out.println("    in cloneApplet");
        ShephardsPlayApplet clonedApplet = main0(new String[0]);
        clonedApplet.mesh = new Mesh(this.mesh); // dup it

        // Now try to copy as much state as possible.  Hack hack hack
        java.lang.reflect.Field fields[] = this.getClass().getDeclaredFields();
        System.out.println("        "+fields.length+" fields:");
        FORI (iField, fields.length)
        {
            java.lang.reflect.Field field = fields[iField];
            System.out.println("            "+field.getName());
            int modifiers = field.getModifiers();
            Class type = field.getType();
            String typeName = type.getName();
            System.out.println("                modifiers: "+field.getModifiers());
            System.out.println("                string: "+field.toString());
            System.out.println("                type: "+type);
            if ((modifiers & java.lang.reflect.Modifier.FINAL) != 0)
                continue; // it's final, can't set, and doesn't matter anyway
            if ((modifiers & java.lang.reflect.Modifier.STATIC) != 0)
                continue; // it's static, can't copy from one instance to another
            try
            {
                if (type.isPrimitive())
                {
                    // clonedApplet.field = this.field;
                    field.set(clonedApplet, field.get(this));
                }
                else if (type.isArray())
                {
                    Class ultimateComponentType = type.getComponentType();
                    while (ultimateComponentType.isArray())
                        ultimateComponentType = ultimateComponentType.getComponentType();
                    if (ultimateComponentType.isPrimitive())
                    {
                        // clonedApplet.field = Arrays.copy(this.field, 100);
                        //field.set(clonedApplet, field.get(this)); // no, want a deep copy
                        //field.set(clonedApplet, Arrays.copy(field.get(this), 100)); // XXX wtf? doesn't work?
                        //field.set(clonedApplet, Arrays.copy(field.get(this), 1)); // XXX wtf? doesn't work?
                        field.set(clonedApplet, Arrays.copy(field.get(this), 0)); // XXX wtf? works?  but I want a deep copy!
                    }
                    else
                    {
                        assert(false);
                        // good, there aren't any of these
                    }
                }
                else if (Listenable.class.isAssignableFrom(type))
                {
                    //clonedApplet.field.set(this.field.get())
                    ((Listenable)field.get(clonedApplet)).set((Listenable)field.get(this));
                }
                else
                {
                    // leave it alone (leave clonedApplet with initial field value)
                }
            }
            catch (IllegalAccessException e)
            {
                System.out.println("Hey! wtf? IllegalAccessException!");
            }

        }

        // set window title.  have to do this AFTER all the Listenables,
        // otherwise it will get clobbered.
        clonedApplet.windowTitle.set("clone of " + this.windowTitle.get());

        System.out.println("    out cloneApplet");

    } // cloneApplet




    //
    // Main...
    //
    public static ShephardsPlayApplet main0(final String args[])
    {
        System.out.println("in main0");
        System.out.println("    java "+System.getProperty("java.version"));


        if (false)
        {
            // test projectiveMatrixFromTiePoints
            double I0[][] = {
                {1},
                {1},
            };
            double I1[][] = {
                {1,0},
                {0,1},
                {1,1},
            };
            double I2[][] = {
                {1,0,0},
                {0,1,0},
                {0,0,1},
                {1,1,1},
            };
            double I3[][] = {
                {1,0,0,0},
                {0,1,0,0},
                {0,0,1,0},
                {0,0,0,1},
                {1,1,1,1},
            };
            testRowProjectiveMatrixFromTiePoints(I0,I0);
            testRowProjectiveMatrixFromTiePoints(I1,I1);
            testRowProjectiveMatrixFromTiePoints(I2,I2);
            testRowProjectiveMatrixFromTiePoints(I3,I3);
            testRowProjectiveMatrixFromTiePoints(I0,VecMath.sxm(10.,I0));
            testRowProjectiveMatrixFromTiePoints(I1,VecMath.sxm(10.,I1));
            testRowProjectiveMatrixFromTiePoints(I2,VecMath.sxm(10.,I2));
            testRowProjectiveMatrixFromTiePoints(I3,VecMath.sxm(10.,I3));
            for (int d = 0; d <= 4; ++d)
            {
                double in[][] = new double[d+2][d+1];
                double out[][] = new double[d+2][d+1];
                FORI (i, in.length)
                    VecMath.random(in[i]);
                FORI (i, out.length)
                    VecMath.random(out[i]);
                testRowProjectiveMatrixFromTiePoints(in, out);
            }

            if (false) // this just doesn't work with tiepoints!  TODO: fails really ungracefully in luDecompose though, should fix that
            {
                // into an ellipse
                double t = .5;
                testRowProjectiveMatrixFromTiePoints(new double[][] {
                    {-1,0,1},
                    {0,0,1},
                    {1,0,1},
                    {0,1,1},
                }, new double[][] {
                    {-1,0,1},
                    {t,0,1},
                    {1,0,1},
                    {t,1,1},
                });
            }

            System.exit(0);
        }

        if (false)
        {
            // test computeSymmetryGroup3d
            int pqs[][] = {
                {1,1},
                {1,2},
                {2,1},
                {1,3},
                {3,1},
                {1,4},
                {4,1},
                {1,5},
                {5,1},
                {1,6},
                {6,1},

                {2,2},
                {2,3},
                {3,2},
                {2,4},
                {4,2},
                {2,5},
                {5,2},
                {2,6},
                {6,2},

                {3,3},
                {3,4},
                {4,3},
                {3,5},
                {5,3},
            };

            FORI (iCentralSymmetry, 2)
            FORI (iLeftRightSymmetry, 2)
            {
                boolean centralSymmetry = iCentralSymmetry==1;
                boolean leftRightSymmetry = iLeftRightSymmetry==1;
                FORI (i, pqs.length)
                {
                    int p = pqs[i][0];
                    int q = pqs[i][1];
                    {
                        System.out.println("    testing computeSymmetryGroup3d(p="+p+", q="+q+", leftRight="+leftRightSymmetry+", central="+centralSymmetry);
                        computeSymmetryGroup3d(p, q, leftRightSymmetry, centralSymmetry);
                    }
                }
            }
            return null;
        } // test computeSymmetryGroup3d

        final ShephardsPlayApplet applet = new ShephardsPlayApplet();

        final JFrame frame = new JFrame(applet.windowTitle.get());

        //frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // supposedly exists since java 1.4, but I can see starting in 1.3, weird
        com.donhatchsw.awt.MainWindowCount.setExitOnLastClose(frame);

        frame.getContentPane().add(applet);

        //dumpComponentHierarchy(frame, 0, 0, 1);

        // the following seems to be necessary, or getParameter() will crash, at least in 1.4.  Want to send params from command line anyway.
        applet.setStub(new java.applet.AppletStub() {
             public void appletResize(int width, int height)
                 { /* should resize frame, but a ShephardsPlayApplet never asks to be resized */ }
             public java.applet.AppletContext getAppletContext() { return null;}
             public java.net.URL getCodeBase() { return null; }
             public java.net.URL getDocumentBase() { return null; }
             public String getParameter(String name)
             {
                 // case insensitive... and unfortunately there's no
                 // startsWithIgnoreCase
                 String prefix = name.toLowerCase() + "=";
                 int i;
                 FOR (i, args.length)
                     if (args[i].toLowerCase().startsWith(prefix))
                         return args[i].substring(prefix.length());
                 return null;
             }
             public boolean isActive() { return true; }
        });

        applet.init();
        applet.start();

        frame.setLocation(10, 10);
        frame.setSize(720, 745);
        //frame.setSize(300,300);

        frame.setVisible(true);

        applet.theMainAppletWindow = frame;


        // for benefit of any debugging function that wants to loop over frames...
        applet.theControlPanelWindow.setName("control panel window");
        applet.theMainAppletWindow.setName("main applet window");
        applet.theHelpWindow.setName("help");

        System.out.println("out main0");
        return applet;
    } // main0

    public static void main(final String args[])
    {
        ShephardsPlayApplet applet = main0(args);
        // release main's token
        com.donhatchsw.awt.MainWindowCount.decrementAndExitIfImTheLastOne();
    } // main

} // class ShephardsPlayApplet
