/*
Trying to make a little applet
that will let me play with triangulations with heights,
and produce the dual diagrams with heights.

For starters, always triangulates entire convex hull.
User should be able to:
    left click - add a vertex
                   - if inside a triangle, trisects the triangle
                   - if outside the convex hull, connects up
                     to all visible other vertices
    right click - delete a vertex that's on the convex hull
                  or that's only connected to three neighbors
    middle drag - move a vertex
    's' - swap a diagonal

TO DO:
    - save/load
    - simple translation from simple lists and back... creating that sample scene was a nightmare!
    - fix optimization problem
    - figure out simpler math behind the mapping from vert heights to edge lengths
    - animation of optimization
    - animation of swap
    - animation of delete vertex (maybe-- might have to triangulate the face to get this to work, which wouldn't be a bad thing)
    - key to delaunayize?
    - don't draw crap when resizing (and fix whatever other applet I got this from too)
    - figure out why stack traces show .java on top even after renumbering
    - gui
    - write a generic applet to reduce pain each time
    - other mesh editing operations (split face by edge, split edge by vertex, join adjacent vertices, separate a vertex into two (but how to assign the neighbors?))  (idea: same interface as split face by edge... but only works if on two different faces... maybe connec dual verts?)
    - BUG: figure out how to make it not repaint continuously when resizing (my other appets too)
    - BUG: when only part of window gets exposed, only the exposed part gets painted?  hmm, not sure I have control over this
    - look at this, maybe clues about positive octant penalty functions...
        http://www.cs.indiana.edu/~yingfeng/ABSURDIST/javadoc/penalty/PenaltyMinimizer.html
      something about "translating into a positive orthant problem" and "optimizing over the positive orthant"
      intersection of a linear subspace witht the positive orthant
      http://projecteuclid.org/Dienst/UI/1.0/Summarize/euclid.mmj/1028988894
      The knee-jerk mapping:
      http://www.math.dartmouth.edu/~doyle/docs/jerk/jerk.pdf
*/

#include "macros.h"

// So can compile in pre-1.4,
// we use these instead of java.awt.event.MouseEvent.BUTTON1 etc.
#define java_awt_event_MouseEvent_BUTTON1 1
#define java_awt_event_MouseEvent_BUTTON2 2
#define java_awt_event_MouseEvent_BUTTON3 3


import com.donhatchsw.util.Arrays;
import com.donhatchsw.util.VecMath;
import com.donhatchsw.util.SortStuff;
import com.donhatchsw.util.ConvexHull;
import com.donhatchsw.util.LinearProgramming;
import com.donhatchsw.util.UndoTreeSquirrel;
import com.donhatchsw.util.TriangulationOptimizer;
import com.donhatchsw.compat.ArrayList;

public class ShephardsPlayApplet
    extends java.applet.Applet
    implements java.awt.event.MouseListener,
               java.awt.event.MouseMotionListener,
               java.awt.event.KeyListener
{
    //
    // Utilities for applet stuff...
    //
        private String getParameterString(String paramName,
                                       String defaultValue)
        {
            String paramValueString = getParameter(paramName);
            if (paramValueString != null)
                return paramValueString;
            else
                return defaultValue;
        }
        private int getParameterInt(String paramName,
                                    int defaultValue)
        {
            String paramValueString = getParameter(paramName);
            if (paramValueString != null)
            {
                try
                {
                    return Integer.decode(paramValueString).intValue();
                }
                catch (NumberFormatException e)
                {
                    return 0;
                }
            }
            else
                return defaultValue;
        }
        private double getParameterDouble(String paramName,
                                          double defaultValue)
        {
            String paramValueString = getParameter(paramName);
            if (paramValueString != null)
            {
                try
                {
                    return Double.parseDouble(paramValueString);
                }
                catch (NumberFormatException e)
                {
                    return 0;
                }
            }
            else
                return defaultValue;
        }
        private boolean getParameterBoolean(String paramName,
                                            boolean defaultValue)
        {
            String paramValueString = getParameter(paramName);
            if (paramValueString != null)
            {
                // Too simplistic, only honors case-sensitive "true"
                //return Boolean.valueOf(paramValueString).booleanValue();

                try
                {
                    int n = Integer.decode(paramValueString).intValue();
                    return n != 0;
                }
                catch (NumberFormatException e)
                {
                    if (paramValueString.equalsIgnoreCase("true")
                     || paramValueString.equalsIgnoreCase("yes")
                     || paramValueString.equalsIgnoreCase("t")
                     || paramValueString.equalsIgnoreCase("y"))
                        return true;
                    return false;
                }
            }
            else
                return defaultValue;
        }

    //
    // Implementing Applet methods...
    //
        ShephardsPlayApplet()
        {
            setLayout(new java.awt.GridBagLayout());
        } // ShephardsPlayApplet ctor

        public void init()
        {
            eventVerbose = getParameterInt("EventVerbose", eventVerbose);
            if (eventVerbose >= 1) System.out.println("in init");

            // These (and eventVerbose) can be specified on the command line as, e.g. doLabels=true
            doLabels = getParameterBoolean("doLabels", doLabels);
            doOptimize = getParameterBoolean("doOptimize", doOptimize);
            doShowPositiveOrthantnessVisualization = getParameterBoolean("doShowPositiveOrthantnessVisualization", doShowPositiveOrthantnessVisualization);
            // XXX this is kind of messed up, we don't get to know whether the user misspelled something

            // Specify an "event listener" object
            // to respond to events.
            // (>= Java 1.1 event model).
            this.addMouseListener(this);
            this.addMouseMotionListener(this);
            this.addKeyListener(this);

            graphicsAntiAliasingSetter = new GraphicsAntiAliasingSetter();

            //doCannedThingHexesSpiral(); // XXX get rid of this probably
            //doCannedThingNetless9(); // XXX get rid of this probably
            //doCannedThingEyeball(); // XXX get rid of this probably
            doCannedThingNetless8(); // XXX get rid of this probably

            if (eventVerbose >= 1) System.out.println("out init");
        } // init

        public void start()
        {
            if (eventVerbose >= 1) System.out.println("in start");
            if (eventVerbose >= 1) System.out.println("out start");
        }
        public void stop()
        {
            if (eventVerbose >= 1) System.out.println("in stop");
            if (eventVerbose >= 1) System.out.println("out stop");
        }
        public void destroy()
        {
            if (eventVerbose >= 1) System.out.println("in destroy");
            if (eventVerbose >= 1) System.out.println("out destroy");
        }

        //
        // Button behavor changed incompatibly between Java 1.1 and 1.4
        // (not sure exactly what version it changed in though).
        // (I think it was 1.4 since that's when getButton() was added
        // to MouseEvent).
        //
        private static int getButton(java.awt.event.MouseEvent e)
        {
            // gag me! we can't even query the java spec version number
            // since System.getProperty() throws a security exception
            // in netscape!
            // so use empirical evidence...
            int mods = e.getModifiers();
#if 0 // can't seem to get this to work under IE at all, so don't try for now, it will just be wrong under 1.4
            boolean is_1_4_or_greater = ((mods & ~0x1fff) != 0);
            if (is_1_4_or_greater)
            {
                try
                {
                    return e.getButton();
                }
                catch (NoSuchMethodError err)
                {
                    // this only happens in IE, not netscape. fall through...
                }
            }
#endif

            if ((mods & java.awt.event.InputEvent.ALT_MASK) != 0)
                return java_awt_event_MouseEvent_BUTTON2;
            if ((mods & java.awt.event.InputEvent.META_MASK) != 0)
                return java_awt_event_MouseEvent_BUTTON3;
            return java_awt_event_MouseEvent_BUTTON1;
        } // getButton

        //
        // MouseListener and MouseMotionListener methods...
        // 
        public void mousePressed(java.awt.event.MouseEvent e)
        {
            if (eventVerbose >= 1) System.out.println("in mousePressed: "+e);
            if (eventVerbose >= 1)
            {
                if (getButton(e) == java_awt_event_MouseEvent_BUTTON1)
                    System.out.println("    (left mouse)");
                if (getButton(e) == java_awt_event_MouseEvent_BUTTON2)
                    System.out.println("    (middle mouse)");
                if (getButton(e) == java_awt_event_MouseEvent_BUTTON3)
                    System.out.println("    (right mouse)");
            }

            double thisP[] = new double[2];
            mostRecentGraphics.pick(e.getX(), e.getY(), thisP);

            stateWhenPressed = new UndoItem.State(mesh, doOptimize, optimizationTypeIndex);

            int whichButton = getButton(e);
            if (whichButton == java_awt_event_MouseEvent_BUTTON1)
            {
                button1IsDown = true;

                if (e.isControlDown())
                {
                    //
                    // Add an edge from the closest vertex
                    //
                    System.out.println("    Adding an edge at "+thisP[0]+" "+thisP[1]+" "+0+"");

                    //
                    // If there are no vertices, add one
                    //
                    ArrayList verts = mesh.verts;
                    if (verts.size() == 0)
                    {
                        System.out.println("        (Adding a vertex first)");
                        mesh.addIsolatedVertex(thisP[0], thisP[1], 0);
                    }

                    //
                    // Select closest vertex
                    //
                    selectedVertIndex = mesh.indexOfClosestVert(thisP[0],thisP[1]);
                    rubberBandingNewEdge = true;
                }
                else // control is not down
                {
                    //
                    // Add a vertex
                    //
                    System.out.println("    Adding a vertex at "+thisP[0]+" "+thisP[1]+" "+0+"");
                    mesh.addIsolatedVertex(thisP[0], thisP[1], 0);

                    ArrayList verts = mesh.verts;
                    ArrayList edges = mesh.edges;
                    if (verts.size() >= 2)
                    {
                        //
                        // If are no edges at all, add an edge.
                        // XXX this is kind of lame when there were more than one isolated vertex, should connect to them all
                        //
                        if (edges.size() == 0)
                        {
                            System.out.println("Adding an edge between two verts");
                            mesh.addEdgeBetweenTwoIsolatedVertices((Mesh.Vertex)verts.get(verts.size()-2),
                                                                   (Mesh.Vertex)verts.get(verts.size()-1));
                        }
                        else // edges.size() >= 1
                        {
                            // There was already an edge.
                            // Find out which face we are on
                            // (all triangles CCW), and kis that face.
                            // if we are not inside any face by that criterion,
                            // then assume we are inside the outer face
                            // and connect the new vertex to every vertex
                            // that's visible from it.
                            //
                            boolean kissed = false;
                            double twiceMostNegativeFaceArea = Double.POSITIVE_INFINITY;
                            Mesh.Edge edgeOnMostNegativeFace = null;
                            // XXX traverses each face of size n n times!  need to keep track of what we've done already
                            int nEdges = mesh.edges.size();
                            FORI (iEdge, nEdges)
                            {
                                boolean thisFaceIsGoodSoFar = true;
                                Mesh.Edge edgeI = (Mesh.Edge)mesh.edges.get(iEdge);
                                double twiceThisFaceArea = 0.;
                                for (Mesh.Edge edge = edgeI;;)
                                {
                                    double twiceThisTriArea = twiceTriArea(
                                                            thisP[0],thisP[1],
                                                            edge.initialVertex().x,
                                                            edge.initialVertex().y,
                                                            edge.finalVertex().x,
                                                            edge.finalVertex().y);
                                    if (twiceThisTriArea < 0)
                                    {
                                        thisFaceIsGoodSoFar = false; // it's bad!
                                    }
                                    twiceThisFaceArea += twiceThisTriArea;

                                    if ((edge = edge.next()) == edgeI)
                                        break;
                                }
                                if (thisFaceIsGoodSoFar)
                                {
                                    // I'm inside this face;
                                    // kis it and done
                                    mesh.kisIsolatedVertex((Mesh.Vertex)verts.get(verts.size()-1),
                                                           edgeI);
                                    kissed = true;
                                    break;
                                }
                                if (twiceThisFaceArea < twiceMostNegativeFaceArea)
                                {
                                    twiceMostNegativeFaceArea = twiceThisFaceArea;
                                    edgeOnMostNegativeFace = edgeI;
                                }
                            }
                            if (!kissed)
                            {
                                System.out.println("In the outer face");
                                //
                                // It wasn't inside any face.
                                // Assume it's in the outer face.
                                // In this case,
                                // make a kiss to the outer face
                                // and then delete all newly added edges
                                // that cross the boundary of the outer face.
                                //

                                ArrayList/*<Mesh.Edge>*/ oldOuterFaceBoundary = new ArrayList();
                                for (Mesh.Edge edge = edgeOnMostNegativeFace;;)
                                {
                                    oldOuterFaceBoundary.add(edge);
                                    if ((edge = edge.next()) == edgeOnMostNegativeFace)
                                        break;
                                }
                                int oldOuterFaceBoundarySize = oldOuterFaceBoundary.size();

                                int oldNumEdges = mesh.edges.size();
                                mesh.kisIsolatedVertex((Mesh.Vertex)verts.get(verts.size()-1),
                                                       edgeOnMostNegativeFace);
                                for (int iEdge = oldNumEdges;
                                     iEdge < mesh.edges.size();
                                     iEdge += 2) // only do one of an edge and its opposite
                                {
                                    for (int iOldBoundaryEdge = 0;
                                         iOldBoundaryEdge < oldOuterFaceBoundarySize;
                                         ++iOldBoundaryEdge)
                                    {
                                        Mesh.Edge oldEdge = (Mesh.Edge)oldOuterFaceBoundary.get(iOldBoundaryEdge);
                                        Mesh.Edge newEdge = (Mesh.Edge)mesh.edges.get(iEdge);

                                        if (newEdge.initialVertex() == oldEdge.initialVertex()
                                         || newEdge.initialVertex() == oldEdge.finalVertex()
                                         || newEdge.finalVertex() == oldEdge.initialVertex()
                                         || newEdge.finalVertex() == oldEdge.finalVertex())
                                            continue;
                                        //System.out.println("    Seeing whether new edge v"+newEdge.initialVertex().myIndex()+" -> v"+newEdge.finalVertex().myIndex()+" crosses old boundary edges v"+oldEdge.initialVertex().myIndex()+" -> v"+oldEdge.finalVertex().myIndex()+"");
                                        if (edgesCrossOrCloseToIt(
                                                        oldEdge.initialVertex().x,
                                                        oldEdge.initialVertex().y,
                                                        oldEdge.finalVertex().x,
                                                        oldEdge.finalVertex().y,
                                                        newEdge.initialVertex().x,
                                                        newEdge.initialVertex().y,
                                                        newEdge.finalVertex().x,
                                                        newEdge.finalVertex().y,
                                                        1e-6))
                                        {
                                            //System.out.println("        It does.");
                                            mesh.deleteEdge(newEdge);
                                            iEdge -= 2; // so we don't skip the one that gets moved into the deleted spot
                                            break;
                                        }
                                        else
                                        {
                                            //System.out.println("        It doesn't.");
                                        }
                                    }
                                }
                            }
                        } // if verts.length >= 3
                    } // if verts.size() >= 2 after adding the new vertex

                    mesh.sanityCheck();

                    selectedVertIndex = verts.size()-1;
                }
            }
            else if (whichButton == java_awt_event_MouseEvent_BUTTON2)
            {
                button2IsDown = true;

                //
                // Select closest vertex
                //
                selectedVertIndex = mesh.indexOfClosestVert(thisP[0],thisP[1]);

                System.out.println("Selected vertex "+selectedVertIndex+"");
            }
            else if (whichButton == java_awt_event_MouseEvent_BUTTON3)
            {
                button3IsDown = true;

                //
                // Delete closest vertex
                //
                selectedVertIndex = mesh.indexOfClosestVert(thisP[0],thisP[1]);
                if (selectedVertIndex != -1)
                    mesh.deleteVertex((Mesh.Vertex)mesh.verts.get(selectedVertIndex));
                selectedVertIndex = -1;

                mesh.sanityCheck();

            } // right mouse

            if (continuouslyDelaunayize) delaunayize();

            prevP = thisP;

            repaint();

            if (eventVerbose >= 1) System.out.println("out mousePressed: "+e);
        } // mousePressed
        public void mouseReleased(java.awt.event.MouseEvent e)
        {
            if (eventVerbose >= 1) System.out.println("in mouseReleased: "+e);

            double thisP[] = new double[2];
            mostRecentGraphics.pick(e.getX(), e.getY(), thisP);

            int whichButton = getButton(e);
            if (whichButton == java_awt_event_MouseEvent_BUTTON1)
            {
                if (rubberBandingNewEdge)
                {
                    if (mesh.verts.size() == 1)
                    {
                        mesh.addIsolatedVertex(thisP[0], thisP[1], 0);
                    }
                    int finalVertIndex = mesh.indexOfClosestVert(thisP[0],thisP[1]);
                    if (selectedVertIndex != -1
                     && finalVertIndex != -1
                     && selectedVertIndex != finalVertIndex)
                    {
                        System.out.println("Trying to add an edge between "+selectedVertIndex+" and "+finalVertIndex);
                        ArrayList verts = mesh.verts;
                        mesh.addEdgeBetweenTwoVertices((Mesh.Vertex)mesh.verts.get(selectedVertIndex),
                                                       (Mesh.Vertex)mesh.verts.get(finalVertIndex));
                        mesh.sanityCheck();
                    }
                }

                rubberBandingNewEdge = false;

                button1IsDown = false;
            }
            else if (whichButton == java_awt_event_MouseEvent_BUTTON2)
            {
                button2IsDown = false;
            }
            else if (whichButton == java_awt_event_MouseEvent_BUTTON3)
            {
                button3IsDown = false;
            }

            if (continuouslyDelaunayize) delaunayize();

            if (stateWhenPressed != null)
            {
                UndoItem.State stateWhenReleased = new UndoItem.State(mesh, doOptimize, optimizationTypeIndex);
                undoTreeSquirrel.Do(new UndoItem(stateWhenPressed, stateWhenReleased));
                stateWhenPressed = null;
            }

            prevP = thisP;

            repaint();

            if (eventVerbose >= 1) System.out.println("out mouseReleased: "+e);
        }
        public void mouseEntered(java.awt.event.MouseEvent e)
        {
            if (eventVerbose >= 1) System.out.println("in mouseEntered: "+e);
            if (eventVerbose >= 1) System.out.println("out mouseEntered: "+e);
        }
        public void mouseExited(java.awt.event.MouseEvent e)
        {
            if (eventVerbose >= 1) System.out.println("in mouseExited: "+e);
            if (eventVerbose >= 1) System.out.println("out mouseExited: "+e);
        }
        public void mouseClicked(java.awt.event.MouseEvent e)
        {
            if (eventVerbose >= 1) System.out.println("in mouseClicked: "+e);
            if (eventVerbose >= 1) System.out.println("out mouseClicked: "+e);
        }
        public void mouseDragged(java.awt.event.MouseEvent e)
        {
            if (eventVerbose >= 2) System.out.println("  in mouseDragged: "+e);

            double thisP[] = new double[2];
            mostRecentGraphics.pick(e.getX(), e.getY(), thisP);

            if (button1IsDown || button2IsDown)
            {
                if (rubberBandingNewEdge)
                {
                    // nothing, we'll just draw the rubberband in the new position when we repaint
                }
                else
                {
                    if (e.isShiftDown())
                    {
                        // Drag all the verts
                        FORIDOWN (iVert, mesh.verts.size())
                        {
                            ((Mesh.Vertex)mesh.verts.get(iVert)).x += thisP[0]-prevP[0];
                            ((Mesh.Vertex)mesh.verts.get(iVert)).y += thisP[1]-prevP[1];
                        }
                    }
                    else if (selectedVertIndex != -1)
                    {
                        // Drag just the selected vert
                        ((Mesh.Vertex)mesh.verts.get(selectedVertIndex)).x += thisP[0]-prevP[0];
                        ((Mesh.Vertex)mesh.verts.get(selectedVertIndex)).y += thisP[1]-prevP[1];
                        if (continuouslyDelaunayize) delaunayize();
                        if (nonEventVerbose >= 1)
                        {
                            double verts[][] = new double[mesh.verts.size()][];
                            FORIDOWN (iVert, mesh.verts.size())
                                verts[iVert] = new double[] {((Mesh.Vertex)mesh.verts.get(iVert)).x,
                                                             ((Mesh.Vertex)mesh.verts.get(iVert)).y,
                                                             ((Mesh.Vertex)mesh.verts.get(iVert)).h};
                            int edges[][] = new int[mesh.edges.size()][];
                            FORIDOWN (iEdge, mesh.edges.size())
                                edges[iEdge] = new int[] {((Mesh.Edge)mesh.edges.get(iEdge)).initialVertex().myIndex(),
                                                          ((Mesh.Edge)mesh.edges.get(iEdge)).finalVertex().myIndex()};
                            PRINTARRAY(verts);
                            PRINTARRAY(edges);
                        }
                    }
                }
            }

            if (button3IsDown) // right mouse
            {
            }

            repaint();

            prevP = thisP;

            if (eventVerbose >= 2) System.out.println("  out mouseDragged: "+e);
        }
        public void mouseMoved(java.awt.event.MouseEvent e)
        {
            if (eventVerbose >= 3) System.out.println("    in mouseMoved: "+e);

            if (mostRecentGraphics != null)
            {
                double thisP[] = new double[2];
                mostRecentGraphics.pick(e.getX(), e.getY(), thisP);
                prevP = thisP;
            }

            if (eventVerbose >= 3) System.out.println("    out mouseMoved: "+e);
        }

        //
        // KeyListener methods...
        //
        public void keyPressed(java.awt.event.KeyEvent e)
        {
            if (eventVerbose >= 1) System.out.println("in keyPressed: "+e);
            double incr = .005;
            switch(e.getKeyCode())
            {
                case java.awt.event.KeyEvent.VK_UP:
                {
                    UndoItem.State before = new UndoItem.State(mesh, doOptimize, optimizationTypeIndex);
                    if (doOptimize)
                    {
                        doOptimize ^= true;
                        System.out.println("doOptimize -> "+doOptimize+" ('O' to turn back on)");
                    }
                    System.out.print("Up");
                    System.out.flush();
                    int iVert = mesh.indexOfClosestVert(prevP[0], prevP[1]);
                    if (e.isShiftDown())
                        ((Mesh.Vertex)mesh.verts.get(iVert)).h += incr*10;
                    else if (e.isControlDown())
                        ((Mesh.Vertex)mesh.verts.get(iVert)).h += incr*.1;
                    else
                        ((Mesh.Vertex)mesh.verts.get(iVert)).h += incr;
                    if (continuouslyDelaunayize) delaunayize();
                    UndoItem.State after = new UndoItem.State(mesh, doOptimize, optimizationTypeIndex);
                    undoTreeSquirrel.Do(new UndoItem(before, after));
                    repaint();
                    break;
                }
                case java.awt.event.KeyEvent.VK_DOWN:
                {
                    UndoItem.State before = new UndoItem.State(mesh, doOptimize, optimizationTypeIndex);
                    if (doOptimize)
                    {
                        doOptimize ^= true;
                        System.out.println("doOptimize -> "+doOptimize+" ('O' to turn back on)");
                    }
                    System.out.print("Down");
                    System.out.flush();
                    int iVert = mesh.indexOfClosestVert(prevP[0], prevP[1]);
                    if (e.isShiftDown())
                        ((Mesh.Vertex)mesh.verts.get(iVert)).h -= incr*10;
                    else if (e.isControlDown())
                        ((Mesh.Vertex)mesh.verts.get(iVert)).h -= incr*.1;
                    else
                        ((Mesh.Vertex)mesh.verts.get(iVert)).h -= incr;
                    if (continuouslyDelaunayize) delaunayize();
                    UndoItem.State after = new UndoItem.State(mesh, doOptimize, optimizationTypeIndex);
                    undoTreeSquirrel.Do(new UndoItem(before, after));
                    repaint();
                    break;
                }
                case java.awt.event.KeyEvent.VK_LEFT:
                {
                    if (e.isShiftDown())
                        translateFudgeX -= 1;
                    else if (e.isControlDown())
                        translateFudgeX -= .01;
                    else
                        translateFudgeX -= .1;
                    System.out.println("translateFudgeX -> "+translateFudgeX);
                    repaint();
                    break;
                }
                case java.awt.event.KeyEvent.VK_RIGHT:
                {
                    if (e.isShiftDown())
                        translateFudgeX += 1;
                    else if (e.isControlDown())
                        translateFudgeX += .01;
                    else
                        translateFudgeX += .1;
                    System.out.println("translateFudgeX -> "+translateFudgeX);
                    repaint();
                    break;
                }

                default:
                    break;
            }
            if (eventVerbose >= 1) System.out.println("out keyPressed: "+e);
        }
        public void keyReleased(java.awt.event.KeyEvent e)
        {
            if (eventVerbose >= 1) System.out.println("in keyReleased: "+e);
            if (eventVerbose >= 1) System.out.println("out keyReleased: "+e);
        }
        public void keyTyped(java.awt.event.KeyEvent e)
        {
            if (eventVerbose >= 1) System.out.println("in keyTyped: "+e);
            char c = e.getKeyChar();

            // In java 1.6, apparently ctrl-letter
            // started coming out as just the letter
            // (with ke.isControlDown() true).
            // Detect this and change it to the old behavior...
            // XXX need to do something else, or nothing at all here, for old javas (1.1) in which isControlDown doesn't exist... or else just stop trying to support 1.1 at all
            if (c >= 'a' && c <= 'z' && e.isControlDown())
            {
                c -= ('a'-1);
            }

#define CTRL(lowerCaseLetter) ((lowerCaseLetter)-'a' + 1)
            switch (c)
            {
                case 'V': // cycle verbosity-- upper-case to minimize possibility of hitting it by accident thus causing subsequent perfomance degradation with no visible reason if Java Console is not visible
                    System.out.print("eventVerbose "+eventVerbose);
                    eventVerbose = (eventVerbose+1) % 4;
                    System.out.println(" -> "+eventVerbose);
                    break;

                case ' ': // just repaint (i.e. mark dirty)
                    repaint();
                    break;
                case 'A': // toggle doAntiAliasing
                    doAntiAliasing ^= true;
                    System.out.println("doAntiAliasing -> "+doAntiAliasing+" (if this platform supports it)");
                    repaint();
                    break;

                case 't': // toggle showTriangles
                    System.out.print("showTriangles "+showTriangles);
                    showTriangles = MOD(showTriangles-1, 3);
                    System.out.println(" -> "+showTriangles);
                    repaint();
                    break;

                case 'B': // toggle doDoubleBuffer
                    doDoubleBuffer ^= true;
                    System.out.println("doDoubleBuffer -> "+doDoubleBuffer);
                    repaint();
                    break;

                case 'i': case '+': case '=': // zoom in
                {
                    UndoItem.State before = new UndoItem.State(mesh, doOptimize, optimizationTypeIndex);
                    double scale = Math.sqrt(2.);
                    FORIDOWN (iVert, mesh.verts.size())
                    {
                        Mesh.Vertex vert = (Mesh.Vertex)mesh.verts.get(iVert);
                        vert.x *= scale;
                        vert.y *= scale;
                        vert.h *= scale*scale;
                    }
                    translateFudgeX *= scale;
                    translateFudgeY *= scale;

                    // should be no need to re-delaunayize
                    UndoItem.State after = new UndoItem.State(mesh, doOptimize, optimizationTypeIndex);
                    undoTreeSquirrel.Do(new UndoItem(before, after));
                    repaint();
                    break;
                }
                case 'o': case '-':           // zoom out
                {
                    UndoItem.State before = new UndoItem.State(mesh, doOptimize, optimizationTypeIndex);
                    double scale = Math.sqrt(.5);
                    FORIDOWN (iVert, mesh.verts.size())
                    {
                        Mesh.Vertex vert = (Mesh.Vertex)mesh.verts.get(iVert);
                        vert.x *= scale;
                        vert.y *= scale;
                        vert.h *= scale*scale;
                    }
                    translateFudgeX *= scale;
                    translateFudgeY *= scale;
                    // should be no need to re-delaunayize
                    UndoItem.State after = new UndoItem.State(mesh, doOptimize, optimizationTypeIndex);
                    undoTreeSquirrel.Do(new UndoItem(before, after));
                    repaint();
                    break;
                }

                case 's': // swap diagonal
                {
                    UndoItem.State before = new UndoItem.State(mesh, doOptimize, optimizationTypeIndex);
                    int closestEdgeIndex = mesh.indexOfClosestEdge(prevP[0],prevP[1]);
                    if (closestEdgeIndex != -1)
                    {
                        System.out.println("Swapping diagonal edge e"+closestEdgeIndex);
                        mesh.swapDiagonal((Mesh.Edge)mesh.edges.get(closestEdgeIndex), false, true);
                        mesh.sanityCheck();
                    }
                    if (continuouslyDelaunayize) delaunayize();
                    UndoItem.State after = new UndoItem.State(mesh, doOptimize, optimizationTypeIndex);
                    undoTreeSquirrel.Do(new UndoItem(before, after));
                    repaint();
                    break;
                }

                case CTRL('s'): // swap diagonal but only if it makes it closer to delaunay
                {
                    // Swap diagonal but only if it makes it closer to delaunay
                    UndoItem.State before = new UndoItem.State(mesh, doOptimize, optimizationTypeIndex);
                    if (e.isShiftDown())
                        delaunayize();
                    else
                    {
                        int closestEdgeIndex = mesh.indexOfClosestEdge(prevP[0],prevP[1]);
                        if (closestEdgeIndex != -1)
                        {
                            System.out.println("Swapping diagonal edge e"+closestEdgeIndex);
                            mesh.swapDiagonal((Mesh.Edge)mesh.edges.get(closestEdgeIndex), true, true);
                            mesh.sanityCheck();
                        }
                        if (continuouslyDelaunayize) delaunayize(); // silly, it will just undo the swap in this case
                    }
                    UndoItem.State after = new UndoItem.State(mesh, doOptimize, optimizationTypeIndex);
                    undoTreeSquirrel.Do(new UndoItem(before, after));
                    repaint();
                    break;
                }

                case 'd': // delete closest edge
                {
                    UndoItem.State before = new UndoItem.State(mesh, doOptimize, optimizationTypeIndex);
                    int closestEdgeIndex = mesh.indexOfClosestEdge(prevP[0],prevP[1]);
                    if (closestEdgeIndex != -1)
                    {
                        System.out.println("Deleting edge e"+closestEdgeIndex);
                        mesh.deleteEdge((Mesh.Edge)mesh.edges.get(closestEdgeIndex));
                        mesh.sanityCheck();
                    }
                    if (continuouslyDelaunayize) delaunayize();
                    UndoItem.State after = new UndoItem.State(mesh, doOptimize, optimizationTypeIndex);
                    undoTreeSquirrel.Do(new UndoItem(before, after));
                    repaint();
                    break;
                }
                case 'S': // turn off optimize, and re-sphereize
                {
                    UndoItem.State before = new UndoItem.State(mesh, doOptimize, optimizationTypeIndex);
                    if (doOptimize)
                    {
                        doOptimize ^= true;
                        System.out.println("doOptimize -> "+doOptimize+" ('O' to turn back on)");
                    }
                    FORIDOWN (iVert, mesh.verts.size())
                        ((Mesh.Vertex)mesh.verts.get(iVert)).h = 0.;
                    if (continuouslyDelaunayize) delaunayize();
                    UndoItem.State after = new UndoItem.State(mesh, doOptimize, optimizationTypeIndex);
                    undoTreeSquirrel.Do(new UndoItem(before, after));
                    repaint();
                    break;
                }

                case 'l': // toggle doLabels
                    doLabels ^= true;
                    System.out.println("doLabels -> "+doLabels);
                    repaint();
                    break;

                case 'O': // toggle doOptimize
                {
                    UndoItem.State before = new UndoItem.State(mesh, doOptimize, optimizationTypeIndex);
                    doOptimize ^= true;
                    System.out.println("doOptimize -> "+doOptimize);
                    if (continuouslyDelaunayize) delaunayize();
                    UndoItem.State after = new UndoItem.State(mesh, doOptimize, optimizationTypeIndex);
                    undoTreeSquirrel.Do(new UndoItem(before, after));
                    repaint();
                    break;
                }

                case 'a': // toggle doArrowsTowardsSharpestDihedrals or doArrowsTowardsShortestEdges
                {
                    if (e.isAltDown())
                    {
                        doArrowsTowardsShortestEdges ^= true;
                        System.out.println("doArrowsTowardsShortestEdges -> "+doArrowsTowardsShortestEdges);
                    }
                    else
                    {
                        doArrowsTowardsSharpestDihedrals ^= true;
                        System.out.println("doArrowsTowardsSharpestDihedrals -> "+doArrowsTowardsSharpestDihedrals);
                    }
                    repaint();
                    break;
                }


                case 'u': case CTRL('z'): // undo
                {
                    UndoItem item = (UndoItem)undoTreeSquirrel.undo();
                    if (item != null)
                    {
                        mesh = new Mesh(item.before.mesh);
                        doOptimize = item.before.doOptimize;
                        optimizationTypeIndex = item.before.optimizationTypeIndex;
                        optimizationType = availableOptimizationTypes[optimizationTypeIndex];
                    }
                    else
                    {
                        System.out.println("Nothing to undo!");
                    }
                    repaint();
                    break;
                }
                case 'r': case 'U': case CTRL('r'): case CTRL('y'): // redo
                {
                    UndoItem item = (UndoItem)undoTreeSquirrel.redo();
                    if (item != null)
                    {
                        mesh = new Mesh(item.after.mesh);
                        doOptimize = item.after.doOptimize;
                        optimizationTypeIndex = item.after.optimizationTypeIndex;
                        optimizationType = availableOptimizationTypes[optimizationTypeIndex];
                    }
                    else
                    {
                        System.out.println("Nothing to redo!");
                    }
                    repaint();
                    break;
                }
                case 'c': // clear
                {
                    UndoItem.State before = new UndoItem.State(mesh, doOptimize, optimizationTypeIndex);
                    mesh = new Mesh();
                    translateFudgeX = 0; // doesn't get undone properly
                    translateFudgeY = 0; // doesn't get undone properly
                    if (continuouslyDelaunayize) delaunayize();
                    UndoItem.State after = new UndoItem.State(mesh, doOptimize, optimizationTypeIndex);
                    undoTreeSquirrel.Do(new UndoItem(before, after));
                    repaint();
                    break;
                }
                case CTRL('q'): // quit
                {
                    System.out.println("Aww.");
                    System.exit(1);
                }

                case 'h': // help
                    System.out.println("===================================================================");
                    System.out.println("Mouse:");
                    System.out.println("    left click: add a vertex and drag it");
                    System.out.println("    middle drag: move a vertex");
                    System.out.println("    right click: delete a vertex");
                    System.out.println("    shift-middle drag: pan entire picture");
                    System.out.println("    control-right drag: create new edge between two vertices");
                    System.out.println("Keys:");
                    System.out.println("    'V' - cycle verbosity (to java console or system output)");
                    System.out.println("    ' ' - just repaint");
                    System.out.println("    'A' - toggle doAntiAliasing");
                    System.out.println("    't' - toggle primary (triangle) mesh");
                    System.out.println("    'B' - toggle doDoubleBuffer");
                    System.out.println("    'i'/'+'/'=' - zoom in");
                    System.out.println("    'o'/'-' - zoom out");
                    System.out.println("    's' - swap a diagonal");
                    System.out.println("    ctrl-'s' - swap a diagonal if the result is more Delaunay");
                    System.out.println("    ctrl-shift-'s' - Delaunay triangulate");
                    System.out.println("    'O' - toggle doOptimize");
                    System.out.println("    'l' - toggle doLabels");
                    System.out.println("    'a' - toggle doArrowsTowardsSharpestDihedrals (green)");
                    System.out.println("    alt-'a' - toggle doArrowsTowardsShortestEdges (cyan)");
                    System.out.println("    'S' - turn off optimize, and re-spherize");
                    System.out.println("    'd' - delete closest edge");
                    System.out.println("    ctrl-'i' - toggle doShowInsideOutDualVerts");
                    System.out.println("    ctrl-'o' - cycle optimizationType");
                    System.out.println("    ctrl-'v' - toggle nonEventVerbose");
                    System.out.println("    Up arrow: pull face plane of closest vertex out");
                    System.out.println("    Down arrow: push face plane of closest vertex in");
                    System.out.println("    Left/right arrow: translate fudge");
                    System.out.println("    'c' - clear");
                    System.out.println("    ctrl-'c' - example in which cutting the sharpest dihedral at each vertex does not lead to a solution");
                    System.out.println("    'u' / ctrl-'z' - undo");
                    System.out.println("    'r' / 'U' / ctrl-'r' / ctrl-'y' - redo");
                    System.out.println("    ctrl-'q' - quit");
                    System.out.println("===================================================================");
                    break;

                case CTRL('i'): // toggle doShowInsideOutDualVerts
                    doShowInsideOutDualVerts ^= true;
                    System.out.println("doShowInsideOutDualVerts -> "+doShowInsideOutDualVerts);
                    repaint();
                    break;

                case CTRL('o'): // cycle optimizationType
                    optimizationTypeIndex = (optimizationTypeIndex+1)%availableOptimizationTypes.length;
                    optimizationType = availableOptimizationTypes[optimizationTypeIndex];
                    System.out.println("optimizationType -> "+optimizationTypeNames[optimizationType]);
                    repaint();
                    break;

                case CTRL('v'): // toggle nonEventVerbose
                    nonEventVerbose = (nonEventVerbose+1)%2;
                    System.out.println("nonEventVerbose -> "+nonEventVerbose);
                    repaint();
                    break;

                case CTRL('c'): // very special case canned... netless9 example
                {
                    UndoItem.State before = new UndoItem.State(mesh, doOptimize, optimizationTypeIndex);

                    if (e.isAltDown())
                        doCannedThingHexesSpiral();
                    else
                        doCannedThingNetless9();

                    if (continuouslyDelaunayize) delaunayize();
                    UndoItem.State after = new UndoItem.State(mesh, doOptimize, optimizationTypeIndex);
                    undoTreeSquirrel.Do(new UndoItem(before, after));
                    repaint();
                    break;
                }
                case CTRL('e'): // very special case canned eyeball example
                {
                    UndoItem.State before = new UndoItem.State(mesh, doOptimize, optimizationTypeIndex);
                    doCannedThingEyeball();
                    if (continuouslyDelaunayize) delaunayize();
                    UndoItem.State after = new UndoItem.State(mesh, doOptimize, optimizationTypeIndex);
                    undoTreeSquirrel.Do(new UndoItem(before, after));
                    repaint();
                    break;
                }

                default:
                    System.out.println("Unknown key '"+c+"'("+(int)e.getKeyChar()+") typed");
                    break;
            }
            if (eventVerbose >= 1) System.out.println("out keyTyped: "+e);
        } // keyTyped

        private void delaunayize()
        {
            //
            // Discard the mesh edges and replace it with
            // the Delaunay triangulation of the vertex set,
            // using 3d convex hull.
            // Project to a paraboloid tweaked by heights,
            // which is the right thing to do.
            //
            int nVerts = mesh.verts.size();
            double verts[][] = new double[nVerts][/*3*/];
            FORI (iVert, nVerts)
            {
                Mesh.Vertex v = (Mesh.Vertex)mesh.verts.get(iVert);
                verts[iVert] = new double[]{v.x, v.y, v.h};
            }

            double vertsForHull[][] = new double[nVerts][3];
            FORI (iVert, nVerts)
            {
                vertsForHull[iVert][0] = verts[iVert][0];
                vertsForHull[iVert][1] = verts[iVert][1];
                vertsForHull[iVert][2] = -verts[iVert][2] - .5 * (SQR(verts[iVert][0]) + SQR(verts[iVert][1])); // XXX not sure what the - is about yet, it's empirical.  I think maybe I have a bunch of stuff backwards, since the down arrow is supposed to press down the face which means pressing UP the vertex.  Bleah.
            }
            //PRINTARRAY(verts);
            //PRINTARRAY(vertsForHull);
            // normalize to range -1..1 in all three dimensions
            double bbox[][] = VecMath.bbox(verts);
            if (bbox != null)
            {
                FORI (iDim, 3)
                {
                    double bboxCenter = .5*(bbox[1][iDim]+bbox[0][iDim]);
                    double bboxRadius = .5*(bbox[1][iDim]-bbox[0][iDim]);
                    if (bboxRadius == 0.)
                        bboxRadius = 1.;
                    FORI (iVert, nVerts)
                        vertsForHull[iVert][iDim] = (vertsForHull[iVert][iDim] - bboxCenter) / bboxRadius;
                }
            }
            //System.out.println("    computing convex hull");
            int hull[][] = ConvexHull.convexHull(vertsForHull, 1e-12);

            // correct it, if 2 verts
            if (nVerts == 2)
                hull = new int[][]{{0,1},{0,1}};

            mesh = new Mesh(verts, hull);

            //
            // Now get rid of each edge
            // that separates two negative-area faces.
            // Analyze all the edges first before deleting any,
            // so that we are only looking at triangle areas.
            //
            {
                ArrayList edgesToDelete = new ArrayList();
                int nEdges = mesh.edges.size();
                for (int iEdge = 0; iEdge < nEdges; iEdge += 2) // only one of an edge and its opposite
                {
                    Mesh.Edge edge = (Mesh.Edge)mesh.edges.get(iEdge);
                    if (mesh.twiceFaceArea(edge) < 0
                     && mesh.twiceFaceArea(edge.opposite()) < 0)
                        edgesToDelete.add(edge);
                }
                int nEdgesToDelete = edgesToDelete.size();
                //System.out.println("    removing "+nEdgesToDelete+" backside edges");
                FORI (iEdgeToDelete, nEdgesToDelete)
                {
                    Mesh.Edge edge = (Mesh.Edge)edgesToDelete.get(iEdgeToDelete);
                    mesh.deleteEdge(edge);
                }
            }

            // XXX should get rid of unreferenced vertices? NO! But should get rid of dups maybe
        } // delaunayize

        private void doCannedThingNetless8()
        {
            double Eps = .04;
            double slope = 1./16; // started with 1./100, 1/10 works but starts pushing outer point far away
            //     3   2
            //       1
            //      5 4
            //       0
            double verts[][] = {
                {0*Eps, -7*Eps, 0},  // the "lowest" face, bottom point of dual
                {0*Eps, 7*Eps, 0},
                {2*Eps, 9*Eps, 0},
                {-2*Eps, 9*Eps, 0},
                {7*slope*Eps, 0,  23*Eps*Eps},
                {-7*slope*Eps, 0, 23*Eps*Eps},
            };
            int faces[][] = {
                {5,4,1},
                {0,4,5},
                {4,2,1},
                {5,1,3},
                {5,3,0},
                {2,4,0},
                {1,2,3},
                {0,3,2},
            };
            mesh = new Mesh(verts, faces);
        } // doCannedThingNetless8

        // Make the mesh into netless9
        private void doCannedThingNetless9()
        {
            if (true)
            {
                // s = how much bigger each edge is from the previous
                double s = 1.05;
                //double s = 1.001;
                double sliceAngle;
                {
                    // In the initial 6 slice pie,
                    // the southwest triangle has sides a=1, b=s^5, c=s^6.
                    // what are its angles?
                    // http://www.teacherschoice.com.au/Maths_Library/Trigonometry/solve_trig_SSS.htm
                    double a = 1;
                    double b = s*s*s*s*s;
                    double c = s*s*s*s*s*s;
                    double C = triangleAngle(a, b, c);
                    // All right, the southwest angle at the center
                    // is C, a bit more than pi/3.
                    // Distribute the rest of the spokes evenly.
                    sliceAngle = (2*Math.PI-C) / 5;
                }
                PRINT(RTOD(sliceAngle));
                int nVerts = 19;
                //int nVerts = 40;
                //int nVerts = 1000;
                double verts[][] = new double[nVerts][3];
                int nNeighbors[] = new int[nVerts]; // zeros
                ArrayList/*<int[]>*/ facesList = new ArrayList();

                // Seed with verts 0 and 1, and an edge between them.
                verts[0][0] = 0;
                verts[0][1] = 0;
                verts[0][2] = 0;
                // Had the seed on the -y axis, changing it to +x axis for the hell of it
                verts[1][0] = 1;
                verts[1][1] = 0;
                verts[1][2] = 0;
                nNeighbors[0] = 1;
                nNeighbors[1] = 1;

                PRINT(VecMath.dist(verts[1], verts[6]));
                PRINT(Math.pow(s, 6));

                int oldestPerimeterEdge[] = {0,1};

                for (int i = 2; i < nVerts; ++i)
                {
                    //PRINT(i);
                    int arity = nNeighbors[oldestPerimeterEdge[0]];
                    assert(arity < 6);
                    double angFrac = 1./(6-arity);
                    //PRINT(1./angFrac);
                    double largestEdge = VecMath.dist(verts[i-1], verts[oldestPerimeterEdge[0]]);
                    //PRINT(largestEdge);
                    //PRINT(Math.pow(s, facesList.size()));

                    double c = VecMath.dist(verts[oldestPerimeterEdge[0]],
                                            verts[oldestPerimeterEdge[1]]);
                    double a = largestEdge * Math.pow(s, 1./angFrac);
                    double b = a*s;
                    //PRINT(a);
                    //PRINT(b);
                    double target[] = completeTriangle(verts[oldestPerimeterEdge[1]],
                                                       verts[oldestPerimeterEdge[0]],
                                                       a, b);
                    double ang0 = Math.atan2(verts[i-1][1]-verts[oldestPerimeterEdge[0]][1],
                                             verts[i-1][0]-verts[oldestPerimeterEdge[0]][0]);
                    double ang1 = Math.atan2(target[1]-verts[oldestPerimeterEdge[0]][1],
                                             target[0]-verts[oldestPerimeterEdge[0]][0]);
                    //PRINT(RTOD(ang0));
                    //PRINT(RTOD(ang1));
                    //PRINT(angFrac);
                    while (ang1 < ang0) ang1 += 2*Math.PI;
                    double ang = LERP(ang0, ang1, angFrac);
                    double length = largestEdge * s;
                    verts[i][0] = verts[oldestPerimeterEdge[0]][0] + length*Math.cos(ang);
                    verts[i][1] = verts[oldestPerimeterEdge[0]][1] + length*Math.sin(ang);
                    facesList.add(new int[]{oldestPerimeterEdge[0], i-1, i});
                    nNeighbors[oldestPerimeterEdge[0]]++;
                    nNeighbors[i-1]++;
                    nNeighbors[i] = 2;
                    if (nNeighbors[oldestPerimeterEdge[0]] == 6)
                    {
                        //System.out.println("COMPLETING at "+i);
                        facesList.add(new int[]{oldestPerimeterEdge[1], oldestPerimeterEdge[0], i});
                        nNeighbors[oldestPerimeterEdge[1]]++;
                        nNeighbors[i]++;
                        oldestPerimeterEdge[0]++;
                        oldestPerimeterEdge[1]++;
                    }
                }

                {
                    int nPerimeterVerts = 0;
                    FORI (i, nVerts)
                        if (nNeighbors[i] < 6)
                            nPerimeterVerts++;
                    int perimeterVerts[] = new int[nPerimeterVerts];
                    nPerimeterVerts = 0;
                    FORI (i, nVerts)
                        if (nNeighbors[i] < 6)
                            perimeterVerts[perimeterVerts.length-1-nPerimeterVerts++] = i;
                    facesList.add(perimeterVerts);
                    PRINT(nPerimeterVerts);
                }


                int faces[][] = new int[facesList.size()][];
                facesList.toArray(faces);
                mesh = new Mesh(verts, faces);
                //PRINTARRAY(nNeighbors);
                //PRINTARRAY(verts);
                //PRINTARRAY(faces);
            }
            FORIDOWN (iVert, mesh.verts.size())
            {
                double scale = .2;
                Mesh.Vertex vert = (Mesh.Vertex)mesh.verts.get(iVert);
                vert.x *= scale;
                vert.y *= scale;
                vert.h *= scale*scale;
            }
        } // doCannedThingNetless9

        // Argh, short-lived brilliant idea
        // that's going nowhere, since a zig-zag
        // through the cornea is always possible.
        private void doCannedThingEyeball()
        {
            int n = 72;
            int nRows = 15;
            double r0 = .25;
            double aspect = 2;

            // empirically, fudges to make it kind of right for n=72, r0=.25, aspect=2
            double incr = .005;
            incr *= .25; // XXX argh! up and down arrows depend on current view scale! squared!

            double rowHeightFudges[] = {
                -0*incr,
                           // +3
                 3*incr,          // -1
                           // +2         // -1
                 5*incr,          // -2
                           // +0         // -1
                 5*incr,          // -3
                           // -3         // -2
                 2*incr,          // -5
                           // -8         // -2.5
                -6*incr,         // -7.5
                           // -15.5      // -4
                -21.5*incr,       // -11.5
                           // -27        // -5.5
                -48.5*incr,       // -17
                           // -44        // -8
                -92.5*incr,       // -25
                           // -69        // -11
                -161.5*incr,      // -36
                           // -105       // -16
                -266.5*incr,      // -52
                           // -157       // -22
                -423.5*incr,      // -74
                           // -231       // -31
                -654.5*incr,      // -105
                           // -336       // -43
                -990.5*incr,      // -148
                           // -484
                -1474.5*incr,
            };    

            ArrayList vertsList = new ArrayList();
            ArrayList facesList = new ArrayList();

            vertsList.add(new double[]{0,0,0});
            FORI (iRow, nRows)
            {
                double multiplier = 1 + aspect*2*Math.PI/n; // magic
                double r = r0 * Math.pow(multiplier, iRow);
                FORI (i, n)
                {
                    double theta = 2*Math.PI*(i+iRow*.5)/n;
                    vertsList.add(new double[]{r*Math.cos(theta),
                                               r*Math.sin(theta),
                                               rowHeightFudges[iRow],
                                               });
                    if (iRow == 0)
                        facesList.add(new int[]{1 + iRow*n + i,
                                                1 + iRow*n + (i+1)%n,
                                                0});
                    else
                    {
                        facesList.add(new int[]{1 + iRow*n + i,
                                                1 + iRow*n + (i+1)%n,
                                                1 + (iRow-1)*n + (i+1)%n});
                        facesList.add(new int[]{1 + iRow*n + i,
                                                1 + (iRow-1)*n + (i+1)%n,
                                                1 + (iRow-1)*n + i});
                    }
                    /*
                    else
                    {
                        facesList.add(new int[]{1 + iRow*n + i,
                                                1 + (iRow-1)*n + (i+1)%n,
                                                1 + (iRow-2)*n + (i+1)%n});
                        facesList.add(new int[]{1 + iRow*n + i,
                                                1 + (iRow-2)*n + (i+1)%n,
                                                1 + (iRow-1)*n + i});
                    }
                    if (iRow == nRows-1)
                        facesList.add(new int[]{1 + iRow*n + i,
                                                1 + iRow*n + (i+1)%n,
                                                1 + (iRow-1)*n + (i+1)%n});
                    */
                }
            }
            int insideOutFace[] = new int[n];
            FORI (i, n)
                insideOutFace[i] = vertsList.size()-1-i;
            facesList.add(insideOutFace);


            double verts[][] = new double[vertsList.size()][];
            vertsList.toArray(verts);
            int faces[][] = new int[facesList.size()][];
            facesList.toArray(faces);
            mesh = new Mesh(verts, faces);
        } // doCannedThingEyeball

        private void doCannedThingHexesSpiral()
        {
            if (true)
            {
                // s = how much bigger each edge is from the previous
                //double s = 1.05;
                //double s = 1.001;
                double s = 1.;
                double sliceAngle;
                {
                    // In the initial 6 slice pie,
                    // the southwest triangle has sides a=1, b=s^5, c=s^6.
                    // what are its angles?
                    // http://www.teacherschoice.com.au/Maths_Library/Trigonometry/solve_trig_SSS.htm
                    double a = 1;
                    double b = s*s*s*s*s;
                    double c = s*s*s*s*s*s;
                    double C = triangleAngle(a, b, c);
                    // All right, the southwest angle at the center
                    // is C, a bit more than pi/3.
                    // Distribute the rest of the spokes evenly.
                    sliceAngle = (2*Math.PI-C) / 5;
                }
                PRINT(RTOD(sliceAngle));
                //int nVerts = 19;
                //int nVerts = 18;
                //int nVerts = 100;
                int nVerts = 500;
                //int nVerts = 1000;
                double verts[][] = new double[nVerts][3];
                int nNeighbors[] = new int[nVerts]; // zeros
                ArrayList/*<int[]>*/ facesList = new ArrayList();

                // Seed with verts 0 and 1, and an edge between them.
                verts[0][0] = 0;
                verts[0][1] = 0;
                verts[0][2] = 0;
                // Had the seed on the -y axis, changing it to +x axis for the hell of it
                verts[1][0] = 1;
                verts[1][1] = 0;
                verts[1][2] = 0;
                nNeighbors[0] = 1;
                nNeighbors[1] = 1;

                PRINT(VecMath.dist(verts[1], verts[6]));
                PRINT(Math.pow(s, 6));

                int oldestPerimeterEdge[] = {0,1};

                for (int i = 2; i < nVerts; ++i)
                {
                    //PRINT(i);
                    int arity = nNeighbors[oldestPerimeterEdge[0]];
                    assert(arity < 6);
                    double angFrac = 1./(6-arity);
                    //PRINT(1./angFrac);
                    double largestEdge = VecMath.dist(verts[i-1], verts[oldestPerimeterEdge[0]]);
                    //PRINT(largestEdge);
                    //PRINT(Math.pow(s, facesList.size()));

                    double c = VecMath.dist(verts[oldestPerimeterEdge[0]],
                                            verts[oldestPerimeterEdge[1]]);
                    double a = largestEdge * Math.pow(s, 1./angFrac);
                    double b = a*s;
                    //PRINT(a);
                    //PRINT(b);
                    double target[] = completeTriangle(verts[oldestPerimeterEdge[1]],
                                                       verts[oldestPerimeterEdge[0]],
                                                       a, b);
                    double ang0 = Math.atan2(verts[i-1][1]-verts[oldestPerimeterEdge[0]][1],
                                             verts[i-1][0]-verts[oldestPerimeterEdge[0]][0]);
                    double ang1 = Math.atan2(target[1]-verts[oldestPerimeterEdge[0]][1],
                                             target[0]-verts[oldestPerimeterEdge[0]][0]);
                    //PRINT(RTOD(ang0));
                    //PRINT(RTOD(ang1));
                    //PRINT(angFrac);
                    while (ang1 < ang0) ang1 += 2*Math.PI;
                    double ang = LERP(ang0, ang1, angFrac);
                    double length = largestEdge * s;
                    verts[i][0] = verts[oldestPerimeterEdge[0]][0] + length*Math.cos(ang);
                    verts[i][1] = verts[oldestPerimeterEdge[0]][1] + length*Math.sin(ang);
                    facesList.add(new int[]{oldestPerimeterEdge[0], i-1, i});
                    nNeighbors[oldestPerimeterEdge[0]]++;
                    nNeighbors[i-1]++;
                    nNeighbors[i] = 2;
                    if (nNeighbors[oldestPerimeterEdge[0]] == 6)
                    {
                        //System.out.println("COMPLETING at "+i);
                        facesList.add(new int[]{oldestPerimeterEdge[1], oldestPerimeterEdge[0], i});
                        nNeighbors[oldestPerimeterEdge[1]]++;
                        nNeighbors[i]++;
                        oldestPerimeterEdge[0]++;
                        oldestPerimeterEdge[1]++;
                    }
                }

                {
                    int nPerimeterVerts = 0;
                    FORI (i, nVerts)
                        if (nNeighbors[i] < 6)
                            nPerimeterVerts++;
                    int perimeterVerts[] = new int[nPerimeterVerts];
                    nPerimeterVerts = 0;
                    FORI (i, nVerts)
                        if (nNeighbors[i] < 6)
                            perimeterVerts[perimeterVerts.length-1-nPerimeterVerts++] = i;
                    facesList.add(perimeterVerts);
                    PRINT(nPerimeterVerts);
                }


                int faces[][] = new int[facesList.size()][];
                facesList.toArray(faces);
                mesh = new Mesh(verts, faces);
                //PRINTARRAY(nNeighbors);
                //PRINTARRAY(verts);
                //PRINTARRAY(faces);
            }
            FORIDOWN (iVert, mesh.verts.size())
            {
                double scale = .2;
                Mesh.Vertex vert = (Mesh.Vertex)mesh.verts.get(iVert);
                vert.x *= scale;
                vert.y *= scale;
                vert.h *= scale*scale;
            }
            //double heightIncr = .005*.14;
            double heightIncr = .005*.01;
            FORIDOWN (iVert, mesh.verts.size())
            {
                ((Mesh.Vertex)mesh.verts.get(iVert)).h -= heightIncr * iVert;
            }
        } // doCannedThingHexesSpiral

        //
        // Make it so we get keyboard focus on startup,
        // without having to click first.  Thanks, Melinda!
        // The state of things seems to be:
        //      - Buttons and TextFields are apparently "focus traversable"
        //        by default.  Canvases and Applets aren't,
        //        implying (not obvious) that you need to click to type
        //        when the app starts,
        //        which is almost never the desired behavior.
        //        You can change this by overriding isFocusTraversable(),
        //        which we do below.
        //      - Other approaches using requestFocus():
        //        A Canvas calling requestFocus() doesn't seem to do
        //        anything.  An Applet calling requestFocus() doesn't
        //        do anything during init(), but I think it works
        //        if you put it in the mouseEntered handler or something,
        //        though this can lead to various unpredictabilities.
        // In this applet we are drawing directly on the Applet (not a Canvas),
        // so presumably the requestFocus() approach would work,
        // but the isFocusTraversable() fix is better in any case.
        //
        public boolean isFocusTraversable()
        {
            return true;
        }

        // override to not clear...
        public void update(java.awt.Graphics g)
        {
            paint(g);
        }


        // PAINT
	public void paint(java.awt.Graphics frontBufferGraphics)
	{
	    if (eventVerbose >= 1) System.out.println("in paint");

            makeSureBackBufferIsRight();
            java.awt.Graphics g;
            if (doDoubleBuffer)
                g = backBufferImage.getGraphics();
            else
                g = frontBufferGraphics;


            java.awt.Dimension size = getSize();
            double minSize = MIN(size.width, size.height);
            MyGraphics mg = new MyGraphics(g, size,
                                    -size.width/minSize,size.width/minSize,
                                    -size.height/minSize,size.height/minSize);
            mostRecentGraphics = mg;

            if (implementAntiAliasingInHardware)
            {
                graphicsAntiAliasingSetter.setAntiAliasing(g,
                                                           doAntiAliasing,
                                                           //1
                                                           eventVerbose
                                                           );
            }


            //
            // Clear to black...
            //
            mg.setColor(java.awt.Color.black);
            mg.fillWindow();



            //
            // Draw the mesh in white...
            //
            if (showTriangles >= 1)
            {
                mg.setColor(java.awt.Color.white);

                ArrayList verts = mesh.verts;
                FORIDOWN (iVert, verts.size())
                {
                    Mesh.Vertex vert = (Mesh.Vertex)verts.get(iVert);
                    mg.drawPoint(vert.x,
                                 vert.y, 3);
                }

                if (showTriangles >= 2)
                {

                    ArrayList edges = mesh.edges;
                    FORIDOWN (iEdge, edges.size()/2)
                    {
                        Mesh.Edge edge = (Mesh.Edge)edges.get(iEdge*2);
                        Mesh.Vertex v0 = edge.initialVertex();
                        Mesh.Vertex v1 = edge.finalVertex();
                        mg.drawLine(v0.x,v0.y,v1.x,v1.y,doAntiAliasing);
                    }
                }
            }

            //
            // Try optimizing the heights...
            //
            if (doOptimize)
            {
                double optimalVertexHeights[] = mesh.findOptimalVertexHeights(optimizationType);
                FORIDOWN (iVert, mesh.verts.size())
                {
                    //PRINTSUB(optimalVertexHeights,iVert);
                    ((Mesh.Vertex)mesh.verts.get(iVert)).h = optimalVertexHeights[iVert];
                }
            }

            //
            // Draw the dual diagram in red...
            //
            if (true)
            {
                //
                // Draw and store the dual verts...
                //
                mg.setColor(java.awt.Color.red);
                double dualVerts[][] = new double[mesh.edges.size()][];
                FORIDOWN (iEdge, mesh.edges.size())
                {
                    if (dualVerts[iEdge] != null)
                        continue; // already did this triangle

                    Mesh.Edge e0 = (Mesh.Edge)mesh.edges.get(iEdge);
                    Mesh.Edge e1 = e0.next();
                    Mesh.Edge e2 = e1.next();
                    if (e2.next() != e0)
                        continue; // not a triangle

                    Mesh.Vertex v0 = e0.initialVertex();
                    Mesh.Vertex v1 = e1.initialVertex();
                    Mesh.Vertex v2 = e2.initialVertex();

                    if (!doShowInsideOutDualVerts)
                    {
                        if (twiceTriArea(v0.x,v0.y,
                                         v1.x,v1.y,
                                         v2.x,v2.y) < 0)
                            continue; // the triangle is inside out; it's the boundary
                    }

                    // XXX fudge-- experiment with translations and scales
                    double fudgeTranslate[] = {translateFudgeX, translateFudgeY};
                    double coords0[] = {v0.x,v0.y};
                    double coords1[] = {v1.x,v1.y};
                    double coords2[] = {v2.x,v2.y};
                    double fudge0 = VecMath.dot(fudgeTranslate, coords0);
                    double fudge1 = VecMath.dot(fudgeTranslate, coords1);
                    double fudge2 = VecMath.dot(fudgeTranslate, coords2);
                    double fudgeScale = 1.;

                    double dualVert[] = new double[3];
                    SolveForDualPoint(v0.x, v0.y, fudge0 + v0.h - (2-fudgeScale) * .5 * (SQR(v0.x)+SQR(v0.y)),
                                      v1.x, v1.y, fudge1 + v1.h - (2-fudgeScale) * .5 * (SQR(v1.x)+SQR(v1.y)),
                                      v2.x, v2.y, fudge2 + v2.h - (2-fudgeScale) * .5 * (SQR(v2.x)+SQR(v2.y)),
                                      dualVert);

                    //System.out.println("    drawing dual vert at "+Arrays.toStringCompact(dualVert));
                    mg.drawPoint(dualVert[0],
                                 dualVert[1], 5);
                    int ind0 = iEdge;
                    int ind1 = e1.myIndex();
                    int ind2 = e2.myIndex();
                    assert(dualVerts[ind0] == null);
                    assert(dualVerts[ind1] == null);
                    assert(dualVerts[ind2] == null);
                    dualVerts[ind0] = dualVert;
                    dualVerts[ind1] = dualVert;
                    dualVerts[ind2] = dualVert;
                }

                //
                // Now try connecting the dual verts
                // 
                FORIDOWN (iEdge, mesh.edges.size())
                {
                    if (dualVerts[iEdge] == null)
                        continue; // not a triangle, or inside out
                    Mesh.Edge edge = (Mesh.Edge)mesh.edges.get(iEdge);
                    int jEdge = edge.opposite().myIndex();
                    if (dualVerts[jEdge] != null)
                    {
                        mg.drawLine(dualVerts[iEdge][0],dualVerts[iEdge][1],
                                    dualVerts[jEdge][0],dualVerts[jEdge][1],
                                    doAntiAliasing);
                    }
                    else
                    {
                        // Draw a ray out to infinity
                        double v0[] = {edge.initialVertex().x,
                                       edge.initialVertex().y};
                        double v1[] = {edge.finalVertex().x,
                                       edge.finalVertex().y};
                        double toEdgeVec[] = VecMath.xv2(
                                                 VecMath.vmv(v0, v1));
                        VecMath.normalize(toEdgeVec, toEdgeVec);
                        double rayLength = 1.; // for edges to infinity
                        //double destPoint[] = VecMath.vpsxv(2, dualVerts[iEdge], rayLength, toEdgeVec); // XXX argh, version that allows specifying length doesn't exist yet, and without that it gets confused because dualVerts[iEdge] has length 3
                        double destPoint[] = {dualVerts[iEdge][0]+rayLength*toEdgeVec[0],
                                              dualVerts[iEdge][1]+rayLength*toEdgeVec[1]};
                        mg.drawLine(dualVerts[iEdge][0],dualVerts[iEdge][1],
                                    destPoint[0],destPoint[1],
                                    doAntiAliasing);
                                                             
                    }
                }

                //
                // And, as polish for voronoi diagrams,
                // draw perpendicular lines
                // at each isolated edge or whisker.
                // XXX should do this along hairs... or maybe every edge that is not on a triangle on either side? nah
                //
                FORIDOWN (iEdge, mesh.edges.size())
                {
                    Mesh.Edge edge = (Mesh.Edge)mesh.edges.get(iEdge);
                    if (edge.next() == edge.opposite()) // check in only one of the two directions
                    //if (dualVerts[iEdge] == null && dualVerts[edge.opposite().myIndex()] == null && iEdge < edge.opposite().myIndex())
                    {
                        double v0[] = {edge.initialVertex().x,
                                       edge.initialVertex().y};
                        double v1[] = {edge.finalVertex().x,
                                       edge.finalVertex().y};
                        double toEdgeVec[] = VecMath.xv2(
                                                 VecMath.vmv(v0, v1));
                        VecMath.normalize(toEdgeVec, toEdgeVec);
                        double midPoint[] = VecMath.lerp(v0, v1, .5);
                        double lineLength = 1.;
                        double fromPoint[] = VecMath.vpsxv(midPoint, -lineLength*.5, toEdgeVec);
                        double toPoint[] = VecMath.vpsxv(midPoint, lineLength*.5, toEdgeVec);
                        mg.drawLine(fromPoint[0],fromPoint[1],
                                    toPoint[0], toPoint[1],
                                    doAntiAliasing);
                    }
                }



                //
                // Now try marking the sharpest dihedral dual edge
                // out of each dual vertex.
                // I.e. the dual edge opposite the largest dual angle.
                // I.e. the dual edge corresponding to the longest of the three primal
                // triangle sides.
                // We draw it 3 times, to make sure we get the same logic from each direction. If there are ties, it will get drawn in each place I think.
                //
                if (doArrowsTowardsSharpestDihedrals)
                {
                    mg.setColor(java.awt.Color.green);
                    FORIDOWN (iEdge, mesh.edges.size())
                    {
                        if (dualVerts[iEdge] == null)
                            continue; // not a triangle, or inside out
                        Mesh.Edge e0 = (Mesh.Edge)mesh.edges.get(iEdge);
                        Mesh.Edge e1 = e0.next();
                        Mesh.Edge e2 = e1.next();
                        assert(e2.next() == e0);
                        Mesh.Vertex triVerts[] = {e0.initialVertex(),
                                                  e1.initialVertex(),
                                                  e2.initialVertex()};
                        double sideLengths[] = new double[3];
                        FORI (i, 3)
                            sideLengths[i] = Math.sqrt(SQR(triVerts[i].x-triVerts[(i+1)%3].x)
                                                     + SQR(triVerts[i].y-triVerts[(i+1)%3].y));
                        int bestSide = MAXI3(sideLengths[0], sideLengths[1], sideLengths[2]);
                        double triCenterDualVert[] = dualVerts[e0.myIndex()]; // huh? using an edge index to index into the dual verts?
                        double v0[] = {triVerts[bestSide].x, triVerts[bestSide].y};
                        double v1[] = {triVerts[(bestSide+1)%3].x, triVerts[(bestSide+1)%3].y};
                        double toEdgeVec[] = VecMath.xv2(
                                                 VecMath.vmv(v0, v1));
                        VecMath.normalize(toEdgeVec, toEdgeVec);
                        // XXX be smarter!  maybe 1/3 of the way along the edge, or somethin
                        double whereToDrawMark[] = {
                            triCenterDualVert[0] + .02 * toEdgeVec[0],
                            triCenterDualVert[1] + .02 * toEdgeVec[1],
                        };
                        //VecMath.vpsxv(whereToDrawMark, whereToDrawMark, .004, VecMath.random(2));
                        mg.drawPoint(whereToDrawMark[0],
                                     whereToDrawMark[1], 5);
                    }
                }
                if (doArrowsTowardsShortestEdges)
                {
                    mg.setColor(java.awt.Color.cyan);
                    FORIDOWN (iEdge, mesh.edges.size())
                    {
                        if (dualVerts[iEdge] == null)
                            continue; // not a triangle, or inside out

                        Mesh.Edge e0 = (Mesh.Edge)mesh.edges.get(iEdge);
                        Mesh.Edge e1 = e0.next();
                        Mesh.Edge e2 = e1.next();
                        assert(e2.next() == e0);
                        Mesh.Vertex triVerts[] = {e0.initialVertex(),
                                                  e1.initialVertex(),
                                                  e2.initialVertex()};
                        double triCenterDualVert[] = dualVerts[e0.myIndex()];
                        double neighborDualVerts[][] = {
                            dualVerts[e0.opposite().myIndex()],
                            dualVerts[e1.opposite().myIndex()],
                            dualVerts[e2.opposite().myIndex()],
                        };
                        double dualSideLengths[] = new double[3];
                        FORI (i, 3)
                        {
                            if (neighborDualVerts[i] == null)
                                dualSideLengths[i] = Double.POSITIVE_INFINITY;
                            else
                                dualSideLengths[i] = VecMath.dist(triCenterDualVert, neighborDualVerts[i]);
                        }
                        int bestSide = MINI3(dualSideLengths[0], dualSideLengths[1], dualSideLengths[2]);
                        double v0[] = {triVerts[bestSide].x, triVerts[bestSide].y};
                        double v1[] = {triVerts[(bestSide+1)%3].x, triVerts[(bestSide+1)%3].y};
                        double toEdgeVec[] = VecMath.xv2(
                                                 VecMath.vmv(v0, v1));
                        VecMath.normalize(toEdgeVec, toEdgeVec);
                        // XXX be smarter!  maybe 1/3 of the way along the edge, or somethin
                        double whereToDrawMark[] = {
                            triCenterDualVert[0] + .02 * toEdgeVec[0],
                            triCenterDualVert[1] + .02 * toEdgeVec[1],
                        };
                        //VecMath.vpsxv(whereToDrawMark, whereToDrawMark, .005, VecMath.random(2));
                        mg.drawPoint(whereToDrawMark[0],
                                     whereToDrawMark[1], 5);

                    }
                }
            }

            //
            // Draw the labels last...
            //
            if (doLabels)
            {
                mg.setColor(java.awt.Color.white);

                boolean trySmartVertexAngles = true;

                double smartVertexAngles[] = null;
                if (trySmartVertexAngles)
                {
                    int nVerts = mesh.verts.size();
                    int nEdges = mesh.edges.size();
                    smartVertexAngles = new double[nVerts]; // initialized to 0

                    FORI (iEdge0, nEdges)
                    {
                        Mesh.Edge edge0 = (Mesh.Edge)mesh.edges.get(iEdge0);
                        Mesh.Vertex vert = edge0.initialVertex();
                        if (smartVertexAngles[vert.myIndex()] != 0.)
                            continue; // already saw this one for sure

                        double biggestGap = -1.;
                        double angOfBiggestGap = 0.;
                        // walk CCW around vertex
                        Mesh.Edge thisEdge = edge0;
                        Mesh.Edge nextEdge;
                        do {
                            assert(thisEdge.initialVertex() == vert);
                            nextEdge = thisEdge.prev().opposite();
                            double nextAng = Math.atan2(nextEdge.finalVertex().y-nextEdge.initialVertex().y,
                                                        nextEdge.finalVertex().x-nextEdge.initialVertex().x);
                            double thisAng = Math.atan2(thisEdge.finalVertex().y-thisEdge.initialVertex().y,
                                                        thisEdge.finalVertex().x-thisEdge.initialVertex().x);
                            double thisGap = nextAng - thisAng;
                            if (thisGap < 0)
                                thisGap += 2*Math.PI;
                            if (thisGap > biggestGap)
                            {
                                biggestGap = thisGap;
                                angOfBiggestGap = thisAng+thisGap/2;
                            }
                        } while ((thisEdge = nextEdge) != edge0);
                        smartVertexAngles[vert.myIndex()] = angOfBiggestGap;
                    }
                }



                if (true)
                {
                    ArrayList verts = mesh.verts;
                    FORIDOWN (iVert, verts.size())
                    {
                        Mesh.Vertex vert = (Mesh.Vertex)verts.get(iVert);
                        double x = vert.x;
                        double y = vert.y;
                        double ang;
                        if (trySmartVertexAngles)
                        {
                            ang = smartVertexAngles[iVert];
                        }
                        else
                        {
                            ang = Math.random() * 2*Math.PI;
                        }
                        double offr = 5/mg.getScaleX(); // pixels
                        double offx = offr*Math.cos(ang);
                        double offy = offr*Math.sin(ang);
                        double offmax = MAX(ABS(offx),ABS(offy));

                        mg.drawString("v"+iVert,
                                      x+offx,
                                      y+offy,
                                      -offx/offmax, offy/offmax);
                    }
                }

                if (false) // edges are too busy, maybe should be separate option
                {
                    ArrayList edges = mesh.edges;
                    FORIDOWN (iEdge, edges.size())
                    {
                        Mesh.Edge edge = (Mesh.Edge)edges.get(iEdge);
                        Mesh.Vertex v0 = edge.initialVertex();
                        Mesh.Vertex v1 = edge.finalVertex();
                        double x = (v0.x+v1.x)/2;
                        double y = (v0.y+v1.y)/2;
                        double ang = Math.PI/2 + Math.atan2(v1.y-v0.y, v1.x-v0.x);
                        double offr = 2/mg.getScaleX(); // pixels
                        double offx = offr*Math.cos(ang);
                        double offy = offr*Math.sin(ang);
                        double offmax = MAX(ABS(offx),ABS(offy));
                        mg.drawString("e"+iEdge,
                                      x+offx,
                                      y+offy,
                                      -offx/offmax, offy/offmax);
                    }
                }
            } // if (doLabels)

            //
            // Draw the rubber band last last
            //
            if (rubberBandingNewEdge)
            {
                mg.setColor(java.awt.Color.white);
                Mesh.Vertex v0 = (Mesh.Vertex)mesh.verts.get(selectedVertIndex);
                mg.drawLine(v0.x, v0.y,
                            prevP[0], prevP[1], doAntiAliasing);
            } // if (rubberBandingNewEdge)

            if (doShowPositiveOrthantnessVisualization)
            {
                int nPoints = 5000;
                int nLabels = 100;
                double M[][] = new double[3][3];
                {
                    // XXX should add a function to VecMath for random orthonormal matrix?
                    FORI (i, 2)
                    FORI (j, 3)
                        M[i][j] = 2*Math.random() - 1.;
                    VecMath.normalize(M[0], M[0]);
                    VecMath.vpsxv(M[1],
                                  M[1],
                                  -VecMath.dot(M[0], M[1]),
                                  M[0]);
                    VecMath.normalize(M[1], M[1]);
                    VecMath.vxv3(M[2], M[0], M[1]);
                }

                double v[] = new double[3];
                double Mv[] = new double[3];
                FORI (iPoint, nLabels+nPoints)
                {
                    VecMath.random(v);

                    if (iPoint == 0 || iPoint == nLabels+nPoints-1)
                        VecMath.fillvec(v, 1.);
                    else if (iPoint == 1 || iPoint == nLabels+nPoints-2)
                        VecMath.fillvec(v, -1);


                    VecMath.normalize(v, v);
                    VecMath.mxv(Mv, M, v);
                    if (Mv[2] < 0.)
                    {
                        VecMath.sxv(v, -1., v);
                        VecMath.sxv(Mv, -1., Mv);
                    }
                    double goodness = VecMath.positiveOrthantness(v, true); // true means use "synopsis"
                    //double incrDegrees = 10.;
                    double incrDegrees = 5.;
                    double dN = goodness * 180 / Math.PI / incrDegrees;
                    int iN = (int)Math.round(dN);
                    if (iPoint <= 1
                     || iPoint >= nLabels+nPoints-2
                     || ABS(iN-dN) < .01)
                    {
                        if (iN == 0)
                            mg.setColor(java.awt.Color.red);
                        else if (iN % 2 == 0)
                            mg.setColor(java.awt.Color.green);
                        else
                            mg.setColor(java.awt.Color.blue);

                        if (iPoint == 0
                         || iPoint == nLabels+nPoints-1)
                            mg.drawString(""+(dN*incrDegrees),
                                          Mv[0],Mv[1], -1., 1.);
                        else if (iPoint < nLabels)
                            mg.drawString(""+(int)Math.round(dN*incrDegrees),
                                          Mv[0],Mv[1], -1., 1.);
                        else
                            mg.drawPoint(Mv[0],Mv[1], 1);
                    }
                    else
                        iPoint--; // cancel loop iteration
                }
            }


            if (g != frontBufferGraphics)
            {
                frontBufferGraphics.drawImage(backBufferImage, 0, 0, this);
            }

	    if (eventVerbose >= 1) System.out.println("out paint");
	} // paint

        private void makeSureBackBufferIsRight()
        {
            if (doDoubleBuffer)
            {
                java.awt.Dimension size = getSize();
                if (backBufferImage == null
                 || backBufferImage.getWidth(this) != size.width
                 || backBufferImage.getHeight(this) != size.height)
                {
                    if (eventVerbose >= 1)
                    {
                        System.out.println("Creating back buffer " + size.width + "x" + size.height);
                    }
                    backBufferImage = createImage(size.width, size.height);
                }
            }
            else
                backBufferImage = null;
        } // makeSureBackBufferIsRight


    //
    // Definition of stuff for this particular app...
    //
        private static class Mesh
        {
            public String toString()
            {
                StringBuffer sb = new StringBuffer();
                sb.append(""+verts.size()+" verts:\n");
                FORI (iVert, verts.size())
                {
                    Vertex vert = (Vertex)verts.get(iVert);
                    sb.append("    "+vert.x+" "+vert.y+" "+vert.h+"\n");
                }
                sb.append(""+edges.size()+" edges:\n");
                FORI (iEdge, edges.size())
                {
                    Edge edge = (Edge)edges.get(iEdge);
                    sb.append("    v"+edge.initialVertex().myIndex()+" -> v"+edge.finalVertex().myIndex()+"\n");
                }
                return sb.toString();
            }

            public class Vertex
            {
                public double x, y, h;
                private int _myIndex = -1;
                public Vertex(double x, double y, double h)
                {
                    this.x = x;
                    this.y = y;
                    this.h = h;
                    verts.add(this);
                    fixVertIndices(verts.size()-1);
                }

                public int myIndex()
                {
                    //return Arrays.indexOfUsingEqualsSymbol(verts, this);
                    return _myIndex;
                }
            } // public class Vertex
            public class Edge
            {
                private Vertex _initialVertex;
                private Edge _opposite; // opposite edge
                private Edge _next; // next edge CCW around the face to my left
                private Edge _prev; // prev edge (next edge CW) around the face to my left
                private int _myIndex = -1;

                public Edge(boolean andBack)
                {
                    this._myIndex = -1; // will get fixed
                    edges.add(this);
                    fixEdgeIndices(edges.size()-1);
                    if (andBack)
                    {
                        Edge opposite = new Edge(false);
                        setOpposite(opposite, true);
                    }
                }

                //
                // Accessor methods...
                //
                public Vertex initialVertex()
                {
                    return _initialVertex;
                }
                public Edge opposite()
                {
                    return _opposite;
                }
                public Edge next()
                {
                    return _next;
                }
                public Edge prev()
                {
                    return _prev;
                }

                public void setInitialVertex(Vertex v)
                {
                    _initialVertex = v;
                }

                public void setOpposite(Edge opposite, boolean andBack)
                {
                    _opposite = opposite;
                    if (andBack)
                        _opposite.setOpposite(this, false);
                }
                public void setNext(Edge next, boolean andBack)
                {
                    _next = next;
                    if (andBack)
                        next.setPrev(this, false);
                }
                public void setPrev(Edge prev, boolean andBack)
                {
                    _prev = prev;
                    if (andBack)
                        prev.setNext(this, false);
                }

                //
                // Helper methods...
                // From the caller's point of view,
                // these are just like the accessor methods
                //
                public Vertex finalVertex()
                {
                    return _opposite._initialVertex;
                }


                public int myIndex()
                {
                    //return Arrays.indexOfUsingEqualsSymbol(edges, this);
                    return _myIndex;
                }
            } // public class Edge

            // Called whenever verts array changes
            private void fixVertIndices(int i0)
            {
                for (int iVert = i0; iVert < verts.size(); ++iVert)
                    ((Vertex)verts.get(iVert))._myIndex = iVert;
            }
            // Called whenever edges array changes
            private void fixEdgeIndices(int i0)
            {
                for (int iEdge = i0; iEdge < edges.size(); ++iEdge)
                    ((Edge)edges.get(iEdge))._myIndex = iEdge;
            }

            public void sanityCheck()
            {
                int nVerts = verts.size();
                int nEdges = edges.size();

                java.util.Hashtable vertToIndex = new java.util.Hashtable();
                java.util.Hashtable edgeToIndex = new java.util.Hashtable();

                FORI (iVert, nVerts)
                {
                    Vertex vert = (Vertex)verts.get(iVert);
                    assert(vert.myIndex() == iVert);
                    assert(vertToIndex.get(vert) == null);
                    vertToIndex.put(vert, new Integer(iVert));
                }
                FORI (iEdge, nEdges)
                {
                    Edge edge = (Edge)edges.get(iEdge);
                    assert(edge.myIndex() == iEdge);
                    assert(edgeToIndex.get(edge) == null);
                    edgeToIndex.put(edge, new Integer(iEdge));
                }

                boolean sawVertAsInitial[] = new boolean[nVerts]; // all false
                boolean sawEdgeAsOpposite[] = new boolean[nEdges]; // all false
                boolean sawEdgeAsNext[] = new boolean[nEdges]; // all false
                boolean sawEdgeAsPrev[] = new boolean[nEdges]; // all false
                FORI (iEdge, nEdges)
                {
                    Edge e = (Edge)edges.get(iEdge);
                    assert(e.myIndex() == iEdge);
                    assert(e.initialVertex() != null);
                    assert(e.opposite() != null);
                    assert(e.opposite() != e);
                    assert(e.initialVertex() != null);
                    assert(e.initialVertex() != e.finalVertex());
                    assert(e.next() != null);
                    assert(e.prev() != null);
                    assert(e.next() != e);
                    assert(e.prev() != e);
                    assert(e.opposite().opposite() == e);
                    assert(e.next().prev() == e);
                    assert(e.prev().next() == e);

                    int initialVertIndex = ((Integer)vertToIndex.get(e.initialVertex())).intValue();
                    int oppositeIndex = ((Integer)edgeToIndex.get(e.opposite())).intValue();
                    int nextIndex = ((Integer)edgeToIndex.get(e.next())).intValue();
                    int prevIndex = ((Integer)edgeToIndex.get(e.prev())).intValue();

                    // Okay for a vert to be initial more than once...
                    sawVertAsInitial[initialVertIndex] = true;

                    // But not the others...
                    assert(!sawEdgeAsOpposite[oppositeIndex]);
                    sawEdgeAsOpposite[oppositeIndex] = true;
                    assert(!sawEdgeAsNext[nextIndex]);
                    sawEdgeAsNext[nextIndex] = true;
                    assert(!sawEdgeAsPrev[prevIndex]);
                    sawEdgeAsPrev[prevIndex] = true;
                }

                FORI (iVert, nVerts)
                {
                    if (false) // can have isolated verts
                        assert(sawVertAsInitial[iVert]);
                }
                FORI (iEdge, nEdges)
                {
                    assert(sawEdgeAsOpposite[iEdge]);
                    assert(sawEdgeAsNext[iEdge]);
                    assert(sawEdgeAsPrev[iEdge]);
                }
            } // sanityCheck




            /*                    ^
                 insertThisEdge   | beforeThisEdge
                <-----------------*
                                 /|\
                                / | \
            */
            public void insertEdgeBefore(Edge insertThisEdge, Edge beforeThisEdge)
            {
                if (nonEventVerbose >= 1)
                    System.out.println("        In insertEdgeBefore(insertThisEdge="+insertThisEdge.myIndex()+", beforeThisEdge="+beforeThisEdge.myIndex()+"");
                beforeThisEdge.prev().setNext(insertThisEdge, true);
                insertThisEdge.opposite().setNext(beforeThisEdge, true);
                insertThisEdge.setInitialVertex(beforeThisEdge.initialVertex());
                if (nonEventVerbose >= 1)
                    System.out.println("        Out insertEdgeBefore(insertThisEdge="+insertThisEdge.myIndex()+", beforeThisEdge="+beforeThisEdge.myIndex()+"");
            }
            public void addWhisker(Edge beforeThisEdge,
                                   Vertex v) // to this vertex
            {
                Edge e = new Edge(true);
                e.opposite().setInitialVertex(v);
                e.setNext(e.opposite(), true);
                insertEdgeBefore(e, beforeThisEdge);
            }
            public void addDiagonal(Edge beforeThisEdge, Edge beforeThatEdge)
            {
                if (nonEventVerbose >= 1)
                    System.out.println("    In addDiagonal(beforeThisEdge="+beforeThisEdge.myIndex()+", beforeThatEdge="+beforeThatEdge.myIndex()+"");
                Edge e = new Edge(true);
                insertEdgeBefore(e, beforeThisEdge);
                insertEdgeBefore(e.opposite(), beforeThatEdge);
                if (nonEventVerbose >= 1)
                    System.out.println("    Out addDiagonal(beforeThisEdge="+beforeThisEdge.myIndex()+", beforeThatEdge="+beforeThatEdge.myIndex()+"");
            }
            // returns true iff did something
            public boolean swapDiagonal(Edge e, boolean onlyIfMoreDelaunay, boolean verbose)
            {
                if (e.next().next().next() != e
                 || e.opposite().next().next().next() != e.opposite())
                {
                    if (verbose)
                        System.out.println("    Can't swap diagonal, it's not on a quad");
                    return false;
                }

                Edge beforeThisEdge = e.prev();
                Edge beforeThatEdge = e.opposite().prev();

                //
                // Another subtle thing to check...
                // Make sure the other diagonal doesn't
                // already exist.
                //
                {
                    Vertex v0 = beforeThisEdge.initialVertex();
                    Vertex v1 = beforeThatEdge.initialVertex();
                    // Could do this faster by walking around the vert,
                    // but this is more complete since it checks for some pathological cases
                    FORIDOWN (iEdge, edges.size())
                    {
                        Edge edge = (Edge)edges.get(iEdge);
                        if (edge.initialVertex() == v0
                         && edge.finalVertex() == v1)
                        {
                            if (verbose)
                                System.out.println("    Can't swap diagonal, the other diagonal already exists");
                            return false;
                        }
                    }
                }

                if (onlyIfMoreDelaunay)
                {
                    Vertex a = beforeThisEdge.finalVertex();
                    Vertex b = beforeThatEdge.initialVertex();
                    Vertex c = beforeThatEdge.finalVertex();
                    Vertex d = beforeThisEdge.initialVertex();
                    // comfort of ac relative to bd
                    double comfort = TriangulationOptimizer.calcQuadComfort(new double[]{a.x,a.y},
                                                                            new double[]{b.x,b.y},
                                                                            new double[]{c.x,c.y},
                                                                            new double[]{d.x,d.y},
                                                                            0, 1);
                    // XXX TODO: take height into account!!!!!
                    if (verbose)
                        System.out.println("    comfort = "+comfort);
                    if (comfort >= 0) // should this be fuzzy? I won't worry about it for now
                    {
                        if (verbose)
                            System.out.println("    Swapping diagonal would not improve it");
                        return false;
                    }
                }

                deleteEdge(e);
                addDiagonal(beforeThisEdge, beforeThatEdge);
                return true;
            } // swapDiagonal
            public void addEdgeBetweenTwoIsolatedVertices(Vertex v0, Vertex v1)
            {
                Edge e = new Edge(true);
                e.setInitialVertex(v0);
                e.opposite().setInitialVertex(v1);
                e.setNext(e.opposite(), true);
                e.setPrev(e.opposite(), true);
            }
            public void addEdgeBetweenTwoVertices(Vertex v0, Vertex v1)
            {
                assert(v0 != v1);
                if (verts.size() == 2)
                {
                    // XXX this case might not be necessary?
                    addEdgeBetweenTwoIsolatedVertices(v0, v1);
                    return;
                }
                // find the face containing both vertices
                // that has greatest area.
                Edge bestBeforeThisEdge = null;
                Edge bestBeforeThatEdge = null;
                double bestTwiceFaceArea = Double.NEGATIVE_INFINITY;
                int nEdges = edges.size();
                FORI (iEdge, nEdges)
                {
                    Edge e0 = (Edge)edges.get(iEdge);
                    if (e0.initialVertex() == v0)
                    {
                        if (e0.finalVertex() == v1)
                        {
                            return; // the vertices are neighbors... definitely don't do anything in this case
                        }
                        // walk around the face CCW looking for v1
                        for (Edge e = e0; e.finalVertex() != v0; e = e.next())
                        {
                            if (e.finalVertex() == v1)
                            {
                                double twiceFaceArea = twiceFaceArea(e0);
                                if (twiceFaceArea > bestTwiceFaceArea)
                                {
                                    bestBeforeThisEdge = e0;
                                    bestBeforeThatEdge = e.next();
                                    bestTwiceFaceArea = twiceFaceArea;
                                }
                                break;
                            }
                        }
                    }
                }
                if (bestBeforeThisEdge != null)
                {
                    addDiagonal(bestBeforeThisEdge,
                                bestBeforeThatEdge);
                    return;
                }
                // XXX TODO: more cases, if either or both of the vertices are isolated, or otherwise connecting two components
            } // addEdgeBetweenTwoVertices

            public double twiceFaceArea(Edge e0)
            {
                double sum = 0;
                Vertex v0 = e0.initialVertex();
                // All edges e not containing v0...
                for (Edge e = e0.next(); e.finalVertex() != v0; e = e.next())
                {
                    Vertex v1 = e.initialVertex();
                    Vertex v2 = e.finalVertex();
                    sum += twiceTriArea(v0.x, v0.y,
                                        v1.x, v1.y,
                                        v2.x, v2.y);
                }
                return sum;
            } // twiceFaceArea

            public void addIsolatedVertex(double x, double y, double h)
            {
                new Vertex(x,y,h); // adds itself to verts
            }
            // This is the "kis" operation, the dual of truncating a vertex.
            public void kisIsolatedVertex(Vertex v, Edge someEdgeOnFace)
            {
                if (nonEventVerbose >= 1)
                    System.out.println("In kis(v="+v.myIndex()+", someEdgeOnFac="+someEdgeOnFace.myIndex()+"");
                //
                // Start by attaching a single whisker to the new vertex...
                //
                if (nonEventVerbose >= 1)
                    System.out.println("    adding a whisker from edge "+someEdgeOnFace.myIndex()+" to vert "+v.myIndex());
                addWhisker(someEdgeOnFace, v);
                if (nonEventVerbose >= 1)
                {
                    System.out.println("    did that at least.");
                    PRINT(this);
                }

                //
                // Now fill in with triangles,
                // connecting everything to the new vertex v.
                //
                while (someEdgeOnFace.next()
                                     .next()
                                     .next() != someEdgeOnFace)
                {
                    if (nonEventVerbose >= 1)
                        System.out.println("    adding diagonal from start of edge "+someEdgeOnFace.prev().myIndex()+" to start of edge "+someEdgeOnFace.prev().prev().prev().myIndex()+"");
                    addDiagonal(someEdgeOnFace.prev(),
                                someEdgeOnFace.prev()
                                              .prev()
                                              .prev());
                    if (nonEventVerbose >= 1)
                    {
                        System.out.println("    did that diagonal.");
                        PRINT(this);
                    }
                }
                if (nonEventVerbose >= 1)
                    System.out.println("Out kis(v="+v.myIndex()+", someEdgeOnFac="+someEdgeOnFace.myIndex()+"");
            }
            public void deleteEdge(Edge e)
            {
                e.prev().setNext(e.opposite().next(), true);
                e.opposite().prev().setNext(e.next(), true);
                /*
                assert(e.next() == e.opposite());
                assert(e.prev() == e.opposite());
                */
                int i = e.myIndex();
                edges.remove(i);
                fixEdgeIndices(i);

                int j = e.opposite().myIndex();
                edges.remove(j);
                fixEdgeIndices(j);
            }
            public void deleteVertex(Vertex v)
            {
                FORI (iEdge, edges.size())
                {
                    Edge edge = (Edge)edges.get(iEdge);
                    if (edge.initialVertex() == v
                     || edge.finalVertex() == v)
                    {
                        deleteEdge(edge);
                        iEdge--; // so when we increment we get back to here
                    }
                }
                int iVert = v.myIndex();
                verts.remove(iVert);
                fixVertIndices(iVert);
            }

            public int indexOfClosestVert(double x, double y)
            {
                double closestDistSqrd = Double.POSITIVE_INFINITY;
                int closestVertIndex = -1;
                FORI (iVert, verts.size()) // beginning to end, so we choose first of equal
                {
                    Vertex vert = (Vertex)verts.get(iVert);
                    double thisDistSqrd = SQR(vert.x-x)
                                        + SQR(vert.y-y);
                    if (thisDistSqrd < closestDistSqrd)
                    {
                        closestDistSqrd = thisDistSqrd;
                        closestVertIndex = iVert;
                    }
                }
                return closestVertIndex; // -1 if none
            } // indexOfClosestVert

            public int indexOfClosestEdge(double x, double y)
            {
                double closestDistSqrd = Double.POSITIVE_INFINITY;
                int closestEdgeIndex = -1;
                FORI (iEdge, edges.size()) // beginning to end, so we choose first of equal
                {
                    Edge edge = (Edge)edges.get(iEdge);
                    double thisDistSqrd = distSqrdFromPointToSeg(x,y,
                                             edge.initialVertex().x,
                                             edge.initialVertex().y,
                                             edge.finalVertex().x,
                                             edge.finalVertex().y);
                    if (thisDistSqrd < closestDistSqrd)
                    {
                        closestDistSqrd = thisDistSqrd;
                        closestEdgeIndex = iEdge;
                    }
                }
                return closestEdgeIndex; // -1 if none
            } // indexOfClosestEdge

            public double[] findOptimalVertexHeights(int optimizationType)
            {
                if (verts.size() < 3)
                    return new double[verts.size()]; // zeros

                if (nonEventVerbose >= 1)
                    System.out.println("In findOptimalVertexHeights");

                int nDependentVerts = 3;
                int dependentVertIndices[] = {0,1,2};
                // Prefer the triangle that contains the origin...
                {
                    FORI (iEdge, edges.size())
                    {
                        Edge edge = (Edge)edges.get(iEdge);
                        if (edge.next().next().next() != edge)
                            continue;
                        Vertex v0 = edge.initialVertex();
                        Vertex v1 = edge.next().initialVertex();
                        Vertex v2 = edge.next().next().initialVertex();
                        if (twiceTriArea(0,0,
                                         v0.x,v0.y,
                                         v1.x,v1.y) >= 0
                         && twiceTriArea(0,0,
                                         v1.x,v1.y,
                                         v2.x,v2.y) >= 0
                         && twiceTriArea(0,0,
                                         v2.x,v2.y,
                                         v0.x,v0.y) >= 0)
                        {
                            dependentVertIndices[0] = v0.myIndex();
                            dependentVertIndices[1] = v1.myIndex();
                            dependentVertIndices[2] = v2.myIndex();
                            break; // origin is inside this tri CCW
                        }
                    }
                }

                // Figure out the desired dualEdgeLength...
                // XXX just hard code for now
                double desiredDualEdgeLength = .25;

                int edge2dualVert[] = VecMath.fillvec(edges.size(), -1);
                int nDualVerts;
                {
                    nDualVerts = 0;
                    FORI (iEdge, edges.size())
                    {
                        if (edge2dualVert[iEdge] != -1)
                            continue; // already saw some other edge on this tri
                        Edge edge = (Edge)edges.get(iEdge);
                        Edge edge1 = edge.next();
                        Edge edge2 = edge1.next();
                        boolean thisIsATri = (edge2.next() == edge);
                        if (thisIsATri)
                        {
                            edge2dualVert[iEdge] = nDualVerts;
                            edge2dualVert[edge1.myIndex()] = nDualVerts;
                            edge2dualVert[edge2.myIndex()] = nDualVerts;
                            nDualVerts++;
                        }
                    }
                }
                int edge2dualEdge[] = VecMath.fillvec(edges.size(), -1);
                int nDualEdges;
                {
                    nDualEdges = 0;
                    FORI (iEdge, edges.size())
                    {
                        if (edge2dualEdge[iEdge] != -1)
                            continue; // already seen it from the opposite edge

                        Edge edge = (Edge)edges.get(iEdge);
                        if (edge2dualVert[iEdge] != -1
                         && edge2dualVert[edge.opposite().myIndex()] != -1)
                        {
                            // Opposite edge is also on a tri
                            // that we haven't counted yet
                            edge2dualEdge[iEdge] = nDualEdges;
                            edge2dualEdge[edge.opposite().myIndex()] = nDualEdges;
                            nDualEdges++;
                        }
                    }
                }

                int dualVert2verts[][] = VecMath.fillmat(nDualVerts, 3, -1);
                int dualEdge2edge[] = VecMath.fillvec(nDualEdges, -1); // XXX not used?
                int dualEdge2dualVerts[][] = VecMath.fillmat(nDualEdges, 2, -1);
                {
                    FORI (iEdge, edges.size())
                    {
                        Edge edge = (Edge)edges.get(iEdge);
                        int iDualEdge = edge2dualEdge[iEdge];
                        if (iDualEdge != -1 // if it has a dual edge
                         && dualEdge2dualVerts[iDualEdge][0] == -1) // if we didn't already do this dual edge from the opposite
                        {
                            dualEdge2edge[iDualEdge] = iEdge;
                            dualEdge2dualVerts[iDualEdge][0] = edge2dualVert[iEdge];
                            dualEdge2dualVerts[iDualEdge][1] = edge2dualVert[edge.opposite().myIndex()];
                        }

                        int iDualVert = edge2dualVert[iEdge];
                        if (iDualVert != -1 // if this edge is on a triangle
                         && dualVert2verts[iDualVert][0] == -1) // if we didn't already do this dual vert
                        {
                            dualVert2verts[iDualVert][0] = edge.initialVertex().myIndex();
                            dualVert2verts[iDualVert][1] = edge.next().initialVertex().myIndex();
                            dualVert2verts[iDualVert][2] = edge.next().next().initialVertex().myIndex();
                        }
                    }
                    FORI (iDualVert, nDualVerts)
                        FORI (j, 3)
                            assert(dualVert2verts[iDualVert][j] != -1);

                    FORI (iDualEdge, nDualEdges)
                    {
                        assert(dualEdge2edge[iDualEdge] != -1);
                        assert(dualEdge2dualVerts[iDualEdge][0] != -1);
                        assert(dualEdge2dualVerts[iDualEdge][1] != -1);
                    }
                }


                // can optimize positions or lengths.  I think optimizing positions is more robust.
                boolean optimizingBarycentrics = optimizationType == OPTIMIZE_BARYCENTRICS_LEAST_SQUARES
                                              || optimizationType == OPTIMIZE_BARYCENTRICS_MAX_MIN
                                              || optimizationType == OPTIMIZE_BARYCENTRICS_INFINITY_NORM;
                if (optimizingBarycentrics)
                {
                    nDependentVerts = 1; // XXX not right in general, should be number of connected components maybe
                    dependentVertIndices = new int[] {0};
                }

                int nIndependentVerts = verts.size() - nDependentVerts;

                if (nIndependentVerts > (optimizingBarycentrics ? 2*nDualVerts : nDualEdges))
                {
                    //PRINT((optimizingBarycentrics ? 2*nDualVerts : nDualEdges));
                    System.out.println("Out findOptimalVertexHeights (too many independent verts, it's underconstrained)");
                    return new double[verts.size()]; // zeros
                }

                int vert2independentVert[] = new int[verts.size()];
                int independentVert2verts[] = new int[nIndependentVerts];
                {
                    int iIndependentVert = 0;
                    FORIDOWN (iVert, verts.size())
                    {
                        if (Arrays.indexOf(dependentVertIndices, iVert) == -1)
                        {
                            vert2independentVert[iVert] = iIndependentVert;
                            independentVert2verts[iIndependentVert] = iVert;
                            iIndependentVert++;
                        }
                        else
                            vert2independentVert[iVert] = -1;
                    }
                    assert(iIndependentVert == nIndependentVerts);
                }


                int nSamples = nIndependentVerts+1;
                double sampleResultVerts[][][] = new double[nSamples][nDualVerts][2];
                {
                    double sampleHeights[][] = new double[nIndependentVerts+1][nIndependentVerts];
                    VecMath.identitymat(sampleHeights); // the unit basis vectors, and a row of zeros at the end

                    FORI (iSample, nSamples)
                    {
                        //
                        // Input sampleHeights[iSample]
                        // and get out sampleResultVerts[iSample]
                        //
                        FORI (iDualVert, nDualVerts)
                        {
                            int iVert0 = dualVert2verts[iDualVert][0];
                            int iVert1 = dualVert2verts[iDualVert][1];
                            int iVert2 = dualVert2verts[iDualVert][2];
                            int iIndependentVert0 = vert2independentVert[iVert0];
                            int iIndependentVert1 = vert2independentVert[iVert1];
                            int iIndependentVert2 = vert2independentVert[iVert2];
                            double h0 = (iIndependentVert0 == -1 ? 0. : sampleHeights[iSample][iIndependentVert0]);
                            double h1 = (iIndependentVert1 == -1 ? 0. : sampleHeights[iSample][iIndependentVert1]);
                            double h2 = (iIndependentVert2 == -1 ? 0. : sampleHeights[iSample][iIndependentVert2]);
                            Vertex v0 = (Vertex)verts.get(iVert0);
                            Vertex v1 = (Vertex)verts.get(iVert1);
                            Vertex v2 = (Vertex)verts.get(iVert2);
                            SolveForDualPoint(v0.x,v0.y,h0 - .5 * (SQR(v0.x)+SQR(v0.y)),
                                              v1.x,v1.y,h1 - .5 * (SQR(v1.x)+SQR(v1.y)),
                                              v2.x,v2.y,h2 - .5 * (SQR(v2.x)+SQR(v2.y)),
                                              sampleResultVerts[iSample][iDualVert]);
                        }
                    }
                    //PRINTMAT(sampleHeights);
                }

                double solvedHeights[];

                if (optimizingBarycentrics)
                {
                    // We want to maximize the minimum barycentric occurring
                    // anywhere in the result.
                    double sampleBarycentrics[][][] = new double[nSamples][nDualVerts][3];
                    FORI (iSample, nSamples)
                    {
                        FORI (iDualVert, nDualVerts)
                        {
                            int tri[] = dualVert2verts[iDualVert];
                            double wholeArea = twiceTriArea(((Vertex)verts.get(tri[0])).x, ((Vertex)verts.get(tri[0])).y,
                                                            ((Vertex)verts.get(tri[1])).x, ((Vertex)verts.get(tri[1])).y,
                                                            ((Vertex)verts.get(tri[2])).x, ((Vertex)verts.get(tri[2])).y);
                            double dualVert[] = sampleResultVerts[iSample][iDualVert];
                            FORI (iVertOnTri, 3)
                            {
                                sampleBarycentrics[iSample][iDualVert][iVertOnTri] =
                                        twiceTriArea(dualVert[0], dualVert[1],
                                                     ((Vertex)verts.get(tri[(iVertOnTri+1)%3])).x,
                                                     ((Vertex)verts.get(tri[(iVertOnTri+1)%3])).y,
                                                     ((Vertex)verts.get(tri[(iVertOnTri+2)%3])).x,
                                                     ((Vertex)verts.get(tri[(iVertOnTri+2)%3])).y)
                                      / wholeArea;
                            }
                        }
                    }
                    double sampleResultVectors[][] = (double[][])Arrays.flatten(sampleBarycentrics, 1, 2);
                    double desiredResultVector[] = VecMath.fillvec(sampleResultVectors[0].length,
                                        optimizationType==OPTIMIZE_BARYCENTRICS_MAX_MIN ? 0. : 1./3.);

                    //
                    // Find C and d
                    // such that x -> C x - d
                    // maps heights to barycentrics.
                    //

                    //
                    // Column i of C is the result from the i'th basis sample,
                    // minus the result from the 0 vector.
                    //
                    double C[][] = new double[sampleResultVectors.length-1][sampleResultVectors[0].length]; // start transposed...
                    FORI (iSample, sampleResultVectors.length-1)
                        VecMath.vmv(C[iSample],
                                    sampleResultVectors[iSample],
                                    sampleResultVectors[sampleResultVectors.length-1]);
                    C = VecMath.transpose(C);

                    //
                    // d is the desired result minus the result from the zero vector.
                    //
                    double d[] = VecMath.vmv(desiredResultVector,
                                             sampleResultVectors[sampleResultVectors.length-1]);

                    // XXX could get clean up the dependent/intependent lookup tables if we want by expressing the independent vertex's constraints here...
                    double A[][] = {}; // no equality constraints
                    double b[] = {}; // no equality constraints

                    LinearProgramming.debugLevel = 0;

                    if (optimizationType == OPTIMIZE_BARYCENTRICS_LEAST_SQUARES)
                    {
                        if (nonEventVerbose >= 1)
                        {
                            System.out.print("    Solving barycentrics least squares from all 1/3's...");
                            System.out.flush();
                        }
                        solvedHeights = VecMath.invmxv(C,d);
                        if (nonEventVerbose >= 1)
                            System.out.println("    done.");
                    }
                    else if (optimizationType == OPTIMIZE_BARYCENTRICS_INFINITY_NORM)
                    {
                        solvedHeights = new double[sampleResultVectors.length-1];
                        if (nonEventVerbose >= 1)
                        {
                            System.out.print("    Solving barycentrics infinity norm from all 1/3's...");
                            System.out.flush();
                        }
                        int result = LinearProgramming.LInfinitySolve(solvedHeights, C,d);
                        if (nonEventVerbose >= 1)
                            System.out.println("    done.");
                        if (result != 0)
                            System.out.println("WARNING: LPSolve returned "+result);
                    }
                    else if (optimizationType == OPTIMIZE_BARYCENTRICS_MAX_MIN)
                    {
                        solvedHeights = new double[sampleResultVectors.length-1];
                        if (nonEventVerbose >= 1)
                        {
                            System.out.print("    Solving barycentrics maximizing minimal element...");
                            System.out.flush();
                        }
                        int result = LinearProgramming.maximizeMinimum(solvedHeights,
                                                                       A, b,
                                                                       C, d);
                        if (nonEventVerbose >= 1)
                            System.out.println("    done.");
                        if (false)
                        {
                            PRINTMAT(A);
                            PRINTVEC(b);
                            PRINTMAT(C);
                            PRINTVEC(d);
                            PRINT(result);
                            PRINTVEC(solvedHeights);
                        }
                        if (result != 0)
                            System.out.println("WARNING: LPSolve returned "+result);
                    }
                    else
                    {
                        assert(false);
                    }
                }
                else // optimize lengths
                {
                    double sampleResultVectors[][];
                    double desiredResultVector[];

                    {
                        double sampleResultLengths[][] = new double[nSamples][nDualEdges];
                        FORI (iSample, nSamples)
                        {
                            //
                            // Calculate sampleResultLengths[iSample]
                            // from sampleResultVerts[iSample]
                            //
                            FORI (iDualEdge, nDualEdges)
                            {
                                sampleResultLengths[iSample][iDualEdge] =
                                    VecMath.dist(sampleResultVerts[iSample][dualEdge2dualVerts[iDualEdge][0]],
                                                 sampleResultVerts[iSample][dualEdge2dualVerts[iDualEdge][1]]);
                                // Need to figure out the sign.
                                // If dual edge length is positive,
                                // it will point from the original edge's left face
                                // to the original edge's right face.
                                // So the dual edge dir cross the original edge dir
                                // should be > 0.
                                double dualEdgeDir[] = VecMath.vmv(sampleResultVerts[iSample][dualEdge2dualVerts[iDualEdge][1]], sampleResultVerts[iSample][dualEdge2dualVerts[iDualEdge][0]]);
                                double originalEdgeDir[] = VecMath.vmv(
                                    new double[] {((Edge)edges.get(dualEdge2edge[iDualEdge])).finalVertex().x,
                                                  ((Edge)edges.get(dualEdge2edge[iDualEdge])).finalVertex().y},
                                    new double[] {((Edge)edges.get(dualEdge2edge[iDualEdge])).initialVertex().x,
                                                  ((Edge)edges.get(dualEdge2edge[iDualEdge])).initialVertex().y}
                                );
                                if (VecMath.vxv2(dualEdgeDir, originalEdgeDir) < 0)
                                {
                                    sampleResultLengths[iSample][iDualEdge] *= -1;
                                }
                            }
                        }
                        //PRINTMAT(sampleResultLengths);
                        sampleResultVectors = sampleResultLengths;
                    }
                    desiredResultVector = VecMath.fillvec(nDualEdges, desiredDualEdgeLength);

                    // the following is general, could optimize something else if desired
                    {

                        //
                        // Row i of A is the result from the i'th basis sample,
                        // minus the result from the 0 vector.
                        //
                        double A[][] = new double[sampleResultVectors.length-1][sampleResultVectors[0].length];
                        FORI (iSample, sampleResultVectors.length-1)
                            VecMath.vmv(A[iSample],
                                        sampleResultVectors[iSample],
                                        sampleResultVectors[sampleResultVectors.length-1]);
                        //
                        // b is the desired result
                        // minus the result from the 0 vector.
                        //
                        double b[] = VecMath.vmv(desiredResultVector,
                                                 sampleResultVectors[sampleResultVectors.length-1]);

                        //PRINTMAT(A);
                        //PRINTVEC(b);

                        double leastSquaresSolution[];
                        if (optimizationType == OPTIMIZE_LENGTHS_LEAST_SQUARES)
                        {
                            if (nonEventVerbose >= 1)
                            {
                                System.out.print("    Solving for lengths least squares from all "+desiredDualEdgeLength+" ...");
                                System.out.flush();
                            }
                            leastSquaresSolution = VecMath.vxinvm(b, A);
                            if (nonEventVerbose >= 1)
                                System.out.println("    done.");
                        }
                        else if (optimizationType == OPTIMIZE_LENGTHS_INFINITY_NORM)
                        {
                            leastSquaresSolution = new double[sampleResultVectors.length-1];
                            if (nonEventVerbose >= 1)
                            {
                                System.out.print("    Solving lengths infinity norm from all .25's...");
                                System.out.flush();
                            }
                            int result = LinearProgramming.LInfinitySolve(leastSquaresSolution, VecMath.transpose(A),b);
                            if (nonEventVerbose >= 1)
                                System.out.println("    done.");
                            if (result != 0)
                                System.out.println("WARNING: LPSolve returned "+result);
                        }
                        else
                            assert(false);

                        //PRINTVEC(leastSquaresSolution);
                        double gotLengths[] = VecMath.vxm(leastSquaresSolution, A);
                        //PRINTVEC(gotLengths);

                        boolean doCheckLeastSquaresSolution = false; // I'm convinced it works
                        if (doCheckLeastSquaresSolution)
                        {
                            System.out.print("    Checking");
                            System.out.flush();

                            int nTests = 100;
                            FORI (iTest, nTests)
                            {
                                System.out.print(".");

                                //
                                // Perturb each element of the solution
                                // by a random amount
                                //
                                double foo[] = VecMath.copyvec(leastSquaresSolution);
                                double dir[] = VecMath.random(leastSquaresSolution.length);
                                VecMath.normalize(dir);
                                double fudges[] = {.01, -.01};
                                FORI (iFudge, fudges.length)
                                {
                                    VecMath.vpsxv(foo, leastSquaresSolution, fudges[iFudge], dir);
                                    double bar[] = VecMath.vxm(foo, A);
                                    //PRINT(VecMath.dist(bar, b));
                                    if (foo.length > 0)
                                        assert(VecMath.dist(gotLengths, b) < VecMath.dist(bar, b));
                                }
                            }
                            System.out.println("    done.");
                        }
                        solvedHeights = leastSquaresSolution;
                    }
                } // optimize lengths

                assert(solvedHeights.length == independentVert2verts.length);
                double optimalVertexHeights[] = new double[verts.size()];
                FORI (iIndex, independentVert2verts.length)
                {
                    optimalVertexHeights[independentVert2verts[iIndex]] = solvedHeights[iIndex];
                }
                FORI (iDependentVert, dependentVertIndices.length)
                    optimalVertexHeights[dependentVertIndices[iDependentVert]] = 0.;

                if (nonEventVerbose >= 1)
                    System.out.println("Out findOptimalVertexHeights");

                return optimalVertexHeights;
            } // findOptimalVertexHeights

            private Mesh()
            {
            }

            private Mesh(double vertPositions[][],
                         int faceIndices[][])
            {
                FORI (i, vertPositions.length)
                {
                    // adds itself to verts...
                    new Vertex(vertPositions[i][0],  // x
                               vertPositions[i][1],  // y
                               vertPositions[i].length == 2 ? 0 : vertPositions[i][2]); // h
                }
                java.util.Hashtable vertIndsToEdge = new java.util.Hashtable();
                FORI (i, faceIndices.length)
                FORI (j, faceIndices[i].length)
                {
                    int v0 = faceIndices[i][j];
                    int v1 = faceIndices[i][(j+1)%faceIndices[i].length];
                    assert(INRANGE(0 <=, v0, < vertPositions.length));
                    assert(INRANGE(0 <=, v1, < vertPositions.length));
                    String v0_v1 = ""+v0+"_"+v1;
                    String v1_v0 = ""+v1+"_"+v0;
                    if (vertIndsToEdge.get(v0_v1) == null)
                    {
                        Edge edge = new Edge(true); // adds itself, and opposite, to verts
                        vertIndsToEdge.put(v0_v1, edge);
                        vertIndsToEdge.put(v1_v0, edge.opposite());
                        edge.setInitialVertex((Vertex)verts.get(v0));
                        edge.opposite().setInitialVertex((Vertex)verts.get(v1));
                    }
                }
                FORI (i, faceIndices.length)
                FORI (j, faceIndices[i].length)
                {
                    int v0 = faceIndices[i][j];
                    int v1 = faceIndices[i][(j+1)%faceIndices[i].length];
                    int v2 = faceIndices[i][(j+2)%faceIndices[i].length];
                    String v0_v1 = ""+v0+"_"+v1;
                    String v1_v2 = ""+v1+"_"+v2;
                    Edge e01 = (Edge)vertIndsToEdge.get(v0_v1);
                    Edge e12 = (Edge)vertIndsToEdge.get(v1_v2);
                    e01.setNext(e12, true);
                }
                sanityCheck();
            } // Mesh from vertex positions and face indices

            private Mesh(Mesh original)
            {
                int nVerts = original.verts.size();
                FORI (iVert, nVerts)
                {
                    Vertex originalVert = (Vertex)original.verts.get(iVert);
                    new Vertex(originalVert.x,
                               originalVert.y,
                               originalVert.h); // adds itself to verts
                }
                int nEdges = original.edges.size();
                FORI (iEdge, nEdges)
                    new Edge(false); // adds itself to edges
                assert(verts.size() == nVerts);
                assert(edges.size() == nEdges);
                java.util.Hashtable oldToNew = new java.util.Hashtable();
                FORI (iVert, nVerts)
                    oldToNew.put((Vertex)original.verts.get(iVert), (Vertex)verts.get(iVert));
                FORI (iEdge, nEdges)
                    oldToNew.put((Edge)original.edges.get(iEdge), (Edge)edges.get(iEdge));
                FORI (iEdge, nEdges)
                {
                    Edge edge = (Edge)edges.get(iEdge);
                    Edge originalEdge = (Edge)original.edges.get(iEdge);
                    edge._initialVertex = (Vertex)oldToNew.get(originalEdge._initialVertex);
                    edge._opposite = (Edge)oldToNew.get(originalEdge._opposite);
                    edge._prev = (Edge)oldToNew.get(originalEdge._prev);
                    edge._next = (Edge)oldToNew.get(originalEdge._next);
                }
            } // Mesh copy constructor

            public ArrayList/*<Vertex>*/ verts = new ArrayList();
            public ArrayList/*<Edge>*/ edges = new ArrayList();
        } // class Mesh

        // Holds the information needed to undo and redo a mesh editing operation.
        // This implementation is very simple and inefficient;
        // it just stores a complete copy of the mesh before and after
        // the editing operation.
        private static class UndoItem
        {
            public static class State
            {
                public Mesh mesh;
                public boolean doOptimize;
                public int optimizationTypeIndex;
                public State(Mesh mesh, boolean doOptimize, int optimizationTypeIndex)
                {
                    this.mesh = new Mesh(mesh);
                    this.doOptimize = doOptimize;
                    this.optimizationTypeIndex = optimizationTypeIndex;
                }
            }
            public State before;
            public State after;
            public UndoItem(State before, State after)
            {
                this.before = before;
                this.after = after;
            }
        } // class UndoItem


        /*
            Note, the h given here are the "actual" positions v.h - .5 * (x^2 + y^2).
            where v.h is the offset stored in the vertex.

            Given:
                x0,y0,h0
                x1,y1,h1
                x2,y2,h2
            representing an infinitesimal triangle
            whose vertices are infinitesimally-squared away from the unit sphere
            at the tangent plane z=1:
                x0 eps, y0 eps, 1 + h0 eps^2
                x1 eps, y1 eps, 1 + h1 eps^2
                x2 eps, y2 eps, 1 + h2 eps^2
            we want to find x,y,h
            representing the point:
                x eps, y eps, 1 + h eps^2
            that is the intersection point of the 3 planes
            whose closest-points-to-origin are the original 3 points.
            That is,
                [x0 eps, y0 eps, 1 + h0 eps^2] [x eps      ]   [x0^2 eps^2 + y0^2 eps^2 + 1 + 2 h0 eps^2 + h0^2 eps^4]
                [x1 eps, y1 eps, 1 + h1 eps^2] [y eps      ] = [x1^2 eps^2 + y1^2 eps^2 + 1 + 2 h1 eps^2 + h1^2 eps^4]
                [x2 eps, y2 eps, 1 + h2 eps^2] [1 + h eps^2]   [x2^2 eps^2 + y2^2 eps^2 + 1 + 2 h2 eps^2 + h2^2 eps^4]
            Now subtract 1 + hi eps^2 from both sides of each equation:
                [x0 eps, y0 eps, 1 + h0 eps^2] [x eps  ]       [x0^2 eps^2 + y0^2 eps^2 + h0 eps^2 + h0^2 eps^4]
                [x1 eps, y1 eps, 1 + h1 eps^2] [y eps  ]     = [x1^2 eps^2 + y1^2 eps^2 + h1 eps^2 + h1^2 eps^4]
                [x2 eps, y2 eps, 1 + h2 eps^2] [h eps^2]       [x2^2 eps^2 + y2^2 eps^2 + h2 eps^2 + h2^2 eps^4]
            Rearrange the left hand sides a bit:
                [x0 eps, y0 eps, eps + h0 eps^3] [x eps]       [x0^2 eps^2 + y0^2 eps^2 + h0 eps^2 + h0^2 eps^4]
                [x1 eps, y1 eps, eps + h1 eps^3] [y eps]     = [x1^2 eps^2 + y1^2 eps^2 + h1 eps^2 + h1^2 eps^4]
                [x2 eps, y2 eps, eps + h2 eps^3] [h eps]       [x2^2 eps^2 + y2^2 eps^2 + h2 eps^2 + h2^2 eps^4]
            Divide both sides by eps^2:
                [x0, y0, 1 + h0 eps^2] [x]   [x0^2 + y0^2 + h0 + h0^2 eps^2]
                [x1, y1, 1 + h1 eps^2] [y] = [x1^2 + y1^2 + h1 + h1^2 eps^2]
                [x2, y2, 1 + h2 eps^2] [h]   [x2^2 + y2^2 + h2 + h2^2 eps^2]
            Finally, the infinitesimals can drop out, and it's equivalent to solving:
                [x0 y0 1] [x]   [x0^2 + y0^2 + h0]
                [x1 y1 1] [y] = [x1^2 + y1^2 + h1]
                [x2 y2 1] [h]   [x0^2 + y2^2 + h2]
            Easy!
        */
        private static void SolveForDualPoint(double x0, double y0, double h0,
                                              double x1, double y1, double h1,
                                              double x2, double y2, double h2,
                                              double result[])
        {
            double M[][] = {
                {x0,y0,1},
                {x1,y1,1},
                {x2,y2,1},
            };
            double b[] = {
                x0*x0 + y0*y0 + h0,
                x1*x1 + y1*y1 + h1,
                x2*x2 + y2*y2 + h2,
            };
            if (result.length == 3)
                VecMath.invmxv(result,M,b);
            else // result.length == 2, just copy the first two
                VecMath.copyvec(result, VecMath.invmxv(M,b));

        } // SolveForDualPoint

        // Calculate the angle C, opposite side c,
        // given side lengths a, b, c,
        // using c^2 = a^2 + b^2 - 2*a*b*cos(C)
        private static double triangleAngle(double a, double b, double c)
        {
            return Math.acos((a*a + b*b - c*c) / (2*a*b));
        }

        // Find vertex v2 that completes the triangle with given edge lengths,
        // such that v0,v1,v2 are CCW.
        private static double[] completeTriangle(double v0[],
                                                 double v1[],
                                                 double dist12,
                                                 double dist20)
        {
            // Make sure has only 2 entries
            v0 = new double[]{v0[0],v0[1]};
            v1 = new double[]{v1[0],v1[1]};
            double ang0 = triangleAngle(VecMath.dist(v0,v1), dist20, dist12);
            double dir01[] = VecMath.normalize(VecMath.vmv(v1,v0));
            double v2[] = VecMath.sxvpsxvpsxv(
                1.,                    v0,
                dist20*Math.cos(ang0), dir01,
                dist20*Math.sin(ang0), VecMath.xv2(dir01));
            return v2;
        } // completeTriangle

        private static double twiceTriArea(double x0, double y0,
                                           double x1, double y1,
                                           double x2, double y2)
        {
            return (x1-x0)*(y2-y0) - (x2-x0)*(y1-y0);
        }

        // eps is in linear units
        private static boolean edgesCrossOrCloseToIt(double a0x, double a0y,
                                                     double a1x, double a1y,
                                                     double b0x, double b0y,
                                                     double b1x, double b1y,
                                                     double eps)
        {
            return twiceTriArea(a0x,a0y,
                                a1x,a1y,
                                b1x,b1y)
                 * twiceTriArea(a1x,a1y,
                                a0x,a0y,
                                b0x,b0y) >= -eps*eps*eps*eps
                && twiceTriArea(b0x,b0y,
                                b1x,b1y,
                                a0x,a0y)
                 * twiceTriArea(b1x,b1y,
                                b0x,b0y,
                                a1x,a1y) >= -eps*eps*eps*eps;
        } // edgesCrossOrCloseToIt

        private static double distSqrdFromPointToSeg(double x, double y,
                                                     double x0, double y0,
                                                     double x1, double y1)
        {
            double v[] = {x-x0,y-y0};
            double v1[] = {x1-x0,y1-y0};
            if (VecMath.normsqrd(v1) == 0.)
                return VecMath.normsqrd(v);
            double t = VecMath.dot(v,v1)
                     / VecMath.dot(v1,v1);
            t = CLAMP(t, 0., 1.);
            double vprojectedOntoV1[] = VecMath.sxv(t, v1);
            return VecMath.distsqrd(v, vprojectedOntoV1);
        }

    //
    // App-specific variables...
    //
        private UndoTreeSquirrel undoTreeSquirrel = new UndoTreeSquirrel();
        private Mesh mesh = new Mesh();
        private int selectedVertIndex = -1;
        private boolean rubberBandingNewEdge = false;
        private boolean doOptimize = false;
            private static final int OPTIMIZE_BARYCENTRICS_LEAST_SQUARES = 0;
            private static final int OPTIMIZE_BARYCENTRICS_INFINITY_NORM = 1;
            private static final int OPTIMIZE_BARYCENTRICS_MAX_MIN = 2;
            private static final int OPTIMIZE_LENGTHS_LEAST_SQUARES = 3;
            private static final int OPTIMIZE_LENGTHS_INFINITY_NORM = 4;
            private static final String optimizationTypeNames[] = {
                "OPTIMIZE_BARYCENTRICS_LEAST_SQUARES from all 1/3's",
                "OPTIMIZE_BARYCENTRICS_INFINITY_NORM from all 1/3's",
                "OPTIMIZE_BARYCENTRICS_MAX_MIN",
                "OPTIMIZE_LENGTHS_LEAST_SQUARES from all .25's",
                "OPTIMIZE_LENGTHS_INFINITY_NORM from all .25's",
            };
            private static final int availableOptimizationTypes[] = {
                OPTIMIZE_BARYCENTRICS_LEAST_SQUARES,
                OPTIMIZE_BARYCENTRICS_INFINITY_NORM,
                OPTIMIZE_BARYCENTRICS_MAX_MIN,
                OPTIMIZE_LENGTHS_LEAST_SQUARES,
                OPTIMIZE_LENGTHS_INFINITY_NORM,
            };
        private int optimizationTypeIndex = 0;
        int optimizationType = availableOptimizationTypes[optimizationTypeIndex];

        private boolean doLabels = false;
        private boolean doArrowsTowardsSharpestDihedrals = true;
        private boolean doArrowsTowardsShortestEdges = true;
        private boolean doShowInsideOutDualVerts = false; // might also be nice to have option for implicit primal vertex in middle of outer face, so that dual will be single-face-bounded... and maybe ctrl-up,ctrl-down will adjust the height of that face

        private boolean doShowPositiveOrthantnessVisualization = false; // XXX total hack-- it's cool but put it somewhere else!!
        private int showTriangles = 2; // 0: nothing, 1: verts, 2: and tris
        private boolean continuouslyDelaunayize = false; // XXX need an interface for this!

    //
    // Applet-generic member variables...
    //
        private GraphicsAntiAliasingSetter graphicsAntiAliasingSetter;
        private int eventVerbose = 0; // can set with eventVerbose=1 on command line
        private static int nonEventVerbose = 0; // so static classes can refer to it
        private boolean doAntiAliasing = false;
        private boolean implementAntiAliasingInHardware = true; // XXX should have a better name for this-- really mean let java runtime do it
        private boolean doDoubleBuffer = true;
        private java.awt.Image backBufferImage = null;
        private MyGraphics mostRecentGraphics = null;
        private double translateFudgeX = 0.;
        private double translateFudgeY = 0.; // no api for changing, currently

        private double prevP[] = null;

    //
    // Track mouse state...
    // (I think java newer versions of java (XXX starting when?)
    // let you query from the events themselves,
    // but e.g. in 1.1 there is no way to tell whether button1
    // is down during a drag without keeping state
    //
        private boolean button1IsDown = false;
        private boolean button2IsDown = false;
        private boolean button3IsDown = false;
        private UndoItem.State stateWhenPressed = null;


    //
    // Main...
    //
    public static void main(final String args[])
    {
        System.out.println("in main");

        final java.awt.Frame frame = new java.awt.Frame("Shephards Play Applet") {
            public boolean handleEvent(java.awt.Event event)
            {
                switch(event.id)
                {
                    case java.awt.Event.WINDOW_DESTROY:
                        System.out.println("bye!");
                        // Empirically, either of the following
                        // cause the app to exit-- do both to be safe!
                        // (XXX I've heard rumors that just doing dispose()
                        //  messes up the debugger)
                        // (XXX but doing exit is evil)
                        dispose(); // hide() doesn't delete the windows
                        System.exit(0);
                        return true;
                }
                return super.handleEvent(event);
            }
        };

        // ARGH! The above no longer works in java 1.5!
        // have to use a listener I guess...
        frame.addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent we) {
                System.out.println("ciao!");
                frame.dispose(); // hide() doesn't delete the windows
                System.exit(0);
            }
        });

        final ShephardsPlayApplet applet = new ShephardsPlayApplet();

        // XXX the following seems to be necessary, or getParameter() will crash, at least in 1.4.  Want to send params from command line anyway.
        applet.setStub(new java.applet.AppletStub() {
             public void appletResize(int width, int height)
                 { /* should resize frame, but a ShephardsPlayApplet never asks to be resized */ }
             public java.applet.AppletContext getAppletContext() { return null;}             public java.net.URL getCodeBase() { return null; }
             public java.net.URL getDocumentBase() { return null; }
             public String getParameter(String name)
             {
                 // case insensitive... and unfortunately there's no
                 // startsWithIgnoreCase
                 String prefix = name.toLowerCase() + "=";
                 int i;
                 FOR (i, args.length)
                     if (args[i].toLowerCase().startsWith(prefix))
                         return args[i].substring(prefix.length());
                 return null;
             }
             public boolean isActive() { return true; }
        });

        frame.add(applet);

        applet.init();
        applet.start();

        frame.move(400, 20);
        frame.resize(512, 512);
        frame.show();

        Misc.printPlatonicSolidVertexCurvatures();

        System.out.println("out main");
    } // main
} // class ShephardsPlayApplet
